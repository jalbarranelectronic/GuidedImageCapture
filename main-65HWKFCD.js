var tj=Object.create;var bd=Object.defineProperty,nj=Object.defineProperties,rj=Object.getOwnPropertyDescriptor,oj=Object.getOwnPropertyDescriptors,sj=Object.getOwnPropertyNames,SD=Object.getOwnPropertySymbols,ij=Object.getPrototypeOf,DD=Object.prototype.hasOwnProperty,aj=Object.prototype.propertyIsEnumerable;var ND=(n,e,t)=>e in n?bd(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Ft=(n,e)=>{for(var t in e||={})DD.call(e,t)&&ND(n,t,e[t]);if(SD)for(var t of SD(e))aj.call(e,t)&&ND(n,t,e[t]);return n},Yt=(n,e)=>nj(n,oj(e));var D=(n,e)=>()=>(n&&(e=n(n=0)),e);var Jn=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),Le=(n,e)=>{for(var t in e)bd(n,t,{get:e[t],enumerable:!0})},kD=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of sj(e))!DD.call(n,o)&&o!==t&&bd(n,o,{get:()=>e[o],enumerable:!(r=rj(e,o))||r.enumerable});return n};var ch=(n,e,t)=>(t=n!=null?tj(ij(n)):{},kD(e||!n||!n.__esModule?bd(t,"default",{value:n,enumerable:!0}):t,n)),_D=n=>kD(bd({},"__esModule",{value:!0}),n);function Bn(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}var Ps,go,Cw=D(()=>{"use strict";Ps=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},go=class{refCount(e){return Bn("refCount")}incRef(e){return Bn("incRef")}timerAvailable(){return!0}time(e){return Bn("time")}read(e){return Bn("read")}readSync(e){return Bn("readSync")}readToGPU(e,t){return Bn("readToGPU")}numDataIds(){return Bn("numDataIds")}disposeData(e,t){return Bn("disposeData")}write(e,t,r){return Bn("write")}move(e,t,r,o,s){return Bn("move")}createTensorFromGPUData(e,t,r){return Bn("createTensorFromGPUData")}memory(){return Bn("memory")}floatPrecision(){return Bn("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Bn("dispose")}}});function p2(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Rg(n,e,t)}function v7(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,r=0;for(;t>0;)r=Math.random()*t|0,t--,Rg(n,t,r),Rg(e,t,r)}function Jl(n,e,t){return Math.max(n,Math.min(e,t))}function b7(n){return n%2===0?n:n+1}function Rg(n,e,t){let r=n[e];n[e]=n[t],n[t]=r}function C7(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function w7(n,e){let t=Math.random();return e*t+(1-t)*n}function I7(n,e){let t=0;for(let r=0;r<n.length;r++){let o=Number(n[r])-Number(e[r]);t+=o*o}return t}function k(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function et(n,e,t=""){k(xn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function rr(n){k(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Ne(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function E7(n){return n.length===0}function ww(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function xn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Go(n){return n%1===0}function T7(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{let e=Math.exp(2*n);return(e-1)/(e+1)}}function S7(n){let e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function N7(n){let e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return p2(e),e}function Wa(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function D7(n,e=o=>0,t,r){return new Promise((o,s)=>{let i=0,a=()=>{if(n()){o();return}i++;let c=e(i);if(t!=null&&i>=t){s();return}r!=null?r(a,c):setTimeout(a,c)};a()})}function k7(n,e){let t=1,r=-1;for(let s=0;s<n.length;++s)if(n[s]>=0)t*=n[s];else if(n[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(n[s]<0)throw Error(`Shapes can not be < 0. Found ${n[s]} at dim ${s}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);let o=n.slice();return o[r]=e/t,o}function Ls(n,e){let t=e.length;return n=n==null?e.map((r,o)=>o):[].concat(n),k(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),k(n.every(r=>Go(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function Iw(n,e){let t=[],r=[],o=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||o?null:Ls(e,n).sort(),i=0;for(let a=0;a<n.length;++a){if(s!=null){if(s[i]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(s[i]==null||s[i]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),s[i]<=a&&i++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function Ew(n,e){return Fg(n,e)}function Fg(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Tw(n,e){for(let t=0;t<n.length;t++){let r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Sw(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function _7(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function ep(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Nw(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function $r(n){return typeof n=="string"||n instanceof String}function d2(n){return typeof n=="boolean"}function f2(n){return typeof n=="number"}function Bs(n){return Array.isArray(n)?Bs(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":f2(n)?"float32":$r(n)?"string":d2(n)?"bool":"float32"}function xo(n){return!!(n&&n.constructor&&n.call&&n.apply)}function tp(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function yo(n){let e=n.length;if(e<2)return[];let t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function m2(n,e,t,r=!1){let o=new Array;if(e.length===1){let s=e[0]*(r?2:1);for(let i=0;i<s;i++)o[i]=t[n+i]}else{let s=e[0],i=e.slice(1),a=i.reduce((c,u)=>c*u)*(r?2:1);for(let c=0;c<s;c++)o[c]=m2(n+c*a,i,t,r)}return o}function Ga(n,e,t=!1){if(n.length===0)return e[0];let r=n.reduce((o,s)=>o*s)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return m2(0,n,e,t)}function A7(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function mf(n,e){let t=np(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function np(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function R7(n,e){let t=n.reduce((r,o)=>r*o,1);if(e==null||e==="float32")return Ga(n,new Float32Array(t));if(e==="int32")return Ga(n,new Int32Array(t));if(e==="bool")return Ga(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function st(n){n.forEach(e=>{k(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function F7(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let o=0;o<n.length-1;++o)r+=t[o]*n[o];return r}function O7(n,e,t){if(e===0)return[];if(e===1)return[n];let r=new Array(e);for(let o=0;o<r.length-1;++o)r[o]=Math.floor(n/t[o]),n-=r[o]*t[o];return r[r.length-1]=n,r}function ja(n){return n&&n.then&&typeof n.then=="function"}var Ot=D(()=>{"use strict";});function $7(n){let e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(P7(e,r[0],r[1]),r.join("="))),e}function P7(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function L7(n,e){let t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function M(){return Og}function g2(n){Og=n}var h2,rp,Og,Gt=D(()=>{"use strict";Ot();h2="tfjsflags",rp=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=$7,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){let o=this.urlFlags[e];M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(ja(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);h2 in e&&e[h2].split(",").forEach(r=>{let[o,s]=r.split(":");this.urlFlags[o]=L7(o,s)})}};Og=null});function kw(){if(Dw==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Dw=n}return Dw}function B7(){let n=kw();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function hf(n,e){let t=B7();if(t.has(n))return t.get(n);{let r=e();return t.set(n,r),t.get(n)}}var Dw,Mg=D(()=>{"use strict";});var qa,Vs,Us,Wo,Ka,op,sp,Xa,Ya,zs,Hs,Gs,Ws,js,Za,gf,Qa,xf,Ja,ec,tc,qs,V7,nc,jo,Ks,Xs,rc,oc,sc,ic,ac,cc,uc,yf,lc,pc,Ys,dc,fc,mc,hc,gc,xc,yc,vc,bc,Cc,$g,Pg,ip,Zs,wc,Ic,vf,Ec,Qs,Tc,Sc,Js,ap,Nc,Dc,ei,ti,kc,_c,Ac,ni,ri,qo,Rc,Fc,oi,si,ii,Oc,ai,ci,Mc,$c,ui,li,pi,di,U7,z7,H7,cp,bf,G7,up,fi,Pc,Cf,Lc,wf,Bc,Vc,lp,mi,Uc,zc,Hc,hi,pp,gi,Gc,Wc,jc,qc,Kc,Xc,Yc,W7,Zc,Qc,Jc,eu,tu,nu,ru,ou,xi,yi,su,iu,If,au,Ef,vi,cu,bi,Ci,uu,lu,pu,du,wi,fu,mu,Ii,Ei,Ti,Si,Ni,dp,hu,gu,xu,yu,vu,bu,Cu,wu,Di,Tf,ki,Iu,Eu,Tu,Su,Nu,Du,_i,Ko,ku,_u,Xo,Au,Ru,Fu,j7,Ou,Ai,fp,Mu,Ri,Fi,Oi,G=D(()=>{"use strict";qa="Abs",Vs="Acos",Us="Acosh",Wo="Add",Ka="AddN",op="All",sp="Any",Xa="ArgMax",Ya="ArgMin",zs="Asin",Hs="Asinh",Gs="Atan",Ws="Atanh",js="Atan2",Za="AvgPool",gf="AvgPoolGrad",Qa="AvgPool3D",xf="AvgPool3DGrad",Ja="BatchMatMul",ec="BatchToSpaceND",tc="Bincount",qs="BitwiseAnd",V7="BroadcastTo",nc="BroadcastArgs",jo="Cast",Ks="Ceil",Xs="ClipByValue",rc="Complex",oc="ComplexAbs",sc="Concat",ic="Conv2D",ac="Conv2DBackpropFilter",cc="Conv2DBackpropInput",uc="Conv3D",yf="Conv3DBackpropFilterV2",lc="Conv3DBackpropInputV2",pc="Cos",Ys="Cosh",dc="Cumprod",fc="Cumsum",mc="CropAndResize",hc="DenseBincount",gc="DepthToSpace",xc="DepthwiseConv2dNative",yc="DepthwiseConv2dNativeBackpropFilter",vc="DepthwiseConv2dNativeBackpropInput",bc="Diag",Cc="Dilation2D",$g="Dilation2DBackpropInput",Pg="Dilation2DBackpropFilter",ip="Draw",Zs="RealDiv",wc="Einsum",Ic="Elu",vf="EluGrad",Ec="Erf",Qs="Equal",Tc="Exp",Sc="ExpandDims",Js="Expm1",ap="FFT",Nc="Fill",Dc="FlipLeftRight",ei="Floor",ti="FloorDiv",kc="FusedBatchNorm",_c="GatherV2",Ac="GatherNd",ni="Greater",ri="GreaterEqual",qo="Identity",Rc="IFFT",Fc="Imag",oi="IsFinite",si="IsInf",ii="IsNan",Oc="LeakyRelu",ai="Less",ci="LessEqual",Mc="LinSpace",$c="Log",ui="Log1p",li="LogicalAnd",pi="LogicalNot",di="LogicalOr",U7="LogicalXor",z7="LogSoftmax",H7="LowerBound",cp="LRN",bf="LRNGrad",G7="MatrixBandPart",up="Max",fi="Maximum",Pc="MaxPool",Cf="MaxPoolGrad",Lc="MaxPool3D",wf="MaxPool3DGrad",Bc="MaxPoolWithArgmax",Vc="Mean",lp="Min",mi="Minimum",Uc="MirrorPad",zc="Mod",Hc="Multinomial",hi="Multiply",pp="Neg",gi="NotEqual",Gc="NonMaxSuppressionV3",Wc="NonMaxSuppressionV4",jc="NonMaxSuppressionV5",qc="OnesLike",Kc="OneHot",Xc="Pack",Yc="PadV2",W7="Pool",Zc="Pow",Qc="Prelu",Jc="Prod",eu="RaggedGather",tu="RaggedRange",nu="RaggedTensorToTensor",ru="Range",ou="Real",xi="Reciprocal",yi="Relu",su="Reshape",iu="ResizeNearestNeighbor",If="ResizeNearestNeighborGrad",au="ResizeBilinear",Ef="ResizeBilinearGrad",vi="Relu6",cu="Reverse",bi="Round",Ci="Rsqrt",uu="ScatterNd",lu="TensorScatterUpdate",pu="SearchSorted",du="Select",wi="Selu",fu="Slice",mu="Sin",Ii="Sinh",Ei="Sign",Ti="Sigmoid",Si="Softplus",Ni="Sqrt",dp="Sum",hu="SpaceToBatchND",gu="SplitV",xu="Softmax",yu="SparseFillEmptyRows",vu="SparseReshape",bu="SparseSegmentMean",Cu="SparseSegmentSum",wu="SparseToDense",Di="SquaredDifference",Tf="Square",ki="StaticRegexReplace",Iu="StridedSlice",Eu="StringNGrams",Tu="StringSplit",Su="StringToHashBucketFast",Nu="Sub",Du="Tan",_i="Tanh",Ko="Tile",ku="TopK",_u="Transform",Xo="Transpose",Au="Unique",Ru="Unpack",Fu="UnsortedSegmentSum",j7="UpperBound",Ou="ZerosLike",Ai="Step",fp="FromPixels",Mu="RotateWithOffset",Ri="_FusedMatMul",Fi="FusedConv2D",Oi="FusedDepthwiseConv2D"});function vo(...n){M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(...n)}function q7(...n){M().getBool("IS_TEST")||M().getBool("PROD")||console.log(...n)}var Lg=D(()=>{"use strict";Gt();});function $u(n,e){let t=_w(n,e);return mp.get(t)}function Bg(n){return Sf.get(n)}function Nf(n){let e=mp.entries(),t=[];for(;;){let{done:r,value:o}=e.next();if(r)break;let[s,i]=o,[a]=s.split("_");a===n&&t.push(i)}return t}function hp(n){let{kernelName:e,backendName:t}=n,r=_w(e,t);mp.has(r)&&vo(`The kernel '${e}' for backend '${t}' is already registered`),mp.set(r,n)}function K7(n){let{kernelName:e}=n;Sf.has(e)&&M().getBool("DEBUG")&&vo(`Overriding the gradient for '${e}'`),Sf.set(e,n)}function X7(n,e){let t=_w(n,e);if(!mp.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);mp.delete(t)}function Y7(n){if(!Sf.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Sf.delete(n)}function Z7(n,e){Nf(n).forEach(r=>{let o=Object.assign({},r,{backendName:e});hp(o)})}function _w(n,e){return`${e}_${n}`}var mp,Sf,Vg=D(()=>{"use strict";Gt();Mg();Lg();mp=hf("kernelRegistry",()=>new Map),Sf=hf("gradRegistry",()=>new Map)});function Ug(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Aw=D(()=>{"use strict";});var D2=Jn((JCe,N2)=>{"use strict";N2.exports=dt;var hr=null;try{hr=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function dt(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}dt.prototype.__isLong__;Object.defineProperty(dt.prototype,"__isLong__",{value:!0});function Un(n){return(n&&n.__isLong__)===!0}dt.isLong=Un;var y2={},v2={};function Lu(n,e){var t,r,o;return e?(n>>>=0,(o=0<=n&&n<256)&&(r=v2[n],r)?r:(t=ft(n,(n|0)<0?-1:0,!0),o&&(v2[n]=t),t)):(n|=0,(o=-128<=n&&n<128)&&(r=y2[n],r)?r:(t=ft(n,n<0?-1:0,!1),o&&(y2[n]=t),t))}dt.fromInt=Lu;function gr(n,e){if(isNaN(n))return e?Pu:xr;if(e){if(n<0)return Pu;if(n>=I2)return S2}else{if(n<=-C2)return Vn;if(n+1>=C2)return T2}return n<0?gr(-n,e).neg():ft(n%xp|0,n/xp|0,e)}dt.fromNumber=gr;function ft(n,e,t){return new dt(n,e,t)}dt.fromBits=ft;var zg=Math.pow;function Fw(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return xr;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return Fw(n.substring(1),e,t).neg();for(var o=gr(zg(t,8)),s=xr,i=0;i<n.length;i+=8){var a=Math.min(8,n.length-i),c=parseInt(n.substring(i,i+a),t);if(a<8){var u=gr(zg(t,a));s=s.mul(u).add(gr(c))}else s=s.mul(o),s=s.add(gr(c))}return s.unsigned=e,s}dt.fromString=Fw;function Pr(n,e){return typeof n=="number"?gr(n,e):typeof n=="string"?Fw(n,e):ft(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}dt.fromValue=Pr;var b2=65536,Q7=1<<24,xp=b2*b2,I2=xp*xp,C2=I2/2,w2=Lu(Q7),xr=Lu(0);dt.ZERO=xr;var Pu=Lu(0,!0);dt.UZERO=Pu;var gp=Lu(1);dt.ONE=gp;var E2=Lu(1,!0);dt.UONE=E2;var Rw=Lu(-1);dt.NEG_ONE=Rw;var T2=ft(-1,2147483647,!1);dt.MAX_VALUE=T2;var S2=ft(-1,-1,!0);dt.MAX_UNSIGNED_VALUE=S2;var Vn=ft(0,-2147483648,!1);dt.MIN_VALUE=Vn;var ie=dt.prototype;ie.toInt=function(){return this.unsigned?this.low>>>0:this.low};ie.toNumber=function(){return this.unsigned?(this.high>>>0)*xp+(this.low>>>0):this.high*xp+(this.low>>>0)};ie.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Vn)){var t=gr(e),r=this.div(t),o=r.mul(t).sub(this);return r.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=gr(zg(e,6),this.unsigned),i=this,a="";;){var c=i.div(s),u=i.sub(c.mul(s)).toInt()>>>0,l=u.toString(e);if(i=c,i.isZero())return l+a;for(;l.length<6;)l="0"+l;a=""+l+a}};ie.getHighBits=function(){return this.high};ie.getHighBitsUnsigned=function(){return this.high>>>0};ie.getLowBits=function(){return this.low};ie.getLowBitsUnsigned=function(){return this.low>>>0};ie.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Vn)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};ie.isZero=function(){return this.high===0&&this.low===0};ie.eqz=ie.isZero;ie.isNegative=function(){return!this.unsigned&&this.high<0};ie.isPositive=function(){return this.unsigned||this.high>=0};ie.isOdd=function(){return(this.low&1)===1};ie.isEven=function(){return(this.low&1)===0};ie.equals=function(e){return Un(e)||(e=Pr(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};ie.eq=ie.equals;ie.notEquals=function(e){return!this.eq(e)};ie.neq=ie.notEquals;ie.ne=ie.notEquals;ie.lessThan=function(e){return this.comp(e)<0};ie.lt=ie.lessThan;ie.lessThanOrEqual=function(e){return this.comp(e)<=0};ie.lte=ie.lessThanOrEqual;ie.le=ie.lessThanOrEqual;ie.greaterThan=function(e){return this.comp(e)>0};ie.gt=ie.greaterThan;ie.greaterThanOrEqual=function(e){return this.comp(e)>=0};ie.gte=ie.greaterThanOrEqual;ie.ge=ie.greaterThanOrEqual;ie.compare=function(e){if(Un(e)||(e=Pr(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};ie.comp=ie.compare;ie.negate=function(){return!this.unsigned&&this.eq(Vn)?Vn:this.not().add(gp)};ie.neg=ie.negate;ie.add=function(e){Un(e)||(e=Pr(e));var t=this.high>>>16,r=this.high&65535,o=this.low>>>16,s=this.low&65535,i=e.high>>>16,a=e.high&65535,c=e.low>>>16,u=e.low&65535,l=0,p=0,d=0,f=0;return f+=s+u,d+=f>>>16,f&=65535,d+=o+c,p+=d>>>16,d&=65535,p+=r+a,l+=p>>>16,p&=65535,l+=t+i,l&=65535,ft(d<<16|f,l<<16|p,this.unsigned)};ie.subtract=function(e){return Un(e)||(e=Pr(e)),this.add(e.neg())};ie.sub=ie.subtract;ie.multiply=function(e){if(this.isZero())return xr;if(Un(e)||(e=Pr(e)),hr){var t=hr.mul(this.low,this.high,e.low,e.high);return ft(t,hr.get_high(),this.unsigned)}if(e.isZero())return xr;if(this.eq(Vn))return e.isOdd()?Vn:xr;if(e.eq(Vn))return this.isOdd()?Vn:xr;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(w2)&&e.lt(w2))return gr(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=e.high>>>16,c=e.high&65535,u=e.low>>>16,l=e.low&65535,p=0,d=0,f=0,m=0;return m+=i*l,f+=m>>>16,m&=65535,f+=s*l,d+=f>>>16,f&=65535,f+=i*u,d+=f>>>16,f&=65535,d+=o*l,p+=d>>>16,d&=65535,d+=s*u,p+=d>>>16,d&=65535,d+=i*c,p+=d>>>16,d&=65535,p+=r*l+o*u+s*c+i*a,p&=65535,ft(f<<16|m,p<<16|d,this.unsigned)};ie.mul=ie.multiply;ie.divide=function(e){if(Un(e)||(e=Pr(e)),e.isZero())throw Error("division by zero");if(hr){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?hr.div_u:hr.div_s)(this.low,this.high,e.low,e.high);return ft(t,hr.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Pu:xr;var r,o,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Pu;if(e.gt(this.shru(1)))return E2;s=Pu}else{if(this.eq(Vn)){if(e.eq(gp)||e.eq(Rw))return Vn;if(e.eq(Vn))return gp;var i=this.shr(1);return r=i.div(e).shl(1),r.eq(xr)?e.isNegative()?gp:Rw:(o=this.sub(e.mul(r)),s=r.add(o.div(e)),s)}else if(e.eq(Vn))return this.unsigned?Pu:xr;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=xr}for(o=this;o.gte(e);){r=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),c=a<=48?1:zg(2,a-48),u=gr(r),l=u.mul(e);l.isNegative()||l.gt(o);)r-=c,u=gr(r,this.unsigned),l=u.mul(e);u.isZero()&&(u=gp),s=s.add(u),o=o.sub(l)}return s};ie.div=ie.divide;ie.modulo=function(e){if(Un(e)||(e=Pr(e)),hr){var t=(this.unsigned?hr.rem_u:hr.rem_s)(this.low,this.high,e.low,e.high);return ft(t,hr.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};ie.mod=ie.modulo;ie.rem=ie.modulo;ie.not=function(){return ft(~this.low,~this.high,this.unsigned)};ie.and=function(e){return Un(e)||(e=Pr(e)),ft(this.low&e.low,this.high&e.high,this.unsigned)};ie.or=function(e){return Un(e)||(e=Pr(e)),ft(this.low|e.low,this.high|e.high,this.unsigned)};ie.xor=function(e){return Un(e)||(e=Pr(e)),ft(this.low^e.low,this.high^e.high,this.unsigned)};ie.shiftLeft=function(e){return Un(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ft(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):ft(0,this.low<<e-32,this.unsigned)};ie.shl=ie.shiftLeft;ie.shiftRight=function(e){return Un(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ft(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):ft(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};ie.shr=ie.shiftRight;ie.shiftRightUnsigned=function(e){if(Un(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return ft(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?ft(t,0,this.unsigned):ft(t>>>e-32,0,this.unsigned)};ie.shru=ie.shiftRightUnsigned;ie.shr_u=ie.shiftRightUnsigned;ie.toSigned=function(){return this.unsigned?ft(this.low,this.high,!1):this};ie.toUnsigned=function(){return this.unsigned?this:ft(this.low,this.high,!0)};ie.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};ie.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};ie.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};dt.fromBytes=function(e,t,r){return r?dt.fromBytesLE(e,t):dt.fromBytesBE(e,t)};dt.fromBytesLE=function(e,t){return new dt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};dt.fromBytesBE=function(e,t){return new dt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}});function Df(n){return Vu.fromString(n,!0,16)}function Ow(n){return n.xor(n.shru(47))}function A2(n,e,t){let r=n.slice(e,e+t);return Vu.fromBytes(Array.from(r),!0,!0)}function it(n,e){return A2(n,e,8)}function k2(n,e){return A2(n,e,4)}function Wt(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Mi(n,e,t=Df("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let o=e.xor(r).mul(t);return o=o.xor(o.shru(47)),o=o.mul(t),o}function J7(n,e,t,r,o,s){o=o.add(n),s=Wt(s.add(o).add(r),21);let i=o;return o=o.add(e),o=o.add(t),s=s.add(Wt(o,44)),[o.add(r),s.add(i)]}function Hg(n,e,t,r){return J7(it(n,e),it(n,e+8),it(n,e+16),it(n,e+24),t,r)}function e9(n,e=n.length){if(e>=8){let t=yn.add(e*2),r=it(n,0).add(yn),o=it(n,e-8),s=Wt(o,37).mul(t).add(r),i=Wt(r,25).add(o).mul(t);return Mi(s,i,t)}if(e>=4){let t=yn.add(e*2),r=k2(n,0);return Mi(r.shl(3).add(e),k2(n,e-4),t)}if(e>0){let t=n[0],r=n[e>>1],o=n[e-1],s=t+(r<<8),i=e+(o<<2);return Ow(yn.mul(s).xor(_2.mul(i))).mul(yn)}return yn}function t9(n,e=n.length){let t=yn.add(e*2),r=it(n,0).mul(Bu),o=it(n,8),s=it(n,e-8).mul(t),i=it(n,e-16).mul(yn);return Mi(Wt(r.add(o),43).add(Wt(s,30)).add(i),r.add(Wt(o.add(yn),18)).add(s),t)}function n9(n,e=n.length){let t=yn.add(e*2),r=it(n,0).mul(yn),o=it(n,8),s=it(n,e-8).mul(t),i=it(n,e-16).mul(yn),a=Wt(r.add(o),43).add(Wt(s,30)).add(i),c=Mi(a,r.add(Wt(o.add(yn),18)).add(s),t),u=it(n,16).mul(t),l=it(n,24),p=a.add(it(n,e-32)).mul(t),d=c.add(it(n,e-24)).mul(t);return Mi(Wt(u.add(l),43).add(Wt(p,30)).add(d),u.add(Wt(l.add(r),18)).add(p),t)}function r9(n,e=n.length){let t=Vu.fromNumber(81,!0);if(e<=32)return e<=16?e9(n,e):t9(n,e);if(e<=64)return n9(n,e);let r=t,o=t.mul(Bu).add(113),s=Ow(o.mul(yn).add(113)).mul(yn),i=[Vu.UZERO,Vu.UZERO],a=[Vu.UZERO,Vu.UZERO];r=r.mul(yn).add(it(n,0));let c=0,u=(e-1>>6)*64,l=u+(e-1&63)-63;do r=Wt(r.add(o).add(i[0]).add(it(n,c+8)),37).mul(Bu),o=Wt(o.add(i[1]).add(it(n,c+48)),42).mul(Bu),r=r.xor(a[1]),o=o.add(i[0]).add(it(n,c+40)),s=Wt(s.add(a[0]),33).mul(Bu),i=Hg(n,c,i[1].mul(Bu),r.add(a[0])),a=Hg(n,c+32,s.add(a[1]),o.add(it(n,c+16))),[s,r]=[r,s],c+=64;while(c!==u);let p=Bu.add(s.and(255).shl(1));return c=l,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Wt(r.add(o).add(i[0]).add(it(n,c+8)),37).mul(p),o=Wt(o.add(i[1]).add(it(n,c+48)),42).mul(p),r=r.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(it(n,c+40))),s=Wt(s.add(a[0]),33).mul(p),i=Hg(n,c,i[1].mul(p),r.add(a[0])),a=Hg(n,c+32,s.add(a[1]),o.add(it(n,c+16))),[s,r]=[r,s],Mi(Mi(i[0],a[0],p).add(Ow(o).mul(_2)).add(s),Mi(i[1],a[1],p).add(r),p)}var Mw,Vu,_2,Bu,yn,R2=D(()=>{"use strict";Mw=ch(D2());Vu=Mw.default||Mw;_2=Df("c3a5c85c97cb3127"),Bu=Df("b492b66fbe98f273"),yn=Df("9ae16a3b2f90404f")});var y={};Le(y,{arraysEqual:()=>xn,arraysEqualWithNull:()=>ww,assert:()=>k,assertNonNegativeIntegerDimensions:()=>st,assertNonNull:()=>rr,assertShapesMatch:()=>et,bytesFromStringArray:()=>Nw,bytesPerElement:()=>ep,checkConversionForErrors:()=>Tw,clamp:()=>Jl,computeStrides:()=>yo,convertBackendValuesAndArrayBuffer:()=>A7,createScalarValue:()=>o9,createShuffledIndices:()=>N7,decodeString:()=>vp,distSquared:()=>I7,encodeString:()=>$i,fetch:()=>i9,fingerPrint64:()=>r9,flatten:()=>Lr,getArrayFromDType:()=>Fg,getTypedArrayFromDType:()=>Ew,hasEncodingLoss:()=>_7,hexToLong:()=>Df,indexToLoc:()=>O7,inferDtype:()=>Bs,inferFromImplicitShape:()=>k7,isBoolean:()=>d2,isFunction:()=>xo,isInt:()=>Go,isNumber:()=>f2,isPromise:()=>ja,isScalarShape:()=>E7,isString:()=>$r,isTypedArray:()=>Ct,isValidDtype:()=>Sw,locToIndex:()=>F7,makeOnesTypedArray:()=>mf,makeZerosNestedTypedArray:()=>R7,makeZerosTypedArray:()=>np,nearestDivisor:()=>tp,nearestLargerEven:()=>b7,now:()=>Uu,parseAxisParam:()=>Ls,randUniform:()=>w7,repeatedTry:()=>D7,rightPad:()=>Wa,shuffle:()=>p2,shuffleCombo:()=>v7,sizeFromShape:()=>Ne,sizeToSquarishShape:()=>S7,squeezeShape:()=>Iw,sum:()=>C7,swap:()=>Rg,tanh:()=>T7,toNestedArray:()=>Ga,toTypedArray:()=>yp});function o9(n,e){return e==="string"?$i(n):yp([n],e)}function s9(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function yp(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Lr(n)),M().getBool("DEBUG")&&Tw(n,e),s9(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){let t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Uu(){return M().platform.now()}function i9(n,e){return M().platform.fetch(n,e)}function $i(n,e="utf-8"){return e=e||"utf-8",M().platform.encode(n,e)}function vp(n,e="utf-8"){return e=e||"utf-8",M().platform.decode(n,e)}function Ct(n){return M().platform.isTypedArray!=null?M().platform.isTypedArray(n):Ug(n)}function Lr(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||ja(n)||n==null||Ct(n)&&t)e.push(n);else if(Array.isArray(n)||Ct(n))for(let r=0;r<n.length;++r)Lr(n[r],e,t);else{let r=-1;for(let o of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(o)&&(r=Math.max(r,Number(o)));for(let o=0;o<=r;o++)Lr(n[o],e,t)}return e}var q=D(()=>{"use strict";Gt();Aw();Ot();Ot();R2();});function a9(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){let o=n[r];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${t}'`),!0}return!1}var Gg,$w,F2=D(()=>{"use strict";Gt();q();Gg=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new $w)}profileKernel(e,t,r){let o,s=()=>{o=r()},i,a=Uu();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let u of o)u.dataSync();i=Promise.resolve({kernelMs:Uu()-a})}if(M().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<o.length;u++){let l=o[u];l.data().then(p=>{a9(p,l.dtype,e)})}return{kernelName:e,outputs:o,inputs:t,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:r,timeMs:o,inputs:s,extraInfo:i}=e;r.forEach(a=>{Promise.all([a.data(),o,i]).then(c=>{this.logger.logKernelProfile(t,a,c[0],c[1],s,c[2])})})}};$w=class{logKernelProfile(e,t,r,o,s,i){let a=typeof o=="number"?Wa(`${o}ms`,9):o.error,c=Wa(e,25),u=t.rank,l=t.size,p=Wa(t.shape.toString(),14),d="";for(let f in s){let m=s[f];if(m!=null){let h=m.shape||t.shape,g=h.length;d+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${c}	%c${a}	%c${u}D ${p}	%c${l}	%c${d}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}});function O2(n,e,t){let r={},o={};for(let c=0;c<e.length;c++)r[e[c].id]=!0;for(let c=0;c<n.length;c++){let u=n[c],l=u.inputs;for(let p in l){let d=l[p],f=!1;for(let m=0;m<e.length;m++)if(r[d.id]){u.outputs.forEach(h=>r[h.id]=!0),f=!0,o[u.id]=!0;break}if(f)break}}let s={};s[t.id]=!0;let i={};for(let c=n.length-1;c>=0;c--){let u=n[c],l=u.inputs;for(let p=0;p<u.outputs.length;p++)if(s[u.outputs[p].id]){for(let d in l)s[l[d].id]=!0,i[u.id]=!0;break}}let a=[];for(let c=0;c<n.length;c++){let u=n[c];if(o[u.id]&&i[u.id]){let l={};for(let d in u.inputs){let f=u.inputs[d];r[f.id]&&(l[d]=f)}let p=Object.assign({},u);p.inputs=l,p.outputs=u.outputs,a.push(p)}}return a}function M2(n,e,t,r){for(let o=e.length-1;o>=0;o--){let s=e[o],i=[];if(s.outputs.forEach(c=>{let u=n[c.id];u!=null?i.push(u):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let c in s.inputs){if(!(c in a))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(a)}.`);let u=t(()=>a[c]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${u.dtype}'`);let l=s.inputs[c];if(!xn(u.shape,l.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${c}' has shape '${u.shape}', which does not match the shape of the input '${l.shape}'`);if(n[l.id]==null)n[l.id]=u;else{let p=n[l.id];n[l.id]=r(p,u),p.dispose()}}}}var $2=D(()=>{"use strict";q();});function L2(n,e,t,r){let o=yo(e),s=c9(n,e,t,o),i=e.length,a=Wg(n,e,t,o,s),c=["Tensor"];return r&&(c.push(`  dtype: ${t}`),c.push(`  rank: ${i}`),c.push(`  shape: [${e}]`),c.push("  values:")),c.push(a.map(u=>"    "+u).join(`
`)),c.join(`
`)}function c9(n,e,t,r){let o=Ne(e),s=r[r.length-1],i=new Array(s).fill(0),a=e.length,c=t==="complex64"?Af(n):n;if(a>1)for(let u=0;u<o/s;u++){let l=u*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],_f(c[l+p],0,t).length)}return i}function _f(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(Pw))} + ${parseFloat(n[1].toFixed(Pw))}j`:$r(n)?r=`'${n}'`:t==="bool"?r=B2(n):r=parseFloat(n.toFixed(Pw)).toString(),Wa(r,e)}function B2(n){return n===0?"false":"true"}function Wg(n,e,t,r,o,s=!0){let i=t==="complex64"?2:1,a=e[0],c=e.length;if(c===0){if(t==="complex64"){let h=Af(n);return[_f(h[0],0,t)]}return t==="bool"?[B2(n[0])]:[n[0].toString()]}if(c===1){if(a>P2){let g=kf*i,x=Array.from(n.slice(0,g)),v=Array.from(n.slice((a-kf)*i,a*i));return t==="complex64"&&(x=Af(x),v=Af(v)),["["+x.map((w,I)=>_f(w,o[I],t)).join(", ")+", ..., "+v.map((w,I)=>_f(w,o[a-kf+I],t)).join(", ")+"]"]}return["["+(t==="complex64"?Af(n):Array.from(n)).map((g,x)=>_f(g,o[x],t)).join(", ")+"]"]}let u=e.slice(1),l=r.slice(1),p=r[0]*i,d=[];if(a>P2){for(let h=0;h<kf;h++){let g=h*p,x=g+p;d.push(...Wg(n.slice(g,x),u,t,l,o,!1))}d.push("...");for(let h=a-kf;h<a;h++){let g=h*p,x=g+p;d.push(...Wg(n.slice(g,x),u,t,l,o,h===a-1))}}else for(let h=0;h<a;h++){let g=h*p,x=g+p;d.push(...Wg(n.slice(g,x),u,t,l,o,h===a-1))}let f=c===2?",":"";d[0]="["+(a>0?d[0]+f:"");for(let h=1;h<d.length-1;h++)d[h]=" "+d[h]+f;let m=`,
`;for(let h=2;h<c;h++)m+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":m),d}function Af(n){let e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}var P2,kf,Pw,V2=D(()=>{"use strict";q();P2=20,kf=3,Pw=7});function U2(n){Br=n}function z2(n){bp=n}function H2(n){u9=n}function Lw(){return hf("Tensor",()=>Ke)}var Ve,Br,bp,u9,Ke,bo,or=D(()=>{"use strict";Mg();V2();q();q();Ve=class{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Ne(e),r!=null){let o=r.length;k(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Fg(t,this.size),this.strides=yo(e)}set(e,...t){t.length===0&&(t=[0]),k(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let o of e){if(o<0||o>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let r=e[e.length-1];for(let o=0;o<e.length-1;++o)r+=this.strides[o]*e[o];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Br().makeTensor(this.values,this.shape,this.dtype)}},Br=null,bp=null,u9=null;Ke=class{constructor(e,t,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ne(e),this.strides=yo(e),this.dataId=r,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return bp.buffer(this.shape,this.dtype,e)}bufferSync(){return bp.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Ga(this.shape,e,this.dtype==="complex64")}arraySync(){return Ga(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Br().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(r=>vp(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Br().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Br().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>vp(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Br().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Br().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return bp.print(this,e)}clone(){return this.throwIfDisposed(),bp.clone(this)}toString(e=!1){let t=this.dataSync();return L2(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),bp.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),Br().makeVariable(this,e,t,r)}};Object.defineProperty(Ke,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});Lw();bo=class extends Ke{constructor(e,t,r,o){super(e.shape,e.dtype,e.dataId,o),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!xn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Br().disposeTensor(this),this.dataId=e.dataId,Br().incRef(this,null)}dispose(){Br().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(bo,Symbol.hasInstance,{value:n=>n instanceof Ke&&n.assign!=null&&n.assign instanceof Function})});function wt(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return l9[n][e]}function Pi(n){return wt(n,"int32")}function jg(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function qg(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}var Bw,G2,W2,j2,q2,l9,Cp=D(()=>{"use strict";Bw=(function(n){return n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6",n})(Bw||{}),G2=(function(n){return n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",n})(G2||{}),W2=(function(n){return n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",n})(W2||{}),j2=(function(n){return n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",n})(j2||{}),q2=(function(n){return n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",n})(q2||{}),l9={float32:j2,int32:G2,bool:W2,complex64:q2}});var Uw={};Le(Uw,{assertTypesMatch:()=>Vw,getTensorsInContainer:()=>Rf,isTensorInList:()=>p9,makeTypesMatch:()=>Ee});function Ee(n,e){if(n.dtype===e.dtype)return[n,e];let t=wt(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function Vw(n,e){k(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function p9(n,e){return e.some(t=>t.id===n.id)}function Rf(n){let e=[];return K2(n,e,new Set),e}function K2(n,e,t){if(n==null)return;if(n instanceof Ke){e.push(n);return}if(!d9(n))return;let r=n;for(let o in r){let s=r[o];t.has(s)||(t.add(s),K2(s,e,t))}}function d9(n){return Array.isArray(n)||typeof n=="object"}var at=D(()=>{"use strict";or();Cp();q();});function zw(n){return n.kernelName!=null}function m9(n){let e=mf(Ne(n),"float32");return N.makeTensor(e,n,"float32")}function Hw(){let n=kw();if(n._tfengine==null){let e=new rp(n);n._tfengine=new f9(e)}return g2(n._tfengine.ENV),U2(()=>n._tfengine),n._tfengine}function h9(n,e){let t={a:n,b:e};return N.runKernel("Add",t)}var Kg,f9,N,B=D(()=>{"use strict";Cw();Gt();Mg();G();Vg();Lg();F2();$2();or();at();q();q();Kg=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},f9=(()=>{class n{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Kg}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let r=0;r<t.length;r++){let o=t[r];if(await this.initializeBackend(o).success){await this.setBackend(o);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:r}=this.initializeBackend(t);if(r)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,r,o=1){return t in this.registryFactory?(vo(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:r,priority:o},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:r,asyncInit:o}=this.initializeBackend(t);if(!(o?await r:r))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Gg(this.backendInstance),!0}setupRegisteredKernels(){Nf(this.backendName).forEach(r=>{r.setupFunc!=null&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Nf(t).forEach(o=>{o.disposeFunc!=null&&o.disposeFunc(this.registry[t])})}initializeBackend(t){let r=this.registryFactory[t];if(r==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let o=r.factory();if(o&&!(o instanceof go)&&typeof o.then=="function"){let s=++this.pendingBackendInitId,i=o.then(a=>s<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,vo(`Initialization of backend ${t} failed`),vo(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=o,{success:!0,asyncInit:!1}}catch(o){return vo(`Initialization of backend ${t} failed`),vo(o.stack||o.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,r)=>this.registryFactory[r].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let r=0;r<t.length;r++){let o=t[r],{success:s,asyncInit:i}=this.initializeBackend(o);if(i||s)return{name:o,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,r){let o=this.state.tensorInfo.get(r),s=o.backend,i=this.readSync(r),a=s.refCount(r);s.disposeData(r,!0),o.backend=t,t.move(r,i,o.shape,o.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,r){let o=null;if(r==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");r=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof r!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=t}let s;return this.scopedRun(()=>this.startScope(o),()=>this.endScope(s),()=>(s=r(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,r,o){t();try{let s=o();return r(),s}catch(s){throw r(),s}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(t){let r=N.runKernel(qo,{x:t}),o={x:t},s=a=>({x:()=>{let c="float32",u={x:a},l={dtype:c};return N.runKernel(jo,u,l)}}),i=[];return this.addTapeNode(this.state.activeScope.name,o,[r],s,i,{}),r}runKernel(t,r,o){if(this.backendName==null&&this.backend,!($u(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:r,attrs:o})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,r,o){let s=this.backend.numDataIds(),i=0;o.forEach(u=>{i+=u.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],c=s-r-i-a;if(c>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${c} data ids) after running '${t}'`)}runKernelFunc(t){let r,o=[],s=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let c;this.backendName==null&&this.backend;let u,l=zw(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(zw(t)){let{kernelName:h,inputs:g,attrs:x}=t;this.backendName==null&&this.backend;let v=$u(h,this.backendName);k(v!=null,()=>`Cannot find registered kernel '${h}' for backend '${this.backendName}'`),c=()=>{let w=this.backend.numDataIds();u=v.kernelFunc({inputs:g,attrs:x,backend:this.backend});let I=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,w,I);let _=I.map(A=>A.rank!=null?A:this.makeTensorFromTensorInfo(A));if(s){let A=this.getTensorsForGradient(h,g,_);o=this.saveTensorsForBackwardMode(A)}return _}}else{let{forwardFunc:h}=t,g=x=>{s&&(o=x.map(v=>this.keep(this.clone(v))))};c=()=>{let x=this.backend.numDataIds();u=this.tidy(()=>h(this.backend,g));let v=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,x,v),v}}let{inputs:p,attrs:d}=t,f=zw(t)?null:t.backwardsFunc,m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?r=c():(m=this.profiler.profileKernel(l,p,()=>c()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),r=m.outputs)}),s&&this.addTapeNode(l,p,r,f,o,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(h=>p[h]!=null?p[h].shape:null),outputShapes:r.map(h=>h.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(t){return t.map(o=>this.keep(this.clone(o)))}getTensorsForGradient(t,r,o){let s=Bg(t);if(s!=null){let i=s.inputsToSave||[],a=s.outputsToSave||[],c;s.saveAllInputs?(k(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),c=Object.keys(r).map(l=>r[l])):c=i.map(l=>r[l]);let u=o.filter((l,p)=>a[p]);return c.concat(u)}return[]}makeTensor(t,r,o,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");o=o||"float32",s=s||this.backend;let i=t;o==="string"&&$r(t[0])&&(i=t.map(u=>$i(u)));let a=s.write(i,r,o),c=new Ke(r,o,a,this.nextTensorId());if(this.trackTensor(c,s),o==="string"){let u=this.state.tensorInfo.get(a),l=Nw(i);this.state.numBytes+=l-u.bytes,u.bytes=l}return c}makeTensorFromDataId(t,r,o,s){o=o||"float32";let i={dataId:t,shape:r,dtype:o};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(t,r){let{dataId:o,shape:s,dtype:i}=t,a=new Ke(s,i,o,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(t,r=!0,o,s){o=o||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));let i=new bo(t,r,o,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,r){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let o=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(o=t.size*ep(t.dtype)),this.state.numBytes+=o,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:r||this.backend,dtype:t.dtype,shape:t.shape,bytes:o})),t instanceof bo||this.track(t)}incRef(t,r){this.trackTensor(t,r),this.backend.incRef(t.dataId)}removeDataId(t,r){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===r&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let r=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let o=t.size*ep(t.dtype);this.state.numBytes-=o}r.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,r.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let r=this.state.registeredVariables[t];this.disposeVariable(r)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let r=this.state.numBytes,o=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-r,this.state.activeProfile.newTensors=this.state.numTensors-o;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,r,o,s,i,a){let c={id:this.state.nextTapeNodeId++,kernelName:t,inputs:r,outputs:o,saved:i},u=Bg(t);u!=null&&(s=u.gradFunc),s!=null&&(c.gradient=l=>(l=l.map((p,d)=>{if(p==null){let f=o[d],m=np(f.size,f.dtype);return this.makeTensor(m,f.shape,f.dtype)}return p}),s(l.length>1?l:l[0],i,a))),this.state.activeTape.push(c)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(r.name=t),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(t){let r=Rf(t),o=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){let a=this.state.activeScope.track[i];!a.kept&&!o.has(a.id)&&a.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(t,r,o,s=!1){if(k(r.length>0,()=>"gradients() received an empty list of xs."),o!=null&&o.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${o.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));k(i instanceof Ke,()=>"The result y returned by f() must be a tensor.");let a=O2(this.state.activeTape,r,i);if(!s&&a.length===0&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let c={};c[i.id]=o??m9(i.shape),M2(c,a,l=>this.tidy(l),h9);let u=r.map(l=>c[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let p of l.saved)p.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(t){return k(xo(t),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{k(r.every(c=>c instanceof Ke),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let o,s={};r.forEach((c,u)=>{s[u]=c});let i=(c,u)=>(o=t(...r,u),k(o.value instanceof Ke,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),k(xo(o.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o.value),a=(c,u)=>{let l=o.gradFunc(c,u),p=Array.isArray(l)?l:[l];k(p.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),k(p.every(f=>f instanceof Ke),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let d={};return p.forEach((f,m)=>{d[m]=()=>f}),d};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,r){return this.state.tensorInfo.get(t).backend.readToGPU(t,r)}async time(t){let r=Uu(),o=await this.backend.time(t);return o.wallMs=Uu()-r,o}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Kg;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();N=Hw()});var Yo={};Le(Yo,{isBrowser:()=>Ww,isMobile:()=>y9,mockIsMobile:()=>x9});function g9(){return typeof navigator<"u"&&navigator!=null}function x9(n){Gw=n}function y9(n){if(Gw!==void 0)return Gw;if(n||g9()){if(n||(n=navigator),n.product==="ReactNative")return!0;let e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){let t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Ww(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Gw,jw=D(()=>{"use strict";});var Nn,wp=D(()=>{"use strict";B();jw();Gt();Nn=M();Nn.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Nn.registerFlag("IS_BROWSER",()=>Ww());Nn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Nn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Nn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Nn.registerFlag("PROD",()=>!1);Nn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Nn.getBool("DEBUG"));Nn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Nn.registerFlag("IS_TEST",()=>!1);Nn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Nn.getBool("DEBUG"));Nn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Nn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Nn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1)});function Jt(n,e){let t=n;if(Ct(n))return e==="string"?[]:[n.length];if(jg(n)){let o=n.channels||"RGBA";return[n.height,n.width*o.length]}else if(qg(n))return[n.buffer.size/(e==null?4:ep(e))];if(!Array.isArray(n))return[];let r=[];for(;Array.isArray(t)||Ct(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&M().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Y2(n,r,[]),r}function Y2(n,e,t){if(t=t||[],!Array.isArray(n)&&!Ct(n)){k(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}k(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),k(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);let r=e.slice(1);for(let o=0;o<n.length;++o)Y2(n[o],r,t.concat(o))}function X2(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function C(n,e,t,r="numeric"){if(n instanceof Lw())return X2(r,n.dtype,e,t),n;let o=Bs(n);if(o!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),X2(r,o,e,t),n==null||!Ct(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){let c=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${c}'`)}let s=Jt(n,o);!Ct(n)&&!Array.isArray(n)&&(n=[n]);let a=o!=="string"?yp(n,o):Lr(n,[],!0);return N.makeTensor(a,s,o)}function Zo(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,i)=>C(s,`${e}[${i}]`,t,r))}var $=D(()=>{"use strict";B();Gt();or();Cp();q();Ot();});function E(n){let e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0],r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Xg;let o=(...s)=>{N.startScope(t);try{let i=r(...s);return ja(i)&&console.error("Cannot return a Promise inside of tidy."),N.endScope(i),i}catch(i){throw N.endScope(null),i}};return Object.defineProperty(o,"name",{value:t,configurable:!0}),o}var Xg,O=D(()=>{"use strict";B();q();Xg="__op"});function v9(n,e){let t=C(n,"real","complex"),r=C(e,"imag","complex");et(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);let o={real:t,imag:r};return N.runKernel(rc,o)}var vn,Li=D(()=>{"use strict";B();G();$();q();O();vn=E({complex_:v9})});function bn(n,e,t,r){if(r==null)r=Bs(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(qg(n)||jg(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return N.backend.createTensorFromGPUData(n,e||t,r)}if(!Ct(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){st(e);let o=Ne(e),s=Ne(t);k(o===s,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<t.length;++i){let a=t[i],c=i===t.length-1?a!==Ne(e.slice(i)):!0;k(t[i]===e[i]||!c,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Ct(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?yp(n,r):Lr(n,[],!0),N.makeTensor(n,e,r)}var Qo=D(()=>{"use strict";B();Cp();q();});function an(n,e,t){let r=Jt(n,t);return bn(n,e,r,t)}var Ff=D(()=>{"use strict";$();Qo();});var Jo,qw=D(()=>{"use strict";Jo={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}});function b9(n,e){let t=0,r=n.length;for(;t<=r;){let o=Math.floor((r-t)/2)+t,s=e(n[o]);if(s===0)return o;s<0?r=o:t=o+1}return-1}var en,Bi=D(()=>{"use strict";q();en=class n{static join(e){return new n(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>Ct(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){let o=e[r];r!==e.length-1&&o.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=t+o.byteLength;this.shards.push({buffer:o,start:t,end:s}),t=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);let r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);let o=t-e,s=new ArrayBuffer(o),i=new Uint8Array(s),a=0;for(let c=r;c<this.shards.length;c++){let u=this.shards[c],p=e+a-u.start,d=a,m=Math.min(t,u.end)-u.start,h=new Uint8Array(u.buffer,p,m-p);if(i.set(h,d),a+=h.length,t<u.end)break}return s}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(o){return e<o.start?-1:e>=o.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=b9(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}});function C9(){M().set("PROD",!0)}function w9(){M().set("DEBUG",!0)}function I9(){M().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Z2(n){M().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function E9(){N.disposeVariables()}function sr(){return N}function T9(){return N.memory()}function S9(n){return N.profile(n)}function Ce(n,e){return N.tidy(n,e)}function ht(n){Rf(n).forEach(t=>t.dispose())}function Cn(n){return N.keep(n)}function N9(n){return N.time(n)}function D9(n){return N.setBackend(n)}function k9(){return N.ready()}function Kw(){return N.backendName}function _9(n){N.removeBackend(n)}function A9(n){return N.findBackend(n)}function R9(n){return N.findBackendFactory(n)}function Of(n,e,t=1){return N.registerBackend(n,e,t)}function Xw(){return N.backend}function F9(n,e){M().setPlatform(n,e)}var zn=D(()=>{"use strict";B();Gt();or();at();H2(Z2)});async function eA(n,e){let t=[],r=[],o=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<o.length;++i){let a=o[i],c=Array.isArray(n)?n[i].tensor:n[a];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${c.dtype}`);let u={name:a,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){let l=new Promise(async p=>{let d=await c.bytes(),f=d.reduce((g,x)=>g+x.length,0)+Vi*d.length,m=new Uint8Array(f),h=0;for(let g=0;g<d.length;g++){let x=d[g],v=new Uint8Array(new Uint32Array([x.length]).buffer);m.set(v,h),h+=Vi,m.set(x,h),h+=x.length}p(m)});r.push(l)}else r.push(c.data());e!=null&&(u.group=e),t.push(u)}let s=await Promise.all(r);return{data:$9(s),specs:t}}function Yg(n,e){let t=new en(n),r={},o=0;for(let s of e){let i=O9(s,(a,c)=>t.slice(o+a,o+c));r[s.name]=tA(s,t.slice(o,o+i)),o+=i}return r}function O9(n,e){let t=Ne(n.shape),r;if("quantization"in n){let o=n.quantization;r=Jo[o.dtype]}else if(n.dtype==="string"){let o=0;for(let s=0;s<t;s++)o+=Vi+new Uint32Array(e(o,o+Vi))[0];return o}else r=Jo[n.dtype];return t*r}async function M9(n,e){let t=Ne(n.shape),r;if("quantization"in n){let o=n.quantization;r=Jo[o.dtype]}else if(n.dtype==="string"){let o=0;for(let s=0;s<t;s++)o+=Vi+new Uint32Array(await e(o,o+Vi))[0];return o}else r=Jo[n.dtype];return t*r}function tA(n,e){let t=n.name,r=n.dtype,o=n.shape,s=Ne(o),i,a=0;if("quantization"in n){let c=n.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${n.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${n.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let u=Jo[c.dtype],l=c.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){i=new Float32Array(l.length);for(let p=0;p<l.length;p++){let d=l[p];i[p]=d*c.scale+c.min}}else if(c.dtype==="float16")i=V9()(l);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(r==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);i=new Int32Array(l.length);for(let p=0;p<l.length;p++){let d=l[p];i[p]=Math.round(d*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);a+=s*u}else if(r==="string"){let c=Ne(n.shape);i=[];for(let u=0;u<c;u++){let l=new Uint32Array(e.slice(a,a+Vi))[0];a+=Vi;let p=new Uint8Array(e.slice(a,a+l));i.push(p),a+=l}}else{let c=Jo[r];if(r==="float32")i=new Float32Array(e);else if(r==="int32")i=new Int32Array(e);else if(r==="bool")i=new Uint8Array(e);else if(r==="complex64"){i=new Float32Array(e);let u=new Float32Array(i.length/2),l=new Float32Array(i.length/2);for(let m=0;m<u.length;m++)u[m]=i[m*2],l[m]=i[m*2+1];let p=an(u,o,"float32"),d=an(l,o,"float32"),f=vn(p,d);return p.dispose(),d.dispose(),f}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);a+=s*c}return an(i,o,r)}async function Q2(n,e,t){let r=new Uint8Array(e);for(;r.byteLength<t;){let{done:o,value:s}=await n.read();if(o&&s==null){let a=t-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}let i=new Uint8Array(r.length+s.byteLength);i.set(r,0),i.set(new Uint8Array(s),r.length),r=i}return r.buffer}async function Zg(n,e){let t={},r=n.getReader(),o=new ArrayBuffer(0);for(let s of e){let i=await M9(s,async(u,l)=>(o=await Q2(r,o,l),o.slice(u,l)));o=await Q2(r,o,i);let a=o.slice(0,i);o=o.slice(i);let c=tA(s,a);if(t[s.name]=c,Kw()==="webgpu"){let u=Xw();"uploadToGPU"in u&&Ne(c.shape)>=M().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(c.dataId)}}return t}function $9(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0,t=[];n.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(e),o=0;return t.forEach(s=>{r.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),r.buffer}function J2(n){return Yw?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function nA(n){if(Yw)return Buffer.from(n).toString("base64");let e=new Uint8Array(n),t="";for(let r=0,o=e.length;r<o;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function rA(n){if(Yw){let r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function oA(n){return en.join(n)}function Zw(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);let t=n.split("/");return t[t.length-1]}function Qg(n,e){let t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function Qw(n,e,t){let r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}async function Ip(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),Qw(n,t,r)}function Co(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:J2(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:J2(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new en(n.weightData).byteLength}}function Mf(n){let e=[];for(let t of n)e.push(...t.weights);return e}function P9(){let n=t=>{let r=t<<13,o=0;for(;(r&8388608)===0;)o-=8388608,r<<=1;return r&=-8388609,o+=947912704,r|o},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function L9(){let n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function B9(){let n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function V9(){let n=P9(),e=L9(),t=B9();return r=>{let o=new ArrayBuffer(4*r.length),s=new Uint32Array(o);for(let i=0;i<r.length;i++){let a=r[i],c=n[t[a>>10]+(a&1023)]+e[a>>10];s[i]=c}return new Float32Array(o)}}var Vi,Yw,Ui=D(()=>{"use strict";Li();Ff();q();qw();Bi();zn();Gt();zn();Vi=4;Yw=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u")});var Mt,sA,iA,aA,cA,zu=D(()=>{"use strict";Mt=class n{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return n.instance==null&&(n.instance=new n),n.instance}static registerSaveRouter(e){n.getInstance().saveRouters.push(e)}static registerLoadRouter(e){n.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return n.getHandlers(e,"save")}static getLoadHandlers(e,t){return n.getHandlers(e,"load",t)}static getHandlers(e,t,r){let o=[];return(t==="load"?n.getInstance().loadRouters:n.getInstance().saveRouters).forEach(i=>{let a=i(e,r);a!==null&&o.push(a)}),o}},sA=n=>Mt.registerSaveRouter(n),iA=n=>Mt.registerLoadRouter(n),aA=n=>Mt.getSaveHandlers(n),cA=(n,e)=>Mt.getLoadHandlers(n,e)});function uA(){if(!M().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function tI(n){let e=n.result;e.createObjectStore(Hu,{keyPath:"modelPath"}),e.createObjectStore(zi,{keyPath:"modelPath"})}function U9(n){return new Gu(n)}function z9(n){return n.startsWith(Gu.URL_SCHEME)?n.slice(Gu.URL_SCHEME.length):n}var Jw,eI,Hu,zi,Gu,lA,Jg,nI=D(()=>{"use strict";wp();Gt();Ui();zu();Bi();Jw="tensorflowjs",eI=1,Hu="models_store",zi="model_info_store";Gu=(()=>{class n{constructor(t){if(this.indexedDB=uA(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,r){return new Promise((o,s)=>{let i=this.indexedDB.open(Jw,eI);i.onupgradeneeded=()=>tI(i),i.onsuccess=()=>{let a=i.result;if(r==null){let c=a.transaction(Hu,"readonly"),l=c.objectStore(Hu).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));o(l.result.modelArtifacts)},l.onerror=p=>(a.close(),s(l.error)),c.oncomplete=()=>a.close()}else{r.weightData=en.join(r.weightData);let c=Co(r),u=a.transaction(zi,"readwrite"),l=u.objectStore(zi),p;try{p=l.put({modelPath:this.modelPath,modelArtifactsInfo:c})}catch(f){return s(f)}let d;p.onsuccess=()=>{d=a.transaction(Hu,"readwrite");let f=d.objectStore(Hu),m;try{m=f.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:c})}catch(h){return s(h)}m.onsuccess=()=>o({modelArtifactsInfo:c}),m.onerror=h=>{l=u.objectStore(zi);let g=l.delete(this.modelPath);g.onsuccess=()=>(a.close(),s(m.error)),g.onerror=x=>(a.close(),s(m.error))}},p.onerror=f=>(a.close(),s(p.error)),u.oncomplete=()=>{d==null?a.close():d.oncomplete=()=>a.close()}}},i.onerror=a=>s(i.error)})}}return n.URL_SCHEME="indexeddb://",n})(),lA=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Gu.URL_SCHEME)?U9(n.slice(Gu.URL_SCHEME.length)):null;Mt.registerSaveRouter(lA);Mt.registerLoadRouter(lA);Jg=class{constructor(){this.indexedDB=uA()}async listModels(){return new Promise((e,t)=>{let r=this.indexedDB.open(Jw,eI);r.onupgradeneeded=()=>tI(r),r.onsuccess=()=>{let o=r.result,s=o.transaction(zi,"readonly"),a=s.objectStore(zi).getAll();a.onsuccess=()=>{let c={};for(let u of a.result)c[u.modelPath]=u.modelArtifactsInfo;e(c)},a.onerror=c=>(o.close(),t(a.error)),s.oncomplete=()=>o.close()},r.onerror=o=>t(r.error)})}async removeModel(e){return e=z9(e),new Promise((t,r)=>{let o=this.indexedDB.open(Jw,eI);o.onupgradeneeded=()=>tI(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(zi,"readwrite"),a=i.objectStore(zi),c=a.get(e),u;c.onsuccess=()=>{if(c.result==null)return s.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let l=a.delete(e),p=()=>{u=s.transaction(Hu,"readwrite");let f=u.objectStore(Hu).delete(e);f.onsuccess=()=>t(c.result.modelArtifactsInfo),f.onerror=m=>r(c.error)};l.onsuccess=p,l.onerror=d=>(p(),s.close(),r(c.error))}},c.onerror=l=>(s.close(),r(c.error)),i.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},o.onerror=s=>r(o.error)})}}});function dA(n){return{info:[Ep,n,pA].join(es),topology:[Ep,n,H9].join(es),weightSpecs:[Ep,n,G9].join(es),weightData:[Ep,n,W9].join(es),modelMetadata:[Ep,n,j9].join(es)}}function fA(n){for(let e of Object.values(n))window.localStorage.removeItem(e)}function q9(n){let e=n.split(es);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(es)}function K9(n){return n.startsWith(Wu.URL_SCHEME)?n.slice(Wu.URL_SCHEME.length):n}function X9(n){return new Wu(n)}var es,Ep,pA,H9,G9,W9,j9,Wu,mA,ex,rI=D(()=>{"use strict";wp();Gt();q();Ui();Bi();zu();es="/",Ep="tensorflowjs_models",pA="info",H9="model_topology",G9="weight_specs",W9="weight_data",j9="model_metadata";Wu=(()=>{class n{constructor(t){if(!M().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=dA(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let r=JSON.stringify(t.modelTopology),o=JSON.stringify(t.weightSpecs),s=Co(t),i=en.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,r),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,nA(i));let a={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw fA(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let r={},o=JSON.parse(this.LS.getItem(this.keys.topology));if(o==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);r.modelTopology=o;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);r.weightSpecs=s;let i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){let c=JSON.parse(i);r.format=c.format,r.generatedBy=c.generatedBy,r.convertedBy=c.convertedBy,c.signature!=null&&(r.signature=c.signature),c.userDefinedMetadata!=null&&(r.userDefinedMetadata=c.userDefinedMetadata),c.modelInitializer!=null&&(r.modelInitializer=c.modelInitializer),c.initializerSignature!=null&&(r.initializerSignature=c.initializerSignature),c.trainingConfig!=null&&(r.trainingConfig=c.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return r.weightData=rA(a),r}}return n.URL_SCHEME="localstorage://",n})(),mA=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Wu.URL_SCHEME)?X9(n.slice(Wu.URL_SCHEME.length)):null;Mt.registerSaveRouter(mA);Mt.registerLoadRouter(mA);ex=class{constructor(){k(M().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),k(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=Ep+es,r=es+pA;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(t)&&s.endsWith(r)){let i=q9(s);e[i]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=K9(e);let t=dA(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let r=JSON.parse(this.LS.getItem(t.info));return fA(t),r}}});function tx(n){if(n.indexOf(Tp)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Vr.getSchemes().join(",")}`);return{scheme:n.split(Tp)[0],path:n.split(Tp)[1]}}async function hA(n,e,t=!1){k(n!==e,()=>`Old path and new path are the same: '${n}'`);let r=Mt.getLoadHandlers(n);k(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),k(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);let o=r[0],s=Mt.getSaveHandlers(e);k(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),k(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);let i=s[0],a=tx(n).scheme,c=tx(n).path,u=a===tx(n).scheme,l=await o.load();t&&u&&await Vr.getManager(a).removeModel(c);let p=await i.save(l);return t&&!u&&await Vr.getManager(a).removeModel(c),p.modelArtifactsInfo}async function gA(){let n=Vr.getSchemes(),e={};for(let t of n){let r=await Vr.getManager(t).listModels();for(let o in r){let s=t+Tp+o;e[s]=r[o]}}return e}async function xA(n){let e=tx(n);return Vr.getManager(e.scheme).removeModel(e.path)}async function yA(n,e){return hA(n,e,!1)}async function vA(n,e){return hA(n,e,!0)}var Tp,Vr,oI=D(()=>{"use strict";q();zu();Tp="://",Vr=class n{constructor(){this.managers={}}static getInstance(){return n.instance==null&&(n.instance=new n),n.instance}static registerManager(e,t){k(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Tp)&&(e=e.slice(0,e.indexOf(Tp))),k(e.length>0,()=>"scheme must not be an empty string.");let r=n.getInstance();k(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){let t=n.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(n.getInstance().managers)}}});var sI,bA=D(()=>{"use strict";wp();Gt();nI();rI();oI();Aw();sI=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!M().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();let o=this.functionRefs[r.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Ug(e)}};if(M().get("IS_BROWSER")){M().setPlatform("browser",new sI);try{Vr.registerManager(Wu.URL_SCHEME,new ex)}catch{}try{Vr.registerManager(Gu.URL_SCHEME,new Jg)}catch{}}});var wA=Jn((Sp,CA)=>{"use strict";var Y9=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("unable to locate global object")},ju=Y9();CA.exports=Sp=ju.fetch;ju.fetch&&(Sp.default=ju.fetch.bind(ju));Sp.Headers=ju.Headers;Sp.Request=ju.Request;Sp.Response=ju.Response});var IA=Jn(()=>{"use strict"});var Z9,iI,aI,EA=D(()=>{"use strict";Gt();Z9={importFetch:()=>wA()},aI=class{constructor(){this.util=IA(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return M().global.fetch!=null?M().global.fetch(e,t):(iI==null&&(iI=Z9.importFetch()),iI(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};M().get("IS_NODE")&&!M().get("IS_BROWSER")&&M().setPlatform("node",new aI)});function ue(n,e="float32",t){return e=e||"float32",st(n),new Ve(n,e,t)}var ts=D(()=>{"use strict";or();q();});function Q9(n,e){let t=C(n,"x","cast");if(!Sw(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:t},o={dtype:e};return N.runKernel(jo,r,o)}var De,tn=D(()=>{"use strict";B();G();$();q();O();De=E({cast_:Q9})});function J9(n){let t={x:C(n,"x","clone","string_or_numeric")};return N.runKernel(qo,t)}var Dn,Np=D(()=>{"use strict";B();G();$();O();Dn=E({clone_:J9})});function $f(n,e=!1){console.log(n.toString(e))}var cI=D(()=>{"use strict";});var eK,TA=D(()=>{"use strict";B();wp();bA();EA();ts();tn();Np();cI();or();Hw();eK={buffer:ue,cast:De,clone:Dn,print:$f};z2(eK)});function tK(n,e){let t=C(n,"a","add"),r=C(e,"b","add");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel("Add",o)}var de,_t=D(()=>{"use strict";B();at();$();O();de=E({add_:tK})});function nK(n,e){let t=C(n,"a","floorDiv"),r=C(e,"b","floorDiv");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel(ti,o)}var Pf,uI=D(()=>{"use strict";B();G();at();$();O();Pf=E({floorDiv_:nK})});function rK(n,e){let t=C(n,"a","div"),r=C(e,"b","div");if([t,r]=Ee(t,r),t.dtype==="int32"&&r.dtype==="int32")return Pf(t,r);let o={a:t,b:r},s={};return N.runKernel(Zs,o,s)}var Oe,kn=D(()=>{"use strict";B();G();at();$();uI();O();Oe=E({div_:rK})});function oK(n,e){let t=C(n,"a","mul"),r=C(e,"b","mul");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel(hi,o)}var ee,ct=D(()=>{"use strict";B();G();at();$();O();ee=E({mul_:oK})});function sK(n){let e=C(n,"x","abs");if(e.dtype==="complex64"){let t={x:e};return N.runKernel(oc,t)}else{let t={x:e};return N.runKernel("Abs",t)}}var $t,qu=D(()=>{"use strict";B();G();$();O();$t=E({abs_:sK})});function iK(n){let t={x:C(n,"x","acos")};return N.runKernel(Vs,t)}var lI,SA=D(()=>{"use strict";B();G();$();O();lI=E({acos_:iK})});function aK(n){let t={x:C(n,"x","acosh")};return N.runKernel(Us,t)}var pI,NA=D(()=>{"use strict";B();G();$();O();pI=E({acosh_:aK})});function cK(n){k(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),k(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);let e=n.map((o,s)=>C(o,`tensors${s}`,"addN")),t=e[0];e.forEach(o=>{if(o.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(o=>{if(!xn(o.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=e;return N.runKernel(Ka,r)}var dI,DA=D(()=>{"use strict";B();G();$();q();O();dI=E({addN_:cK})});function uK(n,e=null,t=!1){let o={x:C(n,"x","all","bool")},s={axis:e,keepDims:t};return N.runKernel("All",o,s)}var fI,kA=D(()=>{"use strict";B();$();O();fI=E({all_:uK})});function lK(n,e=null,t=!1){let o={x:C(n,"x","any","bool")},s={axis:e,keepDims:t};return N.runKernel("Any",o,s)}var mI,_A=D(()=>{"use strict";B();$();O();mI=E({any_:lK})});function pK(n,e=0){let r={x:C(n,"x","argMax")},o={axis:e};return N.runKernel(Xa,r,o)}var hI,AA=D(()=>{"use strict";B();G();$();O();hI=E({argMax_:pK})});function dK(n,e=0){let r={x:C(n,"x","argMin")},o={axis:e};return N.runKernel(Ya,r,o)}var gI,RA=D(()=>{"use strict";B();G();$();O();gI=E({argMin_:dK})});function fK(n){let t={x:C(n,"x","asin")};return N.runKernel(zs,t)}var xI,FA=D(()=>{"use strict";B();G();$();O();xI=E({asin_:fK})});function mK(n){let t={x:C(n,"x","asinh")};return N.runKernel(Hs,t)}var yI,OA=D(()=>{"use strict";B();G();$();O();yI=E({asinh_:mK})});function hK(n){let t={x:C(n,"x","atan")};return N.runKernel(Gs,t)}var vI,MA=D(()=>{"use strict";B();G();$();O();vI=E({atan_:hK})});function gK(n,e){let t=C(n,"a","atan2"),r=C(e,"b","atan2");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel(js,o)}var bI,$A=D(()=>{"use strict";B();G();at();$();O();bI=E({atan2_:gK})});function xK(n){let t={x:C(n,"x","atanh")};return N.runKernel(Ws,t)}var CI,PA=D(()=>{"use strict";B();G();$();O();CI=E({atanh_:xK})});function yK(n,e,t,r,o="NHWC",s){let i=n[3],a=[...e,i],c=BA(o);return Xu(n,a,t,s,r,null,null,c)}function II(n,e,t,r,o,s,i="channelsLast"){let[a,c]=Lf(e),u;if(i==="channelsLast")u=[a,c,n[3],n[3]];else if(i==="channelsFirst")u=[a,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return Xu(n,u,t,r,o,s,!1,i)}function vK(n,e,t,r,o,s,i="NDHWC"){let[a,c,u]=wI(e),l,p;if(i==="NDHWC")p="channelsLast",l=[a,c,u,n[4],n[4]];else if(i==="NCDHW")p="channelsFirst",l=[a,c,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return LA(n,l,t,r,o,!1,p,s)}function Xu(n,e,t,r,o,s,i=!1,a="channelsLast"){let[c,u,l,p]=[-1,-1,-1,-1];if(a==="channelsLast")[c,u,l,p]=n;else if(a==="channelsFirst")[c,p,u,l]=n;else throw new Error(`Unknown dataFormat ${a}`);let[d,f,,m]=e,[h,g]=Lf(t),[x,v]=Lf(r),w=Dp(d,x),I=Dp(f,v),{padInfo:_,outHeight:A,outWidth:R}=wK(o,u,l,h,g,w,I,s,a),F=i?m*p:m,P;return a==="channelsFirst"?P=[c,F,A,R]:a==="channelsLast"&&(P=[c,A,R,F]),{batchSize:c,dataFormat:a,inHeight:u,inWidth:l,inChannels:p,outHeight:A,outWidth:R,outChannels:F,padInfo:_,strideHeight:h,strideWidth:g,filterHeight:d,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:I,dilationHeight:x,dilationWidth:v,inShape:n,outShape:P,filterShape:e}}function LA(n,e,t,r,o,s=!1,i="channelsLast",a){let[c,u,l,p,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[c,u,l,p,d]=n;else if(i==="channelsFirst")[c,d,u,l,p]=n;else throw new Error(`Unknown dataFormat ${i}`);let[f,m,h,,g]=e,[x,v,w]=wI(t),[I,_,A]=wI(r),R=Dp(f,I),F=Dp(m,_),P=Dp(h,A),{padInfo:L,outDepth:V,outHeight:z,outWidth:H}=IK(o,u,l,p,x,v,w,R,F,P,a),j=s?g*d:g,W;return i==="channelsFirst"?W=[c,j,V,z,H]:i==="channelsLast"&&(W=[c,V,z,H,j]),{batchSize:c,dataFormat:i,inDepth:u,inHeight:l,inWidth:p,inChannels:d,outDepth:V,outHeight:z,outWidth:H,outChannels:j,padInfo:L,strideDepth:x,strideHeight:v,strideWidth:w,filterDepth:f,filterHeight:m,filterWidth:h,effectiveFilterDepth:R,effectiveFilterHeight:F,effectiveFilterWidth:P,dilationDepth:I,dilationHeight:_,dilationWidth:A,inShape:n,outShape:W,filterShape:e}}function bK(n,e,t,r,o){r==null&&(r=EI(n,e,t));let s=n[0],i=n[1],a=Bf((s-e+2*r)/t+1,o),c=Bf((i-e+2*r)/t+1,o);return[a,c]}function CK(n,e,t,r,o,s){o==null&&(o=EI(n,e[0],r[0]));let i=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*o>=e[a]&&(i[a]=Bf((n[a]-e[a]+2*o)/r[a]+1,s));return i}function EI(n,e,t,r=1){let o=Dp(e,r);return Math.floor((n[0]*(t-1)-t+o)/2)}function Lf(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function wI(n){return typeof n=="number"?[n,n,n]:n}function Dp(n,e){return e<=1?n:n+(n-1)*(e-1)}function wK(n,e,t,r,o,s,i,a,c){let u,l,p;if(typeof n=="number"){u={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};let f=bK([e,t],s,r,n,a);l=f[0],p=f[1]}else if(n==="same"){l=Math.ceil(e/r),p=Math.ceil(t/o);let d=Math.max(0,(l-1)*r+s-e),f=Math.max(0,(p-1)*o+i-t),m=Math.floor(d/2),h=d-m,g=Math.floor(f/2),x=f-g;u={top:m,bottom:h,left:g,right:x,type:"SAME"}}else if(n==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((e-s+1)/r),p=Math.ceil((t-i+1)/o);else if(typeof n=="object"){let d=c==="channelsLast"?n[1][0]:n[2][0],f=c==="channelsLast"?n[1][1]:n[2][1],m=c==="channelsLast"?n[2][0]:n[3][0],h=c==="channelsLast"?n[2][1]:n[3][1];u={top:d,bottom:f,left:m,right:h,type:d===0&&f===0&&m===0&&h===0?"VALID":"EXPLICIT"},l=Bf((e-s+d+f)/r+1,a),p=Bf((t-i+m+h)/o+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:u,outHeight:l,outWidth:p}}function IK(n,e,t,r,o,s,i,a,c,u,l){let p,d,f,m;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};let g=CK([e,t,r,1],[a,c,u],1,[o,s,i],n,l);d=g[0],f=g[1],m=g[2]}else if(n==="same"){d=Math.ceil(e/o),f=Math.ceil(t/s),m=Math.ceil(r/i);let h=(d-1)*o+a-e,g=(f-1)*s+c-t,x=(m-1)*i+u-r,v=Math.floor(h/2),w=h-v,I=Math.floor(g/2),_=g-I,A=Math.floor(x/2),R=x-A;p={top:I,bottom:_,left:A,right:R,front:v,back:w,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:d,outHeight:f,outWidth:m}}function Bf(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Ku(n){let[e,t,r]=Lf(n);return e===1&&t===1&&r===1}function cn(n,e){return Ku(n)||Ku(e)}function wo(n){return Lf(n).every(e=>e>0)}function BA(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Tt(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")k(Go(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(o=>{k(Go(o),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${o}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}var _n=D(()=>{"use strict";q();});function EK(n,e){let r={x:C(n,"x","reshape","string_or_numeric")},o={shape:e};return N.runKernel(su,r,o)}var U,Se=D(()=>{"use strict";B();G();$();O();U=E({reshape_:EK})});function TK(n,e,t,r,o){let s=C(n,"x","avgPool","float32"),i=1;k(cn(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=s,c=!1;s.rank===3&&(c=!0,a=U(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Tt("avgPool",r,o);let u={x:a},l={filterSize:e,strides:t,pad:r,dimRoundingMode:o},p=N.runKernel(Za,u,l);return p=De(p,s.dtype),c?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Vf,TI=D(()=>{"use strict";B();G();$();q();tn();_n();O();Se();Vf=E({avgPool_:TK})});function SK(n,e,t,r,o,s="NDHWC"){let i=C(n,"x","avgPool3d","float32"),a=i,c=!1;i.rank===4&&(c=!0,a=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),k(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),k(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Tt("avgPool3d",r,o);let u={x:a},l={filterSize:e,strides:t,pad:r,dimRoundingMode:o,dataFormat:s},p=N.runKernel(Qa,u,l);return p=De(p,a.dtype),c?U(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var SI,VA=D(()=>{"use strict";B();G();$();q();tn();_n();O();Se();SI=E({avgPool3d_:SK})});function NK(n,e=0){k(n.length>=1,()=>"Pass at least one tensor to concat");let t=Zo(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return Dn(t[0]);let r=t,o={axis:e};return N.runKernel(sc,r,o)}var Qe,Ur=D(()=>{"use strict";B();G();$();q();Np();O();Qe=E({concat_:NK})});function DK(n,e,t=!1,r=!1){let o=C(n,"a","matMul"),s=C(e,"b","matMul");[o,s]=Ee(o,s);let i={a:o,b:s},a={transposeA:t,transposeB:r};return N.runKernel(Ja,i,a)}var Be,ns=D(()=>{"use strict";B();G();at();$();O();Be=E({matMul_:DK})});function kK(n){let t={x:C(n,"x","sigmoid","float32")};return N.runKernel(Ti,t)}var zr,Uf=D(()=>{"use strict";B();G();$();O();zr=E({sigmoid_:kK})});function _K(n,e,t){let r=C(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let o={x:r},s={begin:e,size:t};return N.runKernel(fu,o,s)}var Me,yr=D(()=>{"use strict";B();G();$();O();Me=E({slice_:_K})});function AK(n){let t={x:C(n,"x","tanh","float32")};return N.runKernel(_i,t)}var kp,NI=D(()=>{"use strict";B();G();$();O();kp=E({tanh_:AK})});function RK(n,e,t,r,o,s){let i=C(n,"forgetBias","basicLSTMCell"),a=C(e,"lstmKernel","basicLSTMCell"),c=C(t,"lstmBias","basicLSTMCell"),u=C(r,"data","basicLSTMCell"),l=C(o,"c","basicLSTMCell"),p=C(s,"h","basicLSTMCell"),d=Qe([u,p],1),f=Be(d,a),m=de(f,c),h=m.shape[0],g=m.shape[1]/4,x=[h,g],v=Me(m,[0,0],x),w=Me(m,[0,g],x),I=Me(m,[0,g*2],x),_=Me(m,[0,g*3],x),A=de(ee(zr(v),kp(w)),ee(l,zr(de(i,I)))),R=ee(kp(A),zr(_));return[A,R]}var DI,UA=D(()=>{"use strict";$();_t();Ur();ns();ct();O();Uf();yr();NI();DI=E({basicLSTMCell_:RK})});function FK(n,e,t){let r=C(n,"x","batchToSpaceND"),o=e.reduce((a,c)=>a*c);k(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),k(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),k(r.shape[0]%o===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`);let s={x:r},i={blockShape:e,crops:t};return N.runKernel(ec,s,i)}var zf,kI=D(()=>{"use strict";B();G();$();q();O();zf=E({batchToSpaceND_:FK})});function zA(n){let e;return n.rank===0||n.rank===1?e=U(n,[1,1,1,n.size]):n.rank===2?e=U(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}var HA=D(()=>{"use strict";Se()});function OK(n,e,t,r,o,s){s==null&&(s=.001);let i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),c=C(t,"variance","batchNorm"),u;o!=null&&(u=C(o,"scale","batchNorm"));let l;r!=null&&(l=C(r,"offset","batchNorm")),k(a.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:zA(i),scale:u,offset:l,mean:a,variance:c},f={varianceEpsilon:s},m=N.runKernel(kc,d,f);return U(m,i.shape)}var rs,Hf=D(()=>{"use strict";B();G();$();q();HA();O();Se();rs=E({batchNorm_:OK})});function MK(n,e,t,r,o,s){let i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),c=C(t,"variance","batchNorm"),u;o!=null&&(u=C(o,"scale","batchNorm"));let l;return r!=null&&(l=C(r,"offset","batchNorm")),k(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),k(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),k(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&k(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&k(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),rs(i,a,c,l,u,s)}var _I,GA=D(()=>{"use strict";$();q();Hf();O();_I=E({batchNorm2d_:MK})});function $K(n,e,t,r,o,s){let i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),c=C(t,"variance","batchNorm"),u;o!=null&&(u=C(o,"scale","batchNorm"));let l;return r!=null&&(l=C(r,"offset","batchNorm")),k(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),k(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),k(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&k(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&k(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),rs(i,a,c,l,u,s)}var AI,WA=D(()=>{"use strict";$();q();Hf();O();AI=E({batchNorm3d_:$K})});function PK(n,e,t,r,o,s){let i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),c=C(t,"variance","batchNorm"),u;o!=null&&(u=C(o,"scale","batchNorm"));let l;return r!=null&&(l=C(r,"offset","batchNorm")),k(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),k(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),k(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&k(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&k(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),rs(i,a,c,l,u,s)}var RI,jA=D(()=>{"use strict";$();q();Hf();O();RI=E({batchNorm4d_:PK})});function LK(n,e,t){let r=C(n,"x","bincount"),o=C(e,"weights","bincount");k(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),k(t>=0,()=>`size must be non-negative, but got ${t}.`),k(o.size===r.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${o.shape}.`);let s={x:r,weights:o},i={size:t};return N.runKernel(tc,s,i)}var Gf,FI=D(()=>{"use strict";B();G();$();q();O();Gf=E({bincount_:LK})});function BK(n,e){let t=C(n,"x","bitwiseAnd"),r=C(e,"y","bitwiseAnd");if(!xn(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if(t.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);let o={a:t,b:r};return N.runKernel(qs,o)}var OI,qA=D(()=>{"use strict";B();G();$();Ot();O();OI=E({bitwiseAnd_:BK})});function VK(n,e){let t=C(n,"s0","broadcastArgs","int32"),r=C(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let o={s0:t,s1:r};return N.runKernel(nc,o)}var MI,KA=D(()=>{"use strict";B();G();$();O();MI=E({broadcastArgs_:VK})});function UK(n,e){let t=C(n,"broadcastTo","x"),r=t.shape;if(st(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){let u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=U(t,u)}let o=t.shape,s=Array.from(e);for(let u=e.length-1;u>=0;u--)if(o[u]===e[u])s[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(s.map((u,l)=>u>1?l:-1).filter(u=>u>=0).length===0)return Dn(t);let a={x:t},c={reps:s};return N.runKernel(Ko,a,c)}var os,$I=D(()=>{"use strict";B();G();$();Ot();Np();O();Se();os=E({broadcastTo_:UK})});function zK(n){let t={x:C(n,"x","ceil","float32")};return N.runKernel(Ks,t)}var PI,XA=D(()=>{"use strict";B();G();$();O();PI=E({ceil_:zK})});function Hr(n,e,t){st(n),t=t||Bs(e);let r={shape:n,value:e,dtype:t};return N.runKernel(Nc,{},r)}var _p=D(()=>{"use strict";B();G();q();Ot();});function HK(n,e,t){let r=C(n,"x","clipByValue");if(k(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Hr(r.shape,e,r.dtype);let o={x:r},s={clipValueMin:e,clipValueMax:t};return N.runKernel(Xs,o,s)}var LI,YA=D(()=>{"use strict";B();G();$();q();_p();O();LI=E({clipByValue_:HK})});function GK(n){return Qe(n,0)}var BI,ZA=D(()=>{"use strict";Ur();O();BI=E({concat1d_:GK})});function WK(n,e){return Qe(n,e)}var VI,QA=D(()=>{"use strict";Ur();O();VI=E({concat2d_:WK})});function jK(n,e){return Qe(n,e)}var UI,JA=D(()=>{"use strict";Ur();O();UI=E({concat3d_:jK})});function qK(n,e){return Qe(n,e)}var zI,eR=D(()=>{"use strict";Ur();O();zI=E({concat4d_:qK})});function KK(n,e,t,r,o="NHWC",s=[1,1],i){let a=C(n,"x","conv2d","float32"),c=C(e,"filter","conv2d","float32"),u=a,l=!1;a.rank===3&&(l=!0,u=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),k(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),Tt("conv2d",r,i);let p=o==="NHWC"?u.shape[3]:u.shape[1];k(p===c.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${c.shape[2]}.`),k(cn(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),k(wo(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),k(wo(t),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:u,filter:c},f={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},m=N.runKernel(ic,d,f);return l?U(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var ss,Wf=D(()=>{"use strict";B();G();$();q();_n();O();Se();ss=E({conv2d_:KK})});function XK(n,e,t,r,o="NWC",s=1,i){let a=C(n,"x","conv1d"),c=C(e,"filter","conv1d"),u=a,l=!1;a.rank===2&&(l=!0,u=U(a,[1,a.shape[0],a.shape[1]])),k(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),k(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),Tt("conv1d",r,i),k(u.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${c.shape[1]}.`),k(cn(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),k(wo(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),k(wo(t),()=>"Error in conv1D: Stride should be larger than 0."),k(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=U(c,[1,c.shape[0],c.shape[1],c.shape[2]]),d=U(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=ss(d,p,[1,t],r,"NHWC",[1,s],i);return l?U(g,[g.shape[2],g.shape[3]]):U(g,[g.shape[0],g.shape[2],g.shape[3]])}var HI,tR=D(()=>{"use strict";$();q();Wf();_n();O();Se();HI=E({conv1d_:XK})});function YK(n,e,t,r,o,s="NHWC",i){k(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,c=e,u=!1;e.rank===3&&(u=!0,c=U(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),k(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),k(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),k(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);let l=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?c.shape[3]:c.shape[1];k(l===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[2]}.`),k(p===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${t.shape[3]}.`),Tt("conv2dDerInput",o,i);let d={dy:c,filter:t},f={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},m=N.runKernel(cc,d,f);return u?U(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var nx,GI=D(()=>{"use strict";B();G();q();_n();O();Se();nx=E({conv2DBackpropInput_:YK})});function ZK(n,e,t,r,o,s){let i=C(n,"x","conv2dTranspose"),a=C(e,"filter","conv2dTranspose");return nx(t,i,a,r,o,"NHWC",s)}var WI,nR=D(()=>{"use strict";$();GI();O();WI=E({conv2dTranspose_:ZK})});function QK(n,e,t,r,o="NDHWC",s=[1,1,1]){let i=C(n,"x","conv3d"),a=C(e,"filter","conv3d"),c=i,u=!1;i.rank===4&&(u=!0,c=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),k(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),k(c.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${a.shape[3]}.`),k(cn(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),k(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`),k(wo(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),k(wo(t),()=>"Error in conv3D: Strides should be larger than 0.");let l={x:c,filter:a},p={strides:t,pad:r,dataFormat:o,dilations:s},d=N.runKernel(uc,l,p);return u?U(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var jI,rR=D(()=>{"use strict";B();G();$();q();_n();O();Se();jI=E({conv3d_:QK})});function JK(n,e,t,r,o){k(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let s=n,i=e,a=!1;e.rank===4&&(a=!0,i=U(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,n[0],n[1],n[2],n[3]]);let c=s[4],u=i.shape[4];k(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),k(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),k(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),k(c===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[3]}.`),k(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);let l={dy:i,filter:t},p={pad:o,strides:r,inputShape:s},d=N.runKernel(lc,l,p);return a?U(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var oR,sR=D(()=>{"use strict";B();G();q();O();Se();oR=E({conv3DBackpropInput_:JK})});function eX(n,e,t,r,o){let s=C(n,"x","conv3dTranspose"),i=C(e,"filter","conv3dTranspose");return oR(t,s,i,r,o)}var qI,iR=D(()=>{"use strict";$();sR();O();qI=E({conv3dTranspose_:eX})});function tX(n){let t={x:C(n,"x","cos","float32")};return N.runKernel("Cos",t)}var KI,aR=D(()=>{"use strict";B();$();O();KI=E({cos_:tX})});function nX(n){let t={x:C(n,"x","cosh","float32")};return N.runKernel(Ys,t)}var XI,cR=D(()=>{"use strict";B();G();$();O();XI=E({cosh_:nX})});function rX(n,e=0,t=!1,r=!1){let s={x:C(n,"x","cumprod")},i={axis:e,exclusive:t,reverse:r};return N.runKernel(dc,s,i)}var YI,uR=D(()=>{"use strict";B();G();$();O();YI=E({cumprod_:rX})});function oX(n,e=0,t=!1,r=!1){let s={x:C(n,"x","cumsum")},i={axis:e,exclusive:t,reverse:r};return N.runKernel(fc,s,i)}var ZI,lR=D(()=>{"use strict";B();G();$();O();ZI=E({cumsum_:oX})});function sX(n,e,t,r=!1){let o=C(n,"x","denseBincount"),s=C(e,"weights","denseBincount");k(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),k(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),k(t>=0,()=>`size must be non-negative, but got ${t}.`),k(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:t,binaryOutput:r};return N.runKernel(hc,i,a)}var QI,pR=D(()=>{"use strict";B();G();$();q();O();QI=E({denseBincount_:sX})});function iX(n,e,t="NHWC"){let r=C(n,"x","depthToSpace","float32"),o=t==="NHWC"?r.shape[1]:r.shape[2],s=t==="NHWC"?r.shape[2]:r.shape[3],i=t==="NHWC"?r.shape[3]:r.shape[1];k(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),k(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e}  for depthToSpace with input shape
    ${r.shape}`),k(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${r.shape}`),k(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`);let a={x:r},c={blockSize:e,dataFormat:t};return N.runKernel(gc,a,c)}var JI,dR=D(()=>{"use strict";B();G();$();q();O();JI=E({depthToSpace_:iX})});function aX(n,e,t,r,o="NHWC",s=[1,1],i){let a=C(n,"x","depthwiseConv2d","float32"),c=C(e,"filter","depthwiseConv2d","float32"),u=a,l=!1;a.rank===3&&(l=!0,u=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),k(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);let p=o==="NHWC"?u.shape[3]:u.shape[1];k(p===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${c.shape[2]}.`),Tt("depthwiseConv2d",r,i);let d={x:u,filter:c},f={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},m=N.runKernel(xc,d,f);return l?U(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Yu,rx=D(()=>{"use strict";B();G();$();q();_n();O();Se();Yu=E({depthwiseConv2d_:aX})});function cX(n){let t={x:C(n,"x","diag")};return N.runKernel(bc,t)}var eE,fR=D(()=>{"use strict";B();G();$();O();eE=E({diag_:cX})});function uX(n,e,t,r,o=[1,1],s="NHWC"){let i=C(n,"x","dilation2d"),a=C(e,"filter","dilation2d");k(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),k(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),k(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let c=i,u=!1;i.rank===3&&(c=U(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),k(c.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${a.shape[2]}`);let l={x:c,filter:a},p={strides:t,pad:r,dilations:o},d=N.runKernel(Cc,l,p);return u?U(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var tE,mR=D(()=>{"use strict";B();G();$();q();O();Se();tE=E({dilation2d_:uX})});var Gr={};Le(Gr,{assertAndGetBroadcastShape:()=>ze,getBroadcastDims:()=>hR,getReductionAxes:()=>ox});function hR(n,e){let t=n.length,r=[];for(let o=0;o<t;o++){let s=t-1-o,i=n[s]||1;(e[e.length-1-o]||1)>1&&i===1&&r.unshift(s)}return r}function ox(n,e){let t=[];for(let r=0;r<e.length;r++){let o=n[n.length-r-1],s=e.length-r-1,i=e[s];(o==null||o===1&&i>1)&&t.unshift(s)}return t}function ze(n,e){let t=Math.max(n.length,e.length),r=new Array(t);for(let o=0;o<t;o++){let s=n[n.length-o-1];s==null&&(s=1);let i=e[e.length-o-1];if(i==null&&(i=1),s===1)r[t-o-1]=i;else if(i===1)r[t-o-1]=s;else if(s!==i){let a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else r[t-o-1]=s}return r}var Pt=D(()=>{"use strict";});function lX(n,e){let t=C(n,"a","equal","string_or_numeric"),r=C(e,"b","equal","string_or_numeric");[t,r]=Ee(t,r),ze(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Qs,o)}var jf,nE=D(()=>{"use strict";B();G();at();$();Pt();O();jf=E({equal_:lX})});function pX(n,e,t){let r=C(e,"a","where"),o=C(t,"b","where"),s=C(n,"condition","where","bool"),i=ze(ze(s.shape,r.shape),o.shape),a=os(s,i),c=os(r,i),u=os(o,i),l={condition:a,t:c,e:u};return N.runKernel(du,l)}var Hn,Ap=D(()=>{"use strict";B();G();$();$I();Pt();O();Hn=E({where_:pX})});function dX(n){let t={x:C(n,"x","zerosLike")};return N.runKernel(Ou,t)}var Nt,is=D(()=>{"use strict";B();G();$();O();Nt=E({zerosLike_:dX})});function fX(n,e){let t=C(n,"a","div"),r=C(e,"b","div");[t,r]=Ee(t,r);let o=Oe(t,r),s=Nt(o),i=jf(r,s);return Hn(i,s,o)}var rE,gR=D(()=>{"use strict";at();$();kn();nE();O();Ap();is();rE=E({divNoNan_:fX})});function mX(n,e){let t=C(n,"t1","dot"),r=C(e,"t2","dot");k((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);let o=t.rank===1?t.size:t.shape[1],s=r.rank===1?r.size:r.shape[0];if(k(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),t.rank===1&&r.rank===1){let i=U(t,[1,-1]),a=U(r,[-1,1]),c=Be(i,a);return U(c,[])}else if(t.rank===1&&r.rank===2){let i=U(t,[1,-1]),a=U(r,[r.shape[0],r.shape[1]]),c=Be(i,a);return U(c,[c.size])}else if(t.rank===2&&r.rank===1){let i=U(r,[-1,1]),a=Be(t,i);return U(a,[a.size])}else{let i=U(r,[r.shape[0],r.shape[1]]);return Be(t,i)}}var oE,xR=D(()=>{"use strict";$();q();ns();O();Se();oE=E({dot_:mX})});function hX(n,...e){let t=e.map((o,s)=>C(o,`tensors${s}`,"einsum")),r={equation:n};return N.runKernel(wc,t,r)}var as,sE=D(()=>{"use strict";B();G();$();O();as=E({einsum_:hX})});function gX(n){let t={x:C(n,"x","elu","float32")};return N.runKernel("Elu",t)}var qf,iE=D(()=>{"use strict";B();$();O();qf=E({elu_:gX})});function xX(n,e){let t=C(n,"x","ensureShape","string_or_numeric");if(!ww(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}var aE,yR=D(()=>{"use strict";$();Ot();O();aE=E({ensureShape_:xX})});function yX(n){let e=C(n,"x","erf");k(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=De(e,"float32"));let t={x:e};return N.runKernel("Erf",t)}var cE,vR=D(()=>{"use strict";B();$();q();tn();O();cE=E({erf_:yX})});function uE(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function bR(n,e,t){let r=n.length+e.length,o=[],s=0,i=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?o.push(n[s++]):o.push(e[i++]);return o}function vX(n,e){let t=[],r=n.length;for(let s=0;s<r;s++)e.indexOf(s)===-1&&t.push(n[s]);let o=e.map(s=>n[s]);return[t,o]}function cs(n,e){let t=e.map(r=>1);return bR(n,t,e)}function bX(n,e,t){k(uE(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function CX(n,e){if(uE(n,e))return null;let t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function wX(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function IX(n,e){let t=[];for(let r=e-n;r<e;++r)t.push(r);return t}var Rp=D(()=>{"use strict";q();});function TX(n,e=null,t=!1){let o={x:C(n,"x","max")},s={reductionIndices:e,keepDims:t};return N.runKernel("Max",o,s)}var Wr,Kf=D(()=>{"use strict";B();$();O();Wr=E({max_:TX})});function SX(n,e=null,t=!1){let o={x:C(n,"x","min")},s={axis:e,keepDims:t};return N.runKernel("Min",o,s)}var Fp,lE=D(()=>{"use strict";B();$();O();Fp=E({min_:SX})});function NX(n,e){let t=C(n,"base","pow"),r=C(e,"exp","pow");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel("Pow",o)}var Eo,Xf=D(()=>{"use strict";B();at();$();O();Eo=E({pow_:NX})});function me(n,e){if((Ct(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ct(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return bn(n,[],[],e)}var un=D(()=>{"use strict";q();Qo();});function DX(n){let t={x:C(n,"x","sqrt","float32")};return N.runKernel(Ni,t)}var wn,Op=D(()=>{"use strict";B();G();$();O();wn=E({sqrt_:DX})});function kX(n){let e=C(n,"x","square"),t={};return N.runKernel("Square",{x:e},t)}var Lt,us=D(()=>{"use strict";B();$();O();Lt=E({square_:kX})});function _X(n,e=null,t=!1){let r=C(n,"x","sum");r.dtype==="bool"&&(r=De(r,"int32"));let o={x:r},s={axis:e,keepDims:t};return N.runKernel("Sum",o,s)}var He,jr=D(()=>{"use strict";B();$();tn();O();He=E({sum_:_X})});function AX(n,e="euclidean",t=null,r=!1){n=C(n,"x","norm");let o=CR(n,e,t),s=o.shape;if(r){let i=Ls(t,n.shape);s=cs(o.shape,i)}return U(o,s)}function CR(n,e,t=null){if(n.rank===0)return $t(n);if(n.rank!==1&&t===null)return CR(U(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return He($t(n),t);if(e===1/0)return Wr($t(n),t);if(e===-1/0)return Fp($t(n),t);if(e==="euclidean"||e===2)return wn(He(Eo($t(n),me(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Wr(He($t(n),t[0]),t[1]-1);if(e===1/0)return Wr(He($t(n),t[1]),t[0]);if(e===-1/0)return Fp(He($t(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return wn(He(Lt(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}var Hi,Yf=D(()=>{"use strict";$();q();qu();Rp();Kf();lE();O();Xf();Se();un();Op();us();jr();Hi=E({norm_:AX})});function RX(n,e=null,t=!1){return Hi(n,"euclidean",e,t)}var pE,wR=D(()=>{"use strict";Yf();O();pE=E({euclideanNorm_:RX})});function FX(n){let t={x:C(n,"x","exp")};return N.runKernel("Exp",t)}var ir,Mp=D(()=>{"use strict";B();$();O();ir=E({exp_:FX})});function OX(n,e=0){let t=C(n,"x","expandDims","string_or_numeric");k(e<=t.rank,()=>"Axis must be <= rank of the tensor");let r={input:t},o={dim:e};return N.runKernel(Sc,r,o)}var vr,sx=D(()=>{"use strict";B();G();$();q();O();vr=E({expandDims_:OX})});function MX(n){let t={x:C(n,"x","expm1")};return N.runKernel(Js,t)}var dE,IR=D(()=>{"use strict";B();G();$();O();dE=E({expm1_:MX})});function $X(n,e){let t=C(n,"x","tile","string_or_numeric");k(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);let r={x:t},o={reps:e};return N.runKernel(Ko,r,o)}var ls,ix=D(()=>{"use strict";B();G();$();q();O();ls=E({tile_:$X})});function PX(n,e,t,r="float32"){e==null&&(e=n);let o=ue([n,e],r),s=n<=e?n:e;for(let a=0;a<s;++a)o.set(1,a,a);let i=U(o.toTensor(),[n,e]);if(t==null)return i;if(t.length===1)return ls(vr(i,0),[t[0],1,1]);if(t.length===2)return ls(vr(vr(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return ls(vr(vr(vr(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}var Zf,fE=D(()=>{"use strict";ts();sx();O();Se();ix();Zf=E({eye_:PX})});function LX(n){let t={x:C(n,"x","floor","float32")};return N.runKernel(ei,t)}var Qf,mE=D(()=>{"use strict";B();G();$();O();Qf=E({floor_:LX})});function BX(n,e,t=0,r=0){let o=C(n,"x","gather"),s=C(e,"indices","gather","int32"),i={x:o,indices:s},a={axis:t,batchDims:r};return N.runKernel(_c,i,a)}var Jf,hE=D(()=>{"use strict";B();G();$();O();Jf=E({gather_:BX})});function VX(n,e){let t=C(n,"a","greater","string_or_numeric"),r=C(e,"b","greater","string_or_numeric");[t,r]=Ee(t,r),ze(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(ni,o)}var Gi,ax=D(()=>{"use strict";B();G();at();$();Pt();O();Gi=E({greater_:VX})});function UX(n,e){let t=C(n,"a","greaterEqual","string_or_numeric"),r=C(e,"b","greaterEqual","string_or_numeric");[t,r]=Ee(t,r),ze(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(ri,o)}var em,gE=D(()=>{"use strict";B();G();at();$();Pt();O();em=E({greaterEqual_:UX})});function zX(n){let t={input:C(n,"input","imag")};return N.runKernel(Fc,t)}var ps,tm=D(()=>{"use strict";B();G();$();O();ps=E({imag_:zX})});function HX(n){let t={x:C(n,"x","isFinite")};return N.runKernel(oi,t)}var xE,ER=D(()=>{"use strict";B();G();$();O();xE=E({isFinite_:HX})});function GX(n){let t={x:C(n,"x","isInf")};return N.runKernel(si,t)}var yE,TR=D(()=>{"use strict";B();G();$();O();yE=E({isInf_:GX})});function WX(n){let t={x:C(n,"x","isNaN")};return N.runKernel(ii,t)}var vE,SR=D(()=>{"use strict";B();G();$();O();vE=E({isNaN_:WX})});function jX(n,e=.2){let r={x:C(n,"x","leakyRelu")},o={alpha:e};return N.runKernel(Oc,r,o)}var nm,bE=D(()=>{"use strict";B();G();$();O();nm=E({leakyRelu_:jX})});function qX(n,e){let t=C(n,"a","less","string_or_numeric"),r=C(e,"b","less","string_or_numeric");[t,r]=Ee(t,r),ze(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(ai,o)}var $p,CE=D(()=>{"use strict";B();G();at();$();Pt();O();$p=E({less_:qX})});function KX(n,e){let t=C(n,"a","lessEqual","string_or_numeric"),r=C(e,"b","lessEqual","string_or_numeric");[t,r]=Ee(t,r),ze(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(ci,o)}var Zu,cx=D(()=>{"use strict";B();G();at();$();Pt();O();Zu=E({lessEqual_:KX})});function wE(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");let r={start:n,stop:e,num:t};return N.runKernel(Mc,{},r)}var NR=D(()=>{"use strict";B();G();});function XX(n,e=5,t=1,r=1,o=.5){let s=C(n,"x","localResponseNormalization");k(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),k(Go(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=U(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let c={x:i},u={depthRadius:e,bias:t,alpha:r,beta:o},l=N.runKernel("LRN",c,u);return a?U(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var IE,DR=D(()=>{"use strict";B();$();q();O();Se();IE=E({localResponseNormalization_:XX})});function YX(n){let t={x:C(n,"x","log","float32")};return N.runKernel("Log",t)}var To,rm=D(()=>{"use strict";B();$();O();To=E({log_:YX})});function ZX(n){let t={x:C(n,"x","log1p")};return N.runKernel(ui,t)}var om,EE=D(()=>{"use strict";B();G();$();O();om=E({log1p_:ZX})});function kR(n){return k(xo(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{let r=C(e,"x","tf.grad","string_or_numeric"),o=t!=null?C(t,"dy","tf.grad"):null;return N.tidy(()=>{let{value:s,grads:i}=N.gradients(()=>n(r),[r],o);return o!=null&&et(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),lx(i),i[0]})}}function _R(n){return k(xo(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{k(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=Zo(e,"args","tf.grads","string_or_numeric"),o=t!=null?C(t,"dy","tf.grads"):null;return N.tidy(()=>{let{value:s,grads:i}=N.gradients(()=>n(...r),r,o);return o!=null&&et(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),lx(i),i})}}function AR(n){return k(xo(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{k(e instanceof Ke,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),k(t==null||t instanceof Ke,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:o}=N.gradients(()=>n(e),[e],t);return lx(r),{grad:r[0],value:o}}}function RR(n){return k(xo(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{k(Array.isArray(e)&&e.every(o=>o instanceof Ke),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),k(t==null||t instanceof Ke,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=N.gradients(()=>n(...e),e,t);return t!=null&&et(r.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),lx(r.grads),r}}function ux(n,e){k(xo(n),()=>"The f passed in variableGrads(f) must be a function"),k(e==null||Array.isArray(e)&&e.every(u=>u instanceof bo),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let t=e!=null;if(!t){e=[];for(let u in N.registeredVariables)e.push(N.registeredVariables[u])}let r=t?e.filter(u=>!u.trainable):null,o=e.length;e=e.filter(u=>u.trainable),k(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=N.gradients(n,e,null,s);k(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),k(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let c={};return e.forEach((u,l)=>{a[l]!=null&&(c[u.name]=a[l])}),r?.forEach(u=>c[u.name]=null),{value:i,grads:c}}function ln(n){return N.customGrad(n)}function lx(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}var ds=D(()=>{"use strict";B();or();$();q();});function QX(n){let t={x:C(n,"x","neg")};return N.runKernel("Neg",t)}var jt,fs=D(()=>{"use strict";B();$();O();jt=E({neg_:QX})});function JX(n){let t={x:C(n,"x","softplus")};return N.runKernel(Si,t)}var sm,TE=D(()=>{"use strict";B();G();$();O();sm=E({softplus_:JX})});function eY(n){let e=C(n,"x","logSigmoid");return ln(r=>({value:jt(sm(jt(r))),gradFunc:i=>ee(i,zr(jt(r)))}))(e)}var SE,FR=D(()=>{"use strict";ds();$();ct();fs();O();Uf();TE();SE=E({logSigmoid_:eY})});function tY(n,e){let t=C(n,"a","sub"),r=C(e,"b","sub");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel("Sub",o)}var ge,Bt=D(()=>{"use strict";B();at();$();O();ge=E({sub_:tY})});function nY(n,e=-1){let t=C(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return ln((o,s)=>{let a=Wr(o,e,!0),c=ge(o,a),u=ge(De(c,"float32"),To(He(ir(c),e,!0)));return s([u]),{value:u,gradFunc:(p,d)=>{let[f]=d,m=!0,h=ir(f);return ge(p,ee(He(p,e,m),h))}}})(t)}var NE,OR=D(()=>{"use strict";ds();$();tn();Mp();rm();Kf();ct();O();Bt();jr();NE=E({logSoftmax_:nY})});function rY(n,e=null,t=!1){let r=C(n,"x","logSumExp"),o=Ls(e,r.shape),s=Wr(r,o,!0),i=ge(r,s),a=ir(i),c=He(a,o),u=To(c),l=de(U(s,u.shape),u);if(t){let p=cs(l.shape,o);return U(l,p)}return l}var im,DE=D(()=>{"use strict";$();q();_t();Rp();Mp();rm();Kf();O();Se();Bt();jr();im=E({logSumExp_:rY})});function oY(n,e){let t=C(n,"a","logicalAnd","bool"),r=C(e,"b","logicalAnd","bool");ze(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(li,o)}var Wi,px=D(()=>{"use strict";B();G();$();Pt();O();Wi=E({logicalAnd_:oY})});function sY(n){let t={x:C(n,"x","logicalNot","bool")};return N.runKernel(pi,t)}var am,kE=D(()=>{"use strict";B();G();$();O();am=E({logicalNot_:sY})});function iY(n,e){let t=C(n,"a","logicalOr","bool"),r=C(e,"b","logicalOr","bool");ze(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(di,o)}var cm,_E=D(()=>{"use strict";B();G();$();Pt();O();cm=E({logicalOr_:iY})});function aY(n,e){let t=C(n,"a","logicalXor","bool"),r=C(e,"b","logicalXor","bool");return ze(t.shape,r.shape),Wi(cm(n,e),am(Wi(n,e)))}var AE,MR=D(()=>{"use strict";$();Pt();px();kE();_E();O();AE=E({logicalXor_:aY})});function cY(n,e,t="left"){let r=C(n,"sortedSequence","searchSorted"),o=C(e,"values","searchSorted"),s=r.shape[r.shape.length-1],i=o.shape[o.shape.length-1],a=U(r,[-1,s]),c=U(o,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ne(c.shape)>=dx)throw new Error(`values tensor size must less than ${dx}`);if(a.shape[1]>=dx)throw new Error(`trailing dim_size must less than ${dx} for int32 output type, was ${a.shape[1]}`);let u={sortedSequence:a,values:c},l={side:t};return N.runKernel(pu,u,l)}var dx,Pp,fx=D(()=>{"use strict";B();G();$();Ot();O();Se();dx=2147483648;Pp=E({searchSorted_:cY})});function RE(n,e){return Pp(n,e,"left")}var $R=D(()=>{"use strict";fx();});function uY(n,e,t,r,o){let s=C(n,"x","maxPool"),i=1,a=s,c=!1;s.rank===3&&(c=!0,a=U(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),k(cn(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),Tt("maxPool",r,o);let u={x:a},l={filterSize:e,strides:t,pad:r,dimRoundingMode:o},p=N.runKernel(Pc,u,l);return c?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var um,FE=D(()=>{"use strict";B();G();$();q();_n();O();Se();um=E({maxPool_:uY})});function lY(n,e=[1,1,1],t,r,o,s="NDHWC"){let i=C(n,"x","maxPool3d"),a=i,c=!1;i.rank===4&&(c=!0,a=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),k(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Tt("maxPool3d",r,o);let u={x:a},l={filterSize:e,strides:t,pad:r,dimRoundingMode:o,dataFormat:s},p=N.runKernel(Lc,u,l);return c?U(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var OE,PR=D(()=>{"use strict";B();G();$();q();_n();O();Se();OE=E({maxPool3d_:lY})});function pY(n,e,t,r,o=!1){let i={x:C(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:r,includeBatchInIndex:o},c=N.runKernel(Bc,i,a);return{result:c[0],indexes:c[1]}}var ME,LR=D(()=>{"use strict";B();G();$();O();ME=E({maxPoolWithArgmax_:pY})});function dY(n,e){let t=C(n,"a","maximum"),r=C(e,"b","maximum");[t,r]=Ee(t,r),t.dtype==="bool"&&(t=De(t,"int32"),r=De(r,"int32")),ze(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(fi,o)}var lm,$E=D(()=>{"use strict";B();G();at();$();Pt();tn();O();lm=E({maximum_:dY})});function fY(n,e=null,t=!1){let o={x:C(n,"x","mean")},s={axis:e,keepDims:t};return N.runKernel(Vc,o,s)}var ji,mx=D(()=>{"use strict";B();G();$();O();ji=E({mean_:fY})});function ar(n,e="float32"){if(st(n),e==="complex64"){let r=ar(n,"float32"),o=ar(n,"float32");return vn(r,o)}let t=np(Ne(n),e);return N.makeTensor(t,n,e)}var pm=D(()=>{"use strict";B();q();Li();});function qr(n,e="float32"){if(st(n),e==="complex64"){let r=qr(n,"float32"),o=ar(n,"float32");return vn(r,o)}let t=mf(Ne(n),e);return N.makeTensor(t,n,e)}var hx=D(()=>{"use strict";B();q();Ot();Li();pm();});function PE(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=C(n,"x","meshgrid",n instanceof Ke?n.dtype:"float32");if(e===void 0)return[r];let o=C(e,"y","meshgrid",e instanceof Ke?e.dtype:"float32"),s=Ne(r.shape),i=Ne(o.shape);return t==="xy"?(r=U(r,[1,-1]),o=U(o,[-1,1]),[Be(qr([i,1],r.dtype),r),Be(o,qr([1,s],o.dtype))]):(r=U(r,[-1,1]),o=U(o,[1,-1]),[Be(r,qr([1,i],r.dtype)),Be(qr([s,1],o.dtype),o)])}var BR=D(()=>{"use strict";ns();hx();Se();or();$();Ot();});function mY(n,e){let t=C(n,"a","minimum"),r=C(e,"b","minimum");[t,r]=Ee(t,r),t.dtype==="bool"&&(t=De(t,"int32"),r=De(r,"int32")),ze(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(mi,o)}var qi,gx=D(()=>{"use strict";B();G();at();$();Pt();tn();O();qi=E({minimum_:mY})});function hY(n,e,t){k(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);let r=C(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");k(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);let o=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)k(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),k(e[a][0]>=0&&e[a][0]<=r.shape[a]-o&&e[a][1]>=0&&e[a][1]<=r.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-o} or less than 0 for input of shape ${r.shape}`);let s={paddings:e,mode:t},i={x:r};return N.runKernel(Uc,i,s)}var LE,VR=D(()=>{"use strict";B();G();$();q();O();LE=E({mirrorPad_:hY})});function gY(n,e){let t=C(n,"a","mod"),r=C(e,"b","mod");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel("Mod",o)}var BE,UR=D(()=>{"use strict";B();at();$();O();BE=E({mod_:gY})});function xY(n,e=null,t=!1){n=C(n,"x","moments");let r=Ls(e,n.shape),o=ji(n,r,t),s=o.shape;t||(s=cs(o.shape,r));let i=Lt(ge(De(n,"float32"),U(o,s))),a=ji(i,r,t);return{mean:o,variance:a}}var VE,zR=D(()=>{"use strict";$();q();Rp();tn();mx();O();Se();us();Bt();VE=E({moments_:xY})});function yY(n,e,t,r){let o=C(e,"data","multiRNNCell"),s=Zo(t,"c","multiRNNCell"),i=Zo(r,"h","multiRNNCell"),a=o,c=[];for(let p=0;p<n.length;p++){let d=n[p](a,s[p],i[p]);c.push(d[0]),c.push(d[1]),a=d[1]}let u=[],l=[];for(let p=0;p<c.length;p+=2)u.push(c[p]),l.push(c[p+1]);return[u,l]}var UE,HR=D(()=>{"use strict";$();O();UE=E({multiRNNCell_:yY})});function vY(n,e,t,r=!1){let o=C(n,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();let c={logits:i===1?U(o,[1,-1]):o},u={numSamples:e,seed:t,normalized:r},l=N.runKernel(Hc,c,u);return i===1?U(l,[l.size]):l}var zE,GR=D(()=>{"use strict";B();G();$();O();Se();zE=E({multinomial_:vY})});function bY(n,e){let t=C(n,"a","notEqual","string_or_numeric"),r=C(e,"b","notEqual","string_or_numeric");[t,r]=Ee(t,r),ze(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(gi,o)}var dm,HE=D(()=>{"use strict";B();G();at();$();Pt();O();dm=E({notEqual_:bY})});function CY(n,e,t=1,r=0,o="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);let i={indices:C(n,"indices","oneHot","int32")},a={dtype:o,depth:e,onValue:t,offValue:r};return N.runKernel(Kc,i,a)}var Lp,GE=D(()=>{"use strict";B();G();$();O();Lp=E({oneHot_:CY})});function wY(n){let t={x:C(n,"x","onesLike")};return N.runKernel(qc,t)}var WE,WR=D(()=>{"use strict";B();G();$();O();WE=E({onesLike_:wY})});function IY(n,e){let t=C(n,"v1","outerProduct"),r=C(e,"v2","outerProduct");k(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);let o=U(t,[-1,1]),s=U(r,[1,-1]);return Be(o,s)}var jE,jR=D(()=>{"use strict";$();q();ns();O();Se();jE=E({outerProduct_:IY})});function EY(n,e,t=0){let r=C(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:e,constantValue:t},s={x:r};return N.runKernel(Yc,s,o)}var Kr,Bp=D(()=>{"use strict";B();G();$();O();Kr=E({pad_:EY})});function TY(n,e,t=0){return k(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Kr(n,[e],t)}var qE,qR=D(()=>{"use strict";q();O();Bp();qE=E({pad1d_:TY})});function SY(n,e,t=0){return k(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Kr(n,e,t)}var KE,KR=D(()=>{"use strict";q();O();Bp();KE=E({pad2d_:SY})});function NY(n,e,t=0){return k(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Kr(n,e,t)}var XE,XR=D(()=>{"use strict";q();O();Bp();XE=E({pad3d_:NY})});function DY(n,e,t=0){return k(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Kr(n,e,t)}var YE,YR=D(()=>{"use strict";q();O();Bp();YE=E({pad4d_:DY})});function kY(n,e,t){let r=C(n,"x","spaceToBatchND");k(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),k(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),k(r.shape.reduce((i,a,c)=>c>0&&c<=e.length?i&&(a+t[c-1][0]+t[c-1][1])%e[c-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);let o={x:r},s={blockShape:e,paddings:t};return N.runKernel(hu,o,s)}var fm,ZE=D(()=>{"use strict";B();G();$();q();O();fm=E({spaceToBatchND_:kY})});function _Y(n,e,t,r,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),r===0&&(r="valid");let a=C(n,"x","maxPool"),c=a,u=!1;a.rank===3&&(u=!0,c=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(cn(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let l=II(c.shape,e,s,o,r),p=[l.dilationHeight,l.dilationWidth],d;r==="same"?d=RY([l.filterHeight,l.filterWidth],p):d=[[0,0],[0,0]];let f=p[0]===1&&p[1]===1,[m,h]=AY([l.inHeight,l.inWidth],p,d),g=f?r:"valid",x=f?c:fm(c,p,m),w=(t==="avg"?()=>Vf(x,e,s,g,i):()=>um(x,e,s,g,i))(),I=f?w:zf(w,p,h);return u?U(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function AY(n,e,t){let r=t.map(l=>l[0]),o=t.map(l=>l[1]),s=n.concat(r,o),i=e.map((l,p)=>(l-s[p]%l)%l),a=o.map((l,p)=>l+i[p]),c=e.map((l,p)=>[r[p],a[p]]),u=e.map((l,p)=>[0,i[p]]);return[c,u]}function RY(n,e){let r=n.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),o=r.map(i=>Math.floor(i/2)),s=r.map((i,a)=>i-o[a]);return r.map((i,a)=>[o[a],s[a]])}var QE,ZR=D(()=>{"use strict";$();q();TI();kI();_n();FE();O();Se();ZE();QE=E({pool_:_Y})});function FY(n,e){let t=C(n,"x","prelu"),r=C(e,"alpha","prelu"),o={x:t,alpha:r};return N.runKernel(Qc,o)}var mm,JE=D(()=>{"use strict";B();G();$();O();mm=E({prelu_:FY})});function OY(n,e=null,t=!1){let r=C(n,"x","prod");r.dtype==="bool"&&(r=De(r,"int32"));let o={x:r},s={axis:e,keepDims:t};return N.runKernel(Jc,o,s)}var eT,QR=D(()=>{"use strict";B();G();$();tn();O();eT=E({prod_:OY})});function MY(n,e,t,r){let o=n.map((l,p)=>C(l,`tensors${p}`,"raggedGather","int32")),s=C(e,"paramsDenseValues","raggedGather"),i=C(t,"indices","raggedGather","int32"),a={paramsNestedSplits:o,paramsDenseValues:s,indices:i},c={outputRaggedRank:r},u=N.runKernel(eu,a,c);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var tT,JR=D(()=>{"use strict";B();G();$();O();tT=E({raggedGather_:MY})});function $Y(n,e,t){let r=C(n,"starts","raggedRange"),o=C(e,"limits","raggedRange",r.dtype),s=C(t,"deltas","raggedRange",r.dtype),i={starts:r,limits:o,deltas:s},a=N.runKernel(tu,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}var nT,eF=D(()=>{"use strict";B();G();$();O();nT=E({raggedRange_:$Y})});function PY(n,e,t,r,o){let s=C(n,"shape","raggedTensorToTensor","int32"),i=C(e,"values","raggedTensorToTensor"),a=C(t,"defaultValue","raggedTensorToTensor",i.dtype),c=r.map((p,d)=>C(p,`tensors${d}`,"raggedTensorToTensor","int32")),u={shape:s,values:i,defaultValue:a,rowPartitionTensors:c},l={rowPartitionTypes:o};return N.runKernel(nu,u,l)}var rT,tF=D(()=>{"use strict";B();G();$();O();rT=E({raggedTensorToTensor_:PY})});function LY(n,e,t){st(n);let r=Ne(n),o=null;if(t==null||t==="float32")o=new Float32Array(r);else if(t==="int32")o=new Int32Array(r);else if(t==="bool")o=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<r;s++)o[s]=e();return N.makeTensor(o,n,t)}var oT,nF=D(()=>{"use strict";B();q();Ot();O();oT=E({rand_:LY})});var oF=Jn((rF,sT)=>{"use strict";(function(n,e,t){function r(a){var c=this,u=i();c.next=function(){var l=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=l-(c.c=l|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(a),c.s0<0&&(c.s0+=1),c.s1-=u(a),c.s1<0&&(c.s1+=1),c.s2-=u(a),c.s2<0&&(c.s2+=1),u=null}function o(a,c){return c.c=a.c,c.s0=a.s0,c.s1=a.s1,c.s2=a.s2,c}function s(a,c){var u=new r(a),l=c&&c.state,p=u.next;return p.int32=function(){return u.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}function i(){var a=4022871197,c=function(u){u=String(u);for(var l=0;l<u.length;l++){a+=u.charCodeAt(l);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(rF,typeof sT=="object"&&sT,typeof define=="function"&&define)});var iF=Jn((sF,iT)=>{"use strict";(function(n,e,t){function r(i){var a=this,c="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var l=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^l^l>>>8},i===(i|0)?a.x=i:c+=i;for(var u=0;u<c.length+64;u++)a.x^=c.charCodeAt(u)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var c=new r(i),u=a&&a.state,l=function(){return(c.next()>>>0)/4294967296};return l.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},l.int32=c.next,l.quick=l,u&&(typeof u=="object"&&o(u,c),l.state=function(){return o(c,{})}),l}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(sF,typeof iT=="object"&&iT,typeof define=="function"&&define)});var cF=Jn((aF,aT)=>{"use strict";(function(n,e,t){function r(i){var a=this,c="";a.next=function(){var l=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(l^l<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:c+=i;for(var u=0;u<c.length+64;u++)a.x^=c.charCodeAt(u)|0,u==c.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var c=new r(i),u=a&&a.state,l=function(){return(c.next()>>>0)/4294967296};return l.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},l.int32=c.next,l.quick=l,u&&(typeof u=="object"&&o(u,c),l.state=function(){return o(c,{})}),l}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(aF,typeof aT=="object"&&aT,typeof define=="function"&&define)});var lF=Jn((uF,cT)=>{"use strict";(function(n,e,t){function r(i){var a=this;a.next=function(){var u=a.x,l=a.i,p,d,f;return p=u[l],p^=p>>>7,d=p^p<<24,p=u[l+1&7],d^=p^p>>>10,p=u[l+3&7],d^=p^p>>>3,p=u[l+4&7],d^=p^p<<7,p=u[l+7&7],p=p^p<<13,d^=p^p<<9,u[l]=d,a.i=l+1&7,d};function c(u,l){var p,d,f=[];if(l===(l|0))d=f[0]=l;else for(l=""+l,p=0;p<l.length;++p)f[p&7]=f[p&7]<<15^l.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?d=f[7]=-1:d=f[p],u.x=f,u.i=0,p=256;p>0;--p)u.next()}c(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var c=new r(i),u=a&&a.state,l=function(){return(c.next()>>>0)/4294967296};return l.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},l.int32=c.next,l.quick=l,u&&(u.x&&o(u,c),l.state=function(){return o(c,{})}),l}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(uF,typeof cT=="object"&&cT,typeof define=="function"&&define)});var dF=Jn((pF,uT)=>{"use strict";(function(n,e,t){function r(i){var a=this;a.next=function(){var u=a.w,l=a.X,p=a.i,d,f;return a.w=u=u+1640531527|0,f=l[p+34&127],d=l[p=p+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,f=l[p]=f^d,a.i=p,f+(u^u>>>16)|0};function c(u,l){var p,d,f,m,h,g=[],x=128;for(l===(l|0)?(d=l,l=null):(l=l+"\0",d=0,x=Math.max(x,l.length)),f=0,m=-32;m<x;++m)l&&(d^=l.charCodeAt((m+32)%l.length)),m===0&&(h=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,m>=0&&(h=h+1640531527|0,p=g[m&127]^=d+h,f=p==0?f+1:0);for(f>=128&&(g[(l&&l.length||0)&127]=-1),f=127,m=512;m>0;--m)d=g[f+34&127],p=g[f=f+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,g[f]=d^p;u.w=h,u.X=g,u.i=f}c(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var c=new r(i),u=a&&a.state,l=function(){return(c.next()>>>0)/4294967296};return l.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},l.int32=c.next,l.quick=l,u&&(u.X&&o(u,c),l.state=function(){return o(c,{})}),l}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})(pF,typeof uT=="object"&&uT,typeof define=="function"&&define)});var mF=Jn((fF,lT)=>{"use strict";(function(n,e,t){function r(i){var a=this,c="";a.next=function(){var l=a.b,p=a.c,d=a.d,f=a.a;return l=l<<25^l>>>7^p,p=p-d|0,d=d<<24^d>>>8^f,f=f-l|0,a.b=l=l<<20^l>>>12^p,a.c=p=p-d|0,a.d=d<<16^p>>>16^f,a.a=f-l|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):c+=i;for(var u=0;u<c.length+20;u++)a.b^=c.charCodeAt(u)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var c=new r(i),u=a&&a.state,l=function(){return(c.next()>>>0)/4294967296};return l.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},l.int32=c.next,l.quick=l,u&&(typeof u=="object"&&o(u,c),l.state=function(){return o(c,{})}),l}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(fF,typeof lT=="object"&&lT,typeof define=="function"&&define)});var hF=Jn(()=>{"use strict"});var xF=Jn((gF,xx)=>{"use strict";(function(n,e,t){var r=256,o=6,s=52,i="random",a=t.pow(r,o),c=t.pow(2,s),u=c*2,l=r-1,p;function d(w,I,_){var A=[];I=I==!0?{entropy:!0}:I||{};var R=g(h(I.entropy?[w,v(e)]:w??x(),3),A),F=new f(A),P=function(){for(var L=F.g(o),V=a,z=0;L<c;)L=(L+z)*r,V*=r,z=F.g(1);for(;L>=u;)L/=2,V/=2,z>>>=1;return(L+z)/V};return P.int32=function(){return F.g(4)|0},P.quick=function(){return F.g(4)/4294967296},P.double=P,g(v(F.S),e),(I.pass||_||function(L,V,z,H){return H&&(H.S&&m(H,F),L.state=function(){return m(F,{})}),z?(t[i]=L,V):L})(P,R,"global"in I?I.global:this==t,I.state)}function f(w){var I,_=w.length,A=this,R=0,F=A.i=A.j=0,P=A.S=[];for(_||(w=[_++]);R<r;)P[R]=R++;for(R=0;R<r;R++)P[R]=P[F=l&F+w[R%_]+(I=P[R])],P[F]=I;(A.g=function(L){for(var V,z=0,H=A.i,j=A.j,W=A.S;L--;)V=W[H=l&H+1],z=z*r+W[l&(W[H]=W[j=l&j+V])+(W[j]=V)];return A.i=H,A.j=j,z})(r)}function m(w,I){return I.i=w.i,I.j=w.j,I.S=w.S.slice(),I}function h(w,I){var _=[],A=typeof w,R;if(I&&A=="object")for(R in w)try{_.push(h(w[R],I-1))}catch{}return _.length?_:A=="string"?w:w+"\0"}function g(w,I){for(var _=w+"",A,R=0;R<_.length;)I[l&R]=l&(A^=I[l&R]*19)+_.charCodeAt(R++);return v(I)}function x(){try{var w;return p&&(w=p.randomBytes)?w=w(r):(w=new Uint8Array(r),(n.crypto||n.msCrypto).getRandomValues(w)),v(w)}catch{var I=n.navigator,_=I&&I.plugins;return[+new Date,n,_,n.screen,v(e)]}}function v(w){return String.fromCharCode.apply(0,w)}if(g(t.random(),e),typeof xx=="object"&&xx.exports){xx.exports=d;try{p=hF()}catch{}}else typeof define=="function"&&define.amd?define(function(){return d}):t["seed"+i]=d})(typeof self<"u"?self:gF,[],Math)});var pT=Jn((y$e,yF)=>{"use strict";var BY=oF(),VY=iF(),UY=cF(),zY=lF(),HY=dF(),GY=mF(),Qu=xF();Qu.alea=BY;Qu.xor128=VY;Qu.xorwow=UY;Qu.xorshift7=zY;Qu.xor4096=HY;Qu.tychei=GY;yF.exports=Qu});var hT={};Le(hT,{TEST_EPSILON_FLOAT16:()=>vF,createVideoElement:()=>QY,encodeStrings:()=>bF,expectArrayBuffersEqual:()=>ZY,expectArraysClose:()=>jY,expectArraysEqual:()=>KY,expectNumbersClose:()=>XY,expectPromiseToFail:()=>qY,expectValuesInRange:()=>YY,play:()=>JY,testEpsilon:()=>fT});function jY(n,e,t){return t==null&&(t=fT()),dT(n,e,(r,o)=>mT(r,o,t))}function fT(){return N.backend.floatPrecision()===32?WY:vF}function dT(n,e,t){let r=!0;if((Ct(n)||Ct(e))&&(r=!1),Ct(n)&&Ct(e)&&(r=!0),r){let i=n.constructor.name,a=e.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(n)&&Array.isArray(e)){let i=Jt(n),a=Jt(e);if(!xn(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}let o=Ct(n)?n:Lr(n),s=Ct(e)?e:Lr(e);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let a=o[i],c=s[i];if(!t(a,c))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${c}.
Actual:   ${o}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function qY(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function KY(n,e){let t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return $r(n)||$r(n[0])||$r(e)||$r(e[0])?dT(n,t,(r,o)=>r==o):dT(n,e,(r,o)=>mT(r,o,0))}function XY(n,e,t){if(t==null&&(t=fT()),!mT(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function mT(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function YY(n,e,t){for(let r=0;r<n.length;r++)if(n[r]<e||n[r]>t)throw new Error(`Value out of range:${n[r]} low: ${e}, high: ${t}`)}function ZY(n,e){let t=new Float32Array(n),r=new Float32Array(e);if(t.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${t.length}`);for(let o=0;o<r.length;o++)if(t[o]!==r[o])throw new Error(`Expected ArrayBuffer value at ${o} to be ${r[o]} but got ${t[o]} instead`)}function bF(n){for(let e=0;e<n.length;e++){let t=n[e];Array.isArray(t)?bF(t):n[e]=$i(t)}return n}function QY(n){let e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",r=>t(e)),e.load()})}async function JY(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}var WY,vF,CF=D(()=>{"use strict";B();$();q();WY=.001,vF=.1});var bx,Ju,yx,vx,hm=D(()=>{"use strict";bx=ch(pT());Ju=class{constructor(e,t,r,o,s){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=bx.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let e,t,r=!1;for(;!r;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*o*a,t=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},yx=class{constructor(e,t,r,o){this.alpha=e,this.beta=1/t,this.dtype=r;let s=o||Math.random();this.randu=bx.alea(s.toString()),this.randn=new Ju(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,e=o*o,t=1-.331*e*e,r=.5*e+this.d*(1-i+Math.log(i)),s=this.randu(),s<t||Math.log(s)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},vx=class{constructor(e=0,t=1,r,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=bx.alea(o)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}});function eZ(n,e,t=1,r="float32",o){if(st(n),t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new yx(e,t,r,o),i=ue(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var gT,wF=D(()=>{"use strict";Ot();ts();O();hm();gT=E({randomGamma_:eZ})});function tZ(n,e=0,t=1,r,o){if(st(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new Ju(e,t,r,!1,o),i=ue(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var gm,xT=D(()=>{"use strict";Ot();ts();O();hm();gm=E({randomNormal_:tZ})});function nZ(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return gm(n,0,1,e,t)}var yT,IF=D(()=>{"use strict";O();xT();yT=E({randomStandardNormal_:nZ})});function rZ(n,e=0,t=1,r="float32",o){st(n);let s=ue(n,r),i=new vx(e,t,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var el,Cx=D(()=>{"use strict";Ot();ts();O();hm();el=E({randomUniform_:rZ})});function oZ(n,e,t,r){return el(n,e,t,"int32",r)}var vT,EF=D(()=>{"use strict";O();Cx();vT=E({randomUniformInt_:oZ})});function ms(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");let o={start:n,stop:e,step:t,dtype:r};return N.runKernel(ru,{},o)}var wx=D(()=>{"use strict";B();G();});function sZ(n){let t={input:C(n,"input","real")};return N.runKernel(ou,t)}var So,xm=D(()=>{"use strict";B();G();$();O();So=E({real_:sZ})});function iZ(n){let t={x:C(n,"x","reciprocal")};return N.runKernel(xi,t)}var bT,TF=D(()=>{"use strict";B();G();$();O();bT=E({reciprocal_:iZ})});function aZ(n){let t={x:C(n,"x","relu")};return N.runKernel(yi,t)}var hs,ym=D(()=>{"use strict";B();G();$();O();hs=E({relu_:aZ})});function cZ(n){let t={x:C(n,"x","relu6")};return N.runKernel(vi,t)}var vm,CT=D(()=>{"use strict";B();G();$();O();vm=E({relu6_:cZ})});function uZ(n,e){let r={x:C(n,"x","reverse")},o={dims:e};return N.runKernel(cu,r,o)}var Gn,tl=D(()=>{"use strict";B();G();$();O();Gn=E({reverse_:uZ})});function lZ(n){let e=C(n,"x","reverse");return k(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Gn(e,0)}var wT,SF=D(()=>{"use strict";$();q();O();tl();wT=E({reverse1d_:lZ})});function pZ(n,e){let t=C(n,"x","reverse");return k(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Gn(t,e)}var IT,NF=D(()=>{"use strict";$();q();O();tl();IT=E({reverse2d_:pZ})});function dZ(n,e){let t=C(n,"x","reverse");return k(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Gn(t,e)}var ET,DF=D(()=>{"use strict";$();q();O();tl();ET=E({reverse3d_:dZ})});function fZ(n,e){let t=C(n,"x","reverse");return k(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Gn(t,e)}var TT,kF=D(()=>{"use strict";$();q();O();tl();TT=E({reverse4d_:fZ})});function mZ(n){let t={x:C(n,"x","round")};return N.runKernel(bi,t)}var bm,ST=D(()=>{"use strict";B();G();$();O();bm=E({round_:mZ})});function hZ(n){let t={x:C(n,"x","rsqrt","float32")};return N.runKernel(Ci,t)}var NT,_F=D(()=>{"use strict";B();G();$();O();NT=E({rsqrt_:hZ})});function gZ(n){let t={x:C(n,"x","selu")};return N.runKernel(wi,t)}var DT,AF=D(()=>{"use strict";B();G();$();O();DT=E({selu_:gZ})});function xZ(n,e,t,r,o,s=[1,1],i="NHWC"){let a=C(n,"x","separableConv2d"),c=C(e,"depthwiseFilter","separableConv2d"),u=C(t,"pointwiseFilter","separableConv2d"),l=a,p=!1;if(a.rank===3&&(p=!0,l=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");k(l.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),k(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),k(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),k(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),k(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let d=c.shape[2],f=c.shape[3];k(u.shape[2]===d*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*f}, but got ${u.shape[2]}.`);let m=Yu(l,c,r,o,i,s),g=ss(m,u,1,"valid",i);return p?U(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var kT,RF=D(()=>{"use strict";$();q();Wf();rx();O();Se();kT=E({separableConv2d_:xZ})});async function yZ(n,e){let t=C(n,"x","setdiff1d"),r=C(e,"y","setdiff1d");k(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),k(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),k(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let o=await t.data(),s=await r.data(),i=new Set(s),a=0;for(let l=0;l<o.length;l++)i.has(o[l])||a++;let c=new Ve([a],t.dtype),u=new Ve([a],"int32");for(let l=0,p=0;l<o.length;l++)i.has(o[l])||(c.values[p]=o[l],u.values[p]=l,p++);return[c.toTensor(),u.toTensor()]}var _T,FF=D(()=>{"use strict";or();$();q();_T=yZ});function vZ(n){let t={x:C(n,"x","sign")};return N.runKernel(Ei,t)}var AT,OF=D(()=>{"use strict";B();G();$();O();AT=E({sign_:vZ})});function bZ(n){let t={x:C(n,"x","sin","float32")};return N.runKernel("Sin",t)}var RT,MF=D(()=>{"use strict";B();$();O();RT=E({sin_:bZ})});function CZ(n){let t={x:C(n,"x","sinh")};return N.runKernel(Ii,t)}var FT,$F=D(()=>{"use strict";B();G();$();O();FT=E({sinh_:CZ})});function wZ(n,e,t){let r=C(n,"x","slice1d");return k(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Me(r,[e],[t])}var OT,PF=D(()=>{"use strict";$();q();O();yr();OT=E({slice1d_:wZ})});function IZ(n,e,t){let r=C(n,"x","slice2d");return k(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Me(r,e,t)}var MT,LF=D(()=>{"use strict";$();q();O();yr();MT=E({slice2d_:IZ})});function EZ(n,e,t){let r=C(n,"x","slice3d");return k(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Me(r,e,t)}var $T,BF=D(()=>{"use strict";$();q();O();yr();$T=E({slice3d_:EZ})});function TZ(n,e,t){let r=C(n,"x","slice4d");return k(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Me(r,e,t)}var PT,VF=D(()=>{"use strict";$();q();O();yr();PT=E({slice4d_:TZ})});function SZ(n,e=-1){let t=C(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);let r={logits:t},o={dim:e};return N.runKernel(xu,r,o)}var LT,UF=D(()=>{"use strict";B();G();$();O();LT=E({softmax_:SZ})});function NZ(n){k(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);let e={input:n};return N.runKernel("FFT",e)}var nl,Ix=D(()=>{"use strict";B();q();O();nl=E({fft_:NZ})});function DZ(n){k(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);let e={input:n};return N.runKernel(Rc,e)}var Ki,Ex=D(()=>{"use strict";B();G();q();O();Ki=E({ifft_:DZ})});function kZ(n){let e=n.shape[n.shape.length-1],t=n.size/e,r;if(e<=2){let o=U(n,[t,e]);r=Ki(o)}else{let o=[t,2*(e-1)],s=U(So(n),[t,e]),i=U(ps(n),[t,e]),a=Gn(Me(s,[0,1],[t,e-2]),1),c=ee(Gn(Me(i,[0,1],[t,e-2]),1),me(-1)),u=Qe([s,a],1),l=Qe([i,c],1),p=U(vn(u,l),[o[0],o[1]]);r=Ki(p)}if(r=So(r),n.rank===3&&n.shape[0]!==0){let o=r,s=n.shape[0];r=U(r,[s,r.shape[0]/s,r.shape[1]]),o.dispose()}return r}var Cm,BT=D(()=>{"use strict";Li();Ur();tm();ct();O();xm();Se();tl();un();yr();Ex();Cm=E({irfft_:kZ})});function _Z(n,e,t=0){let o={x:C(n,"x","split")},s={numOrSizeSplits:e,axis:t};return N.runKernel(gu,o,s)}var No,wm=D(()=>{"use strict";B();G();$();O();No=E({split_:_Z})});function AZ(n,e){k(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1],r=n.size/t,o;if(e!=null&&e<t){let m=n.shape.map(g=>0),h=n.shape.map(g=>g);h[n.shape.length-1]=e,o=Me(n,m,h),t=e}else if(e!=null&&e>t){let m=n.shape.map(h=>h);m[n.shape.length-1]=e-t,o=Qe([n,ar(m)],n.shape.length-1),t=e}else o=n;let s=Nt(o),i=U(vn(o,s),[r,t]),a=nl(i),c=Math.floor(t/2)+1,u=So(a),l=ps(a),p=No(u,[c,t-c],u.shape.length-1),d=No(l,[c,t-c],l.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=c,U(vn(p[0],d[0]),f)}var rl,Tx=D(()=>{"use strict";q();Li();Ur();tm();O();xm();Se();yr();wm();pm();is();Ix();rl=E({rfft_:AZ})});function RZ(n,e){let t=C(n,"a","squaredDifference"),r=C(e,"b","squaredDifference");[t,r]=Ee(t,r),ze(t.shape,r.shape);let o={a:t,b:r},s={};return N.runKernel(Di,o,s)}var Im,VT=D(()=>{"use strict";B();G();at();$();Pt();O();Im=E({squaredDifference_:RZ})});function FZ(n,e){let t=C(n,"x","squeeze","string_or_numeric");return U(t,Iw(t.shape,e).newShape)}var ol,Sx=D(()=>{"use strict";$();q();O();Se();ol=E({squeeze_:FZ})});function OZ(n,e=0){let t=Zo(n,"tensors","stack","string_or_numeric");k(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&k(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");let r=t,o={axis:e};return N.runKernel(Xc,r,o)}var pn,Em=D(()=>{"use strict";B();G();$();q();O();pn=E({stack_:OZ})});function MZ(n,e=0){let r={x:C(n,"x","step")},o={alpha:e};return N.runKernel(Ai,r,o)}var Tm,UT=D(()=>{"use strict";B();G();$();O();Tm=E({step_:MZ})});function $Z(n,e,t,r,o=0,s=0,i=0,a=0,c=0){let l={x:C(n,"x","stridedSlice","string_or_numeric")},p={begin:e,end:t,strides:r,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:c};return N.runKernel(Iu,l,p)}var zT,zF=D(()=>{"use strict";B();G();$();O();zT=E({stridedSlice_:$Z})});function PZ(n){let t={x:C(n,"x","tan","float32")};return N.runKernel("Tan",t)}var HT,HF=D(()=>{"use strict";B();$();O();HT=E({tan_:PZ})});function Vt(n,e){rr(n);let t=Jt(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return bn(n,null,t,e)}var Xi=D(()=>{"use strict";$();q();Qo();});function gs(n,e,t){if(rr(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=Jt(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return bn(n,e,r,t)}var Nx=D(()=>{"use strict";$();q();Qo();});function Sm(n,e,t){if(rr(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=Jt(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return bn(n,e,r,t)}var GT=D(()=>{"use strict";$();q();Qo();});function WT(n,e,t){if(rr(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=Jt(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return bn(n,e,r,t)}var GF=D(()=>{"use strict";$();q();Qo();});function jT(n,e,t){if(rr(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=Jt(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return bn(n,e,r,t)}var WF=D(()=>{"use strict";$();q();Qo();});function qT(n,e,t){if(rr(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=Jt(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,bn(n,e,r,t)}var jF=D(()=>{"use strict";$();q();Qo();});var Nm={};Le(Nm,{calculateShapes:()=>qF,validateInput:()=>Vp,validateUpdateShape:()=>KT});function KT(n,e,t){let r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${o}.`;if(t.rank<o)throw new Error(s+` update.rank < ${o}. `);if(n.length<r+(t.rank-o))throw new Error(s+` Output shape length < ${r+(t.rank-o)}`);if(t.rank!==o+n.length-r)throw new Error(s+` update.rank != ${o+n.length-r}`);for(let i=0;i<o;++i)if(t.shape[i]!==e.shape[i])throw new Error(s+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-o;++i)if(t.shape[i+o]!==n[i+r])throw new Error(s+` updates.shape[${i+o}] (${t.shape[i+o]}) != shape[${i+o}] (${n[i+o]})`)}function Vp(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}KT(t,e,n)}function qF(n,e,t){let r=e.shape.length,o=r>1?e.shape[r-1]:1,s=t.length,i=1;for(let p=o;p<s;++p)i*=t[p];let a=o<1?1:o,c=Ne(e.shape)/a,u=[...yo(t.slice(0,o)),1],l=Ne(t);return{sliceRank:o,numUpdates:c,sliceSize:i,strides:u,outputSize:l}}var Dm=D(()=>{"use strict";q()});function LZ(n,e,t){let r=C(n,"tensor","tensorScatterupdate"),o=C(e,"indices","tensorScatterupdate","int32"),s=C(t,"updates","tensorScatterupdate");if(Vp(s,o,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:o,updates:s},a={};return N.runKernel(lu,i,a)}var XT,KF=D(()=>{"use strict";B();G();$();O();Dm();XT=E({tensorScatterUpdate_:LZ})});function BZ(n,e=1,t=!0){let r=C(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);let s={x:r},i={k:e,sorted:t},[a,c]=N.runKernel(ku,s,i);return{values:a,indices:c}}var YT,XF=D(()=>{"use strict";B();G();$();O();YT=E({topk_:BZ})});function VZ(n,e=0,t=1,r,o){if(st(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new Ju(e,t,r,!0,o),i=ue(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var ZT,YF=D(()=>{"use strict";Ot();ts();O();hm();ZT=E({truncatedNormal_:VZ})});function UZ(n,e=0){let t=C(n,"x","unique","string_or_numeric");k(t.rank>0,()=>"The input tensor must be at least 1D");let r={x:t},o={axis:e},[s,i]=N.runKernel(Au,r,o);return{values:s,indices:i}}var QT,ZF=D(()=>{"use strict";B();G();$();q();O();QT=E({unique_:UZ})});function zZ(n,e,t){let r=C(n,"x","unsortedSegmentSum"),o=C(e,"segmentIds","unsortedSegmentSum","int32");k(Go(t),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:o},i={numSegments:t};return N.runKernel(Fu,s,i)}var JT,QF=D(()=>{"use strict";B();G();$();q();O();JT=E({unsortedSegmentSum_:zZ})});function HZ(n,e=0){let t=C(n,"x","unstack","string_or_numeric");k(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);let r={value:t},o={axis:e};return N.runKernel(Ru,r,o)}var Wn,Dx=D(()=>{"use strict";B();G();$();q();O();Wn=E({unstack_:HZ})});function eS(n,e){return Pp(n,e,"right")}var JF=D(()=>{"use strict";fx();});function tS(n,e=!0,t,r){return N.makeVariable(n,e,t,r)}var eO=D(()=>{"use strict";B();});function kx(n,e){let t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);let r=ue(n,"int32"),o=ue([t.length,n.length],"int32");for(let s=0;s<t.length;s++){let i=r.indexToLoc(t[s]),a=s*n.length;o.values.set(i,a)}return o.toTensor()}var nS=D(()=>{"use strict";ts();});async function GZ(n){let e=C(n,"condition","whereAsync","bool"),t=await e.data(),r=kx(e.shape,t);return n!==e&&e.dispose(),r}var km,rS=D(()=>{"use strict";nS();$();km=GZ});async function WZ(n,e,t){let r=C(n,"tensor","boolMask"),o=C(e,"mask","boolMask","bool"),s=t??0,i=o.rank,a=r.shape;k(i>0,()=>"mask cannot be scalar"),et(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let h=s;h<s+i;h++)c*=a[h];let u=a.slice(0,s).concat([c],a.slice(s+i)),l=U(r,u),p=U(o,[-1]),d=await km(p),f=ol(d,[1]),m=Jf(l,f,s);return n!==r&&r.dispose(),e!==o&&o.dispose(),f.dispose(),l.dispose(),p.dispose(),d.dispose(),m}var tO,nO=D(()=>{"use strict";$();q();hE();Se();Sx();rS();tO=WZ});function jZ(n,e,t){let r=C(n,"x","transpose");if(e==null&&(e=r.shape.map((i,a)=>a).reverse()),k(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(i=>{k(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();let o={x:r},s={perm:e};return r.dtype==="complex64"?Ce(()=>{let i=So(r),a=ps(r);return i=N.runKernel(Xo,{x:i},s),a=N.runKernel(Xo,{x:a},s),t&&(a=jt(a)),vn(i,a)}):N.runKernel(Xo,o,s)}var sl,_x=D(()=>{"use strict";B();zn();G();$();q();Li();tm();fs();O();xm();sl=E({transpose_:jZ})});function qZ(n,e,t,r,o=!0){let s=C(n,"v","movingAverage"),i=C(e,"x","movingAverage"),a=C(t,"decay","movingAverage");Vw(s,i),k(xn(s.shape,i.shape),()=>"Shape mismatch in v and x");let c=me(1),u=ge(c,a),l=ee(ge(i,s),u);if(o){k(r!=null,()=>"When using zeroDebias: true, step is required.");let p=C(r,"step","movingAverage");l=Oe(l,ge(c,Eo(a,p)))}return de(s,l)}var rO,oO=D(()=>{"use strict";at();$();q();_t();kn();ct();O();Xf();un();Bt();rO=E({movingAverage_:qZ})});function KZ(n,e,t){st(t);let r=C(n,"indices","scatterND","int32"),o=C(e,"updates","scatterND");Vp(o,r,t);let s={indices:r,updates:o},i={shape:t};return N.runKernel(uu,s,i)}var sO,iO=D(()=>{"use strict";B();G();$();Ot();O();Dm();sO=E({scatterND_:KZ})});function aO(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);let o=n.rank>0?n.shape[0]:1,s=n.rank>1?n.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);let i=e.size;if(!(e.rank===0||e.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}var cO=D(()=>{"use strict"});function YZ(n,e,t,r=0){st(t);let o=C(n,"sparseIndices","sparseToDense","int32"),s=C(e,"sparseValues","sparseToDense","string_or_numeric"),i=C(r,"defaultValue","sparseToDense",s.dtype);aO(o,s,t,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},c={outputShape:t};return N.runKernel(wu,a,c)}var uO,lO=D(()=>{"use strict";B();G();cO();$();Ot();O();uO=E({sparseToDense_:YZ})});function ZZ(n,e){let t=C(e,"indices","gatherND","int32"),o={params:C(n,"x","gatherND","string_or_numeric"),indices:t};return N.runKernel(Ac,o)}var pO,dO=D(()=>{"use strict";B();G();$();O();pO=E({gatherND_:ZZ})});function fO(n,e){if(e==null)return n.shape.slice();if(xn(n.shape,e))return e;if(n.shape.length===e.length){let t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}var mO=D(()=>{"use strict";q();});function QZ(n,e,t,r){let o=C(n,"x","dropout");if(k(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),k(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Ke?o.clone():o;let s=fO(o,t),i=1-e,a=Oe(Qf(de(el(s,0,1,"float32",r),i)),i);return ee(o,a)}var hO,gO=D(()=>{"use strict";or();$();q();_t();kn();mO();mE();ct();O();Cx();hO=E({dropout_:QZ})});function Ax(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Up(n,e,t){let r=1-n%2,o=new Float32Array(n);for(let s=0;s<n;++s){let i=2*Math.PI*s/(n+r-1);o[s]=e-t*Math.cos(i)}return Vt(o,"float32")}var _m=D(()=>{"use strict";Xi();});async function JZ(n,e,t=1){let r=C(n,"predictions","inTopK"),o=C(e,"targets","inTopK");k(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),k(r.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${o.rank}`),et(r.shape.slice(0,r.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];k(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);let i=await r.data(),a=await o.data(),[c,u]=[i.length/s,s],l=Ew("bool",c);for(let p=0;p<c;p++){let d=p*u,f=i.subarray(d,d+u),m=[];for(let h=0;h<f.length;h++)m.push({value:f[h],index:h});m.sort((h,g)=>g.value-h.value),l[p]=0;for(let h=0;h<t;h++)if(m[h].index===a[p]){l[p]=1;break}}return n!==r&&r.dispose(),e!==o&&o.dispose(),an(l,o.shape,"bool")}var xO,yO=D(()=>{"use strict";$();q();Ff();xO=JZ});function eQ(n,e,t,r,o,s="NHWC",i){let a=n;n.rank===3&&(a=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=U(e,[1,e.shape[0],e.shape[1],e.shape[2]])),k(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),k(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),k(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);let u=s==="NHWC"?a.shape[3]:a.shape[1],l=s==="NHWC"?c.shape[3]:c.shape[1];k(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),k(l===t[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${t[3]}).`),Tt("conv2dDerFilter",o,i);let p={x:a,dy:c},d={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:t};return N.runKernel(ac,p,d)}var vO,bO=D(()=>{"use strict";B();G();q();_n();O();Se();vO=E({conv2DBackpropFilter_:eQ})});function il(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return ee(n,Tm(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function al(n,e){let t=e,r=ox(n.shape,e.shape);return r.length>0&&(t=He(t,r)),U(t,n.shape)}function cl(n,e,t,r){if(e==="linear")return n;if(e==="relu")return hs(n);if(e==="elu")return qf(n);if(e==="relu6")return vm(n);if(e==="prelu")return mm(n,t);if(e==="leakyrelu")return nm(n,r);if(e==="sigmoid")return zr(n);throw new Error(`Unknown fused activation ${e}.`)}var ul,zp=D(()=>{"use strict";Pt();iE();bE();ct();JE();ym();CT();Se();Uf();UT();jr();ul=(n,e)=>!(n>0)||e==="linear"});function tQ({x:n,filter:e,strides:t,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:l}){if(c=c||"linear",ul(N.state.gradientDepth,c)===!1){k(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let A=ss(n,e,t,r,o,s,i);return a!=null&&(A=de(A,a)),cl(A,c,u,l)}let p=C(n,"x","conv2d","float32"),d=C(e,"filter","conv2d","float32"),f=p,m=!1;p.rank===3&&(m=!0,f=U(p,[1,p.shape[0],p.shape[1],p.shape[2]])),k(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),k(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Tt("fused conv2d",r,i);let h=o==="NHWC"?f.shape[3]:f.shape[1];k(d.shape[2]===h,()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${d.shape[2]}.`),k(cn(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let g=Xu(f.shape,d.shape,t,s,r,i),x;a!=null&&(x=C(a,"bias","fused conv2d"),[x]=Ee(x,p),o==="NHWC"?ze(g.outShape,x.shape):(k(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),k(x.shape.length===0||x.shape[0]===g.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let v;if(u!=null){let A=u.shape;if(k(A.length<=1||A.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${A.length}.`),A.length===1)k(A[0]===1||A[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the number of output channels (${g.outChannels}).`);else if(A.length===3)try{ze(A,g.outShape)}catch{let F=`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(F)}v=C(u,"prelu weights","fused conv2d")}let w=(A,R)=>{k(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[F,P,L,V]=R,z=il(A,L,c);k(Ku(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let H=nx(P.shape,z,F,t,r),j=vO(P,z,F.shape,t,r),W=[H,j];if(V!=null){let Y=al(V,z);W.push(Y)}return W},I={x:f,filter:d,bias:x,preluActivationWeights:v},_={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:c,leakyreluAlpha:l};return a==null?ln((R,F,P)=>{let L=N.runKernel(Fi,I,_);return P([F,R,L]),m&&(L=U(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:w}})(f,d):ln((R,F,P,L)=>{let V=N.runKernel(Fi,I,_);return L([F,R,V,P]),m&&(V=U(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:w}})(f,d,x)}var CO,wO=D(()=>{"use strict";B();ds();G();at();$();q();_t();Pt();Wf();bO();GI();_n();zp();O();Se();CO=E({fusedConv2d_:tQ})});function nQ(n,e,t,r,o,s=[1,1],i){let a=n;n.rank===3&&(a=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=U(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u={x:a,dy:c},l={strides:r,pad:o,dimRoundingMode:i,dilations:s,filterShape:t};return N.runKernel(yc,u,l)}var IO,EO=D(()=>{"use strict";B();G();O();Se();IO=E({depthwiseConv2dNativeBackpropFilter_:nQ})});function rQ(n,e,t,r,o,s=[1,1],i){let a=e,c=!1;e.rank===3&&(c=!0,a=U(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u={dy:a,filter:t},l={strides:r,pad:o,dimRoundingMode:i,dilations:s,inputShape:n},p=N.runKernel(vc,u,l);return c?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var TO,SO=D(()=>{"use strict";B();G();O();Se();TO=E({depthwiseConv2dNativeBackpropInput_:rQ})});function oQ({x:n,filter:e,strides:t,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:c="linear",preluActivationWeights:u,leakyreluAlpha:l}){if(ul(N.state.gradientDepth,c)===!1){let _=Yu(n,e,t,r,o,s,i);return a!=null&&(_=de(_,a)),cl(_,c,u,l)}let p=C(n,"x","depthwiseConv2d","float32"),d=C(e,"filter","depthwiseConv2d","float32"),f=p,m=!1;p.rank===3&&(m=!0,f=U(p,[1,p.shape[0],p.shape[1],p.shape[2]])),k(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),k(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),k(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),s==null&&(s=[1,1]),k(cn(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),Tt("fused depthwiseConv2d",r,i);let h=Xu(f.shape,d.shape,t,s,r,i,!0),g;a!=null&&(g=C(a,"bias","fused conv2d"),[g]=Ee(g,p),ze(h.outShape,g.shape));let x;u!=null&&(x=C(u,"prelu weights","fused depthwiseConv2d"));let v=(_,A)=>{k(Ku(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[R,F,P,L]=A,V=il(_,P,c),z=TO(F.shape,V,R,t,r,s,i),H=IO(F,V,R.shape,t,r,s,i);if(L!=null){let j=al(g,V);return[z,H,j]}return[z,H]},w={x:f,filter:d,bias:g,preluActivationWeights:x},I={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:c,leakyreluAlpha:l};return a==null?ln((A,R,F)=>{let P=N.runKernel(Oi,w,I);return F([R,A,P]),m&&(P=U(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:v}})(f,d):ln((A,R,F,P)=>{let L=N.runKernel(Oi,w,I);return P([R,A,L,F]),m&&(L=U(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:v}})(f,d,g)}var NO,DO=D(()=>{"use strict";B();ds();G();at();$();q();_t();Pt();_n();rx();EO();SO();zp();O();Se();NO=E({fusedDepthwiseConv2d_:oQ})});function sQ({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(ul(N.state.gradientDepth,s)===!1){let V=Be(n,e,t,r);return o!=null&&(V=de(V,o)),cl(V,s,i,a)}let c=C(n,"a","fused matMul"),u=C(e,"b","fused matMul");[c,u]=Ee(c,u);let l=t?c.shape[c.rank-2]:c.shape[c.rank-1],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=t?c.shape[c.rank-1]:c.shape[c.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=c.shape.slice(0,-2),h=u.shape.slice(0,-2),g=Ne(m),x=Ne(h);k(l===p,()=>`Error in fused matMul: inner shapes (${l}) and (${p}) of Tensors with shapes ${c.shape} and ${u.shape} and transposeA=${t} and transposeB=${r} must match.`);let w=ze(c.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,f]),I=t?U(c,[g,l,d]):U(c,[g,d,l]),_=r?U(u,[x,f,p]):U(u,[x,p,f]),A;o!=null&&(A=C(o,"bias","fused matMul"),[A]=Ee(A,c),ze(w,A.shape));let R;i!=null&&(R=C(i,"prelu weights","fused matMul"));let F=(V,z)=>{let[H,j,W,Y]=z,Z=il(U(V,W.shape),W,s),K,Q;if(!t&&!r?(K=Be(Z,j,!1,!0),Q=Be(H,Z,!0,!1)):!t&&r?(K=Be(Z,j,!1,!1),Q=Be(Z,H,!0,!1)):t&&!r?(K=Be(j,Z,!1,!0),Q=Be(H,Z,!1,!1)):(K=Be(j,Z,!0,!0),Q=Be(Z,H,!0,!0)),o!=null){let te=al(Y,Z);return[K,Q,te]}else return[K,Q]},P={a:I,b:_,bias:A,preluActivationWeights:R},L={transposeA:t,transposeB:r,activation:s,leakyreluAlpha:a};return o==null?ln((z,H,j)=>{let W=N.runKernel(Ri,P,L);return j([z,H,W]),{value:U(W,w),gradFunc:F}})(I,_):ln((z,H,j,W)=>{let Y=N.runKernel(Ri,P,L);return W([z,H,Y,j]),{value:U(Y,w),gradFunc:F}})(I,_,A)}var kO,_O=D(()=>{"use strict";B();ds();G();at();$();q();_t();Pt();zp();ns();O();Se();kO=E({fusedMatMul_:sQ})});var Rx={};Le(Rx,{conv2d:()=>CO,depthwiseConv2d:()=>NO,matMul:()=>kO});var AO=D(()=>{"use strict";wO();DO();_O();});function iQ(n){return Up(n,.54,.46)}var RO,FO=D(()=>{"use strict";O();_m();RO=E({hammingWindow_:iQ})});function aQ(n){return Up(n,.5,.5)}var Fx,oS=D(()=>{"use strict";O();_m();Fx=E({hannWindow_:aQ})});function cQ(n,e,t,r=!1,o=0){let s=0,i=[];for(;s+e<=n.size;)i.push(Me(n,s,e)),s+=t;if(r)for(;s<n.size;){let a=s+e-n.size,c=Qe([Me(n,s,e-a),Hr([a],o)]);i.push(c),s+=t}return i.length===0?gs([],[0,e]):U(Qe(i),[i.length,e])}var Ox,sS=D(()=>{"use strict";Ur();_p();O();Se();yr();Nx();Ox=E({frame_:cQ})});function uQ(n,e,t,r,o=Fx){r==null&&(r=Ax(e));let s=Ox(n,e,t),i=ee(s,o(e));return rl(i,r)}var OO,MO=D(()=>{"use strict";ct();O();_m();Tx();sS();oS();OO=E({stft_:uQ})});function lQ(n,e,t,r,o="bilinear",s=0){let i=C(n,"image","cropAndResize"),a=C(e,"boxes","cropAndResize","float32"),c=C(t,"boxInd","cropAndResize","int32"),u=a.shape[0];k(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),k(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),k(c.rank===1&&c.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),k(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),k(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),k(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let l={image:i,boxes:a,boxInd:c},p={method:o,extrapolationValue:s,cropSize:r};return N.runKernel(mc,l,p)}var $O,PO=D(()=>{"use strict";B();G();$();q();O();$O=E({cropAndResize_:lQ})});function pQ(n){let e=C(n,"image","flipLeftRight","float32");k(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);let t={image:e};return N.runKernel(Dc,t,{})}var LO,BO=D(()=>{"use strict";B();G();$();q();O();LO=E({flipLeftRight_:pQ})});function dQ(n){let e=C(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];k(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),k(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let o=new Array(e.rank);return o.fill(1,0,t),o[t]=3,ls(e,o)}var VO,UO=D(()=>{"use strict";$();q();O();ix();VO=E({grayscaleToRGB_:dQ})});function fQ(n){let e=C(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];k(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),k(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let o=e.dtype,s=De(e,"float32"),i=Vt([.2989,.587,.114]),a;switch(e.rank){case 2:a=as("ij,j->i",s,i);break;case 3:a=as("ijk,k->ij",s,i);break;case 4:a=as("ijkl,l->ijk",s,i);break;case 5:a=as("ijklm,m->ijkl",s,i);break;case 6:a=as("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return a=vr(a,-1),De(a,o)}var zO,HO=D(()=>{"use strict";$();q();tn();sE();sx();O();Xi();zO=E({rgbToGrayscale_:fQ})});function mQ(n,e,t=0,r=.5){let o=C(n,"image","rotateWithOffset","float32");k(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:e,fillValue:t,center:r};return N.runKernel(Mu,s,i)}var GO,WO=D(()=>{"use strict";B();G();$();q();O();GO=E({rotateWithOffset_:mQ})});function br(n,e,t,r,o,s){r==null&&(r=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=n.shape[0];return t=Math.min(t,i),k(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),k(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),k(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),k(e.rank===1,()=>"scores must be a 1D tensor"),k(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),k(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:o,softNmsSigma:s}}var ll=D(()=>{"use strict";q();});function hQ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY){let s=C(n,"boxes","nonMaxSuppression","float32"),i=C(e,"scores","nonMaxSuppression","float32"),a=br(s,i,t,r,o);t=a.maxOutputSize,r=a.iouThreshold,o=a.scoreThreshold;let c={maxOutputSize:t,iouThreshold:r,scoreThreshold:o};return N.runKernel(Gc,{boxes:s,scores:i},c)}var jO,qO=D(()=>{"use strict";B();G();$();ll();O();jO=E({nonMaxSuppression_:hQ})});function KO(n,e,t){let r=gQ(n,e,t),o=r<0?-(r+1):r;n.splice(o,0,e)}function gQ(n,e,t){return yQ(n,e,t||xQ)}function xQ(n,e){return n>e?1:n<e?-1:0}function yQ(n,e,t){let r=0,o=n.length,s=0,i=!1;for(;r<o;){s=r+(o-r>>>1);let a=t(e,n[s]);a>0?r=s+1:(o=s,i=!a)}return i?r:-r-1}var XO=D(()=>{"use strict";});function Mx(n,e,t,r,o){return iS(n,e,t,r,o,0)}function $x(n,e,t,r,o,s){return iS(n,e,t,r,o,0,!1,s,!0)}function Px(n,e,t,r,o,s){return iS(n,e,t,r,o,s,!0)}function iS(n,e,t,r,o,s,i=!1,a=!1,c=!1){let u=[];for(let g=0;g<e.length;g++)e[g]>o&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(YO);let l=s>0?-.5/s:0,p=[],d=[];for(;p.length<t&&u.length>0;){let g=u.pop(),{score:x,boxIndex:v,suppressBeginIndex:w}=g;if(x<o)break;let I=!1;for(let _=p.length-1;_>=w;--_){let A=vQ(n,v,p[_]);if(A>=r){I=!0;break}if(g.score=g.score*bQ(r,l,A),g.score<=o)break}g.suppressBeginIndex=p.length,I||(g.score===x?(p.push(v),d.push(g.score)):g.score>o&&KO(u,g,YO))}let f=p.length,m=t-f;a&&m>0&&(p.push(...new Array(m).fill(0)),d.push(...new Array(m).fill(0)));let h={selectedIndices:p};return i&&(h.selectedScores=d),c&&(h.validOutputs=f),h}function vQ(n,e,t){let r=n.subarray(e*4,e*4+4),o=n.subarray(t*4,t*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),u=Math.min(o[0],o[2]),l=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),d=Math.max(o[1],o[3]),f=(a-s)*(c-i),m=(p-u)*(d-l);if(f<=0||m<=0)return 0;let h=Math.max(s,u),g=Math.max(i,l),x=Math.min(a,p),v=Math.min(c,d),w=Math.max(x-h,0)*Math.max(v-g,0);return w/(f+m-w)}function bQ(n,e,t){let r=Math.exp(e*t*t);return t<=n?r:0}function YO(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}var Am=D(()=>{"use strict";XO();});async function CQ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY){let s=C(n,"boxes","nonMaxSuppressionAsync"),i=C(e,"scores","nonMaxSuppressionAsync"),a=br(s,i,t,r,o);t=a.maxOutputSize,r=a.iouThreshold,o=a.scoreThreshold;let c=await Promise.all([s.data(),i.data()]),u=c[0],l=c[1],{selectedIndices:p}=Mx(u,l,t,r,o);return s!==n&&s.dispose(),i!==e&&i.dispose(),Vt(p,"int32")}var ZO,QO=D(()=>{"use strict";Am();$();ll();Xi();ZO=CQ});function wQ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(n,"boxes","nonMaxSuppression"),a=C(e,"scores","nonMaxSuppression"),c=br(i,a,t,r,o,s);t=c.maxOutputSize,r=c.iouThreshold,o=c.scoreThreshold,s=c.softNmsSigma;let u={boxes:i,scores:a},l={maxOutputSize:t,iouThreshold:r,scoreThreshold:o,softNmsSigma:s},p=N.runKernel(jc,u,l);return{selectedIndices:p[0],selectedScores:p[1]}}var JO,eM=D(()=>{"use strict";B();G();$();ll();O();JO=E({nonMaxSuppressionWithScore_:wQ})});async function IQ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(n,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),c=br(i,a,t,r,o,s);t=c.maxOutputSize,r=c.iouThreshold,o=c.scoreThreshold,s=c.softNmsSigma;let u=await Promise.all([i.data(),a.data()]),l=u[0],p=u[1],{selectedIndices:d,selectedScores:f}=Px(l,p,t,r,o,s);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:Vt(d,"int32"),selectedScores:Vt(f)}}var tM,nM=D(()=>{"use strict";Am();$();ll();Xi();tM=IQ});function EQ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(n,"boxes","nonMaxSuppression"),a=C(e,"scores","nonMaxSuppression"),c=br(i,a,t,r,o,null),u=c.maxOutputSize,l=c.iouThreshold,p=c.scoreThreshold,d={boxes:i,scores:a},f={maxOutputSize:u,iouThreshold:l,scoreThreshold:p,padToMaxOutputSize:s},m=N.runKernel(Wc,d,f);return{selectedIndices:m[0],validOutputs:m[1]}}var rM,oM=D(()=>{"use strict";B();G();$();ll();O();rM=E({nonMaxSuppressionPadded_:EQ})});async function TQ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(n,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),c=br(i,a,t,r,o,null),u=c.maxOutputSize,l=c.iouThreshold,p=c.scoreThreshold,[d,f]=await Promise.all([i.data(),a.data()]),{selectedIndices:m,validOutputs:h}=$x(d,f,u,l,p,s);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:Vt(m,"int32"),validOutputs:me(h,"int32")}}var sM,iM=D(()=>{"use strict";Am();$();ll();un();Xi();sM=TQ});function SQ(n,e,t=!1,r=!1){let o=C(n,"images","resizeBilinear");k(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),k(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),k(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=U(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,a={images:s},c={alignCorners:t,halfPixelCenters:r,size:e},u=N.runKernel(au,a,c);return i?U(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var aM,cM=D(()=>{"use strict";B();G();$();q();O();Se();aM=E({resizeBilinear_:SQ})});function NQ(n,e,t=!1,r=!1){let o=C(n,"images","resizeNearestNeighbor");k(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),k(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),k(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),k(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=U(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,a={images:s},c={alignCorners:t,halfPixelCenters:r,size:e},u=N.runKernel(iu,a,c);return i?U(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var uM,lM=D(()=>{"use strict";B();G();$();q();O();Se();uM=E({resizeNearestNeighbor_:NQ})});function DQ(n,e="binary",t=!1,r=.5){let o=C(n,"image","threshold"),s=.2989,i=.587,a=.114,c=o.shape[0]*o.shape[1],u=ee(Vt([r]),255),l,p,d,f;if(k(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),k(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),k(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),k(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),o.shape[2]===3){[l,p,d]=No(o,[1,1,1],-1);let g=ee(l,s),x=ee(p,i),v=ee(d,a);f=de(de(g,x),v)}else f=n;if(e==="otsu"){let g=Gf(De(bm(f),"int32"),an([]),256);u=kQ(g,c)}let m=t?Zu(f,u):Gi(f,u);return De(ee(m,255),"int32")}function kQ(n,e){let t=Vt([-1]),r=Vt([0]),o=Vt([0]),s,i,a,c,u,l;for(let p=0;p<n.size-1;p++){s=Me(n,0,p+1),i=Me(n,p+1),u=Oe(He(s),e),l=Oe(He(i),e);let d=He(ee(s,ms(0,s.size)));a=Oe(d,He(s));let f=Hr(i.shape,s.size),m=de(ms(0,i.size),f),h=ee(i,m);c=Oe(He(h),He(i));let g=ge(a,c),x=ge(a,c),v=ee(u,l);o=ee(ee(v,g),x);let w=Gi(o,r);r=Hn(w,o,r),t=Hn(w,Vt([p]),t)}return t}var pM,dM=D(()=>{"use strict";Xi();O();tn();wm();FI();cx();ax();jr();_t();ct();kn();Bt();ST();Ap();_p();yr();wx();Ff();q();$();pM=E({threshold_:DQ})});function _Q(n,e,t="nearest",r="constant",o=0,s){let i=C(n,"image","transform","float32"),a=C(e,"transforms","transform","float32");k(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),k(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),k(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let c={image:i,transforms:a},u={interpolation:t,fillMode:r,fillValue:o,outputShape:s};return N.runKernel(_u,c,u)}var fM,mM=D(()=>{"use strict";B();G();$();q();O();fM=E({transform_:_Q})});function AQ(n,e,t){let r=C(n,"a","bandPart");k(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let o=r.shape,[s,i]=r.shape.slice(-2),a,c;typeof e=="number"?(k(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),k(e<=s,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`),a=C(e<0?s:e,"numLower","bandPart")):(k(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Hn($p(e,0),s,qi(e,s))),typeof t=="number"?(k(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),k(t<=i,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`),c=C(t<0?i:t,"numUpper","bandPart")):(k(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),c=Hn($p(t,0),i,qi(t,i)));let u=U(ms(0,s,1,"int32"),[-1,1]),l=ms(0,i,1,"int32"),p=ge(u,l),d=Wi(Zu(p,a),em(p,jt(c))),f=ar([s,i],r.dtype);return U(pn(Wn(U(r,[-1,s,i])).map(m=>Hn(d,m,f))),o)}var hM,gM=D(()=>{"use strict";$();q();gE();CE();cx();px();gx();fs();O();wx();Se();Em();Bt();Dx();Ap();pm();hM=E({bandPart_:AQ})});function RQ(n){let e;if(Array.isArray(n)){e=!1,k(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=n[0].shape[0];for(let s=1;s<n.length;++s)k(n[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[s].shape[0]} vs. ${o})`)}else e=!0,n=No(n,n.shape[0],0).map(o=>ol(o,[0]));k(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);let t=[],r=n;for(let o=0;o<n.length;++o)t.push(N.tidy(()=>{let s=r[o];if(o>0)for(let i=0;i<o;++i){let a=ee(He(ee(t[i],s)),t[i]);s=ge(s,a)}return Oe(s,Hi(s,"euclidean"))}));return e?pn(t,0):t}var xM,yM=D(()=>{"use strict";B();q();kn();ct();Yf();O();wm();Sx();Em();Bt();jr();xM=E({gramSchmidt_:RQ})});function FQ(n,e=!1){if(k(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return vM(n,e);{let t=n.shape.slice(0,n.shape.length-2).reduce((c,u)=>c*u),r=Wn(U(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),o=[],s=[];r.forEach(c=>{let[u,l]=vM(c,e);o.push(u),s.push(l)});let i=U(pn(o,0),n.shape),a=U(pn(s,0),n.shape);return[i,a]}}function vM(n,e=!1){return N.tidy(()=>{k(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);let t=n.shape[0],r=n.shape[1],o=Zf(t),s=Dn(n),i=gs([[1]],[1,1]),a=Dn(i),c=t>=r?r:t;for(let u=0;u<c;++u){let l=s,p=a,d=o;[a,s,o]=N.tidy(()=>{let f=Me(s,[u,u],[t-u,1]),m=Hi(f),h=Me(s,[u,u],[1,1]),g=Hn(Gi(h,0),gs([[-1]]),gs([[1]])),x=ge(h,ee(g,m)),v=Oe(f,x);v.shape[0]===1?a=Dn(i):a=Qe([i,Me(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);let w=jt(Oe(Be(g,x),m)),I=Me(s,[u,0],[t-u,r]),_=ee(w,a),A=sl(a);if(u===0)s=ge(I,Be(_,Be(A,I)));else{let P=ge(I,Be(_,Be(A,I)));s=Qe([Me(s,[0,0],[u,r]),P],0)}let R=sl(_),F=Me(o,[0,u],[t,o.shape[1]-u]);if(u===0)o=ge(F,Be(Be(F,a),R));else{let P=ge(F,Be(Be(F,a),R));o=Qe([Me(o,[0,0],[t,u]),P],1)}return[a,s,o]}),ht([l,p,d])}return!e&&t>r&&(o=Me(o,[0,0],[t,r]),s=Me(s,[0,0],[r,r])),[o,s]})}var bM,CM=D(()=>{"use strict";B();zn();q();Np();Ur();kn();fE();ax();ns();ct();fs();Yf();O();Se();yr();Em();Bt();Nx();_x();Dx();Ap();bM=E({qr_:FQ})});var gt,Xr=D(()=>{"use strict";gt=(function(n){return n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",n})(gt||{})});function OQ(n,e,t=gt.SUM_BY_NONZERO_WEIGHTS){let r=C(n,"losses","computeWeightedLoss"),o=null;e!=null&&(o=C(e,"weights","computeWeightedLoss"));let s=o==null?r:ee(r,o);if(t===gt.NONE)return s;if(t===gt.SUM)return He(s);if(t===gt.MEAN){if(o==null)return ji(s);{let i=r.size/o.size,a=Oe(He(s),He(o));return i>1?Oe(a,me(i)):a}}if(t===gt.SUM_BY_NONZERO_WEIGHTS){if(o==null)return Oe(He(s),me(r.size));{let i=ee(o,qr(r.shape)),a=De(He(dm(i,me(0))),"float32");return Oe(He(s),a)}}throw Error(`Unknown reduction: ${t}`)}var nn,Do=D(()=>{"use strict";$();tn();kn();Xr();mx();ct();HE();hx();O();un();jr();nn=E({computeWeightedLoss_:OQ})});function MQ(n,e,t,r=gt.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"labels","absoluteDifference"),s=C(e,"predictions","absoluteDifference"),i=null;t!=null&&(i=C(t,"weights","absoluteDifference")),et(o.shape,s.shape,"Error in absoluteDifference: ");let a=$t(ge(o,s));return nn(a,i,r)}var wM,IM=D(()=>{"use strict";$();q();qu();Xr();O();Bt();Do();wM=E({absoluteDifference_:MQ})});function $Q(n,e,t,r,o=gt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"labels","cosineDistance"),i=C(e,"predictions","cosineDistance"),a=null;r!=null&&(a=C(r,"weights","cosineDistance")),et(s.shape,i.shape,"Error in cosineDistance: ");let c=me(1),u=ge(c,He(ee(s,i),t,!0));return nn(u,a,o)}var EM,TM=D(()=>{"use strict";$();q();Xr();ct();O();un();Bt();jr();Do();EM=E({cosineDistance_:$Q})});function PQ(n,e,t,r=gt.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"labels","hingeLoss"),s=C(e,"predictions","hingeLoss"),i=null;t!=null&&(i=C(t,"weights","hingeLoss")),et(o.shape,s.shape,"Error in hingeLoss: ");let a=me(1);o=ge(ee(me(2),o),a);let c=hs(ge(a,ee(o,s)));return nn(c,i,r)}var SM,NM=D(()=>{"use strict";$();q();Xr();ct();O();ym();un();Bt();Do();SM=E({hingeLoss_:PQ})});function LQ(n,e,t,r=1,o=gt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"labels","huberLoss"),i=C(e,"predictions","huberLoss"),a=null;t!=null&&(a=C(t,"weights","huberLoss")),et(s.shape,i.shape,"Error in huberLoss: ");let c=me(r),u=$t(ge(i,s)),l=qi(u,c),p=ge(u,l),d=de(ee(me(.5),Lt(l)),ee(c,p));return nn(d,a,o)}var DM,kM=D(()=>{"use strict";$();q();qu();_t();Xr();gx();ct();O();un();us();Bt();Do();DM=E({huberLoss_:LQ})});function BQ(n,e,t,r=1e-7,o=gt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"labels","logLoss"),i=C(e,"predictions","logLoss"),a=null;t!=null&&(a=C(t,"weights","logLoss")),et(s.shape,i.shape,"Error in logLoss: ");let c=me(1),u=me(r),l=jt(ee(s,To(de(i,u)))),p=ee(ge(c,s),To(de(ge(c,i),u))),d=ge(l,p);return nn(d,a,o)}var _M,AM=D(()=>{"use strict";$();q();_t();rm();Xr();ct();fs();O();un();Bt();Do();_M=E({logLoss_:BQ})});function VQ(n,e,t,r=gt.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"labels","meanSquaredError"),s=C(e,"predictions","meanSquaredError"),i=null;t!=null&&(i=C(t,"weights","meanSquaredError")),et(o.shape,s.shape,"Error in meanSquaredError: ");let a=Im(o,s);return nn(a,i,r)}var RM,FM=D(()=>{"use strict";$();q();Xr();O();VT();Do();RM=E({meanSquaredError_:VQ})});function UQ(n,e){let t=C(n,"labels","sigmoidCrossEntropyWithLogits"),r=C(e,"logits","sigmoidCrossEntropyWithLogits");et(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=hs(r),s=ee(r,t),i=om(ir(jt($t(r))));return de(ge(o,s),i)}function zQ(n,e,t,r=0,o=gt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"multiClassLabels","sigmoidCrossEntropy"),i=C(e,"logits","sigmoidCrossEntropy"),a=null;if(t!=null&&(a=C(t,"weights","sigmoidCrossEntropy")),et(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let u=me(r),l=me(1),p=me(.5);s=de(ee(s,ge(l,u)),ee(p,u))}let c=UQ(s,i);return nn(c,a,o)}var OM,MM=D(()=>{"use strict";$();q();qu();_t();Mp();EE();Xr();ct();fs();O();ym();un();Bt();Do();OM=E({sigmoidCrossEntropy_:zQ})});function HQ(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return ln((o,s,i)=>{let c=im(s,[t],!0),u=ge(De(s,"float32"),c);i([o,u]);let l=jt(ee(u,o));return{value:He(l,[t]),gradFunc:(f,m)=>{let[h,g]=m,x=cs(f.shape,[t]);return[ee(U(f,x),ge(De(h,"float32"),ir(g))),ee(U(f,x),ge(ir(g),De(h,"float32")))]}}})(n,e)}function GQ(n,e,t,r=0,o=gt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"onehotLabels","softmaxCrossEntropy"),i=C(e,"logits","softmaxCrossEntropy"),a=null;if(t!=null&&(a=C(t,"weights","softmaxCrossEntropy")),et(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let u=me(r),l=me(1),p=me(s.shape[1]);s=de(ee(s,ge(l,u)),Oe(u,p))}let c=HQ(s,i);return nn(c,a,o)}var $M,PM=D(()=>{"use strict";ds();$();q();_t();Rp();tn();kn();Mp();DE();Xr();ct();fs();O();Se();un();Bt();jr();Do();$M=E({softmaxCrossEntropy_:GQ})});function WQ(n,e,t,r){let o=C(n,"indices","sparseFillEmptyRows","int32"),s=C(e,"values","sparseFillEmptyRows"),i=C(t,"denseShape","sparseFillEmptyRows","int32"),a=C(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let c={indices:o,values:s,denseShape:i,defaultValue:a},u=N.runKernel(yu,c);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var LM,BM=D(()=>{"use strict";B();G();$();O();LM=E({sparseFillEmptyRows_:WQ})});function jQ(n,e,t){let r=C(n,"inputIndices","sparseReshape","int32"),o=C(e,"inputShape","sparseReshape","int32"),s=C(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:o,newShape:s},a=N.runKernel(vu,i);return{outputIndices:a[0],outputShape:a[1]}}var VM,UM=D(()=>{"use strict";B();G();$();O();VM=E({sparseReshape_:jQ})});function qQ(n,e,t){let r=C(n,"data","sparseSegmentMean"),o=C(e,"indices","sparseSegmentMean","int32"),s=C(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return N.runKernel(bu,i)}var zM,HM=D(()=>{"use strict";B();G();$();O();zM=E({sparseSegmentMean_:qQ})});function KQ(n,e,t){let r=C(n,"data","sparseSegmentSum"),o=C(e,"indices","sparseSegmentSum","int32"),s=C(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return N.runKernel(Cu,i)}var GM,WM=D(()=>{"use strict";B();G();$();O();GM=E({sparseSegmentSum_:KQ})});function XQ(n,e,t,r,o,s,i,a){let c=C(n,"data","stringNGrams","string");if(c.dtype!=="string")throw new Error("Data must be of datatype string");if(c.shape.length!==1)throw new Error(`Data must be a vector, saw: ${c.shape}`);let u=C(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let l={separator:t,nGramWidths:r,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:c,dataSplits:u},d=N.runKernel(Eu,p,l);return{nGrams:d[0],nGramsSplits:d[1]}}var jM,qM=D(()=>{"use strict";B();G();$();O();jM=E({stringNGrams_:XQ})});function YQ(n,e,t=!0){let r=C(n,"input","stringSplit","string"),o=C(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:t},i={input:r,delimiter:o},a=N.runKernel(Tu,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var KM,XM=D(()=>{"use strict";B();G();$();O();KM=E({stringSplit_:YQ})});function ZQ(n,e){let t=C(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");let o={input:t};return N.runKernel(Su,o,r)}var YM,ZM=D(()=>{"use strict";B();G();$();O();YM=E({stringToHashBucketFast_:ZQ})});function QQ(n,e,t,r=!0){let o=C(n,"input","staticRegexReplace","string"),s={pattern:e,rewrite:t,replaceGlobal:r};return N.runKernel(ki,{x:o},s)}var QM,JM=D(()=>{"use strict";B();G();$();O();QM=E({staticRegexReplace_:QQ})});var e$,t$,n$,r$,o$,s$,i$,Rm=D(()=>{"use strict";qu();SA();NA();_t();DA();kA();_A();AA();RA();FA();OA();MA();$A();PA();TI();VA();UA();kI();Hf();GA();WA();jA();FI();qA();KA();$I();ts();tn();XA();YA();Np();Li();Ur();ZA();QA();JA();eR();tR();Wf();nR();rR();iR();aR();cR();uR();lR();pR();dR();rx();fR();mR();kn();gR();xR();sE();iE();yR();nE();vR();wR();Mp();sx();IR();fE();_p();mE();uI();hE();ax();gE();tm();ER();TR();SR();bE();CE();cx();NR();DR();rm();EE();FR();OR();DE();px();kE();_E();MR();$R();ns();Kf();FE();PR();LR();$E();mx();BR();lE();gx();VR();UR();zR();ct();HR();GR();fs();HE();GE();hx();WR();jR();Bp();qR();KR();XR();YR();ZR();Xf();JE();cI();QR();JR();eF();tF();nF();wF();xT();IF();Cx();EF();wx();xm();TF();ym();CT();Se();tl();SF();NF();DF();kF();ST();_F();un();AF();RF();FF();Uf();OF();MF();$F();yr();PF();LF();BF();VF();UF();TE();ZE();Ix();Ex();BT();Tx();wm();Op();us();VT();Sx();Em();UT();zF();Bt();jr();HF();NI();Ff();Xi();Nx();GT();GF();WF();jF();KF();ix();XF();YF();ZF();QF();Dx();JF();eO();Ap();rS();pm();is();nO();_x();Yf();oO();iO();fx();lO();dO();gO();_m();yO();O();Tx();Ix();Ex();BT();AO();FO();oS();sS();MO();PO();BO();UO();HO();WO();qO();QO();eM();nM();oM();iM();cM();lM();dM();mM();gM();yM();CM();IM();Do();TM();NM();kM();AM();FM();MM();PM();BM();UM();HM();WM();qM();XM();ZM();JM();e$={fft:nl,ifft:Ki,rfft:rl,irfft:Cm},t$={hammingWindow:RO,hannWindow:Fx,frame:Ox,stft:OO},n$={flipLeftRight:LO,grayscaleToRGB:VO,resizeNearestNeighbor:uM,resizeBilinear:aM,rgbToGrayscale:zO,rotateWithOffset:GO,cropAndResize:$O,nonMaxSuppression:jO,nonMaxSuppressionAsync:ZO,nonMaxSuppressionWithScore:JO,nonMaxSuppressionWithScoreAsync:tM,nonMaxSuppressionPadded:rM,nonMaxSuppressionPaddedAsync:sM,threshold:pM,transform:fM},r$={bandPart:hM,gramSchmidt:xM,qr:bM},o$={absoluteDifference:wM,computeWeightedLoss:nn,cosineDistance:EM,hingeLoss:SM,huberLoss:DM,logLoss:_M,meanSquaredError:RM,sigmoidCrossEntropy:OM,softmaxCrossEntropy:$M},s$={sparseFillEmptyRows:LM,sparseReshape:VM,sparseSegmentMean:zM,sparseSegmentSum:GM},i$={stringNGrams:jM,stringSplit:KM,stringToHashBucketFast:YM,staticRegexReplace:QM}});var uS={};Le(uS,{Serializable:()=>Fm,SerializationMap:()=>Lx,getRegisteredName:()=>eJ,registerClass:()=>cS});function cS(n,e,t){k(n.className!=null,()=>"Class being registered does not have the static className property defined."),k(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),k(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);let r=t,o=e+">"+r;return Lx.register(n),JQ.set(o,n),aS.set(n,o),n}function eJ(n){return aS.has(n)?aS.get(n):n.className}var JQ,aS,Fm,Lx,Bx=D(()=>{"use strict";q();JQ=new Map,aS=new Map,Fm=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Lx=class n{constructor(){this.classNameMap={}}static getMap(){return n.instance==null&&(n.instance=new n),n.instance}static register(e){n.getMap().classNameMap[e.className]=[e,e.fromConfig]}}});var dn,Yi=D(()=>{"use strict";zn();ds();Rm();Bx();dn=class extends Fm{minimize(e,t=!1,r){let{value:o,grads:s}=this.computeGradients(e,r);if(r!=null){let i=r.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return ht(s),t?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return ux(e,t)}dispose(){this.iterations_!=null&&ht(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:me(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(dn,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null})});var Zi,Vx=D(()=>{"use strict";B();zn();_t();kn();ct();Rm();us();is();Yi();Zi=class extends dn{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{let s=N.registeredVariables[r],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accum_grad`,variable:Ce(()=>Nt(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${r}/accum_var`,variable:Ce(()=>Nt(s).variable(i))});let a=Array.isArray(e)?e[o].tensor:e[r];if(a==null)return;let c=this.accumulatedGrads[o].variable,u=this.accumulatedUpdates[o].variable;Ce(()=>{let l=de(ee(c,this.rho),ee(Lt(a),1-this.rho)),p=ee(Oe(wn(de(u,this.epsilon)),wn(de(c,this.epsilon))),a),d=de(ee(u,this.rho),ee(Lt(p),1-this.rho));c.assign(l),u.assign(d);let f=de(ee(p,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(ht(this.accumulatedGrads.map(e=>e.variable)),ht(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}});var Qi,Ux=D(()=>{"use strict";B();zn();_t();kn();_p();ct();Op();us();Yi();Qi=class extends dn{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{let s=N.registeredVariables[r];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accumulator`,variable:Ce(()=>Hr(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(e)?e[o].tensor:e[r];if(i==null)return;let a=this.accumulatedGrads[o].variable;Ce(()=>{let c=de(a,Lt(i));a.assign(c);let u=de(ee(Oe(i,wn(de(c,N.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&ht(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}});var Ji,zx=D(()=>{"use strict";B();zn();_t();kn();ct();Xf();un();Op();us();Bt();is();Yi();Ji=class extends dn{static get className(){return"Adam"}constructor(e,t,r,o=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ce(()=>{this.accBeta1=me(t).variable(),this.accBeta2=me(r).variable()}),o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Ce(()=>{let r=ge(1,this.accBeta1),o=ge(1,this.accBeta2);t.forEach((s,i)=>{let a=N.registeredVariables[s],c=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:Ce(()=>Nt(a).variable(c))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:Ce(()=>Nt(a).variable(c))});let u=Array.isArray(e)?e[i].tensor:e[s];if(u==null)return;let l=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,d=de(ee(l,this.beta1),ee(u,1-this.beta1)),f=de(ee(p,this.beta2),ee(Lt(u),1-this.beta2)),m=Oe(d,r),h=Oe(f,o);l.assign(d),p.assign(f);let g=de(ee(Oe(m,de(wn(h),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(ee(this.accBeta1,this.beta1)),this.accBeta2.assign(ee(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&ht(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&ht(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Ce(()=>{this.accBeta1.assign(Eo(this.beta1,this.iterations_+1)),this.accBeta2.assign(Eo(this.beta2,this.iterations_+1))});let t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}});var ea,Hx=D(()=>{"use strict";B();zn();qu();_t();kn();$E();ct();un();Bt();is();Yi();ea=class extends dn{static get className(){return"Adamax"}constructor(e,t,r,o=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ce(()=>{this.iteration=me(0).variable(),this.accBeta1=me(t).variable()}),o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Ce(()=>{let r=ge(1,this.accBeta1),o=Oe(-this.learningRate,de(ee(this.iteration,this.decay),1));t.forEach((s,i)=>{let a=N.registeredVariables[s],c=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:Nt(a).variable(c)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:Nt(a).variable(c)});let u=Array.isArray(e)?e[i].tensor:e[s];if(u==null)return;let l=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,d=de(ee(l,this.beta1),ee(u,1-this.beta1)),f=ee(p,this.beta2),m=$t(u),h=lm(f,m);l.assign(d),p.assign(h);let g=de(ee(Oe(o,r),Oe(d,de(h,this.epsilon))),a);a.assign(g)}),this.iteration.assign(de(this.iteration,1)),this.accBeta1.assign(ee(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&ht(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&ht(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}});var ko,Om=D(()=>{"use strict";B();zn();_t();ct();un();Yi();ko=class extends dn{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{let s=Array.isArray(e)?e[o].tensor:e[r];if(s==null)return;let i=N.registeredVariables[r];Ce(()=>{let a=de(ee(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Cn(me(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}});var ta,Gx=D(()=>{"use strict";B();zn();_t();ct();un();is();Om();ta=class extends ko{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=me(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{let s=N.registeredVariables[r];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${r}/momentum`,variable:Ce(()=>Nt(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(e)?e[o].tensor:e[r];a!=null&&Ce(()=>{let c,u=de(ee(this.m,i),a);this.useNesterov?c=de(ee(this.c,de(a,ee(u,this.m))),s):c=de(ee(this.c,u),s),i.assign(u),s.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&ht(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}});var na,Wx=D(()=>{"use strict";B();zn();_t();kn();ct();Op();us();Bt();is();Yi();na=class extends dn{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,o=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=N.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{let s=N.registeredVariables[r],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${r}/rms`,variable:Ce(()=>Nt(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${r}/momentum`,variable:Ce(()=>Nt(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${r}/mg`,variable:Ce(()=>Nt(s).variable(i))});let a=Array.isArray(e)?e[o].tensor:e[r];if(a==null)return;let c=this.accumulatedMeanSquares[o].variable,u=this.accumulatedMoments[o].variable;Ce(()=>{let l=de(ee(c,this.decay),ee(Lt(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,d=de(ee(p,this.decay),ee(a,1-this.decay)),f=Oe(ee(a,this.learningRate),wn(ge(l,de(Lt(d),this.epsilon)))),m=de(ee(u,this.momentum),f);c.assign(l),p.assign(d),u.assign(m);let h=ge(s,m);s.assign(h)}else{let p=de(ee(c,this.decay),ee(Lt(a),1-this.decay)),d=de(ee(u,this.momentum),Oe(ee(a,this.learningRate),wn(de(p,this.epsilon))));c.assign(p),u.assign(d);let f=ge(s,d);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&ht(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&ht(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&ht(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}});function a$(){for(let n of tJ)cS(n)}var tJ,c$=D(()=>{"use strict";Vx();Ux();zx();Hx();Gx();Wx();Om();Bx();tJ=[Zi,Qi,Ji,ea,ta,na,ko]});function u$(n){return new Promise(e=>setTimeout(e)).then(n)}function iJ(n="model"){return new lS(n)}function l$(n){return new pS(n)}var nJ,rJ,oJ,lS,pS,sJ,p$=D(()=>{"use strict";wp();Gt();Ui();zu();Bi();nJ="model",rJ=".json",oJ=".weights.bin";lS=(()=>{class n{constructor(t){if(!M().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(n.URL_SCHEME)&&(t=t.slice(n.URL_SCHEME.length)),(t==null||t.length===0)&&(t=nJ),this.modelJsonFileName=t+rJ,this.weightDataFileName=t+oJ}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let r=en.join(t.weightData),o=window.URL.createObjectURL(new Blob([r],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],i=Qg(t,s),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),c=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(c.download=this.modelJsonFileName,c.href=a,await u$(()=>c.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=o,await u$(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Co(t)}}}}return n.URL_SCHEME="downloads://",n})(),pS=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let r=new FileReader;r.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}let c=Ip(s,u=>this.loadWeights(u));e(c)},r.onerror=o=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){let t=[],r=[];for(let i of e)t.push(...i.weights),r.push(...i.paths);let o=this.checkManifestAndWeightFiles(e),s=r.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[t,i])}loadWeightsFile(e,t){return new Promise((r,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;r(a)},s.onerror=i=>o(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],r=this.weightsFiles.map(s=>Zw(s.name)),o={};for(let s of e)s.paths.forEach(i=>{let a=Zw(i);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},sJ=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(lS.URL_SCHEME)?iJ(n.slice(lS.URL_SCHEME.length)):null;Mt.registerSaveRouter(sJ)});function dS(n,e,t,r){i(n),t=t??0,r=r??1,a(t,r);let o=0,s=c=>(c.then(u=>{let l=t+ ++o/n.length*(r-t);return e(l),u}),c);function i(c){k(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function a(c,u){k(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),k(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),k(u>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${u}`)}return Promise.all(n.map(s))}var d$=D(()=>{"use strict";q();});async function fS(n,e){e==null&&(e={});let t=e.fetchFunc==null?M().platform.fetch:e.fetchFunc,r=n.map(p=>t(p,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(r):await dS(r,e.onProgress,0,.5)).map(p=>p.arrayBuffer());return e.onProgress==null?await Promise.all(a):await dS(a,e.onProgress,.5,1)}function f$(n,e){var t;let r=e.fetchFunc==null?M().platform.fetch:e.fetchFunc,o=0,s;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async i=>{for(var a;o<n.length;){s||(s=(await r(n[o],e.requestInit,{isBinary:!0})).body.getReader());let{done:c,value:u}=await s.read();if(c){o++,s=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,o/n.length);continue}i.enqueue(u);return}i.close()}})}async function m$(n,e="",t,r){return mS(i=>fS(i,{requestInit:r}))(n,e,t)}function mS(n){return async(e,t="",r)=>{let o=e.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((f,m)=>{let h=0;f.weights.forEach(g=>{let x="quantization"in g?g.quantization.dtype:g.dtype,v=Jo[x]*Ne(g.shape),w=()=>{o[m]=!0,s[m]==null&&(s[m]=[]),s[m].push({manifestEntry:g,groupOffset:h,sizeBytes:v})};r!=null?r.forEach((I,_)=>{I===g.name&&(w(),i[_]=!0)}):w(),a.push(g.name),h+=v})}),!i.every(f=>f)){let f=r.filter((m,h)=>!i[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let c=o.reduce((f,m,h)=>(m&&f.push(h),f),[]),u=[];c.forEach(f=>{e[f].paths.forEach(m=>{let h=t+(t.endsWith("/")?"":"/")+m;u.push(h)})});let l=await n(u),p={},d=0;return c.forEach(f=>{let m=e[f].paths.length,h=new en(l.slice(d,d+m));s[f].forEach(x=>{let v=h.slice(x.groupOffset,x.groupOffset+x.sizeBytes),w=Yg(v,[x.manifestEntry]);for(let I in w)p[I]=w[I]}),d+=m}),p}}var hS=D(()=>{"use strict";Gt();q();Bi();Ui();d$();qw();});function uJ(n){let e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),o=t>e?n.substring(t):"";return[r+"/",o]}function jx(n){return n.match(h$.URL_SCHEME_REGEX)!=null}function qx(n,e){return new h$(n,e)}function x$(n,e){return qx(n,e)}var aJ,cJ,h$,g$,y$=D(()=>{"use strict";Gt();q();Ui();Bi();zu();hS();aJ="application/octet-stream",cJ="application/json",h$=(()=>{class n{constructor(t,r){if(this.DEFAULT_METHOD="POST",r==null&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,r.fetchFunc!=null?(k(typeof r.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=M().platform.fetch,k(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&k(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,r.requestInit!=null&&r.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let r=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);r.body=new FormData;let o=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],s=Qg(t,o);if(r.body.append("model.json",new Blob([JSON.stringify(s)],{type:cJ}),"model.json"),t.weightData!=null){let a=en.join(t.weightData);r.body.append("model.weights.bin",new Blob([a],{type:aJ}),"model.weights.bin")}let i=await this.fetch(this.path,r);if(i.ok)return{modelArtifactsInfo:Co(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let r;try{r=await t.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let o=r.modelTopology,s=r.weightsManifest;if(o==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return r}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let t=await this.loadModelJSON();return Ip(t,r=>this.loadWeights(r))}async loadStream(){let t=await this.loadModelJSON(),r=await this.getWeightUrls(t.weightsManifest),o=Mf(t.weightsManifest),s=()=>f$(r,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:o,getWeightStream:s})}async getWeightUrls(t){let r=Array.isArray(this.path)?this.path[1]:this.path,[o,s]=uJ(r),i=this.weightPathPrefix||o,a=[],c=[];for(let u of t)for(let l of u.paths)this.weightUrlConverter!=null?c.push(this.weightUrlConverter(l)):a.push(i+l+s);return this.weightUrlConverter&&a.push(...await Promise.all(c)),a}async loadWeights(t){let r=await this.getWeightUrls(t),o=Mf(t),s=await fS(r,this.loadOptions);return[o,s]}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();g$=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>jx(r)):t=jx(n),t)return qx(n,e)}return null};Mt.registerSaveRouter(g$);Mt.registerLoadRouter(g$)});function v$(n,e,t,r){let o=arguments;return new gS(xS(...o))}function xS(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Mm(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Mm({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Mm({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function b$(n){return new Kx(n)}function C$(n){return new Kx(n)}var Mm,Kx,gS,w$=D(()=>{"use strict";Mm=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},Kx=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},gS=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}});var _o={};Le(_o,{CompositeArrayBuffer:()=>en,browserFiles:()=>l$,browserHTTPRequest:()=>x$,concatenateArrayBuffers:()=>oA,copyModel:()=>yA,decodeWeights:()=>Yg,decodeWeightsStream:()=>Zg,encodeWeights:()=>eA,fromMemory:()=>v$,fromMemorySync:()=>xS,getLoadHandlers:()=>cA,getModelArtifactsForJSON:()=>Ip,getModelArtifactsForJSONSync:()=>Qw,getModelArtifactsInfoForJSON:()=>Co,getSaveHandlers:()=>aA,getWeightSpecs:()=>Mf,http:()=>qx,isHTTPScheme:()=>jx,listModels:()=>gA,loadWeights:()=>m$,moveModel:()=>vA,registerLoadRouter:()=>iA,registerSaveRouter:()=>sA,removeModel:()=>xA,weightsLoaderFactory:()=>mS,withSaveHandler:()=>b$,withSaveHandlerSync:()=>C$});var I$=D(()=>{"use strict";nI();rI();p$();y$();Ui();w$();zu();hS();Bi();oI();});function lJ(n,e,t){let r=C(n,"labels","confusionMatrix"),o=C(e,"predictions","confusionMatrix");k(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),k(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),k(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),k(r.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),k(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);let s=Lp(De(r,"int32"),t),i=Lp(De(o,"int32"),t),a=sl(s),c=Be(a,i);return De(c,"int32")}var E$,T$=D(()=>{"use strict";$();q();tn();ns();GE();O();_x();E$=E({confusionMatrix_:lJ})});var yS={};Le(yS,{confusionMatrix:()=>E$});var S$=D(()=>{"use strict";T$();});var vS={};Le(vS,{draw:()=>yJ,fromPixels:()=>vJ,fromPixelsAsync:()=>hJ,toPixels:()=>xJ});function D$(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,o=!1,s=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)s=!0;else if(n.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if($u(fp,N.backendName)!=null){let m={pixels:n},h={numChannels:e};return N.runKernel(fp,m,h)}let[u,l]=o?[n.videoWidth,n.videoHeight]:[n.width,n.height],p;if(i)p=n.getContext("2d").getImageData(0,0,u,l).data;else if(r||t)p=n.data;else if(s||o||a){if(pl==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")pl=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else pl=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});pl.canvas.width=u,pl.canvas.height=l,pl.drawImage(n,0,0,u,l),p=pl.getImageData(0,0,u,l).data}let d;if(e===4)d=new Int32Array(p);else{let m=u*l;d=new Int32Array(m*e);for(let h=0;h<m;h++)for(let g=0;g<e;++g)d[h*e+g]=p[h*4+g]}return Sm(d,[l,u,e],"int32")}function pJ(n){return n!=null&&n.data instanceof Uint8Array}function dJ(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function fJ(n){return n!=null&&n.width!==0&&n.height!==0}function mJ(n){return dJ()&&!(n instanceof ImageBitmap)&&fJ(n)&&!pJ(n)}async function hJ(n,e=3){let t=null;if(M().getBool("WRAP_TO_IMAGEBITMAP")&&mJ(n)){let r;try{r=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===n.width&&r.height===n.height?t=r:t=n}else t=n;return D$(t,e)}function k$(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);let e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function gJ(n){let e=n?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function xJ(n,e){let t=C(n,"img","toPixels");if(!(n instanceof Ke)){let u=t;t=De(u,"int32"),u.dispose()}k$(t);let[r,o]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2],i=await t.data(),a=t.dtype==="float32"?255:1,c=new Uint8ClampedArray(o*r*4);for(let u=0;u<r*o;++u){let l=[0,0,0,255];for(let d=0;d<s;d++){let f=i[u*s+d];if(t.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(t.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(l[0]=f*a,l[1]=f*a,l[2]=f*a):l[d]=f*a}let p=u*4;c[p+0]=Math.round(l[0]),c[p+1]=Math.round(l[1]),c[p+2]=Math.round(l[2]),c[p+3]=Math.round(l[3])}if(e!=null){N$||$u(ip,N.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),N$=!0),e.width=o,e.height=r;let u=e.getContext("2d"),l=new ImageData(c,o,r);u.putImageData(l,0,0)}return t!==n&&t.dispose(),c}function yJ(n,e,t){let r=C(n,"img","draw");if(!(n instanceof Ke)){let i=r;r=De(i,"int32"),i.dispose()}k$(r),gJ(t?.imageOptions);let o={image:r},s={canvas:e,options:t};N.runKernel(ip,o,s)}var pl,N$,vJ,_$=D(()=>{"use strict";B();Gt();G();Vg();or();$();tn();O();GT();N$=!1;vJ=E({fromPixels_:D$})});var bS={};Le(bS,{prepareAndValidate:()=>A$});function A$(n,e){let t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(Ne(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);let o=e.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=n.shape,c=o.slice();c.pop();let u=1;for(let p=s;p<t;++p)u*=a[p],c.push(a[p]);let l=[...yo(n.shape).map(p=>p/u),1].slice(0,s);return[c,i,u,l]}var CS=D(()=>{"use strict";q()});var At={};Le(At,{assertParamsValid:()=>CJ,computeFlatOffset:()=>SJ,computeOutShape:()=>IJ,getNormalizedAxes:()=>EJ,isSliceContinous:()=>TJ,maskToAxes:()=>wJ,parseSliceParams:()=>NJ,sliceInfo:()=>DJ,startForAxis:()=>B$,startIndicesWithElidedDims:()=>$$,stopForAxis:()=>V$,stopIndicesWithElidedDims:()=>P$,stridesForAxis:()=>L$,stridesWithElidedDims:()=>F$});function CJ(n,e,t){let r=n.shape.length;k(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),k(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let o=0;o<r;++o)k(e[o]+t[o]<=n.shape[o],()=>`Error in slice${r}D: begin[${o}] + size[${o}] (${e[o]+t[o]}) would overflow input.shape[${o}] (${n.shape[o]})`)}function wJ(n){let e=[],t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function IJ(n,e,t){let r=[];for(let o=0;o<n.length;o++)r[o]=Math.ceil((e[o]-n[o])/t[o]);return r}function F$(n,e,t,r){let o=[...n];for(let s=o.length;s<r.length;s++)o.push(1);for(let s=0;s<t;s++)s===0?o[e]=1:(o.splice(e,0,1),o.pop());return o}function O$(n,e,t){return t<=n?t:t-(e-1)}function M$(n,e){let t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function EJ(n,e,t,r,o,s,i,a,c){let u=n.length,l=new Array(u),p=new Array(u),d=new Array(u);if(e.length&&t>0){let f=e[0],m=t+1;l=$$(i,f,m,r,n),p=P$(a,f,m,o,n),d=F$(s,f,m,n)}else for(let f=0;f<u;f++)l[f]=B$(i,r,s,n,f,c),p[f]=V$(a,o,s,n,f,c),d[f]=L$(s,f,c);return{begin:l,end:p,strides:d}}function $$(n,e,t,r,o){let s=[...o],i=M$(t,e);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let c=O$(e,t,a),u=r[c];n&1<<c&&(u=0),s[a]=u}return s}function P$(n,e,t,r,o){let s=[...o],i=M$(t,e);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let c=O$(e,t,a),u=r[c];n&1<<c&&(u=Number.MAX_SAFE_INTEGER),s[a]=u}for(let a=0;a<s.length;a++){let c=o[a];s[a]<0&&(s[a]+=c),s[a]=Jl(0,s[a],o[a])}return s}function L$(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function B$(n,e,t,r,o,s){let i=e[o],a=t[o]||1;(n&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let c=r[o];return i<0&&(i+=c),i=Jl(0,i,c-1),i}function V$(n,e,t,r,o,s){let i=e[o],a=t[o]||1;(n&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let c=r[o];return i<0&&(i+=c),a>0?i=Jl(0,i,c):i=Jl(-1,i,c-1),i}function TJ(n,e,t){let r=t.length;for(let o=0;o<t.length;o++)if(t[o]>1){r=o;break}for(let o=r+1;o<t.length;o++)if(e[o]>0||t[o]!==n[o])return!1;return!0}function SJ(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function NJ(n,e,t){let r,o=n.shape.length;typeof e=="number"?r=[e,...new Array(o-1).fill(0)]:e.length<o?r=e.concat(new Array(o-e.length).fill(0)):r=e.slice(),r.forEach(i=>{k(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(o).fill(-1):typeof t=="number"?s=[t,...new Array(o-1).fill(-1)]:t.length<o?s=t.concat(new Array(o-t.length).fill(-1)):s=t,s=s.map((i,a)=>i>=0?i:(k(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,s]}function DJ(n,e,t,r,o,s,i,a,c){let u;if(r==null?(u=new Array(e.length),u.fill(1)):u=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let l=!1,p={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:c};for(let w=0;w<p.dims;w++)l&&(1<<w&a)!==0&&p.numAddAxisAfterEllipsis++,1<<w&i&&(l=!0);l||(p.ellipsisMask|=1<<p.dims,p.dims++);let d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};kJ(p,d);let f=!0,m=!0,h=!0,g=[],x=[];for(let w=0;w<n.length;++w){if(d.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);let I=!!(d.shrinkAxisMask&1<<w),_=n[w];if(_===-1){g.push(I?1:-1);continue}let A=[d.beginMask&1<<w,d.endMask&1<<w],R=[d.strides[w]>0?0:-1,d.strides[w]>0?_:_-1];if(I&&d.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&d.strides[w]===1;let F=!!(d.beginMask&1<<w&&d.endMask&1<<w);if(d.beginValid&&d.endValid){if(I){let z=d.begin[w]<0?_+d.begin[w]:d.begin[w];if(d.begin[w]=z,d.end[w]=d.begin[w]+1,z<0||z>=_)throw Error(`slice index ${d.begin[w]} of dimension ${w} out of bounds.`)}else d.begin[w]=R$(d.begin[w],0,d.strides[w],_,A,R),d.end[w]=R$(d.end[w],1,d.strides[w],_,A,R);let V=d.strides[w]===1&&d.begin[w]===0&&d.end[w]===_;f=f&&V,m=m&&(w===0&&d.strides[w]===1||V)}else f=f&&d.strides[w]===1&&F,m=m&&(w===0&&d.strides[w]===1||F);let P,L=!1;if(d.beginValid&&d.endValid?(P=d.end[w]-d.begin[w],L=!0):I?(P=1,L=!0):F&&_>=0&&(d.strides[w]<0?P=-_:P=_,L=!0),L){let V;P===0||P<0!=d.strides[w]<0?V=0:V=Math.trunc(P/d.strides[w])+(P%d.strides[w]!==0?1:0),g.push(V)}else g.push(-1)}for(let w=0;w<d.finalShapeGatherIndices.length;++w){let I=d.finalShapeGatherIndices[w];I>=0?x.push(g[I]):I===wS&&x.push(1)}return{finalShapeSparse:x.filter((w,I)=>d.finalShapeGatherIndices[I]!==wS),finalShape:x,isIdentity:f,sliceDim0:m,isSimpleSlice:h,begin:d.begin,end:d.end,strides:d.strides}}function kJ(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){let o=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<o;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(wS),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(bJ),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function R$(n,e,t,r,o,s){if(o[e])return t>0?s[e]:s[e+1&1];{let i=n<0?r+n:n;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var wS,bJ,IS=D(()=>{"use strict";q();wS=-2,bJ=-1});var U$,z$=D(()=>{"use strict";U$="4.22.0"});var Hp,ES=D(()=>{"use strict";Vx();Ux();zx();Hx();Gx();Wx();Om();Hp=class{static sgd(e){return new ko(e)}static momentum(e,t,r=!1){return new ta(e,t,r)}static rmsprop(e,t=.9,r=0,o=null,s=!1){return new na(e,t,r,o,s)}static adam(e=.001,t=.9,r=.999,o=null){return new Ji(e,t,r,o)}static adadelta(e=.001,t=.95,r=null){return new Zi(e,t,r)}static adamax(e=.002,t=.9,r=.999,o=null,s=0){return new ea(e,t,r,o,s)}static adagrad(e,t=.1){return new Qi(e,t)}}});var _J,H$=D(()=>{"use strict";ES();_J=Hp});function Xx(){return new Promise(n=>AJ(()=>n()))}var AJ,G$=D(()=>{"use strict";AJ=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n()});function RJ(n,e){let t=n[0].length;n.forEach((o,s)=>{k(o.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),k(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);let r=n[0];n.forEach((o,s)=>{for(let i=0;i<t;i++)k(i===e||o[i]===r[i],()=>`Error in concat${t}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function FJ(n,e){let t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}var W$=D(()=>{"use strict";q();});var j$=D(()=>{"use strict";});function OJ(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let o=1;o<t.length;++o){let s=t[o],i=r[r.length-t.length+o],a=r[i];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${o+n}] = ${s} but shape[${o+n}] = ${a}`)}else r[i]=s}return r}function MJ(n){let e={FIRST_DIM_SIZE:xs.FIRST_DIM_SIZE,VALUE_ROWIDS:xs.VALUE_ROWIDS,ROW_LENGTHS:xs.ROW_LENGTHS,ROW_SPLITS:xs.ROW_SPLITS,ROW_LIMITS:xs.ROW_LIMITS,ROW_STARTS:xs.ROW_STARTS},t=[];for(let r of n)if(r in e)t.push(e[r]);else break;return t}function $J(n){return n.length===0?0:n[0]===xs.FIRST_DIM_SIZE?n.length-1:n.length}function PJ(n,e){if(n==null||e==null)return;let t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let o=0;o<Math.min(t,r-1);++o){let s=n[o],i=e[o+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${o-n.length}] = ${s} but ragged tensor input.flatValues.shape[${o-n.length}] = ${i}`)}}var xs,q$=D(()=>{"use strict";xs=(function(n){return n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",n})(xs||{})});function LJ(n){return n<=Yx?n:tp(n,Math.floor(Math.sqrt(n)))}var Yx,TS=D(()=>{"use strict";q();Yx=30});function BJ(n,e,t){let r=t*(typeof n=="number"?n:n[0]),o=e*(typeof n=="number"?n:n[1]);return[r,o]}var K$=D(()=>{"use strict";});function VJ(n,e,t,r=!0){let o=[];if(r)o=o.concat(e.slice(0)),o.push(n[0]/t),o=o.concat(n.slice(1));else{o=o.concat(n[0]);let s=e.length;for(let i=0;i<s;++i)o=o.concat([n[i+1]/e[i],e[i]]);o=o.concat(n.slice(s+1))}return o}function UJ(n,e,t=!0){let r=[];if(t){r.push(e);for(let o=e+1;o<n;++o)o<=2*e?(r.push(o),r.push(o-(e+1))):r.push(o)}else{let o=[],s=[];for(let i=1;i<n;++i)i>=e*2+1||i%2===1?s.push(i):o.push(i);r.push(...o),r.push(0),r.push(...s)}return r}function zJ(n,e,t,r=!0){let o=[];r?o.push(n[0]/t):o.push(n[0]*t);for(let s=1;s<n.length;++s)s<=e.length?r?o.push(e[s-1]*n[s]):o.push(n[s]/e[s-1]):o.push(n[s]);return o}function HJ(n,e){let t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function GJ(n,e,t){let r=n.slice(0,1);for(let o=0;o<t;++o)r.push(n[o+1]-e[o][0]-e[o][1]);return r}var X$=D(()=>{"use strict";});var WJ,jJ,Y$=D(()=>{"use strict";WJ=1.7580993408473768,jJ=1.0507009873554805});var qJ,KJ,XJ,YJ,ZJ,QJ,Z$=D(()=>{"use strict";qJ=.3275911,KJ=.254829592,XJ=-.284496736,YJ=1.421413741,ZJ=-1.453152027,QJ=1.061405429});function JJ(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);let t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function eee(n){let e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function tee(n){let e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let o=0;o<n.length;o+=4)t[Math.floor(o/4)]=n[o],r[Math.floor(o/4)]=n[o+1];return{real:t,imag:r}}function nee(n){let e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let o=2;o<n.length;o+=4)t[Math.floor(o/4)]=n[o],r[Math.floor(o/4)]=n[o+1];return{real:t,imag:r}}function ree(n,e){let t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function oee(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function see(n,e){let t=new Float32Array(n/2),r=new Float32Array(n/2);for(let o=0;o<Math.ceil(n/2);o++){let s=(e?2:-2)*Math.PI*(o/n);t[o]=Math.cos(s),r[o]=Math.sin(s)}return{real:t,imag:r}}function iee(n,e,t){let r=(t?2:-2)*Math.PI*(n/e),o=Math.cos(r),s=Math.sin(r);return{real:o,imag:s}}var Q$=D(()=>{"use strict";});function cee(n,e){n=n.replace(/\s/g,"");let t=(n.length-n.replace(aee,"").length)/SS.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${SS}").`);let[r,o]=n.split(SS);k(r.indexOf(eP)===-1,()=>`The ellipsis notation ("${eP}") is not supported yet.`);let s=r.split(J$),i=s.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let d=0;d<o.length;++d){let f=o[d];if(!s.some(m=>m.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let d=0;d<r.length;++d){let f=r[d];a.indexOf(f)===-1&&f!==J$&&a.push(f)}let c=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);c[d]=[];for(let f=0;f<s[d].length;++f)c[d].push(a.indexOf(s[d][f]))}let u=a.length,l=o.length,p=[];for(let d=l;d<u;++d)p.push(d);return{allDims:a,summedDims:p,idDims:c}}function uee(n,e){let t=new Array(n);t.fill(-1);for(let o=0;o<e.length;++o)t[e[o]]=o;let r=[];for(let o=0;o<n;++o)t[o]===-1&&r.push(o);return t=t.filter(o=>o!==-1),{permutationIndices:t,expandDims:r}}function lee(n,e,t){let r=new Array(n);for(let o=0;o<t.length;++o){let s=t[o].shape;for(let i=0;i<e[o].length;++i)r[e[o][i]]===void 0?r[e[o][i]]=s[i]:k(r[e[o][i]]===s[i],()=>`Expected dimension ${r[e[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function pee(n,e){let t=n,r=[],o=0;n.length===0&&t.push(-1),o=n.length+1;for(let i=0;i<o;++i)r.push([]);let s=[];for(let i=0;i<t.length;++i){let a=t[i],c=fee(e,a);for(let u of c)s.indexOf(u)===-1&&(r[i].push(u),s.push(u))}return{path:t,steps:r}}function dee(n){return n.every((e,t)=>e===t)}function fee(n,e){let t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}var SS,aee,J$,eP,tP=D(()=>{"use strict";Ot();SS="->",aee=/->/g,J$=",",eP="..."});function mee(n,e,t=0){let r=[];if(typeof e=="number")k(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{let o=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);k(o<=1,()=>"There should be only one negative value in split array.");let s=e.indexOf(-1);if(s!==-1){let i=e.reduce((a,c)=>c>0?a+c:a);e[s]=n.shape[t]-i}k(n.shape[t]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}var nP=D(()=>{"use strict";q()});function hee(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function gee(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function xee(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}var rP=D(()=>{"use strict";});function yee(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function vee(n,e){return`size ${n} must be non-negative, not ${e}`}function bee(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Cee(n,e){let t=Ne(n),r=Ne(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function wee(n,e){let t=Ne(n),r=Ne(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}var oP=D(()=>{"use strict";q();});function Iee(){return"segment ids must be >= 0"}function Eee(){return"segment ids are not increasing"}function Tee(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function See(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}var sP=D(()=>{"use strict";});var NS={};Le(NS,{collectGatherOpShapeInfo:()=>kee,computeOutShape:()=>Dee,segOpComputeOptimalWindowSize:()=>Nee});function Nee(n,e){let t=!1,r;for(n<=Yx?(r=n,t=!0):r=tp(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=tp(n,r+1);return r}function Dee(n,e,t){let r=[],o=n.length;for(let s=0;s<o;s++)s!==e?r.push(n[s]):r.push(t);return r}function kee(n,e,t,r){let o=e.shape.length,s=n.shape.length;if(r!==0&&(r<-o||r>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${r}`);if(r<0&&(r+=o),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let p=0;p<r;++p)if(n.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);let i=n.shape[t],a=[],c=1,u=1,l=1;for(let p=0;p<r;++p)a.push(n.shape[p]),c*=n.shape[p];for(let p=r;p<t;p++)a.push(n.shape[p]),u*=n.shape[p];for(let p=r;p<o;p++)a.push(e.shape[p]);for(let p=t+1;p<s;p++)a.push(n.shape[p]),l*=n.shape[p];return{batchSize:c,sliceSize:l,outerSize:u,dimSize:i,outputShape:a}}var iP=D(()=>{"use strict";q();TS();});var S={};Le(S,{ERF_A1:()=>KJ,ERF_A2:()=>XJ,ERF_A3:()=>YJ,ERF_A4:()=>ZJ,ERF_A5:()=>QJ,ERF_P:()=>qJ,PARALLELIZE_THRESHOLD:()=>Yx,RowPartitionType:()=>xs,SELU_SCALE:()=>jJ,SELU_SCALEALPHA:()=>WJ,applyActivation:()=>cl,assertAndGetBroadcastShape:()=>ze,assertAxesAreInnerMostDims:()=>bX,assertParamsConsistent:()=>RJ,assignToTypedArray:()=>oee,axesAreInnerMostDims:()=>uE,calculateShapes:()=>qF,checkEinsumDimSizes:()=>lee,checkPadOnDimRoundingMode:()=>Tt,combineLocations:()=>bR,combineRaggedTensorToTensorShapes:()=>OJ,complexWithEvenIndex:()=>tee,complexWithOddIndex:()=>nee,computeConv2DInfo:()=>Xu,computeConv3DInfo:()=>LA,computeDefaultPad:()=>EI,computeDilation2DInfo:()=>yK,computeOptimalWindowSize:()=>LJ,computeOutAndReduceShapes:()=>vX,computeOutShape:()=>FJ,computePool2DInfo:()=>II,computePool3DInfo:()=>vK,convertConv2DDataFormat:()=>BA,decodeEinsumEquation:()=>cee,eitherStridesOrDilationsAreOne:()=>cn,expandShapeToKeepDim:()=>cs,exponent:()=>iee,exponents:()=>see,fromStringArrayToUint8:()=>Aee,fromUint8ToStringArray:()=>_ee,getAxesPermutation:()=>CX,getBroadcastDims:()=>hR,getComplexWithIndex:()=>ree,getEinsumComputePath:()=>pee,getEinsumPermutation:()=>uee,getFusedBiasGradient:()=>al,getFusedDyActivation:()=>il,getImageCenter:()=>BJ,getInnerMostAxes:()=>IX,getPermuted:()=>UJ,getRaggedRank:()=>$J,getReductionAxes:()=>ox,getReshaped:()=>VJ,getReshapedPermuted:()=>zJ,getRowPartitionTypesHelper:()=>MJ,getSliceBeginCoords:()=>HJ,getSliceSize:()=>GJ,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>hee,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>gee,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>xee,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>bee,getSparseReshapeInputOutputMismatchErrorMessage:()=>wee,getSparseReshapeInputOutputMultipleErrorMessage:()=>Cee,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>yee,getSparseReshapeNegativeOutputDimErrorMessage:()=>vee,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>See,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Iee,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Eee,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Tee,getUndoAxesPermutation:()=>wX,isIdentityPermutation:()=>dee,log:()=>q7,mergeRealAndImagArrays:()=>JJ,prepareAndValidate:()=>A$,prepareSplitSize:()=>mee,segment_util:()=>NS,shouldFuse:()=>ul,slice_util:()=>At,splitRealAndImagArrays:()=>eee,stridesOrDilationsArePositive:()=>wo,tupleValuesAreOne:()=>Ku,upcastType:()=>wt,validateDefaultValueShape:()=>PJ,validateInput:()=>Vp,validateUpdateShape:()=>KT,warn:()=>vo});function _ee(n){try{return n.map(e=>vp(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Aee(n){return n.map(e=>$i(e))}var aP=D(()=>{"use strict";q();Rp();Pt();W$();_n();zp();j$();q$();TS();IS();Cp();K$();X$();CS();Dm();Y$();zp();Z$();Lg();Q$();tP();nP();rP();oP();sP();iP();});var qt={};Le(qt,{nonMaxSuppressionV3Impl:()=>Mx,nonMaxSuppressionV4Impl:()=>$x,nonMaxSuppressionV5Impl:()=>Px,whereImpl:()=>kx});var cP=D(()=>{"use strict";Am();nS();});var uP=D(()=>{"use strict";I$();S$();Pt();_$();CS();Dm();IS();Bx();at();CF();q();z$();Vx();Ux();zx();Hx();Gx();Yi();ES();Wx();Om();or();Cp();Rm();Xr();H$();zn();Vg();ds();Gt();G$();aP();jw();cP();Cw();G();});var Zx={};Le(Zx,{Abs:()=>qa,Acos:()=>Vs,Acosh:()=>Us,AdadeltaOptimizer:()=>Zi,AdagradOptimizer:()=>Qi,AdamOptimizer:()=>Ji,AdamaxOptimizer:()=>ea,Add:()=>Wo,AddN:()=>Ka,All:()=>op,Any:()=>sp,ArgMax:()=>Xa,ArgMin:()=>Ya,Asin:()=>zs,Asinh:()=>Hs,Atan:()=>Gs,Atan2:()=>js,Atanh:()=>Ws,AvgPool:()=>Za,AvgPool3D:()=>Qa,AvgPool3DGrad:()=>xf,AvgPoolGrad:()=>gf,BatchMatMul:()=>Ja,BatchToSpaceND:()=>ec,Bincount:()=>tc,BitwiseAnd:()=>qs,BroadcastArgs:()=>nc,BroadcastTo:()=>V7,Cast:()=>jo,Ceil:()=>Ks,ClipByValue:()=>Xs,Complex:()=>rc,ComplexAbs:()=>oc,Concat:()=>sc,Conv2D:()=>ic,Conv2DBackpropFilter:()=>ac,Conv2DBackpropInput:()=>cc,Conv3D:()=>uc,Conv3DBackpropFilterV2:()=>yf,Conv3DBackpropInputV2:()=>lc,Cos:()=>pc,Cosh:()=>Ys,CropAndResize:()=>mc,Cumprod:()=>dc,Cumsum:()=>fc,DataStorage:()=>Ps,DenseBincount:()=>hc,DepthToSpace:()=>gc,DepthwiseConv2dNative:()=>xc,DepthwiseConv2dNativeBackpropFilter:()=>yc,DepthwiseConv2dNativeBackpropInput:()=>vc,Diag:()=>bc,Dilation2D:()=>Cc,Dilation2DBackpropFilter:()=>Pg,Dilation2DBackpropInput:()=>$g,Draw:()=>ip,ENV:()=>Og,Einsum:()=>wc,Elu:()=>Ic,EluGrad:()=>vf,Environment:()=>rp,Equal:()=>Qs,Erf:()=>Ec,Exp:()=>Tc,ExpandDims:()=>Sc,Expm1:()=>Js,FFT:()=>ap,Fill:()=>Nc,FlipLeftRight:()=>Dc,Floor:()=>ei,FloorDiv:()=>ti,FromPixels:()=>fp,FusedBatchNorm:()=>kc,FusedConv2D:()=>Fi,FusedDepthwiseConv2D:()=>Oi,GatherNd:()=>Ac,GatherV2:()=>_c,Greater:()=>ni,GreaterEqual:()=>ri,IFFT:()=>Rc,Identity:()=>qo,Imag:()=>Fc,IsFinite:()=>oi,IsInf:()=>si,IsNan:()=>ii,KernelBackend:()=>go,LRN:()=>cp,LRNGrad:()=>bf,LeakyRelu:()=>Oc,Less:()=>ai,LessEqual:()=>ci,LinSpace:()=>Mc,Log:()=>$c,Log1p:()=>ui,LogSoftmax:()=>z7,LogicalAnd:()=>li,LogicalNot:()=>pi,LogicalOr:()=>di,LogicalXor:()=>U7,LowerBound:()=>H7,MatrixBandPart:()=>G7,Max:()=>up,MaxPool:()=>Pc,MaxPool3D:()=>Lc,MaxPool3DGrad:()=>wf,MaxPoolGrad:()=>Cf,MaxPoolWithArgmax:()=>Bc,Maximum:()=>fi,Mean:()=>Vc,Min:()=>lp,Minimum:()=>mi,MirrorPad:()=>Uc,Mod:()=>zc,MomentumOptimizer:()=>ta,Multinomial:()=>Hc,Multiply:()=>hi,Neg:()=>pp,NonMaxSuppressionV3:()=>Gc,NonMaxSuppressionV4:()=>Wc,NonMaxSuppressionV5:()=>jc,NotEqual:()=>gi,OP_SCOPE_SUFFIX:()=>Xg,OneHot:()=>Kc,OnesLike:()=>qc,Optimizer:()=>dn,OptimizerConstructors:()=>Hp,Pack:()=>Xc,PadV2:()=>Yc,Pool:()=>W7,Pow:()=>Zc,Prelu:()=>Qc,Prod:()=>Jc,RMSPropOptimizer:()=>na,RaggedGather:()=>eu,RaggedRange:()=>tu,RaggedTensorToTensor:()=>nu,Range:()=>ru,Rank:()=>Bw,Real:()=>ou,RealDiv:()=>Zs,Reciprocal:()=>xi,Reduction:()=>gt,Relu:()=>yi,Relu6:()=>vi,Reshape:()=>su,ResizeBilinear:()=>au,ResizeBilinearGrad:()=>Ef,ResizeNearestNeighbor:()=>iu,ResizeNearestNeighborGrad:()=>If,Reverse:()=>cu,RotateWithOffset:()=>Mu,Round:()=>bi,Rsqrt:()=>Ci,SGDOptimizer:()=>ko,ScatterNd:()=>uu,SearchSorted:()=>pu,Select:()=>du,Selu:()=>wi,Sigmoid:()=>Ti,Sign:()=>Ei,Sin:()=>mu,Sinh:()=>Ii,Slice:()=>fu,Softmax:()=>xu,Softplus:()=>Si,SpaceToBatchND:()=>hu,SparseFillEmptyRows:()=>yu,SparseReshape:()=>vu,SparseSegmentMean:()=>bu,SparseSegmentSum:()=>Cu,SparseToDense:()=>wu,SplitV:()=>gu,Sqrt:()=>Ni,Square:()=>Tf,SquaredDifference:()=>Di,StaticRegexReplace:()=>ki,Step:()=>Ai,StridedSlice:()=>Iu,StringNGrams:()=>Eu,StringSplit:()=>Tu,StringToHashBucketFast:()=>Su,Sub:()=>Nu,Sum:()=>dp,Tan:()=>Du,Tanh:()=>_i,Tensor:()=>Ke,TensorBuffer:()=>Ve,TensorScatterUpdate:()=>lu,Tile:()=>Ko,TopK:()=>ku,Transform:()=>_u,Transpose:()=>Xo,Unique:()=>Au,Unpack:()=>Ru,UnsortedSegmentSum:()=>Fu,UpperBound:()=>j7,Variable:()=>bo,ZerosLike:()=>Ou,_FusedMatMul:()=>Ri,abs:()=>$t,acos:()=>lI,acosh:()=>pI,add:()=>de,addN:()=>dI,all:()=>fI,any:()=>mI,argMax:()=>hI,argMin:()=>gI,asin:()=>xI,asinh:()=>yI,atan:()=>vI,atan2:()=>bI,atanh:()=>CI,avgPool:()=>Vf,avgPool3d:()=>SI,backend:()=>Xw,backend_util:()=>S,basicLSTMCell:()=>DI,batchNorm:()=>rs,batchNorm2d:()=>_I,batchNorm3d:()=>AI,batchNorm4d:()=>RI,batchToSpaceND:()=>zf,bincount:()=>Gf,bitwiseAnd:()=>OI,booleanMaskAsync:()=>tO,broadcastArgs:()=>MI,broadcastTo:()=>os,broadcast_util:()=>Gr,browser:()=>vS,buffer:()=>ue,cast:()=>De,ceil:()=>PI,clipByValue:()=>LI,clone:()=>Dn,complex:()=>vn,concat:()=>Qe,concat1d:()=>BI,concat2d:()=>VI,concat3d:()=>UI,concat4d:()=>zI,conv1d:()=>HI,conv2d:()=>ss,conv2dTranspose:()=>WI,conv3d:()=>jI,conv3dTranspose:()=>qI,copyRegisteredKernels:()=>Z7,cos:()=>KI,cosh:()=>XI,cosineWindow:()=>Up,cumprod:()=>YI,cumsum:()=>ZI,customGrad:()=>ln,denseBincount:()=>QI,deprecationWarn:()=>Z2,depthToSpace:()=>JI,depthwiseConv2d:()=>Yu,device_util:()=>Yo,diag:()=>eE,dilation2d:()=>tE,disableDeprecationWarnings:()=>I9,dispose:()=>ht,disposeVariables:()=>E9,div:()=>Oe,divNoNan:()=>rE,dot:()=>oE,dropout:()=>hO,einsum:()=>as,elu:()=>qf,enableDebugMode:()=>w9,enableProdMode:()=>C9,enclosingPowerOfTwo:()=>Ax,engine:()=>sr,ensureShape:()=>aE,env:()=>M,equal:()=>jf,erf:()=>cE,euclideanNorm:()=>pE,exp:()=>ir,expandDims:()=>vr,expm1:()=>dE,eye:()=>Zf,fft:()=>nl,fill:()=>Hr,findBackend:()=>A9,findBackendFactory:()=>R9,floor:()=>Qf,floorDiv:()=>Pf,fused:()=>Rx,gather:()=>Jf,gatherND:()=>pO,gather_util:()=>bS,getBackend:()=>Kw,getGradient:()=>Bg,getKernel:()=>$u,getKernelsForBackend:()=>Nf,grad:()=>kR,grads:()=>_R,greater:()=>Gi,greaterEqual:()=>em,ifft:()=>Ki,imag:()=>ps,image:()=>n$,inTopKAsync:()=>xO,io:()=>_o,irfft:()=>Cm,isFinite:()=>xE,isInf:()=>yE,isNaN:()=>vE,keep:()=>Cn,kernel_impls:()=>qt,leakyRelu:()=>nm,less:()=>$p,lessEqual:()=>Zu,linalg:()=>r$,linspace:()=>wE,localResponseNormalization:()=>IE,log:()=>To,log1p:()=>om,logSigmoid:()=>SE,logSoftmax:()=>NE,logSumExp:()=>im,logicalAnd:()=>Wi,logicalNot:()=>am,logicalOr:()=>cm,logicalXor:()=>AE,losses:()=>o$,lowerBound:()=>RE,matMul:()=>Be,math:()=>yS,max:()=>Wr,maxPool:()=>um,maxPool3d:()=>OE,maxPoolWithArgmax:()=>ME,maximum:()=>lm,mean:()=>ji,memory:()=>T9,meshgrid:()=>PE,min:()=>Fp,minimum:()=>qi,mirrorPad:()=>LE,mod:()=>BE,moments:()=>VE,movingAverage:()=>rO,mul:()=>ee,multiRNNCell:()=>UE,multinomial:()=>zE,neg:()=>jt,nextFrame:()=>Xx,norm:()=>Hi,notEqual:()=>dm,oneHot:()=>Lp,ones:()=>qr,onesLike:()=>WE,op:()=>E,outerProduct:()=>jE,pad:()=>Kr,pad1d:()=>qE,pad2d:()=>KE,pad3d:()=>XE,pad4d:()=>YE,pool:()=>QE,pow:()=>Eo,prelu:()=>mm,print:()=>$f,prod:()=>eT,profile:()=>S9,raggedGather:()=>tT,raggedRange:()=>nT,raggedTensorToTensor:()=>rT,rand:()=>oT,randomGamma:()=>gT,randomNormal:()=>gm,randomStandardNormal:()=>yT,randomUniform:()=>el,randomUniformInt:()=>vT,range:()=>ms,ready:()=>k9,real:()=>So,reciprocal:()=>bT,registerBackend:()=>Of,registerGradient:()=>K7,registerKernel:()=>hp,relu:()=>hs,relu6:()=>vm,removeBackend:()=>_9,reshape:()=>U,reverse:()=>Gn,reverse1d:()=>wT,reverse2d:()=>IT,reverse3d:()=>ET,reverse4d:()=>TT,rfft:()=>rl,round:()=>bm,rsqrt:()=>NT,scalar:()=>me,scatterND:()=>sO,scatter_util:()=>Nm,searchSorted:()=>Pp,selu:()=>DT,separableConv2d:()=>kT,serialization:()=>uS,setBackend:()=>D9,setPlatform:()=>F9,setdiff1dAsync:()=>_T,sigmoid:()=>zr,sign:()=>AT,signal:()=>t$,sin:()=>RT,sinh:()=>FT,slice:()=>Me,slice1d:()=>OT,slice2d:()=>MT,slice3d:()=>$T,slice4d:()=>PT,slice_util:()=>At,softmax:()=>LT,softplus:()=>sm,spaceToBatchND:()=>fm,sparse:()=>s$,sparseToDense:()=>uO,spectral:()=>e$,split:()=>No,sqrt:()=>wn,square:()=>Lt,squaredDifference:()=>Im,squeeze:()=>ol,stack:()=>pn,step:()=>Tm,stridedSlice:()=>zT,string:()=>i$,sub:()=>ge,sum:()=>He,sumOutType:()=>Pi,tan:()=>HT,tanh:()=>kp,tensor:()=>an,tensor1d:()=>Vt,tensor2d:()=>gs,tensor3d:()=>Sm,tensor4d:()=>WT,tensor5d:()=>jT,tensor6d:()=>qT,tensorScatterUpdate:()=>XT,tensor_util:()=>Uw,test_util:()=>hT,tidy:()=>Ce,tile:()=>ls,time:()=>N9,topk:()=>YT,train:()=>_J,transpose:()=>sl,truncatedNormal:()=>ZT,unique:()=>QT,unregisterGradient:()=>Y7,unregisterKernel:()=>X7,unsortedSegmentSum:()=>JT,unstack:()=>Wn,upcastType:()=>wt,upperBound:()=>eS,util:()=>y,valueAndGrad:()=>AR,valueAndGrads:()=>RR,variable:()=>tS,variableGrads:()=>ux,version_core:()=>U$,where:()=>Hn,whereAsync:()=>km,zeros:()=>ar,zerosLike:()=>Nt});var T=D(()=>{"use strict";TA();c$();uP();a$()});var mue,lG=D(()=>{"use strict";T();mue=M();mue.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})});var Yn,pG,dG=D(()=>{"use strict";Yn=(function(n){return n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",n})(Yn||{});(function(n){let e;(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(pG||(pG={}))});function fG(n,e){let t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};JN[n]=t}function ab(n){return JN[n]}function mG(n){delete JN[n]}var JN,cb=D(()=>{"use strict";JN={}});function b(n,e,t,r,o){let s=e.inputParams[n];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,c=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd,u=a<0?e.inputNames.length+a:a;if(s.type==="tensor")return St(e.inputNames[u],t,r,o);if(s.type==="tensors"){let d=e.inputs.slice(a,c);return e.inputNames.slice(a,c).filter((m,h)=>{var g;return((g=d[h])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(m=>St(m,t,r,o))}let l=St(e.inputNames[u],t,r,o),p=l.dataSync();return s.type==="number"?p[0]:y.toNestedArray(l.shape,p)}let i=e.attrParams[n];return i&&i.value}function St(n,e,t,r){let[o,s]=In(n,t);if(r!=null){let a=r.getHashTableHandleByName(o);if(a!=null)return a}let i=t.currentContextIds.find(a=>!!e[ub(o,a)]);return i!==void 0?e[ub(o,i)][s]:void 0}function eD(n,e,t){return e[ub(n,t.currentContextId)]}function eo(n,e){let[t,r,o]=In(n,e);return[ub(t,e&&e.currentContextId),r,o]}function ub(n,e){return e?`${n}-${e}`:n}function In(n,e){if(n==="")return["",0,void 0];let t=e!=null&&e.parseNodeNameCache!=null;if(t){let s=e.parseNodeNameCache.get(n);if(s!=null)return s}let r=n.split(":"),o;if(r.length===1)o=[n,0,void 0];else{let s=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);o=[s,a,i]}return t&&e.parseNodeNameCache.set(n,o),o}function rh(n,e,t){let r=b("pad",n,e,t);if(r==="explicit"){r=b("explicitPaddings",n,e,t);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=r[s*2],o[s][1]=r[s*2+1];return o}return r}function to(n){return n.kept?n:Dn(n)}var vt=D(()=>{"use strict";T();});var tD={};Le(tD,{json:()=>gue});var gue,hG=D(()=>{"use strict";gue=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var nD={};Le(nD,{json:()=>xue});var xue,gG=D(()=>{"use strict";xue=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var rD={};Le(rD,{json:()=>yue});var yue,xG=D(()=>{"use strict";yue=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]});var oD={};Le(oD,{json:()=>vue});var vue,yG=D(()=>{"use strict";vue=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]});var sD={};Le(sD,{json:()=>bue});var bue,vG=D(()=>{"use strict";bue=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});var iD={};Le(iD,{json:()=>Cue});var Cue,bG=D(()=>{"use strict";Cue=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var aD={};Le(aD,{json:()=>wue});var wue,CG=D(()=>{"use strict";wue=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]});var cD={};Le(cD,{json:()=>Iue});var Iue,wG=D(()=>{"use strict";Iue=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]});var uD={};Le(uD,{json:()=>Eue});var Eue,IG=D(()=>{"use strict";Eue=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]});var lD={};Le(lD,{json:()=>Tue});var Tue,EG=D(()=>{"use strict";Tue=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]});var pD={};Le(pD,{json:()=>Sue});var Sue,TG=D(()=>{"use strict";Sue=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}]});var dD={};Le(dD,{json:()=>Nue});var Nue,SG=D(()=>{"use strict";Nue=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}]});var fD={};Le(fD,{json:()=>Due});var Due,NG=D(()=>{"use strict";Due=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}]});var mD={};Le(mD,{json:()=>kue});var kue,DG=D(()=>{"use strict";kue=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});var hD={};Le(hD,{json:()=>_ue});var _ue,kG=D(()=>{"use strict";_ue=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]});var gD={};Le(gD,{json:()=>Aue});var Aue,_G=D(()=>{"use strict";Aue=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]});var xD={};Le(xD,{json:()=>Rue});var Rue,AG=D(()=>{"use strict";Rue=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});var yD={};Le(yD,{json:()=>Fue});var Fue,RG=D(()=>{"use strict";Fue=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]});var vD={};Le(vD,{json:()=>Oue});var Oue,FG=D(()=>{"use strict";Oue=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]});function Mue(n){let e=M().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function MG(n,e){let t=Array.isArray(n)?String.fromCharCode.apply(null,n):Mue(n);return e?t:t.toLowerCase()}function lb(n,e,t,r=!1){let o=n[e];return o!=null?MG(o.s,r):t}function pb(n,e,t){let r=n[e];return r?r.b:t}function db(n,e,t){let r=n[e]||{},o=r.i!=null?r.i:r.f!=null?r.f:t;return typeof o=="number"?o:parseInt(o,10)}function bD(n){switch(typeof n=="string"&&(n=Yn[n]),n){case Yn.DT_FLOAT:case Yn.DT_HALF:return"float32";case Yn.DT_INT32:case Yn.DT_INT64:case Yn.DT_INT8:case Yn.DT_UINT8:return"int32";case Yn.DT_BOOL:return"bool";case Yn.DT_DOUBLE:return"float32";case Yn.DT_STRING:return"string";case Yn.DT_COMPLEX64:case Yn.DT_COMPLEX128:return"complex64";default:return null}}function OG(n,e,t){let r=n[e];return r&&r.func?r.func.name:t}function fb(n,e,t){let r=n[e];return r&&r.type?bD(r.type):t}function mb(n,e,t){let r=n[e];return r&&r.list&&r.list.type?r.list.type.map(o=>bD(o)):t}function $G(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function hb(n,e,t){let r=n[e];return r&&r.shape?$G(r.shape):t}function gb(n,e,t){let r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):t}function xb(n,e,t,r=!1){let o=n[e];return o&&o.list&&o.list.s?o.list.s.map(s=>MG(s,r)):t}function yb(n,e,t){let r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(o=>$G(o)):t}function vb(n,e,t){let r=n[e];return r&&r.list&&r.list.b?r.list.b:t}var oh,CD=D(()=>{"use strict";T();dG();cb();vt();hG();gG();xG();yG();vG();bG();CG();wG();IG();EG();TG();SG();NG();DG();kG();_G();AG();RG();FG();oh=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[tD,nD,rD,oD,sD,iD,aD,cD,uD,lD,pD,dD,fD,mD,hD,gD,xD,yD,vD],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,o)=>(r[o.tfOpName]=o,r),{})}transformGraph(e,t={}){let r=e.node,o=[],s=[],i=[],a=r.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&i.push(h[g.name]),h),{}),c=[],u=[],l={},p={};t!=null&&(l=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let d=Object.keys(a);d.forEach(h=>{let g=a[h];g.inputNames.forEach((x,v)=>{let[w,,I]=eo(x),_=a[w];if(_.outputs!=null){let A=_.outputs.indexOf(I);if(A!==-1){let R=`${w}:${A}`;g.inputNames[v]=R}}g.inputs.push(_),_.children.push(g)})}),Object.keys(p).length===0?d.forEach(h=>{let g=a[h];g.children.length===0&&u.push(g)}):Object.keys(p).forEach(h=>{let[g]=eo(h),x=a[g];x!=null&&(x.signatureKey=p[h],u.push(x))}),Object.keys(l).length>0?Object.keys(l).forEach(h=>{let[g]=eo(h),x=a[g];x&&(x.signatureKey=l[h],c.push(x))}):c=o;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let m={nodes:a,inputs:c,outputs:u,weights:s,placeholders:o,signature:t,functions:f};return i.length>0&&(m.initNodes=i),m}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){let t=ab(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=lb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=lb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=xb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=xb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=db(e.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=db(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=gb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=gb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=pb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=pb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=vb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=vb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=hb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=hb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=yb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=yb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=fb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=fb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=mb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=mb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=OG(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=OG(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return o[s.name]={value:a,type:i},o},{})),r}mapFunction(e){let t=e.nodeDef,r=[],o=[],s={};t!=null&&(s=t.reduce((p,d)=>(p[d.name]=this.mapNode(d),d.op==="Const"&&o.push(p[d.name]),p),{}));let i=[],a=[];e.signature.inputArg.forEach(p=>{let[d]=eo(p.name),f={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:bD(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,i.push(f),s[d]=f}),Object.keys(s).forEach(p=>{let d=s[p];d.inputNames.forEach((f,m)=>{let[h,,g]=eo(f),x=s[h];if(x.outputs!=null){let v=x.outputs.indexOf(g);if(v!==-1){let w=`${h}:${v}`;d.inputNames[m]=w}}d.inputs.push(x),x.children.push(d)})});let u=e.ret;e.signature.outputArg.forEach(p=>{let[d,f]=eo(u[p.name]),m=s[d];m!=null&&(m.defaultOutput=f,a.push(m))});let l=this.mapArgsToSignature(e);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:r,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}});var bb,PG=D(()=>{"use strict";vt();CD();bb=class{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(o=>this.getInput(o)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(e){return St(e,this.tensorMap,this.context)}getAttr(e,t){let r=this.node.rawAttrs[e];if(r.tensor!=null)return St(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return db(this.node.rawAttrs,e,t);if(r.s!=null)return lb(this.node.rawAttrs,e,t);if(r.b!=null)return pb(this.node.rawAttrs,e,t);if(r.shape!=null)return hb(this.node.rawAttrs,e,t);if(r.type!=null)return fb(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return gb(this.node.rawAttrs,e,t);if(r.list.s!=null)return xb(this.node.rawAttrs,e,t);if(r.list.shape!=null)return yb(this.node.rawAttrs,e,t);if(r.list.b!=null)return vb(this.node.rawAttrs,e,t);if(r.list.type!=null)return mb(this.node.rawAttrs,e,t)}return t}}});var Ue={};Le(Ue,{OP_SCOPE_SUFFIX:()=>Xg,abs:()=>$t,acos:()=>lI,acosh:()=>pI,add:()=>de,addN:()=>dI,all:()=>fI,any:()=>mI,argMax:()=>hI,argMin:()=>gI,asin:()=>xI,asinh:()=>yI,atan:()=>vI,atan2:()=>bI,atanh:()=>CI,avgPool:()=>Vf,avgPool3d:()=>SI,basicLSTMCell:()=>DI,batchNorm:()=>rs,batchNorm2d:()=>_I,batchNorm3d:()=>AI,batchNorm4d:()=>RI,batchToSpaceND:()=>zf,bincount:()=>Gf,bitwiseAnd:()=>OI,booleanMaskAsync:()=>tO,broadcastArgs:()=>MI,broadcastTo:()=>os,buffer:()=>ue,cast:()=>De,ceil:()=>PI,clipByValue:()=>LI,clone:()=>Dn,complex:()=>vn,concat:()=>Qe,concat1d:()=>BI,concat2d:()=>VI,concat3d:()=>UI,concat4d:()=>zI,conv1d:()=>HI,conv2d:()=>ss,conv2dTranspose:()=>WI,conv3d:()=>jI,conv3dTranspose:()=>qI,cos:()=>KI,cosh:()=>XI,cosineWindow:()=>Up,cumprod:()=>YI,cumsum:()=>ZI,denseBincount:()=>QI,depthToSpace:()=>JI,depthwiseConv2d:()=>Yu,diag:()=>eE,dilation2d:()=>tE,div:()=>Oe,divNoNan:()=>rE,dot:()=>oE,dropout:()=>hO,einsum:()=>as,elu:()=>qf,enclosingPowerOfTwo:()=>Ax,ensureShape:()=>aE,equal:()=>jf,erf:()=>cE,euclideanNorm:()=>pE,exp:()=>ir,expandDims:()=>vr,expm1:()=>dE,eye:()=>Zf,fft:()=>nl,fill:()=>Hr,floor:()=>Qf,floorDiv:()=>Pf,fused:()=>Rx,gather:()=>Jf,gatherND:()=>pO,greater:()=>Gi,greaterEqual:()=>em,ifft:()=>Ki,imag:()=>ps,image:()=>n$,inTopKAsync:()=>xO,irfft:()=>Cm,isFinite:()=>xE,isInf:()=>yE,isNaN:()=>vE,leakyRelu:()=>nm,less:()=>$p,lessEqual:()=>Zu,linalg:()=>r$,linspace:()=>wE,localResponseNormalization:()=>IE,log:()=>To,log1p:()=>om,logSigmoid:()=>SE,logSoftmax:()=>NE,logSumExp:()=>im,logicalAnd:()=>Wi,logicalNot:()=>am,logicalOr:()=>cm,logicalXor:()=>AE,losses:()=>o$,lowerBound:()=>RE,matMul:()=>Be,max:()=>Wr,maxPool:()=>um,maxPool3d:()=>OE,maxPoolWithArgmax:()=>ME,maximum:()=>lm,mean:()=>ji,meshgrid:()=>PE,min:()=>Fp,minimum:()=>qi,mirrorPad:()=>LE,mod:()=>BE,moments:()=>VE,movingAverage:()=>rO,mul:()=>ee,multiRNNCell:()=>UE,multinomial:()=>zE,neg:()=>jt,norm:()=>Hi,notEqual:()=>dm,oneHot:()=>Lp,ones:()=>qr,onesLike:()=>WE,op:()=>E,outerProduct:()=>jE,pad:()=>Kr,pad1d:()=>qE,pad2d:()=>KE,pad3d:()=>XE,pad4d:()=>YE,pool:()=>QE,pow:()=>Eo,prelu:()=>mm,print:()=>$f,prod:()=>eT,raggedGather:()=>tT,raggedRange:()=>nT,raggedTensorToTensor:()=>rT,rand:()=>oT,randomGamma:()=>gT,randomNormal:()=>gm,randomStandardNormal:()=>yT,randomUniform:()=>el,randomUniformInt:()=>vT,range:()=>ms,real:()=>So,reciprocal:()=>bT,relu:()=>hs,relu6:()=>vm,reshape:()=>U,reverse:()=>Gn,reverse1d:()=>wT,reverse2d:()=>IT,reverse3d:()=>ET,reverse4d:()=>TT,rfft:()=>rl,round:()=>bm,rsqrt:()=>NT,scalar:()=>me,scatterND:()=>sO,searchSorted:()=>Pp,selu:()=>DT,separableConv2d:()=>kT,setdiff1dAsync:()=>_T,sigmoid:()=>zr,sign:()=>AT,signal:()=>t$,sin:()=>RT,sinh:()=>FT,slice:()=>Me,slice1d:()=>OT,slice2d:()=>MT,slice3d:()=>$T,slice4d:()=>PT,softmax:()=>LT,softplus:()=>sm,spaceToBatchND:()=>fm,sparse:()=>s$,sparseToDense:()=>uO,spectral:()=>e$,split:()=>No,sqrt:()=>wn,square:()=>Lt,squaredDifference:()=>Im,squeeze:()=>ol,stack:()=>pn,step:()=>Tm,stridedSlice:()=>zT,string:()=>i$,sub:()=>ge,sum:()=>He,tan:()=>HT,tanh:()=>kp,tensor:()=>an,tensor1d:()=>Vt,tensor2d:()=>gs,tensor3d:()=>Sm,tensor4d:()=>WT,tensor5d:()=>jT,tensor6d:()=>qT,tensorScatterUpdate:()=>XT,tile:()=>ls,topk:()=>YT,transpose:()=>sl,truncatedNormal:()=>ZT,unique:()=>QT,unsortedSegmentSum:()=>JT,unstack:()=>Wn,upperBound:()=>eS,variable:()=>tS,where:()=>Hn,whereAsync:()=>km,zeros:()=>ar,zerosLike:()=>Nt});var zt=D(()=>{"use strict";Rm();});var LG,BG=D(()=>{"use strict";zt();vt();LG=(n,e,t,r=Ue)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(b("a",n,e,t),b("b",n,e,t))];case"AddN":return[r.addN(b("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(b("a",n,e,t),b("b",n,e,t))];case"Mul":return[r.mul(b("a",n,e,t),b("b",n,e,t))];case"RealDiv":case"Div":return[r.div(b("a",n,e,t),b("b",n,e,t))];case"DivNoNan":return[r.divNoNan(b("a",n,e,t),b("b",n,e,t))];case"FloorDiv":return[r.floorDiv(b("a",n,e,t),b("b",n,e,t))];case"Sub":return[r.sub(b("a",n,e,t),b("b",n,e,t))];case"Minimum":return[r.minimum(b("a",n,e,t),b("b",n,e,t))];case"Maximum":return[r.maximum(b("a",n,e,t),b("b",n,e,t))];case"Pow":return[r.pow(b("a",n,e,t),b("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(b("a",n,e,t),b("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var VG,UG=D(()=>{"use strict";zt();vt();VG=(n,e,t,r=Ue)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(b("x",n,e,t))];case"Acos":return[r.acos(b("x",n,e,t))];case"Acosh":return[r.acosh(b("x",n,e,t))];case"Asin":return[r.asin(b("x",n,e,t))];case"Asinh":return[r.asinh(b("x",n,e,t))];case"Atan":return[r.atan(b("x",n,e,t))];case"Atan2":return[r.atan2(b("x",n,e,t),b("y",n,e,t))];case"Atanh":return[r.atanh(b("x",n,e,t))];case"Ceil":return[r.ceil(b("x",n,e,t))];case"Complex":return[r.complex(b("real",n,e,t),b("imag",n,e,t))];case"Cos":return[r.cos(b("x",n,e,t))];case"Cosh":return[r.cosh(b("x",n,e,t))];case"Elu":return[r.elu(b("x",n,e,t))];case"Erf":return[r.erf(b("x",n,e,t))];case"Exp":return[r.exp(b("x",n,e,t))];case"Expm1":return[r.expm1(b("x",n,e,t))];case"Floor":return[r.floor(b("x",n,e,t))];case"Log":return[r.log(b("x",n,e,t))];case"Log1p":return[r.log1p(b("x",n,e,t))];case"Imag":return[r.imag(b("x",n,e,t))];case"Neg":return[r.neg(b("x",n,e,t))];case"Reciprocal":return[r.reciprocal(b("x",n,e,t))];case"Real":return[r.real(b("x",n,e,t))];case"Relu":return[r.relu(b("x",n,e,t))];case"Round":return[r.round(b("x",n,e,t))];case"Selu":return[r.selu(b("x",n,e,t))];case"Sigmoid":return[r.sigmoid(b("x",n,e,t))];case"Sin":return[r.sin(b("x",n,e,t))];case"Sign":return[r.sign(b("x",n,e,t))];case"Sinh":return[r.sinh(b("x",n,e,t))];case"Softplus":return[r.softplus(b("x",n,e,t))];case"Sqrt":return[r.sqrt(b("x",n,e,t))];case"Square":return[r.square(b("x",n,e,t))];case"Tanh":return[r.tanh(b("x",n,e,t))];case"Tan":return[r.tan(b("x",n,e,t))];case"ClipByValue":return[r.clipByValue(b("x",n,e,t),b("clipValueMin",n,e,t),b("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(b("x",n,e,t))];case"Rsqrt":return[r.rsqrt(St(n.inputNames[0],e,t))];case"LeakyRelu":return[r.leakyRelu(b("x",n,e,t),b("alpha",n,e,t))];case"Prelu":return[r.prelu(b("x",n,e,t),b("alpha",n,e,t))];case"IsNan":return[r.isNaN(St(n.inputNames[0],e,t))];case"IsInf":return[r.isInf(St(n.inputNames[0],e,t))];case"IsFinite":return[r.isFinite(St(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});function Zn(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){y.assert(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){let o=n[r],s=e[r];y.assert(o<0||s<0||o===s,()=>t+` Shapes ${n} and ${e} must match`)}}}function zG(n){return!(typeof n=="number"||n.some(e=>e<0))}function hd(n,e,t){let r=Cb(n,t),o=!zG(r);if(o&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(o&&e.forEach(s=>{r=Cb(s.shape,r)}),!zG(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Cb(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);let t=[];for(let r=0;r<n.length;++r){let o=n[r],s=e[r];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=o>=0?o:s}return t}var wD=D(()=>{"use strict";T();});var wb,HG=D(()=>{"use strict";T();wD();wb=class{constructor(e,t,r,o,s,i,a){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=me(0),Cn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Zn(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,Cn(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,o)=>this.write(r,t[o]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let o=0;o<this.size();o++)e.push(o)}if(e.length===0)return an([],[0].concat(this.elementShape));let r=this.readMany(e);return Zn(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),pn(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return an([],[0].concat(this.elementShape));let t=[];for(let o=0;o<this.size();o++)t.push(o);let r=this.readMany(t);return Zn(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Qe(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Wn(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0,o=e.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=r===0?0:t.size/r,i=[];Ce(()=>{t=U(t,[1,r,s]);for(let c=0;c<e.length;++c){let l=[0,c===0?0:o[c-1],0],p=[1,e[c],s];i[c]=U(Me(t,l,p),this.elementShape)}return i});let a=[];for(let c=0;c<e.length;c++)a[c]=c;this.writeMany(a,i)}}});function GG(n,e,t){let r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);let o=n.shape.slice(1);Zn(o,e,"TensorList shape mismatch: ");let s=Wn(n);return new gd(s,e,r)}function WG(n,e,t,r){return new gd([],n,e,r)}function jG(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);let o=Math.max(...e);if(r!=null&&r!==-1&&o>=r)throw new Error(`Max index must be < array size (${o}  vs. ${r})`);let s=new gd([],t,n.dtype,r),i=Wn(n,0);return e.forEach((a,c)=>{s.setItem(a,i[c])}),s}function qG(n,e,t){let r=0,o=e.map(l=>(r+=l,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);let s=n.shape.slice(1),i=Cb(s,t),a=r===0?0:n.size/r,c=Ce(()=>{let l=[];n=U(n,[1,r,a]);for(let p=0;p<e.length;++p){let f=[0,p===0?0:o[p-1],0],m=[1,e[p],a];l[p]=U(Me(n,f,m),i)}return n.dispose(),l}),u=new gd([],t,n.dtype,e.length);for(let l=0;l<c.length;l++)u.setItem(l,c[l]);return u}var gd,KG=D(()=>{"use strict";T();wD();gd=class n{get id(){return this.idTensor.id}constructor(e,t,r,o=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e?.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);Zn(t,s.shape,"TensorList shape mismatch: "),Cn(s)}),this.idTensor=me(0),this.maxNumElements=o,Cn(this.idTensor)}copy(){return new n([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Zn(e,this.elementShape,"TensorList shape mismatch: ");let o=hd(this.elementShape,this.tensors,e);return Ce(()=>{let s=this.tensors.map(i=>U(i,o));return pn(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=hd(this.elementShape,this.tensors,e),o=this.tensors.pop();return o.kept=!1,Zn(o.shape,e,"TensorList shape mismatch: "),U(o,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Zn(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Cn(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new n([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Zn(this.tensors[e].shape,t,"TensorList shape mismatch: ");let o=hd(this.elementShape,this.tensors,t);return U(this.tensors[e],o)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Zn(this.elementShape,t.shape,"TensorList shape mismatch: "),Cn(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Zn(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());let o=hd(this.elementShape,this.tensors,r);return e.length===0?an([],[0].concat(o)):Ce(()=>{let s=e.map(i=>U(this.tensors[i],o));return pn(s,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Zn(this.elementShape,t,"TensorList shape mismatch: ");let r=hd(this.elementShape,this.tensors,t);return this.size()===0?an([],[0].concat(r)):Ce(()=>{let o=this.tensors.map(s=>U(s,r));return Qe(o,0)})}}});var XG,YG=D(()=>{"use strict";T();HG();KG();vt();XG=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{let r=b("thenBranch",n,e,t),o=b("elseBranch",n,e,t),s=b("cond",n,e,t),i=b("args",n,e,t);return(await s.data())[0]?t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[o].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{let r=b("body",n,e,t),o=b("cond",n,e,t),s=b("args",n,e,t),i=await t.functionMap[o].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),a=s.map(l=>l.id),c=await i[0].data();i.forEach(l=>{!l.kept&&a.indexOf(l.id)===-1&&l.dispose()});let u=s;for(;c[0];){let l=u;u=await t.functionMap[r].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);let p=u.map(f=>f.id);l.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let d=await t.functionMap[o].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);c=await d[0].data(),d.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return u}case"LoopCond":{let r=b("pred",n,e,t);return[to(r)]}case"Switch":{let r=b("pred",n,e,t),o=b("data",n,e,t);return o.kept||(o=to(o)),(await r.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let r=n.inputNames.find(o=>St(o,e,t)!==void 0);if(r){let o=St(r,e,t);return[to(o)]}return}case"Enter":{let r=b("frameName",n,e,t),o=b("tensor",n,e,t);return t.enterFrame(r),[to(o)]}case"Exit":{let r=b("tensor",n,e,t);return t.exitFrame(),[to(r)]}case"NextIteration":{let r=b("tensor",n,e,t);return t.nextIteration(),[to(r)]}case"TensorArrayV3":{let r=b("size",n,e,t),o=b("dtype",n,e,t),s=b("elementShape",n,e,t),i=b("dynamicSize",n,e,t),a=b("clearAfterRead",n,e,t),c=b("identicalElementShapes",n,e,t),u=b("name",n,e,t),l=new wb(u,o,r,s,c,i,a);return t.addTensorArray(l),[l.idTensor,me(1)]}case"TensorArrayWriteV3":{let r=b("tensorArrayId",n,e,t),o=b("index",n,e,t),s=b("tensor",n,e,t),i=t.getTensorArray(r.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let r=b("tensorArrayId",n,e,t),o=b("index",n,e,t);return[t.getTensorArray(r.id).read(o)]}case"TensorArrayGatherV3":{let r=b("tensorArrayId",n,e,t),o=b("indices",n,e,t),s=b("dtype",n,e,t);return[t.getTensorArray(r.id).gather(o,s)]}case"TensorArrayScatterV3":{let r=b("tensorArrayId",n,e,t),o=b("indices",n,e,t),s=b("tensor",n,e,t),i=t.getTensorArray(r.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=b("tensorArrayId",n,e,t),o=t.getTensorArray(r.id),s=b("dtype",n,e,t);return[o.concat(s)]}case"TensorArraySplitV3":{let r=b("tensorArrayId",n,e,t),o=b("tensor",n,e,t),s=b("lengths",n,e,t),i=t.getTensorArray(r.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let r=b("tensorArrayId",n,e,t),o=t.getTensorArray(r.id);return[me(o.size(),"int32")]}case"TensorArrayCloseV3":{let r=b("tensorArrayId",n,e,t),o=t.getTensorArray(r.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let r=b("tensorListId",n,e,t),o=b("index",n,e,t),s=b("tensor",n,e,t),i=t.getTensorList(r.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let r=b("tensorListId",n,e,t),o=b("index",n,e,t),s=b("elementShape",n,e,t),i=b("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=b("indices",n,e,t),o=b("tensor",n,e,t),s=b("elementShape",n,e,t),i=b("numElements",n,e,t),a=jG(o,r,s,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=b("elementShape",n,e,t),o=b("elementDType",n,e,t),s;n.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=b(s,n,e,t),a=n.op==="TensorListReserve"?-1:i,c=WG(r,o,i,a);return t.addTensorList(c),[c.idTensor]}case"TensorListGather":{let r=b("tensorListId",n,e,t),o=b("indices",n,e,t),s=b("elementShape",n,e,t),i=b("elementDType",n,e,t);return[t.getTensorList(r.id).gather(o,i,s)]}case"TensorListStack":{let r=b("tensorListId",n,e,t),o=b("elementShape",n,e,t),s=b("elementDType",n,e,t),i=b("numElements",n,e,t);return[t.getTensorList(r.id).stack(o,s,i)]}case"TensorListFromTensor":{let r=b("tensor",n,e,t),o=b("elementShape",n,e,t),s=b("elementDType",n,e,t),i=GG(r,o,s);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=b("tensorListId",n,e,t),o=t.getTensorList(r.id),s=b("dtype",n,e,t),i=b("elementShape",n,e,t);return[o.concat(s,i)]}case"TensorListPushBack":{let r=b("tensorListId",n,e,t),o=b("tensor",n,e,t),s=t.getTensorList(r.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let r=b("tensorListId",n,e,t),o=b("elementShape",n,e,t),s=b("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(o,s)]}case"TensorListSplit":{let r=b("tensor",n,e,t),o=b("elementShape",n,e,t),s=b("lengths",n,e,t),i=qG(r,s,o);return t.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=b("tensorListId",n,e,t),o=t.getTensorList(r.id);return[me(o.size(),"int32")]}case"TensorListResize":{let r=b("tensorListId",n,e,t),o=b("size",n,e,t),i=t.getTensorList(r.id).resize(o);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});function ZG(n,e,t){let[r,o]=b("fusedOps",n,e,t),s=r==="biasadd",i=!s,a=o==="prelu",c=r==="fusedbatchnorm",u=b("numArgs",n,e,t);if(s){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let l=b("strides",n,e,t),p=rh(n,e,t),d=b("dataFormat",n,e,t).toUpperCase(),f=b("dilations",n,e,t),[m,h]=b("args",n,e,t);i&&(h=m,m=void 0);let g=b("leakyreluAlpha",n,e,t);return{stride:l,pad:p,dataFormat:d,dilations:f,biasArg:m,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var QG,JG=D(()=>{"use strict";zt();vt();QG=(n,e,t,r=Ue)=>{switch(n.op){case"Conv1D":{let o=b("stride",n,e,t),s=b("pad",n,e,t),i=b("dataFormat",n,e,t).toUpperCase(),a=b("dilation",n,e,t);return[r.conv1d(b("x",n,e,t),b("filter",n,e,t),o,s,i,a)]}case"Conv2D":{let o=b("strides",n,e,t),s=rh(n,e,t),i=b("dataFormat",n,e,t).toUpperCase(),a=b("dilations",n,e,t);return[r.conv2d(b("x",n,e,t),b("filter",n,e,t),[o[1],o[2]],s,i,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:c,preluArg:u,activationFunc:l,leakyreluAlpha:p}=ZG(n,e,t);return[r.fused.conv2d({x:b("x",n,e,t),filter:b("filter",n,e,t),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:c,activation:l,preluActivationWeights:u,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:c,preluArg:u,activationFunc:l,leakyreluAlpha:p}=ZG(n,e,t);return[r.fused.depthwiseConv2d({x:b("x",n,e,t),filter:b("filter",n,e,t),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:c,activation:l,preluActivationWeights:u,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=b("outputShape",n,e,t),s=b("strides",n,e,t),i=rh(n,e,t);return[r.conv2dTranspose(b("x",n,e,t),b("filter",n,e,t),o,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=b("strides",n,e,t),s=rh(n,e,t),i=b("dilations",n,e,t),a=b("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(b("input",n,e,t),b("filter",n,e,t),[o[1],o[2]],s,a,[i[1],i[2]])]}case"Conv3D":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("dataFormat",n,e,t).toUpperCase(),a=b("dilations",n,e,t);return[r.conv3d(b("x",n,e,t),b("filter",n,e,t),[o[1],o[2],o[3]],s,i,[a[1],a[2],a[3]])]}case"AvgPool":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.avgPool(b("x",n,e,t),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.maxPool(b("x",n,e,t),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("kernelSize",n,e,t),a=b("includeBatchInIndex",n,e,t),{result:c,indexes:u}=r.maxPoolWithArgmax(b("x",n,e,t),[i[1],i[2]],[o[1],o[2]],s,a);return[c,u]}case"AvgPool3D":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.avgPool3d(b("x",n,e,t),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.maxPool3d(b("x",n,e,t),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("dilations",n,e,t),a=o[1],c=o[2],u=i[1],l=i[2];return[r.dilation2d(b("x",n,e,t),b("filter",n,e,t),[a,c],s,[u,l],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var eW,tW=D(()=>{"use strict";zt();vt();eW=(n,e,t,r=Ue)=>{switch(n.op){case"Fill":{let o=b("shape",n,e,t),s=b("dtype",n,e,t),i=b("value",n,e,t);return[r.fill(o,i,s)]}case"LinSpace":{let o=b("start",n,e,t),s=b("stop",n,e,t),i=b("num",n,e,t);return[r.linspace(o,s,i)]}case"Multinomial":{let o=b("logits",n,e,t),s=b("numSamples",n,e,t),i=b("seed",n,e,t);return[r.multinomial(o,s,i)]}case"OneHot":{let o=b("indices",n,e,t),s=b("depth",n,e,t),i=b("onValue",n,e,t),a=b("offValue",n,e,t),c=b("dtype",n,e,t);return[r.oneHot(o,s,i,a,c)]}case"Ones":return[r.ones(b("shape",n,e,t),b("dtype",n,e,t))];case"OnesLike":return[r.onesLike(b("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(b("shape",n,e,t),b("dtype",n,e,t),b("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(b("shape",n,e,t),b("minval",n,e,t),b("maxval",n,e,t),b("dtype",n,e,t))];case"RandomUniformInt":return[r.randomUniformInt(b("shape",n,e,t),b("minval",n,e,t),b("maxval",n,e,t),b("seed",n,e,t))];case"Range":{let o=b("start",n,e,t),s=b("stop",n,e,t),i=b("step",n,e,t);return[r.range(o,s,i,b("dtype",n,e,t))]}case"TruncatedNormal":{let o=b("shape",n,e,t),s=b("mean",n,e,t),i=b("stdDev",n,e,t),a=b("seed",n,e,t);return[r.truncatedNormal(o,s,i,b("dtype",n,e,t),a)]}case"Zeros":return[r.zeros(b("shape",n,e,t),b("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});function ID(n,e,t){let r=b("boxes",n,e,t),o=b("scores",n,e,t),s=b("maxOutputSize",n,e,t),i=b("iouThreshold",n,e,t),a=b("scoreThreshold",n,e,t),c=b("softNmsSigma",n,e,t);return{boxes:r,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:c}}var nW,rW=D(()=>{"use strict";zt();vt();nW=async(n,e,t,r,o=Ue)=>{switch(n.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:u,softNmsSigma:l}=ID(n,e,t),p=await o.image.nonMaxSuppressionWithScoreAsync(s,i,a,c,u,l);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:u}=ID(n,e,t),l=b("padToMaxOutputSize",n,e,t),p=await o.image.nonMaxSuppressionPaddedAsync(s,i,a,c,u,l);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:u}=ID(n,e,t);return[await o.image.nonMaxSuppressionAsync(s,i,a,c,u)]}case"Where":{let s=o.cast(b("condition",n,e,t),"bool"),i=[await o.whereAsync(s)];return s.dispose(),i}case"ListDiff":return o.setdiff1dAsync(b("x",n,e,t),b("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var oW,sW=D(()=>{"use strict";zt();vt();oW=(n,e,t,r=Ue)=>{switch(n.op){case"LowerBound":{let o=b("sortedSequence",n,e,t),s=b("values",n,e,t);return[r.lowerBound(o,s)]}case"TopKV2":{let o=b("x",n,e,t),s=b("k",n,e,t),i=b("sorted",n,e,t),a=r.topk(o,s,i);return[a.values,a.indices]}case"UpperBound":{let o=b("sortedSequence",n,e,t),s=b("values",n,e,t);return[r.upperBound(o,s)]}case"Unique":{let o=b("x",n,e,t),s=r.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=b("x",n,e,t),s=b("axis",n,e,t),i=r.unique(o,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var iW,aW=D(()=>{"use strict";zt();vt();iW=(n,e,t,r=Ue)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":let o=b("default",n,e,t);return[St(n.name,e,t)||o];case"Placeholder":return[St(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=b("x",n,e,t);return[to(l)]}case"IdentityN":return b("x",n,e,t).map(l=>to(l));case"Snapshot":let s=b("x",n,e,t);return[to(s)];case"Shape":return[r.tensor1d(b("x",n,e,t).shape,"int32")];case"ShapeN":return b("x",n,e,t).map(l=>r.tensor1d(l.shape));case"Size":return[r.scalar(b("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(b("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=b("x",n,e,t),a=b("data",n,e,t),c=b("message",n,e,t),u=b("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(c);for(let l=0;l<a.length;l++)console.log(Array.prototype.slice.call(a[l].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var Ib,cW=D(()=>{"use strict";T();zt();Ib=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=me(0),this.tensorMap=new Map,Cn(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return me(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let r=await e.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),Ce(()=>{let o=Wn(t),s=r.length,i=o.length;y.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let c=r[a],u=o[a];Cn(u),this.tensorMap.set(c,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let r=await e.data();return Ce(()=>{let o=[];for(let s=0;s<r.length;s++){let i=r[s],a=this.findWithDefault(i,t);o.push(a)}return pn(o)})}findWithDefault(e,t){let r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}});var uW,lW=D(()=>{"use strict";cW();vt();uW=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{let o=r.getHashTableHandleByName(n.name);if(o!=null)return[o];{let s=b("keyDType",n,e,t),i=b("valueDType",n,e,t),a=new Ib(s,i);return r.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let o=b("tableHandle",n,e,t,r),s=b("keys",n,e,t),i=b("values",n,e,t);return[await r.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=b("tableHandle",n,e,t,r),s=b("keys",n,e,t),i=b("defaultValue",n,e,t);return[await r.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=b("tableHandle",n,e,t,r);return[r.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var pW,dW=D(()=>{"use strict";zt();vt();pW=(n,e,t,r=Ue)=>{switch(n.op){case"ResizeBilinear":{let o=b("images",n,e,t),s=b("size",n,e,t),i=b("alignCorners",n,e,t),a=b("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(o,[s[0],s[1]],i,a)]}case"ResizeNearestNeighbor":{let o=b("images",n,e,t),s=b("size",n,e,t),i=b("alignCorners",n,e,t),a=b("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(o,[s[0],s[1]],i,a)]}case"CropAndResize":{let o=b("image",n,e,t),s=b("boxes",n,e,t),i=b("boxInd",n,e,t),a=b("cropSize",n,e,t),c=b("method",n,e,t),u=b("extrapolationValue",n,e,t);return[r.image.cropAndResize(o,s,i,a,c,u)]}case"ImageProjectiveTransformV3":{let o=b("images",n,e,t),s=b("transforms",n,e,t),i=b("outputShape",n,e,t),a=b("fillValue",n,e,t),c=b("interpolation",n,e,t),u=b("fillMode",n,e,t);return[r.image.transform(o,s,c.toLowerCase(),u.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var fW,mW=D(()=>{"use strict";zt();vt();fW=(n,e,t,r=Ue)=>{switch(n.op){case"Equal":return[r.equal(b("a",n,e,t),b("b",n,e,t))];case"NotEqual":return[r.notEqual(b("a",n,e,t),b("b",n,e,t))];case"Greater":return[r.greater(b("a",n,e,t),b("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(b("a",n,e,t),b("b",n,e,t))];case"Less":return[r.less(b("a",n,e,t),b("b",n,e,t))];case"LessEqual":return[r.lessEqual(b("a",n,e,t),b("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(b("a",n,e,t),b("b",n,e,t))];case"LogicalNot":return[r.logicalNot(b("a",n,e,t))];case"LogicalOr":return[r.logicalOr(b("a",n,e,t),b("b",n,e,t))];case"Select":case"SelectV2":return[r.where(b("condition",n,e,t),b("a",n,e,t),b("b",n,e,t))];case"BitwiseAnd":return[r.bitwiseAnd(b("a",n,e,t),b("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var hW,gW=D(()=>{"use strict";zt();vt();hW=(n,e,t,r=Ue)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(b("a",n,e,t),b("b",n,e,t),b("transposeA",n,e,t),b("transposeB",n,e,t))];case"Einsum":return[r.einsum(b("equation",n,e,t),...b("tensors",n,e,t))];case"Transpose":return[r.transpose(b("x",n,e,t),b("perm",n,e,t))];case"_FusedMatMul":let[o,s]=b("fusedOps",n,e,t),i=o==="biasadd",a=s==="prelu",c=b("numArgs",n,e,t),u=b("leakyreluAlpha",n,e,t);if(i){if(a&&c!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&c!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,p]=b("args",n,e,t);return[r.fused.matMul({a:b("a",n,e,t),b:b("b",n,e,t),transposeA:b("transposeA",n,e,t),transposeB:b("transposeB",n,e,t),bias:l,activation:s,preluActivationWeights:p,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(b("a",n,e,t),b("numLower",n,e,t),b("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var xW,yW=D(()=>{"use strict";zt();vt();xW=(n,e,t,r=Ue)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(b("x",n,e,t),b("axis",n,e,t),b("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(b("x",n,e,t),b("mean",n,e,t),b("variance",n,e,t),b("offset",n,e,t),b("scale",n,e,t),b("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(b("x",n,e,t),b("mean",n,e,t),b("variance",n,e,t),b("offset",n,e,t),b("scale",n,e,t),b("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(b("x",n,e,t),b("radius",n,e,t),b("bias",n,e,t),b("alpha",n,e,t),b("beta",n,e,t))];case"Softmax":return[r.softmax(b("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var vW,bW=D(()=>{"use strict";zt();vt();vW=(n,e,t,r=Ue)=>{switch(n.op){case"RaggedGather":{let{outputNestedSplits:o,outputDenseValues:s}=r.raggedGather(b("paramsNestedSplits",n,e,t),b("paramsDenseValues",n,e,t),b("indices",n,e,t),b("outputRaggedRank",n,e,t));return o.concat(s)}case"RaggedRange":{let{rtNestedSplits:o,rtDenseValues:s}=r.raggedRange(b("starts",n,e,t),b("limits",n,e,t),b("splits",n,e,t));return[o,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(b("shape",n,e,t),b("values",n,e,t),b("defaultValue",n,e,t),b("rowPartitionTensors",n,e,t),b("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var CW,wW=D(()=>{"use strict";zt();vt();CW=(n,e,t,r=Ue)=>{switch(n.op){case"Max":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.max(b("x",n,e,t),a,c)]}case"Mean":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.mean(b("x",n,e,t),a,c)]}case"Min":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.min(b("x",n,e,t),a,c)]}case"Sum":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.sum(b("x",n,e,t),a,c)]}case"All":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.all(b("x",n,e,t),a,c)]}case"Any":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.any(b("x",n,e,t),a,c)]}case"ArgMax":{let a=b("axis",n,e,t);return[r.argMax(b("x",n,e,t),a)]}case"ArgMin":{let a=b("axis",n,e,t);return[r.argMin(b("x",n,e,t),a)]}case"Prod":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.prod(b("x",n,e,t),a,c)]}case"Cumprod":{let a=b("axis",n,e,t),c=b("exclusive",n,e,t),u=b("reverse",n,e,t);return[r.cumprod(b("x",n,e,t),a,c,u)]}case"Cumsum":{let a=b("axis",n,e,t),c=b("exclusive",n,e,t),u=b("reverse",n,e,t);return[r.cumsum(b("x",n,e,t),a,c,u)]}case"Bincount":let o=b("x",n,e,t),s=b("weights",n,e,t),i=b("size",n,e,t);return[r.bincount(o,s,i)];case"DenseBincount":{let a=b("x",n,e,t),c=b("weights",n,e,t),u=b("size",n,e,t),l=b("binaryOutput",n,e,t);return[r.denseBincount(a,c,u,l)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var IW,EW=D(()=>{"use strict";T();zt();vt();IW=(n,e,t,r=Ue)=>{switch(n.op){case"ConcatV2":case"Concat":{let o=b("n",n,e,t),s=b("axis",n,e,t),i=b("tensors",n,e,t);return i=i.slice(0,o),[r.concat(i,s)]}case"Gather":{let o=b("x",n,e,t),s=b("indices",n,e,t);return[r.gather(o,r.cast(s,"int32"),0)]}case"GatherV2":{let o=b("axis",n,e,t),s=b("batchDims",n,e,t),i=b("x",n,e,t),a=b("indices",n,e,t);return[r.gather(i,r.cast(a,"int32"),o,s)]}case"Reverse":{let o=b("dims",n,e,t),s=[];for(let a=0;a<o.length;a++)o[a]&&s.push(a);let i=b("x",n,e,t);return[r.reverse(i,s)]}case"ReverseV2":{let o=b("axis",n,e,t),s=b("x",n,e,t);return[r.reverse(s,o)]}case"Slice":{let o=b("begin",n,e,t),s=b("size",n,e,t);return[r.slice(b("x",n,e,t),o,s)]}case"StridedSlice":{let o=b("begin",n,e,t),s=b("end",n,e,t),i=b("strides",n,e,t),a=b("beginMask",n,e,t),c=b("endMask",n,e,t),u=b("ellipsisMask",n,e,t),l=b("newAxisMask",n,e,t),p=b("shrinkAxisMask",n,e,t),d=b("x",n,e,t);return[r.stridedSlice(d,o,s,i,a,c,u,l,p)]}case"Pack":return Ce(()=>{let o=b("axis",n,e,t),s=b("tensors",n,e,t),i=s[0].shape,a=r.squeeze(s[0]).shape,c=s.map(u=>{let l=y.arraysEqual(u.shape,i);if(!l&&!y.arraysEqual(r.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return l?u:r.reshape(u,i)});return[r.stack(c,o)]});case"Unpack":{let o=b("axis",n,e,t),s=b("tensor",n,e,t);return r.unstack(s,o)}case"Tile":{let o=b("reps",n,e,t);return[r.tile(b("x",n,e,t),o)]}case"Split":case"SplitV":{let o=b("axis",n,e,t),s=b("numOrSizeSplits",n,e,t),i=b("x",n,e,t);return r.split(i,s,o)}case"ScatterNd":{let o=b("indices",n,e,t),s=b("values",n,e,t),i=b("shape",n,e,t);return[r.scatterND(o,s,i)]}case"GatherNd":{let o=b("x",n,e,t),s=b("indices",n,e,t);return[r.gatherND(o,s)]}case"SparseToDense":{let o=b("sparseIndices",n,e,t),s=b("outputShape",n,e,t),i=b("sparseValues",n,e,t),a=b("defaultValue",n,e,t);return[r.sparseToDense(o,i,s,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{let o=b("indices",n,e,t),s=b("values",n,e,t),i=b("tensor",n,e,t);return[r.tensorScatterUpdate(i,o,s)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var TW,SW=D(()=>{"use strict";zt();vt();TW=(n,e,t,r=Ue)=>{switch(n.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(b("indices",n,e,t),b("values",n,e,t),b("denseShape",n,e,t),b("defaultValue",n,e,t));return[o,s,i,a]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=r.sparse.sparseReshape(b("inputIndices",n,e,t),b("inputShape",n,e,t),b("newShape",n,e,t));return[o,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(b("data",n,e,t),b("indices",n,e,t),b("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(b("data",n,e,t),b("indices",n,e,t),b("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var NW,DW=D(()=>{"use strict";zt();vt();NW=(n,e,t,r=Ue)=>{switch(n.op){case"FFT":return[r.fft(b("x",n,e,t))];case"IFFT":return[r.ifft(b("x",n,e,t))];case"RFFT":return[r.rfft(b("x",n,e,t))];case"IRFFT":return[r.irfft(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var kW,_W=D(()=>{"use strict";zt();vt();kW=(n,e,t,r=Ue)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(b("input",n,e,t),b("pattern",n,e,t),b("rewrite",n,e,t),b("replaceGlobal",n,e,t))];case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=r.string.stringNGrams(b("data",n,e,t),b("dataSplits",n,e,t),b("separator",n,e,t),b("nGramWidths",n,e,t),b("leftPad",n,e,t),b("rightPad",n,e,t),b("padWidth",n,e,t),b("preserveShortSequences",n,e,t));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:i}=r.string.stringSplit(b("input",n,e,t),b("delimiter",n,e,t),b("skipEmpty",n,e,t));return[o,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(b("input",n,e,t),b("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var AW,RW=D(()=>{"use strict";zt();vt();AW=(n,e,t,r=Ue)=>{switch(n.op){case"Cast":return[r.cast(b("x",n,e,t),b("dtype",n,e,t))];case"ExpandDims":{let o=b("axis",n,e,t);return[r.expandDims(b("x",n,e,t),o)]}case"Squeeze":{let o=b("axis",n,e,t);return[r.squeeze(b("x",n,e,t),o)]}case"Reshape":return[r.reshape(b("x",n,e,t),b("shape",n,e,t))];case"EnsureShape":return[r.ensureShape(b("x",n,e,t),b("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(b("x",n,e,t),b("padding",n,e,t),b("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(b("x",n,e,t),b("padding",n,e,t),b("constantValue",n,e,t))];case"SpaceToBatchND":{let o=b("blockShape",n,e,t),s=b("paddings",n,e,t);return[r.spaceToBatchND(b("x",n,e,t),o,s)]}case"BatchToSpaceND":{let o=b("blockShape",n,e,t),s=b("crops",n,e,t);return[r.batchToSpaceND(b("x",n,e,t),o,s)]}case"DepthToSpace":{let o=b("blockSize",n,e,t),s=b("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(b("x",n,e,t),o,s)]}case"BroadcastTo":return[r.broadcastTo(b("x",n,e,t),b("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(b("s0",n,e,t),b("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});function ED(n,e,t,r,o=Ce){let s=((i,a,c)=>{switch(i.category){case"arithmetic":return o(()=>LG(i,a,c));case"basic_math":return o(()=>VG(i,a,c));case"control":return XG(i,a,c);case"convolution":return o(()=>QG(i,a,c));case"creation":return o(()=>eW(i,a,c));case"dynamic":return nW(i,a,c);case"evaluation":return o(()=>oW(i,a,c));case"image":return o(()=>pW(i,a,c));case"graph":return o(()=>iW(i,a,c));case"logical":return o(()=>fW(i,a,c));case"matrices":return o(()=>hW(i,a,c));case"normalization":return o(()=>xW(i,a,c));case"ragged":return o(()=>vW(i,a,c));case"reduction":return o(()=>CW(i,a,c));case"slice_join":return o(()=>IW(i,a,c));case"sparse":return o(()=>TW(i,a,c));case"spectral":return o(()=>NW(i,a,c));case"string":return o(()=>kW(i,a,c));case"transformation":return o(()=>AW(i,a,c));case"hash_table":return uW(i,a,c,r);case"custom":let u=ab(i.op);if(u&&u.customExecutor)return u.customExecutor(new bb(i,a,c));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return y.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var FW=D(()=>{"use strict";T();PG();cb();BG();UG();YG();JG();tW();rW();sW();aW();lW();dW();mW();gW();yW();bW();wW();EW();SW();DW();_W();RW();});var sh,OW=D(()=>{"use strict";sh=class{constructor(e={},t={},r={},o={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=o,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}});function TD(n,e,t,r){let o=new Set,s=[],i=null,a=null,c=new Set,u=new Set(Object.keys(n).map(d=>In(d)[0]));r=r||[];let l=new Set(r.map(d=>In(d.name)[0])),p=[...e];for(;p.length>0;){let d=p.pop();if((ua(d)||ale(d)||cle(d))&&i==null&&(i=d,a=i.children.map(f=>f.name).filter(f=>o.has(f))),o.add(d.name),t[d.name]==null&&!u.has(d.name)&&!l.has(d.name)){if(d.inputs.length===0){s.push(d.name);continue}d.inputs.forEach(f=>{c.has(f.name)||(c.add(f.name),p.push(f))})}}return{inputs:n,outputs:e,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function MW(n,e){let{usedNodes:t,inputs:r}=e,o=Object.keys(r).map(g=>In(g)[0]).map(g=>n.nodes[g]),s=n.initNodes||[],i=g=>t.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(x=>[x.name,x])).values()]}let c=a([...o,...n.weights,...s]).filter(i),u=a([...c,...Object.values(n.nodes)]).filter(i),l=new Map(u.map(g=>[g.name,g])),p={};for(let g of u){p[g.name]=p[g.name]||0;for(let x of g.children)i(x)||(p[x.name]=Number.POSITIVE_INFINITY),p[x.name]=(p[x.name]||0)+1}let d=Object.entries(p).filter(([,g])=>g===0).map(([g])=>g),f=[...d];for(;d.length>0;){let g=d.pop(),x=l.get(g);for(let v of x.children.filter(i))--p[v.name]===0&&(f.push(v.name),d.push(v.name))}let m=f.map(g=>l.get(g)),h=nle(m,c);return rle(h,c),h}function nle(n,e){let t=new Map(n.map(i=>[i.name,i])),r=e.map(i=>i.name),o=new Set(r);for(;r.length>0;){let i=r.pop(),a=t.get(i);for(let c of a.children)!t.has(c.name)||o.has(c.name)||(o.add(c.name),r.push(c.name))}return n.filter(i=>o.has(i.name))}function rle(n,e){let t=new Map(n.map((a,c)=>[a.name,c])),r=new Set(e.map(a=>a.name)),o=a=>r.has(typeof a=="string"?a:a.name),s=new Set(n.map(a=>a.name)),i=a=>s.has(typeof a=="string"?a:a.name);for(let a of n){for(let c of a.children.filter(i)){if(!t.has(c.name))throw new xd(`Child ${c.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(c.name))throw new xd(`Node ${a.name} is scheduled to run after its child ${c.name}.`)}if(!o(a))for(let c of a.inputs){if(!t.has(c.name))throw new xd(`Input ${c.name} of node ${a.name} is unreachable.`);if(t.get(c.name)>t.get(a.name))throw new xd(`Node ${a.name} is scheduled to run before its input ${c.name}.`)}}}function $W(n){let e=new Map(n.map((a,c)=>[a.name,c])),t=Number.MAX_SAFE_INTEGER,r=n.map((a,c)=>ua(a)?t:c),o=a=>{let c=r[e.get(a.name)];return c??-1},s=n.map((a,c)=>a.children.map(o).reduce((u,l)=>Math.max(u,l),r[c])),i=new Map;for(let a=0;a<n.length;++a){let c=s[a];if(c===t)continue;let u=n[a],l=n[c];i.has(l.name)||i.set(l.name,[]),i.get(l.name).push(u)}return i}function ua(n){return ole.has(n.op)}function ale(n){return sle.has(n.op)}function cle(n){return ile.has(n.op)}var xd,ole,sle,ile,PW=D(()=>{"use strict";vt();xd=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};ole=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),sle=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),ile=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"])});var ih,LW=D(()=>{"use strict";T();vt();FW();OW();PW();ih=class n{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(r=>e[r].map(o=>o.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new n(e.functions[r],this)})}getCompilationKey(e,t){let r=e.map(s=>s.name).sort(),o=t.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+o.join(this.SEPARATOR)}compile(e,t){let r=TD(e,t,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let u=t.map(p=>p.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${l}]. Missing the following inputs: [${o}]`)}let a=MW(this.graph,r),c=$W(a);return{orderedNodes:a,nodeLiveUntilMap:c}}cloneAndKeepTensor(e){if(e==null)return null;let t=e.clone();return Cn(t),t}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let o=r.map(d=>this.graph.nodes[In(d)[0]]),s=t.map(d=>In(d)[0]),i=new Set(s),a=s.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);let c=this.getCompilationKey(o,a),u=this.compiledMap.get(c);u==null&&(u=this.compile(e,a),this.compiledMap.set(c,u));try{this.keepIntermediateTensors=M().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let l={},p={};return Ce(()=>{let d=new sh(this.weightMap,l,p,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(x=>{let[v,w]=In(x,d),I=[];I[w]=e[x],f[v]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[v]=this.cloneTensorList(I))});let m=this.getFrozenTensorIds(f),{orderedNodes:h,nodeLiveUntilMap:g}=u;for(let x of h){if(f[x.name])continue;let v=ED(x,f,d,this._resourceManager);if(y.isPromise(v))throw new Error(`The execution of the op '${x.op}' returned a promise. Please use model.executeAsync() instead.`);f[x.name]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[x.name]=this.cloneTensorList(v)),this.checkTensorForDisposalWithNodeLiveUntilInfo(x,f,d,m,i,g.get(x.name))}return this.parent==null&&d.dispose(m),t.map(x=>St(x,f,d))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(o=>o.id)));return new Set(t)}checkTensorForDisposal(e,t,r,o,s,i,a){if(!(ua(t)||i.has(e))){for(let c of r[e])c!=null&&(a[c.id]=(a[c.id]||0)+t.children.length);for(let c of t.inputs){if(ua(c))continue;let u=eD(c.name,r,o);if(u!=null)for(let l of u){if(!l||l.kept||s.has(l.id))continue;let p=a[l.id];p===1?(l.dispose(),delete a[l.id]):p!=null&&a[l.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,o,s,i){function a(c){return ua(c)||s.has(c.name)}if(!(ua(e)||i==null))for(let c of i){if(a(c))continue;let u=eD(c.name,t,r);for(let l of u)!l||l.kept||o.has(l.id)||l.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,o={},s={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=M().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let i=new sh(this.weightMap,o,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let a=await this.executeWithControlFlow(e,i,t,r),c=t.map(d=>St(d,a,i)),u=c.map(d=>d.id),l=Object.keys(e).map(d=>e[d].id),p=new Set([...u,...l,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(f=>{f&&!f.isDisposed&&!p.has(f.id)&&f.dispose()})}),this.parent==null&&i.dispose(p),c}async executeFunctionAsync(e,t,r){let o=e.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,o){let s=Object.keys(e),i=s.map(I=>this.graph.nodes[In(I)[0]]),a=r.map(I=>In(I)[0]),c=new Set(a),u=a.map(I=>this.graph.nodes[I]);u.length===0&&(u=this._outputs);let{usedNodes:l,missingInputs:p,dynamicNode:d,syncInputs:f}=TD(e,u,this.weightMap,this._initNodes),m=[...i,...this.graph.weights,...this._initNodes||[]].map(I=>({node:I,contexts:t.currentContext})),h=Object.assign({},this.weightMap);Object.keys(e).forEach(I=>{let[_,A]=In(I),R=[];R[A]=e[I],h[_]=R});let g={},x=this.getFrozenTensorIds(h),v={};for(;m.length>0;){let I=this.processStack(i,m,t,h,v,x,c,g,l);await Promise.all(I)}d==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let w=u.filter(I=>!ua(I)&&!St(I.name,h,t)).map(I=>I.name);if(w.length>0){let I="";throw d!=null&&(I=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${I}`)}return h}processStack(e,t,r,o,s,i,a,c,u){let l=[];for(;t.length>0;){let p=t.pop();r.currentContext=p.contexts;let d="";if(p.node.op==="Enter"&&b("isConstant",p.node,o,r)&&([d]=eo(p.node.name,r)),o[p.node.name]==null){let f=ED(p.node,o,r,this._resourceManager);d||([d]=eo(p.node.name,r));let m=r.currentContext;y.isPromise(f)?l.push(f.then(h=>(o[d]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(h)),r.currentContext=m,this.checkTensorForDisposal(d,p.node,o,r,i,a,c),this.processChildNodes(p.node,t,r,o,s,u),h))):(o[d]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(f)),this.checkTensorForDisposal(d,p.node,o,r,i,a,c),this.processChildNodes(p.node,t,r,o,s,u))}else this.processChildNodes(p.node,t,r,o,s,u)}return l}processChildNodes(e,t,r,o,s,i){e.children.forEach(a=>{let[c]=eo(a.name,r);s[c]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!St(u,o,r))&&(s[c]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!St(u,o,r))&&(s[c]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let r=e[t],[o]=In(t),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((c,u)=>i[u]===-1||i[u]===c);y.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&y.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;let o={};for(let s in e){let i=(r=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||r===void 0?void 0:r[s];i!=null?o[i.name]=e[s]:o[s]=e[s]}return o}checkInputs(e){let t=Object.keys(e).filter(r=>{let[o]=In(r);return this.graph.nodes[o]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var r,o;let s=(o=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||o===void 0?void 0:o[t];return s!=null?s.name:t},{})}checkOutputs(e){e.forEach(t=>{let[r]=In(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}});var Eb,BW=D(()=>{"use strict";Eb=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}});async function VW(n,e={},t=_o){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=ple(n));let r=new yd(n,e,t);return await r.load(),r}function UW(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){let[r,o]=n;if(!r)throw new Error("modelJSON must be the first element of the array");if(!o||!(o instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let s=_o.getWeightSpecs(r.weightsManifest),i=_o.getModelArtifactsForJSONSync(r,s,o);e=_o.fromMemorySync(i)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=_o.fromMemorySync(n);else throw new Error("Unknown model format");let t=new yd(e);return t.load(),t}function ple(n){return n.endsWith("/")||(n=n+"/"),`${n}${lle}${ule}`}var ule,lle,yd,zW=D(()=>{"use strict";T();CD();LW();BW();Ui();ule="?tfjs-format=file",lle="model.json",yd=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=_o){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new Eb}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return y.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await Zg(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let r=this.artifacts.modelTopology,o=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(o=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=o,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new ih(oh.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=oh.Instance.transformGraph(e.modelInitializer);this.initializer=new ih(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Ke?[e]:e,r={};return t.forEach((o,s)=>r[this.structuredOutputKeys[s]]=o),r}return e}predict(e,t){let r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){let r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof Ke)&&!Array.isArray(e)){let s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(let i in s){let a=s[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];let r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let o=0;return this.inputNodes.reduce((s,i)=>{var a,c,u;let l=(u=(c=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||c===void 0?void 0:c[i])===null||u===void 0?void 0:u.resourceId;return l!=null?s[i]=this.resourceIdToCapturedInput[l]:s[i]=e[o++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,r=Object.keys(t);for(let o=0;o<r.length;o++){let s=r[o],i=t[s];this.resourceIdToCapturedInput[i.resourceId]=e[o]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&ht(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}});var HW,GW=D(()=>{"use strict";HW="4.22.0"});var WW={};Le(WW,{GraphModel:()=>yd,deregisterOp:()=>mG,loadGraphModel:()=>VW,loadGraphModelSync:()=>UW,registerOp:()=>fG,version_converter:()=>HW});var jW=D(()=>{"use strict";lG();zW();cb();GW();});var KW=Jn((Tb,qW)=>{"use strict";(function(n,e){typeof Tb=="object"&&typeof qW<"u"?e(Tb,(jW(),_D(WW)),(T(),_D(Zx))):typeof define=="function"&&define.amd?define(["exports","@tensorflow/tfjs-converter","@tensorflow/tfjs-core"],e):e((n=n||self).cocoSsd=n.cocoSsd||{},n.tf,n.tf)})(Tb,function(n,e,t){"use strict";let r={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class o{constructor(i,a){this.modelPath=a||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(i)}/model.json`}getPrefix(i){return i==="lite_mobilenet_v2"?`ssd${i}`:`ssd_${i}`}async load(){this.model=await e.loadGraphModel(this.modelPath);let i=t.zeros([1,300,300,3],"int32"),a=await this.model.executeAsync(i);await Promise.all(a.map(c=>c.data())),a.map(c=>c.dispose()),i.dispose()}async infer(i,a,c){let u=t.tidy(()=>(i instanceof t.Tensor||(i=t.browser.fromPixels(i)),t.expandDims(i))),l=u.shape[1],p=u.shape[2],d=await this.model.executeAsync(u),f=d[0].dataSync(),m=d[1].dataSync();u.dispose(),t.dispose(d);let[h,g]=this.calculateMaxScores(f,d[0].shape[1],d[0].shape[2]),x=t.getBackend();t.getBackend()==="webgl"&&t.setBackend("cpu");let v=t.tidy(()=>{let I=t.tensor2d(m,[d[1].shape[1],d[1].shape[3]]);return t.image.nonMaxSuppression(I,h,a,c,c)}),w=v.dataSync();return v.dispose(),x!==t.getBackend()&&t.setBackend(x),this.buildDetectedObjects(p,l,m,h,w,g)}buildDetectedObjects(i,a,c,u,l,p){let d=l.length,f=[];for(let m=0;m<d;m++){let h=[];for(let I=0;I<4;I++)h[I]=c[4*l[m]+I];let g=h[0]*a,x=h[1]*i,v=h[2]*a,w=h[3]*i;h[0]=x,h[1]=g,h[2]=w-x,h[3]=v-g,f.push({bbox:h,class:r[p[l[m]]+1].displayName,score:u[l[m]]})}return f}calculateMaxScores(i,a,c){let u=[],l=[];for(let p=0;p<a;p++){let d=Number.MIN_VALUE,f=-1;for(let m=0;m<c;m++)i[p*c+m]>d&&(d=i[p*c+m],f=m);u[p]=d,l[p]=f}return[u,l]}async detect(i,a=20,c=.5){return this.infer(i,a,c)}dispose(){this.model!=null&&this.model.dispose()}}n.ObjectDetection=o,n.load=async function(s={}){if(t==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");let i=s.base||"lite_mobilenet_v2",a=s.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(i)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${i}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);let c=new o(i,a);return await c.load(),c},n.version="2.2.3",Object.defineProperty(n,"__esModule",{value:!0})})});var Ab;function uh(){return Ab}function no(n){let e=Ab;return Ab=n,e}var AD=Symbol("NotFound");function Tl(n){return n===AD||n?.name==="\u0275NotFound"}function Rb(n,e){return Object.is(n,e)}var mn=null,lh=!1,Fb=1,cj=null,Mn=Symbol("SIGNAL");function $e(n){let e=mn;return mn=n,e}function dh(){return mn}var Sl={version:0,lastCleanEpoch:0,dirty:!1,producers:void 0,producersTail:void 0,consumers:void 0,consumersTail:void 0,recomputing:!1,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,kind:"unknown",producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function Cd(n){if(lh)throw new Error("");if(mn===null)return;mn.consumerOnSignalRead(n);let e=mn.producersTail;if(e!==void 0&&e.producer===n)return;let t,r=mn.recomputing;if(r&&(t=e!==void 0?e.nextProducer:mn.producers,t!==void 0&&t.producer===n)){mn.producersTail=t,t.lastReadVersion=n.version;return}let o=n.consumersTail;if(o!==void 0&&o.consumer===mn&&(!r||lj(o,mn)))return;let s=kl(mn),i={producer:n,consumer:mn,nextProducer:t,prevConsumer:o,lastReadVersion:n.version,nextConsumer:void 0};mn.producersTail=i,e!==void 0?e.nextProducer=i:mn.producers=i,s&&FD(n,i)}function RD(){Fb++}function Ob(n){if(!(kl(n)&&!n.dirty)&&!(!n.dirty&&n.lastCleanEpoch===Fb)){if(!n.producerMustRecompute(n)&&!Dl(n)){ph(n);return}n.producerRecomputeValue(n),ph(n)}}function Mb(n){if(n.consumers===void 0)return;let e=lh;lh=!0;try{for(let t=n.consumers;t!==void 0;t=t.nextConsumer){let r=t.consumer;r.dirty||uj(r)}}finally{lh=e}}function $b(){return mn?.consumerAllowSignalWrites!==!1}function uj(n){n.dirty=!0,Mb(n),n.consumerMarkedDirty?.(n)}function ph(n){n.dirty=!1,n.lastCleanEpoch=Fb}function Nl(n){return n&&(n.producersTail=void 0,n.recomputing=!0),$e(n)}function wd(n,e){if($e(e),!n)return;n.recomputing=!1;let t=n.producersTail,r=t!==void 0?t.nextProducer:n.producers;if(r!==void 0){if(kl(n))do r=Pb(r);while(r!==void 0);t!==void 0?t.nextProducer=void 0:n.producers=void 0}}function Dl(n){for(let e=n.producers;e!==void 0;e=e.nextProducer){let t=e.producer,r=e.lastReadVersion;if(r!==t.version||(Ob(t),r!==t.version))return!0}return!1}function pa(n){if(kl(n)){let e=n.producers;for(;e!==void 0;)e=Pb(e)}n.producers=void 0,n.producersTail=void 0,n.consumers=void 0,n.consumersTail=void 0}function FD(n,e){let t=n.consumersTail,r=kl(n);if(t!==void 0?(e.nextConsumer=t.nextConsumer,t.nextConsumer=e):(e.nextConsumer=void 0,n.consumers=e),e.prevConsumer=t,n.consumersTail=e,!r)for(let o=n.producers;o!==void 0;o=o.nextProducer)FD(o.producer,o)}function Pb(n){let e=n.producer,t=n.nextProducer,r=n.nextConsumer,o=n.prevConsumer;if(n.nextConsumer=void 0,n.prevConsumer=void 0,r!==void 0?r.prevConsumer=o:e.consumersTail=o,o!==void 0)o.nextConsumer=r;else if(e.consumers=r,!kl(e)){let s=e.producers;for(;s!==void 0;)s=Pb(s)}return t}function kl(n){return n.consumerIsAlwaysLive||n.consumers!==void 0}function Lb(n){cj?.(n)}function lj(n,e){let t=e.producersTail;if(t!==void 0){let r=e.producers;do{if(r===n)return!0;if(r===t)break;r=r.nextProducer}while(r!==void 0)}return!1}function pj(){throw new Error}var OD=pj;function MD(n){OD(n)}function Bb(n){OD=n}var dj=null;function Vb(n,e){let t=Object.create(fh);t.value=n,e!==void 0&&(t.equal=e);let r=()=>$D(t);return r[Mn]=t,Lb(t),[r,i=>_l(t,i),i=>Ub(t,i)]}function $D(n){return Cd(n),n.value}function _l(n,e){$b()||MD(n),n.equal(n.value,e)||(n.value=e,fj(n))}function Ub(n,e){$b()||MD(n),_l(n,e(n.value))}var fh=Yt(Ft({},Sl),{equal:Rb,value:void 0,kind:"signal"});function fj(n){n.version++,RD(),Mb(n),dj?.(n)}function $n(n){return typeof n=="function"}function mh(n){let t=n(r=>{Error.call(r),r.stack=new Error().stack});return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}var hh=mh(n=>function(t){n(this),this.message=t?`${t.length} errors occurred during unsubscription:
${t.map((r,o)=>`${o+1}) ${r.toString()}`).join(`
  `)}`:"",this.name="UnsubscriptionError",this.errors=t});function Id(n,e){if(n){let t=n.indexOf(e);0<=t&&n.splice(t,1)}}var En=class n{constructor(e){this.initialTeardown=e,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let e;if(!this.closed){this.closed=!0;let{_parentage:t}=this;if(t)if(this._parentage=null,Array.isArray(t))for(let s of t)s.remove(this);else t.remove(this);let{initialTeardown:r}=this;if($n(r))try{r()}catch(s){e=s instanceof hh?s.errors:[s]}let{_finalizers:o}=this;if(o){this._finalizers=null;for(let s of o)try{PD(s)}catch(i){e=e??[],i instanceof hh?e=[...e,...i.errors]:e.push(i)}}if(e)throw new hh(e)}}add(e){var t;if(e&&e!==this)if(this.closed)PD(e);else{if(e instanceof n){if(e.closed||e._hasParent(this))return;e._addParent(this)}(this._finalizers=(t=this._finalizers)!==null&&t!==void 0?t:[]).push(e)}}_hasParent(e){let{_parentage:t}=this;return t===e||Array.isArray(t)&&t.includes(e)}_addParent(e){let{_parentage:t}=this;this._parentage=Array.isArray(t)?(t.push(e),t):t?[t,e]:e}_removeParent(e){let{_parentage:t}=this;t===e?this._parentage=null:Array.isArray(t)&&Id(t,e)}remove(e){let{_finalizers:t}=this;t&&Id(t,e),e instanceof n&&e._removeParent(this)}};En.EMPTY=(()=>{let n=new En;return n.closed=!0,n})();var zb=En.EMPTY;function gh(n){return n instanceof En||n&&"closed"in n&&$n(n.remove)&&$n(n.add)&&$n(n.unsubscribe)}function PD(n){$n(n)?n():n.unsubscribe()}var Nr={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1};var Al={setTimeout(n,e,...t){let{delegate:r}=Al;return r?.setTimeout?r.setTimeout(n,e,...t):setTimeout(n,e,...t)},clearTimeout(n){let{delegate:e}=Al;return(e?.clearTimeout||clearTimeout)(n)},delegate:void 0};function LD(n){Al.setTimeout(()=>{let{onUnhandledError:e}=Nr;if(e)e(n);else throw n})}function Hb(){}var BD=Gb("C",void 0,void 0);function VD(n){return Gb("E",void 0,n)}function UD(n){return Gb("N",n,void 0)}function Gb(n,e,t){return{kind:n,value:e,error:t}}var da=null;function Rl(n){if(Nr.useDeprecatedSynchronousErrorHandling){let e=!da;if(e&&(da={errorThrown:!1,error:null}),n(),e){let{errorThrown:t,error:r}=da;if(da=null,t)throw r}}else n()}function zD(n){Nr.useDeprecatedSynchronousErrorHandling&&da&&(da.errorThrown=!0,da.error=n)}var fa=class extends En{constructor(e){super(),this.isStopped=!1,e?(this.destination=e,gh(e)&&e.add(this)):this.destination=gj}static create(e,t,r){return new Fl(e,t,r)}next(e){this.isStopped?jb(UD(e),this):this._next(e)}error(e){this.isStopped?jb(VD(e),this):(this.isStopped=!0,this._error(e))}complete(){this.isStopped?jb(BD,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(e){this.destination.next(e)}_error(e){try{this.destination.error(e)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}},mj=Function.prototype.bind;function Wb(n,e){return mj.call(n,e)}var qb=class{constructor(e){this.partialObserver=e}next(e){let{partialObserver:t}=this;if(t.next)try{t.next(e)}catch(r){xh(r)}}error(e){let{partialObserver:t}=this;if(t.error)try{t.error(e)}catch(r){xh(r)}else xh(e)}complete(){let{partialObserver:e}=this;if(e.complete)try{e.complete()}catch(t){xh(t)}}},Fl=class extends fa{constructor(e,t,r){super();let o;if($n(e)||!e)o={next:e??void 0,error:t??void 0,complete:r??void 0};else{let s;this&&Nr.useDeprecatedNextContext?(s=Object.create(e),s.unsubscribe=()=>this.unsubscribe(),o={next:e.next&&Wb(e.next,s),error:e.error&&Wb(e.error,s),complete:e.complete&&Wb(e.complete,s)}):o=e}this.destination=new qb(o)}};function xh(n){Nr.useDeprecatedSynchronousErrorHandling?zD(n):LD(n)}function hj(n){throw n}function jb(n,e){let{onStoppedNotification:t}=Nr;t&&Al.setTimeout(()=>t(n,e))}var gj={closed:!0,next:Hb,error:hj,complete:Hb};var HD=typeof Symbol=="function"&&Symbol.observable||"@@observable";function GD(n){return n}function WD(n){return n.length===0?GD:n.length===1?n[0]:function(t){return n.reduce((r,o)=>o(r),t)}}var Ol=(()=>{class n{constructor(t){t&&(this._subscribe=t)}lift(t){let r=new n;return r.source=this,r.operator=t,r}subscribe(t,r,o){let s=yj(t)?t:new Fl(t,r,o);return Rl(()=>{let{operator:i,source:a}=this;s.add(i?i.call(s,a):a?this._subscribe(s):this._trySubscribe(s))}),s}_trySubscribe(t){try{return this._subscribe(t)}catch(r){t.error(r)}}forEach(t,r){return r=jD(r),new r((o,s)=>{let i=new Fl({next:a=>{try{t(a)}catch(c){s(c),i.unsubscribe()}},error:s,complete:o});this.subscribe(i)})}_subscribe(t){var r;return(r=this.source)===null||r===void 0?void 0:r.subscribe(t)}[HD](){return this}pipe(...t){return WD(t)(this)}toPromise(t){return t=jD(t),new t((r,o)=>{let s;this.subscribe(i=>s=i,i=>o(i),()=>r(s))})}}return n.create=e=>new n(e),n})();function jD(n){var e;return(e=n??Nr.Promise)!==null&&e!==void 0?e:Promise}function xj(n){return n&&$n(n.next)&&$n(n.error)&&$n(n.complete)}function yj(n){return n&&n instanceof fa||xj(n)&&gh(n)}function vj(n){return $n(n?.lift)}function qD(n){return e=>{if(vj(e))return e.lift(function(t){try{return n(t,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function KD(n,e,t,r,o){return new Kb(n,e,t,r,o)}var Kb=class extends fa{constructor(e,t,r,o,s,i){super(e),this.onFinalize=s,this.shouldUnsubscribe=i,this._next=t?function(a){try{t(a)}catch(c){e.error(c)}}:super._next,this._error=o?function(a){try{o(a)}catch(c){e.error(c)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){e.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var e;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){let{closed:t}=this;super.unsubscribe(),!t&&((e=this.onFinalize)===null||e===void 0||e.call(this))}}};var XD=mh(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});var Ns=(()=>{class n extends Ol{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(t){let r=new yh(this,this);return r.operator=t,r}_throwIfClosed(){if(this.closed)throw new XD}next(t){Rl(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(let r of this.currentObservers)r.next(t)}})}error(t){Rl(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=t;let{observers:r}=this;for(;r.length;)r.shift().error(t)}})}complete(){Rl(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;let{observers:t}=this;for(;t.length;)t.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var t;return((t=this.observers)===null||t===void 0?void 0:t.length)>0}_trySubscribe(t){return this._throwIfClosed(),super._trySubscribe(t)}_subscribe(t){return this._throwIfClosed(),this._checkFinalizedStatuses(t),this._innerSubscribe(t)}_innerSubscribe(t){let{hasError:r,isStopped:o,observers:s}=this;return r||o?zb:(this.currentObservers=null,s.push(t),new En(()=>{this.currentObservers=null,Id(s,t)}))}_checkFinalizedStatuses(t){let{hasError:r,thrownError:o,isStopped:s}=this;r?t.error(o):s&&t.complete()}asObservable(){let t=new Ol;return t.source=this,t}}return n.create=(e,t)=>new yh(e,t),n})(),yh=class extends Ns{constructor(e,t){super(),this.destination=e,this.source=t}next(e){var t,r;(r=(t=this.destination)===null||t===void 0?void 0:t.next)===null||r===void 0||r.call(t,e)}error(e){var t,r;(r=(t=this.destination)===null||t===void 0?void 0:t.error)===null||r===void 0||r.call(t,e)}complete(){var e,t;(t=(e=this.destination)===null||e===void 0?void 0:e.complete)===null||t===void 0||t.call(e)}_subscribe(e){var t,r;return(r=(t=this.source)===null||t===void 0?void 0:t.subscribe(e))!==null&&r!==void 0?r:zb}};var Ed=class extends Ns{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){let t=super._subscribe(e);return!t.closed&&e.next(this._value),t}getValue(){let{hasError:e,thrownError:t,_value:r}=this;if(e)throw t;return this._throwIfClosed(),r}next(e){super.next(this._value=e)}};function Xb(n,e){return qD((t,r)=>{let o=0;t.subscribe(KD(r,s=>{r.next(n.call(e,s,o++))}))})}var YD=Yt(Ft({},Sl),{consumerIsAlwaysLive:!0,consumerAllowSignalWrites:!0,dirty:!0,hasRun:!1,kind:"effect"});function ZD(n){if(n.dirty=!1,n.hasRun&&!Dl(n))return;n.hasRun=!0;let e=Nl(n);try{n.cleanup(),n.fn()}finally{wd(n,e)}}var Eh="https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss",Te=class extends Error{code;constructor(e,t){super($l(e,t)),this.code=e}};function bj(n){return`NG0${Math.abs(n)}`}function $l(n,e){return`${bj(n)}${e?": "+e:""}`}var va=globalThis;function Je(n){for(let e in n)if(n[e]===Je)return e;throw Error("")}function ha(n){if(typeof n=="string")return n;if(Array.isArray(n))return`[${n.map(ha).join(", ")}]`;if(n==null)return""+n;let e=n.overriddenName||n.name;if(e)return`${e}`;let t=n.toString();if(t==null)return""+t;let r=t.indexOf(`
`);return r>=0?t.slice(0,r):t}function a0(n,e){return n?e?`${n} ${e}`:n:e||""}var Cj=Je({__forward_ref__:Je});function Th(n){return n.__forward_ref__=Th,n.toString=function(){return ha(this())},n}function er(n){return t1(n)?n():n}function t1(n){return typeof n=="function"&&n.hasOwnProperty(Cj)&&n.__forward_ref__===Th}function n1(n,e){n==null&&c0(e,n,null,"!=")}function c0(n,e,t,r){throw new Error(`ASSERTION ERROR: ${n}`+(r==null?"":` [Expected=> ${t} ${r} ${e} <=Actual]`))}function Et(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function kd(n){return{providers:n.providers||[],imports:n.imports||[]}}function Sh(n){return wj(n,Nh)}function wj(n,e){return n.hasOwnProperty(e)&&n[e]||null}function Ij(n){let e=n?.[Nh]??null;return e||null}function Zb(n){return n&&n.hasOwnProperty(bh)?n[bh]:null}var Nh=Je({\u0275prov:Je}),bh=Je({\u0275inj:Je}),Ge=class{_desc;ngMetadataName="InjectionToken";\u0275prov;constructor(e,t){this._desc=e,this.\u0275prov=void 0,typeof t=="number"?this.__NG_ELEMENT_ID__=t:t!==void 0&&(this.\u0275prov=Et({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}};function u0(n){return n&&!!n.\u0275providers}var l0=Je({\u0275cmp:Je}),p0=Je({\u0275dir:Je}),d0=Je({\u0275pipe:Je});var Qb=Je({\u0275fac:Je}),ba=Je({__NG_ELEMENT_ID__:Je}),JD=Je({__NG_ENV_ID__:Je});function Dh(n){return typeof n=="string"?n:n==null?"":String(n)}function Ch(n){return typeof n=="function"?n.name||n.toString():typeof n=="object"&&n!=null&&typeof n.type=="function"?n.type.name||n.type.toString():Dh(n)}var f0=Je({ngErrorCode:Je}),r1=Je({ngErrorMessage:Je}),Sd=Je({ngTokenPath:Je});function m0(n,e){return o1("",-200,e)}function kh(n,e){throw new Te(-201,!1)}function Ej(n,e){n[Sd]??=[];let t=n[Sd],r;typeof e=="object"&&"multi"in e&&e?.multi===!0?(n1(e.provide,"Token with multi: true should have a provide property"),r=Ch(e.provide)):r=Ch(e),t[0]!==r&&n[Sd].unshift(r)}function Tj(n,e){let t=n[Sd],r=n[f0],o=n[r1]||n.message;return n.message=Nj(o,r,t,e),n}function o1(n,e,t){let r=new Te(e,n);return r[f0]=e,r[r1]=n,t&&(r[Sd]=t),r}function Sj(n){return n[f0]}function Nj(n,e,t=[],r=null){let o="";t&&t.length>1&&(o=` Path: ${t.join(" -> ")}.`);let s=r?` Source: ${r}.`:"";return $l(e,`${n}${s}${o}`)}var Jb;function s1(){return Jb}function Tn(n){let e=Jb;return Jb=n,e}function h0(n,e,t){let r=Sh(n);if(r&&r.providedIn=="root")return r.value===void 0?r.value=r.factory():r.value;if(t&8)return null;if(e!==void 0)return e;kh(n,"Injector")}var Dj={},ma=Dj,kj="__NG_DI_FLAG__",e0=class{injector;constructor(e){this.injector=e}retrieve(e,t){let r=ga(t)||0;try{return this.injector.get(e,r&8?null:ma,r)}catch(o){if(Tl(o))return o;throw o}}};function _j(n,e=0){let t=uh();if(t===void 0)throw new Te(-203,!1);if(t===null)return h0(n,void 0,e);{let r=Aj(e),o=t.retrieve(n,r);if(Tl(o)){if(r.optional)return null;throw o}return o}}function Xe(n,e=0){return(s1()||_j)(er(n),e)}function Fe(n,e){return Xe(n,ga(e))}function ga(n){return typeof n>"u"||typeof n=="number"?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function Aj(n){return{optional:!!(n&8),host:!!(n&1),self:!!(n&2),skipSelf:!!(n&4)}}function t0(n){let e=[];for(let t=0;t<n.length;t++){let r=er(n[t]);if(Array.isArray(r)){if(r.length===0)throw new Te(900,!1);let o,s=0;for(let i=0;i<r.length;i++){let a=r[i],c=Rj(a);typeof c=="number"?c===-1?o=a.token:s|=c:o=a}e.push(Xe(o,s))}else e.push(Xe(r))}return e}function Rj(n){return n[kj]}function xa(n,e){let t=n.hasOwnProperty(Qb);return t?n[Qb]:null}function i1(n,e,t){if(n.length!==e.length)return!1;for(let r=0;r<n.length;r++){let o=n[r],s=e[r];if(t&&(o=t(o),s=t(s)),s!==o)return!1}return!0}function a1(n){return n.flat(Number.POSITIVE_INFINITY)}function _h(n,e){n.forEach(t=>Array.isArray(t)?_h(t,e):e(t))}function g0(n,e,t){e>=n.length?n.push(t):n.splice(e,0,t)}function _d(n,e){return e>=n.length-1?n.pop():n.splice(e,1)[0]}var Ca={},Dr=[],ks=new Ge(""),x0=new Ge("",-1),y0=new Ge(""),Nd=class{get(e,t=ma){if(t===ma){let o=o1("",-201);throw o.name="\u0275NotFound",o}return t}};function wa(n){return n[l0]||null}function v0(n){return n[p0]||null}function c1(n){return n[d0]||null}function Ad(n){return{\u0275providers:n}}function u1(n){return Ad([{provide:ks,multi:!0,useValue:n}])}function l1(...n){return{\u0275providers:b0(!0,n),\u0275fromNgModule:!0}}function b0(n,...e){let t=[],r=new Set,o,s=i=>{t.push(i)};return _h(e,i=>{let a=i;wh(a,s,[],r)&&(o||=[],o.push(a))}),o!==void 0&&p1(o,s),t}function p1(n,e){for(let t=0;t<n.length;t++){let{ngModule:r,providers:o}=n[t];C0(o,s=>{e(s,r)})}}function wh(n,e,t,r){if(n=er(n),!n)return!1;let o=null,s=Zb(n),i=!s&&wa(n);if(!s&&!i){let c=n.ngModule;if(s=Zb(c),s)o=c;else return!1}else{if(i&&!i.standalone)return!1;o=n}let a=r.has(o);if(i){if(a)return!1;if(r.add(o),i.dependencies){let c=typeof i.dependencies=="function"?i.dependencies():i.dependencies;for(let u of c)wh(u,e,t,r)}}else if(s){if(s.imports!=null&&!a){r.add(o);let u;try{_h(s.imports,l=>{wh(l,e,t,r)&&(u||=[],u.push(l))})}finally{}u!==void 0&&p1(u,e)}if(!a){let u=xa(o)||(()=>new o);e({provide:o,useFactory:u,deps:Dr},o),e({provide:y0,useValue:o,multi:!0},o),e({provide:ks,useValue:()=>Xe(o),multi:!0},o)}let c=s.providers;if(c!=null&&!a){let u=n;C0(c,l=>{e(l,u)})}}else return!1;return o!==n&&n.providers!==void 0}function C0(n,e){for(let t of n)u0(t)&&(t=t.\u0275providers),Array.isArray(t)?C0(t,e):e(t)}var Fj=Je({provide:String,useValue:Je});function d1(n){return n!==null&&typeof n=="object"&&Fj in n}function Oj(n){return!!(n&&n.useExisting)}function Mj(n){return!!(n&&n.useFactory)}function Ih(n){return typeof n=="function"}var Rd=new Ge(""),vh={},e1={},Yb;function Fd(){return Yb===void 0&&(Yb=new Nd),Yb}var ur=class{},ya=class extends ur{parent;source;scopes;records=new Map;_ngOnDestroyHooks=new Set;_onDestroyHooks=[];get destroyed(){return this._destroyed}_destroyed=!1;injectorDefTypes;constructor(e,t,r,o){super(),this.parent=t,this.source=r,this.scopes=o,r0(e,i=>this.processProvider(i)),this.records.set(x0,Ml(void 0,this)),o.has("environment")&&this.records.set(ur,Ml(void 0,this));let s=this.records.get(Rd);s!=null&&typeof s.value=="string"&&this.scopes.add(s.value),this.injectorDefTypes=new Set(this.get(y0,Dr,{self:!0}))}retrieve(e,t){let r=ga(t)||0;try{return this.get(e,ma,r)}catch(o){if(Tl(o))return o;throw o}}destroy(){Td(this),this._destroyed=!0;let e=$e(null);try{for(let r of this._ngOnDestroyHooks)r.ngOnDestroy();let t=this._onDestroyHooks;this._onDestroyHooks=[];for(let r of t)r()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),$e(e)}}onDestroy(e){return Td(this),this._onDestroyHooks.push(e),()=>this.removeOnDestroy(e)}runInContext(e){Td(this);let t=no(this),r=Tn(void 0),o;try{return e()}finally{no(t),Tn(r)}}get(e,t=ma,r){if(Td(this),e.hasOwnProperty(JD))return e[JD](this);let o=ga(r),s,i=no(this),a=Tn(void 0);try{if(!(o&4)){let u=this.records.get(e);if(u===void 0){let l=Vj(e)&&Sh(e);l&&this.injectableDefInScope(l)?u=Ml(n0(e),vh):u=null,this.records.set(e,u)}if(u!=null)return this.hydrate(e,u,o)}let c=o&2?Fd():this.parent;return t=o&8&&t===ma?null:t,c.get(e,t)}catch(c){let u=Sj(c);throw u===-200||u===-201?new Te(u,null):c}finally{Tn(a),no(i)}}resolveInjectorInitializers(){let e=$e(null),t=no(this),r=Tn(void 0),o;try{let s=this.get(ks,Dr,{self:!0});for(let i of s)i()}finally{no(t),Tn(r),$e(e)}}toString(){let e=[],t=this.records;for(let r of t.keys())e.push(ha(r));return`R3Injector[${e.join(", ")}]`}processProvider(e){e=er(e);let t=Ih(e)?e:er(e&&e.provide),r=Pj(e);if(!Ih(e)&&e.multi===!0){let o=this.records.get(t);o||(o=Ml(void 0,vh,!0),o.factory=()=>t0(o.multi),this.records.set(t,o)),t=e,o.multi.push(e)}this.records.set(t,r)}hydrate(e,t,r){let o=$e(null);try{if(t.value===e1)throw m0(ha(e));return t.value===vh&&(t.value=e1,t.value=t.factory(void 0,r)),typeof t.value=="object"&&t.value&&Bj(t.value)&&this._ngOnDestroyHooks.add(t.value),t.value}finally{$e(o)}}injectableDefInScope(e){if(!e.providedIn)return!1;let t=er(e.providedIn);return typeof t=="string"?t==="any"||this.scopes.has(t):this.injectorDefTypes.has(t)}removeOnDestroy(e){let t=this._onDestroyHooks.indexOf(e);t!==-1&&this._onDestroyHooks.splice(t,1)}};function n0(n){let e=Sh(n),t=e!==null?e.factory:xa(n);if(t!==null)return t;if(n instanceof Ge)throw new Te(204,!1);if(n instanceof Function)return $j(n);throw new Te(204,!1)}function $j(n){if(n.length>0)throw new Te(204,!1);let t=Ij(n);return t!==null?()=>t.factory(n):()=>new n}function Pj(n){if(d1(n))return Ml(void 0,n.useValue);{let e=f1(n);return Ml(e,vh)}}function f1(n,e,t){let r;if(Ih(n)){let o=er(n);return xa(o)||n0(o)}else if(d1(n))r=()=>er(n.useValue);else if(Mj(n))r=()=>n.useFactory(...t0(n.deps||[]));else if(Oj(n))r=(o,s)=>Xe(er(n.useExisting),s!==void 0&&s&8?8:void 0);else{let o=er(n&&(n.useClass||n.provide));if(Lj(n))r=()=>new o(...t0(n.deps));else return xa(o)||n0(o)}return r}function Td(n){if(n.destroyed)throw new Te(205,!1)}function Ml(n,e,t=!1){return{factory:n,value:e,multi:t?[]:void 0}}function Lj(n){return!!n.deps}function Bj(n){return n!==null&&typeof n=="object"&&typeof n.ngOnDestroy=="function"}function Vj(n){return typeof n=="function"||typeof n=="object"&&n.ngMetadataName==="InjectionToken"}function r0(n,e){for(let t of n)Array.isArray(t)?r0(t,e):t&&u0(t)?r0(t.\u0275providers,e):e(t)}function Ah(n,e){let t;n instanceof ya?(Td(n),t=n):t=new e0(n);let r,o=no(t),s=Tn(void 0);try{return e()}finally{no(o),Tn(s)}}function m1(){return s1()!==void 0||uh()!=null}var _r=0,Ie=1,we=2,Zt=3,lr=4,pr=5,Od=6,Pl=7,hn=8,Ia=9,oo=10,sn=11,Ll=12,w0=13,Ea=14,Ar=15,_s=16,Ta=17,so=18,Md=19,I0=20,Lo=21,Rh=22,Vo=23,tr=24,Fh=25,gn=26,h1=1;var As=7,$d=8,Sa=9,Sn=10;function Uo(n){return Array.isArray(n)&&typeof n[h1]=="object"}function Rr(n){return Array.isArray(n)&&n[h1]===!0}function E0(n){return(n.flags&4)!==0}function Na(n){return n.componentOffset>-1}function Pd(n){return(n.flags&1)===1}function Da(n){return!!n.template}function Bl(n){return(n[we]&512)!==0}function ka(n){return(n[we]&256)===256}var g1="svg",x1="math";function dr(n){for(;Array.isArray(n);)n=n[_r];return n}function y1(n,e){return dr(e[n])}function io(n,e){return dr(e[n.index])}function Oh(n,e){return n.data[e]}function v1(n,e){return n[e]}function T0(n,e,t,r){t>=n.data.length&&(n.data[t]=null,n.blueprint[t]=null),e[t]=r}function ao(n,e){let t=e[n];return Uo(t)?t:t[_r]}function b1(n){return(n[we]&4)===4}function Mh(n){return(n[we]&128)===128}function C1(n){return Rr(n[Zt])}function _a(n,e){return e==null?null:n[e]}function S0(n){n[Ta]=0}function N0(n){n[we]&1024||(n[we]|=1024,Mh(n)&&Aa(n))}function w1(n,e){for(;n>0;)e=e[Ea],n--;return e}function Ld(n){return!!(n[we]&9216||n[tr]?.dirty)}function $h(n){n[oo].changeDetectionScheduler?.notify(8),n[we]&64&&(n[we]|=1024),Ld(n)&&Aa(n)}function Aa(n){n[oo].changeDetectionScheduler?.notify(0);let e=Ds(n);for(;e!==null&&!(e[we]&8192||(e[we]|=8192,!Mh(e)));)e=Ds(e)}function D0(n,e){if(ka(n))throw new Te(911,!1);n[Lo]===null&&(n[Lo]=[]),n[Lo].push(e)}function I1(n,e){if(n[Lo]===null)return;let t=n[Lo].indexOf(e);t!==-1&&n[Lo].splice(t,1)}function Ds(n){let e=n[Zt];return Rr(e)?e[Zt]:e}function k0(n){return n[Pl]??=[]}function _0(n){return n.cleanup??=[]}function E1(n,e,t,r){let o=k0(e);o.push(t),n.firstCreatePass&&_0(n).push(r,o.length-1)}var We={lFrame:$1(null),bindingsEnabled:!0,skipHydrationRootTNode:null},Bd=(function(n){return n[n.Off=0]="Off",n[n.Exhaustive=1]="Exhaustive",n[n.OnlyDirtyViews=2]="OnlyDirtyViews",n})(Bd||{}),Uj=0,o0=!1;function T1(){return We.lFrame.elementDepthCount}function S1(){We.lFrame.elementDepthCount++}function A0(){We.lFrame.elementDepthCount--}function R0(){return We.bindingsEnabled}function N1(){return We.skipHydrationRootTNode!==null}function F0(n){return We.skipHydrationRootTNode===n}function O0(){We.skipHydrationRootTNode=null}function pt(){return We.lFrame.lView}function co(){return We.lFrame.tView}function uo(n){return We.lFrame.contextLView=n,n[hn]}function lo(n){return We.lFrame.contextLView=null,n}function fr(){let n=M0();for(;n!==null&&n.type===64;)n=n.parent;return n}function M0(){return We.lFrame.currentTNode}function D1(){let n=We.lFrame,e=n.currentTNode;return n.isParent?e:e.parent}function Vl(n,e){let t=We.lFrame;t.currentTNode=n,t.isParent=e}function $0(){return We.lFrame.isParent}function k1(){We.lFrame.isParent=!1}function P0(n){c0("Must never be called in production mode"),Uj=n}function L0(){return o0}function Ul(n){let e=o0;return o0=n,e}function _1(){let n=We.lFrame,e=n.bindingRootIndex;return e===-1&&(e=n.bindingRootIndex=n.tView.bindingStartIndex),e}function A1(n){return We.lFrame.bindingIndex=n}function B0(){return We.lFrame.bindingIndex++}function R1(){return We.lFrame.inI18n}function F1(n,e){let t=We.lFrame;t.bindingIndex=t.bindingRootIndex=n,Ph(e)}function O1(){return We.lFrame.currentDirectiveIndex}function Ph(n){We.lFrame.currentDirectiveIndex=n}function V0(){return We.lFrame.currentQueryIndex}function Lh(n){We.lFrame.currentQueryIndex=n}function zj(n){let e=n[Ie];return e.type===2?e.declTNode:e.type===1?n[pr]:null}function U0(n,e,t){if(t&4){let o=e,s=n;for(;o=o.parent,o===null&&!(t&1);)if(o=zj(s),o===null||(s=s[Ea],o.type&10))break;if(o===null)return!1;e=o,n=s}let r=We.lFrame=M1();return r.currentTNode=e,r.lView=n,!0}function Bh(n){let e=M1(),t=n[Ie];We.lFrame=e,e.currentTNode=t.firstChild,e.lView=n,e.tView=t,e.contextLView=n,e.bindingIndex=t.bindingStartIndex,e.inI18n=!1}function M1(){let n=We.lFrame,e=n===null?null:n.child;return e===null?$1(n):e}function $1(n){let e={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return n!==null&&(n.child=e),e}function P1(){let n=We.lFrame;return We.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}var z0=P1;function Vh(){let n=P1();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function L1(n){return(We.lFrame.contextLView=w1(n,We.lFrame.contextLView))[hn]}function Uh(){return We.lFrame.selectedIndex}function Rs(n){We.lFrame.selectedIndex=n}function B1(){let n=We.lFrame;return Oh(n.tView,n.selectedIndex)}function V1(){return We.lFrame.currentNamespace}var U1=!0;function zh(){return U1}function Hh(n){U1=n}var Hj={elements:void 0};function Gh(){return Hj}function s0(n,e=null,t=null,r){let o=z1(n,e,t,r);return o.resolveInjectorInitializers(),o}function z1(n,e=null,t=null,r,o=new Set){let s=[t||Dr,l1(n)];return r=r||(typeof n=="object"?void 0:ha(n)),new ya(s,e||Fd(),r||null,o)}var Bo=class n{static THROW_IF_NOT_FOUND=ma;static NULL=new Nd;static create(e,t){if(Array.isArray(e))return s0({name:""},t,e,"");{let r=e.name??"";return s0({name:r},e.parent,e.providers,r)}}static \u0275prov=Et({token:n,providedIn:"any",factory:()=>Xe(x0)});static __NG_ELEMENT_ID__=-1},mr=new Ge(""),Ra=(()=>{class n{static __NG_ELEMENT_ID__=Gj;static __NG_ENV_ID__=t=>t}return n})(),Dd=class extends Ra{_lView;constructor(e){super(),this._lView=e}get destroyed(){return ka(this._lView)}onDestroy(e){let t=this._lView;return D0(t,e),()=>I1(t,e)}};function Gj(){return new Dd(pt())}var kr=class{_console=console;handleError(e){this._console.error("ERROR",e)}},po=new Ge("",{providedIn:"root",factory:()=>{let n=Fe(ur),e;return t=>{n.destroyed&&!e?setTimeout(()=>{throw t}):(e??=n.get(kr),e.handleError(t))}}}),H1={provide:ks,useValue:()=>void Fe(kr),multi:!0},Wj=new Ge("",{providedIn:"root",factory:()=>{let n=Fe(mr).defaultView;if(!n)return;let e=Fe(po),t=s=>{e(s.reason),s.preventDefault()},r=s=>{s.error?e(s.error):e(new Error(s.message,{cause:s})),s.preventDefault()},o=()=>{n.addEventListener("unhandledrejection",t),n.addEventListener("error",r)};typeof Zone<"u"?Zone.root.run(o):o(),Fe(Ra).onDestroy(()=>{n.removeEventListener("error",r),n.removeEventListener("unhandledrejection",t)})}});function H0(){return Ad([u1(()=>void Fe(Wj))])}function Pn(n,e){let[t,r,o]=Vb(n,e?.equal),s=t,i=s[Mn];return s.set=r,s.update=o,s.asReadonly=G0.bind(s),s}function G0(){let n=this[Mn];if(n.readonlyFn===void 0){let e=()=>this();e[Mn]=n,n.readonlyFn=e}return n.readonlyFn}var ro=class{},Vd=new Ge("",{providedIn:"root",factory:()=>!1});var W0=new Ge(""),Wh=new Ge("");var Ud=(()=>{class n{view;node;constructor(t,r){this.view=t,this.node=r}static __NG_ELEMENT_ID__=jj}return n})();function jj(){return new Ud(pt(),fr())}var Fa=(()=>{class n{taskId=0;pendingTasks=new Set;destroyed=!1;pendingTask=new Ed(!1);get hasPendingTasks(){return this.destroyed?!1:this.pendingTask.value}get hasPendingTasksObservable(){return this.destroyed?new Ol(t=>{t.next(!1),t.complete()}):this.pendingTask}add(){!this.hasPendingTasks&&!this.destroyed&&this.pendingTask.next(!0);let t=this.taskId++;return this.pendingTasks.add(t),t}has(t){return this.pendingTasks.has(t)}remove(t){this.pendingTasks.delete(t),this.pendingTasks.size===0&&this.hasPendingTasks&&this.pendingTask.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this.hasPendingTasks&&this.pendingTask.next(!1),this.destroyed=!0,this.pendingTask.unsubscribe()}static \u0275prov=Et({token:n,providedIn:"root",factory:()=>new n})}return n})();function Oa(...n){}var zd=(()=>{class n{static \u0275prov=Et({token:n,providedIn:"root",factory:()=>new i0})}return n})(),i0=class{dirtyEffectCount=0;queues=new Map;add(e){this.enqueue(e),this.schedule(e)}schedule(e){e.dirty&&this.dirtyEffectCount++}remove(e){let t=e.zone,r=this.queues.get(t);r.has(e)&&(r.delete(e),e.dirty&&this.dirtyEffectCount--)}enqueue(e){let t=e.zone;this.queues.has(t)||this.queues.set(t,new Set);let r=this.queues.get(t);r.has(e)||r.add(e)}flush(){for(;this.dirtyEffectCount>0;){let e=!1;for(let[t,r]of this.queues)t===null?e||=this.flushQueue(r):e||=t.run(()=>this.flushQueue(r));e||(this.dirtyEffectCount=0)}}flushQueue(e){let t=!1;for(let r of e)r.dirty&&(this.dirtyEffectCount--,t=!0,r.run());return t}};function cg(n){return{toString:n}.toString()}function r5(n){return typeof n=="function"}var Yh=class{previousValue;currentValue;firstChange;constructor(e,t,r){this.previousValue=e,this.currentValue=t,this.firstChange=r}isFirstChange(){return this.firstChange}};function xk(n,e,t,r){e!==null?e.applyValueToInputSignal(e,r):n[t]=r}function o5(n){return n.type.prototype.ngOnChanges&&(n.setInput=i5),s5}function s5(){let n=vk(this),e=n?.current;if(e){let t=n.previous;if(t===Ca)n.previous=e;else for(let r in e)t[r]=e[r];n.current=null,this.ngOnChanges(e)}}function i5(n,e,t,r,o){let s=this.declaredInputs[r],i=vk(n)||a5(n,{previous:Ca,current:null}),a=i.current||(i.current={}),c=i.previous,u=c[s];a[s]=new Yh(u&&u.currentValue,t,c===Ca),xk(n,e,o,t)}var yk="__ngSimpleChanges__";function vk(n){return n[yk]||null}function a5(n,e){return n[yk]=e}var G1=[];var ot=function(n,e=null,t){for(let r=0;r<G1.length;r++){let o=G1[r];o(n,e,t)}};function c5(n,e,t){let{ngOnChanges:r,ngOnInit:o,ngDoCheck:s}=e.type.prototype;if(r){let i=o5(e);(t.preOrderHooks??=[]).push(n,i),(t.preOrderCheckHooks??=[]).push(n,i)}o&&(t.preOrderHooks??=[]).push(0-n,o),s&&((t.preOrderHooks??=[]).push(n,s),(t.preOrderCheckHooks??=[]).push(n,s))}function bk(n,e){for(let t=e.directiveStart,r=e.directiveEnd;t<r;t++){let s=n.data[t].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:c,ngAfterViewChecked:u,ngOnDestroy:l}=s;i&&(n.contentHooks??=[]).push(-t,i),a&&((n.contentHooks??=[]).push(t,a),(n.contentCheckHooks??=[]).push(t,a)),c&&(n.viewHooks??=[]).push(-t,c),u&&((n.viewHooks??=[]).push(t,u),(n.viewCheckHooks??=[]).push(t,u)),l!=null&&(n.destroyHooks??=[]).push(t,l)}}function jh(n,e,t){Ck(n,e,3,t)}function qh(n,e,t,r){(n[we]&3)===t&&Ck(n,e,t,r)}function j0(n,e){let t=n[we];(t&3)===e&&(t&=16383,t+=1,n[we]=t)}function Ck(n,e,t,r){let o=r!==void 0?n[Ta]&65535:0,s=r??-1,i=e.length-1,a=0;for(let c=o;c<i;c++)if(typeof e[c+1]=="number"){if(a=e[c],r!=null&&a>=r)break}else e[c]<0&&(n[Ta]+=65536),(a<s||s==-1)&&(u5(n,t,e,c),n[Ta]=(n[Ta]&4294901760)+c+2),c++}function W1(n,e){ot(4,n,e);let t=$e(null);try{e.call(n)}finally{$e(t),ot(5,n,e)}}function u5(n,e,t,r){let o=t[r]<0,s=t[r+1],i=o?-t[r]:t[r],a=n[i];o?n[we]>>14<n[Ta]>>16&&(n[we]&3)===e&&(n[we]+=16384,W1(a,s)):W1(a,s)}var Hl=-1,Wd=class{factory;name;injectImpl;resolving=!1;canSeeViewProviders;multi;componentProviders;index;providerFactory;constructor(e,t,r,o){this.factory=e,this.name=o,this.canSeeViewProviders=t,this.injectImpl=r}};function l5(n){return(n.flags&8)!==0}function p5(n){return(n.flags&16)!==0}function d5(n,e,t){let r=0;for(;r<t.length;){let o=t[r];if(typeof o=="number"){if(o!==0)break;r++;let s=t[r++],i=t[r++],a=t[r++];n.setAttribute(e,i,a,s)}else{let s=o,i=t[++r];m5(s)?n.setProperty(e,s,i):n.setAttribute(e,s,i),r++}}return r}function f5(n){return n===3||n===4||n===6}function m5(n){return n.charCodeAt(0)===64}function ug(n,e){if(!(e===null||e.length===0))if(n===null||n.length===0)n=e.slice();else{let t=-1;for(let r=0;r<e.length;r++){let o=e[r];typeof o=="number"?t=o:t===0||(t===-1||t===2?j1(n,t,o,null,e[++r]):j1(n,t,o,null,null))}}return n}function j1(n,e,t,r,o){let s=0,i=n.length;if(e===-1)i=-1;else for(;s<n.length;){let a=n[s++];if(typeof a=="number"){if(a===e){i=-1;break}else if(a>e){i=s-1;break}}}for(;s<n.length;){let a=n[s];if(typeof a=="number")break;if(a===t){o!==null&&(n[s+1]=o);return}s++,o!==null&&s++}i!==-1&&(n.splice(i,0,e),s=i+1),n.splice(s++,0,t),o!==null&&n.splice(s++,0,o)}function wk(n){return n!==Hl}function Zh(n){return n&32767}function h5(n){return n>>16}function Qh(n,e){let t=h5(n),r=e;for(;t>0;)r=r[Ea],t--;return r}var Q0=!0;function Jh(n){let e=Q0;return Q0=n,e}var g5=256,Ik=g5-1,Ek=5,x5=0,fo={};function y5(n,e,t){let r;typeof t=="string"?r=t.charCodeAt(0)||0:t.hasOwnProperty(ba)&&(r=t[ba]),r==null&&(r=t[ba]=x5++);let o=r&Ik,s=1<<o;e.data[n+(o>>Ek)]|=s}function Tk(n,e){let t=Sk(n,e);if(t!==-1)return t;let r=e[Ie];r.firstCreatePass&&(n.injectorIndex=e.length,q0(r.data,n),q0(e,null),q0(r.blueprint,null));let o=yC(n,e),s=n.injectorIndex;if(wk(o)){let i=Zh(o),a=Qh(o,e),c=a[Ie].data;for(let u=0;u<8;u++)e[s+u]=a[i+u]|c[i+u]}return e[s+8]=o,s}function q0(n,e){n.push(0,0,0,0,0,0,0,0,e)}function Sk(n,e){return n.injectorIndex===-1||n.parent&&n.parent.injectorIndex===n.injectorIndex||e[n.injectorIndex+8]===null?-1:n.injectorIndex}function yC(n,e){if(n.parent&&n.parent.injectorIndex!==-1)return n.parent.injectorIndex;let t=0,r=null,o=e;for(;o!==null;){if(r=Ak(o),r===null)return Hl;if(t++,o=o[Ea],r.injectorIndex!==-1)return r.injectorIndex|t<<16}return Hl}function v5(n,e,t){y5(n,e,t)}function Nk(n,e,t){if(t&8||n!==void 0)return n;kh(e,"NodeInjector")}function Dk(n,e,t,r){if(t&8&&r===void 0&&(r=null),(t&3)===0){let o=n[Ia],s=Tn(void 0);try{return o?o.get(e,r,t&8):h0(e,r,t&8)}finally{Tn(s)}}return Nk(r,e,t)}function kk(n,e,t,r=0,o){if(n!==null){if(e[we]&2048&&!(r&2)){let i=I5(n,e,t,r,fo);if(i!==fo)return i}let s=_k(n,e,t,r,fo);if(s!==fo)return s}return Dk(e,t,r,o)}function _k(n,e,t,r,o){let s=C5(t);if(typeof s=="function"){if(!U0(e,n,r))return r&1?Nk(o,t,r):Dk(e,t,r,o);try{let i;if(i=s(r),i==null&&!(r&8))kh(t);else return i}finally{z0()}}else if(typeof s=="number"){let i=null,a=Sk(n,e),c=Hl,u=r&1?e[Ar][pr]:null;for((a===-1||r&4)&&(c=a===-1?yC(n,e):e[a+8],c===Hl||!K1(r,!1)?a=-1:(i=e[Ie],a=Zh(c),e=Qh(c,e)));a!==-1;){let l=e[Ie];if(q1(s,a,l.data)){let p=b5(a,e,t,i,r,u);if(p!==fo)return p}c=e[a+8],c!==Hl&&K1(r,e[Ie].data[a+8]===u)&&q1(s,a,e)?(i=l,a=Zh(c),e=Qh(c,e)):a=-1}}return o}function b5(n,e,t,r,o,s){let i=e[Ie],a=i.data[n+8],c=r==null?Na(a)&&Q0:r!=i&&(a.type&3)!==0,u=o&1&&s===a,l=Kh(a,i,t,c,u);return l!==null?eg(e,i,l,a,o):fo}function Kh(n,e,t,r,o){let s=n.providerIndexes,i=e.data,a=s&1048575,c=n.directiveStart,u=n.directiveEnd,l=s>>20,p=r?a:a+l,d=o?a+l:u;for(let f=p;f<d;f++){let m=i[f];if(f<c&&t===m||f>=c&&m.type===t)return f}if(o){let f=i[c];if(f&&Da(f)&&f.type===t)return c}return null}function eg(n,e,t,r,o){let s=n[t],i=e.data;if(s instanceof Wd){let a=s;if(a.resolving){let f=Ch(i[t]);throw m0(f)}let c=Jh(a.canSeeViewProviders);a.resolving=!0;let u=i[t].type||i[t],l,p=a.injectImpl?Tn(a.injectImpl):null,d=U0(n,r,0);try{s=n[t]=a.factory(void 0,o,i,n,r),e.firstCreatePass&&t>=r.directiveStart&&c5(t,i[t],e)}finally{p!==null&&Tn(p),Jh(c),a.resolving=!1,z0()}}return s}function C5(n){if(typeof n=="string")return n.charCodeAt(0)||0;let e=n.hasOwnProperty(ba)?n[ba]:void 0;return typeof e=="number"?e>=0?e&Ik:w5:e}function q1(n,e,t){let r=1<<n;return!!(t[e+(n>>Ek)]&r)}function K1(n,e){return!(n&2)&&!(n&1&&e)}var $a=class{_tNode;_lView;constructor(e,t){this._tNode=e,this._lView=t}get(e,t,r){return kk(this._tNode,this._lView,e,ga(r),t)}};function w5(){return new $a(fr(),pt())}function I5(n,e,t,r,o){let s=n,i=e;for(;s!==null&&i!==null&&i[we]&2048&&!Bl(i);){let a=_k(s,i,t,r|2,fo);if(a!==fo)return a;let c=s.parent;if(!c){let u=i[I0];if(u){let l=u.get(t,fo,r);if(l!==fo)return l}c=Ak(i),i=i[Ea]}s=c}return o}function Ak(n){let e=n[Ie],t=e.type;return t===2?e.declTNode:t===1?n[pr]:null}function E5(){return jl(fr(),pt())}function jl(n,e){return new ql(io(n,e))}var ql=(()=>{class n{nativeElement;constructor(t){this.nativeElement=t}static __NG_ELEMENT_ID__=E5}return n})();function T5(n){return n instanceof ql?n.nativeElement:n}function S5(){return this._results[Symbol.iterator]()}var tg=class{_emitDistinctChangesOnly;dirty=!0;_onDirty=void 0;_results=[];_changesDetected=!1;_changes=void 0;length=0;first=void 0;last=void 0;get changes(){return this._changes??=new Ns}constructor(e=!1){this._emitDistinctChangesOnly=e}get(e){return this._results[e]}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,t){return this._results.reduce(e,t)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e,t){this.dirty=!1;let r=a1(e);(this._changesDetected=!i1(this._results,r,t))&&(this._results=r,this.length=r.length,this.last=r[this.length-1],this.first=r[0])}notifyOnChanges(){this._changes!==void 0&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.next(this)}onDirty(e){this._onDirty=e}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){this._changes!==void 0&&(this._changes.complete(),this._changes.unsubscribe())}[Symbol.iterator]=S5};function Rk(n){return(n.flags&128)===128}var vC=(function(n){return n[n.OnPush=0]="OnPush",n[n.Default=1]="Default",n})(vC||{}),Fk=new Map,N5=0;function D5(){return N5++}function k5(n){Fk.set(n[Md],n)}function J0(n){Fk.delete(n[Md])}var X1="__ngContext__";function Gl(n,e){Uo(e)?(n[X1]=e[Md],k5(e)):n[X1]=e}function Ok(n){return $k(n[Ll])}function Mk(n){return $k(n[lr])}function $k(n){for(;n!==null&&!Rr(n);)n=n[lr];return n}var eC;function bC(n){eC=n}function Pk(){if(eC!==void 0)return eC;if(typeof document<"u")return document;throw new Te(210,!1)}var lg=new Ge("",{providedIn:"root",factory:()=>_5}),_5="ng",pg=new Ge(""),Kl=new Ge("",{providedIn:"platform",factory:()=>"unknown"});var dg=new Ge("",{providedIn:"root",factory:()=>Pk().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});var A5="h",R5="b";var Lk=!1,Bk=new Ge("",{providedIn:"root",factory:()=>Lk});var F5=(n,e,t,r)=>{};function O5(n,e,t,r){F5(n,e,t,r)}function CC(n){return(n.flags&32)===32}var M5=()=>null;function Vk(n,e,t=!1){return M5(n,e,t)}function Uk(n,e){let t=n.contentQueries;if(t!==null){let r=$e(null);try{for(let o=0;o<t.length;o+=2){let s=t[o],i=t[o+1];if(i!==-1){let a=n.data[i];Lh(s),a.contentQueries(2,e[i],i)}}}finally{$e(r)}}}function tC(n,e,t){Lh(0);let r=$e(null);try{e(n,t)}finally{$e(r)}}function zk(n,e,t){if(E0(e)){let r=$e(null);try{let o=e.directiveStart,s=e.directiveEnd;for(let i=o;i<s;i++){let a=n.data[i];if(a.contentQueries){let c=t[i];a.contentQueries(1,c,i)}}}finally{$e(r)}}}var Ho=(function(n){return n[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",n})(Ho||{});var ng=class{changingThisBreaksApplicationSecurity;constructor(e){this.changingThisBreaksApplicationSecurity=e}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Eh})`}};function Hk(n){return n instanceof ng?n.changingThisBreaksApplicationSecurity:n}function Gk(n,e){let t=Wk(n);if(t!=null&&t!==e){if(t==="ResourceURL"&&e==="URL")return!0;throw new Error(`Required a safe ${e}, got a ${t} (see ${Eh})`)}return t===e}function Wk(n){return n instanceof ng&&n.getTypeName()||null}var $5=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;function jk(n){return n=String(n),n.match($5)?n:"unsafe:"+n}var wC=(function(n){return n[n.NONE=0]="NONE",n[n.HTML=1]="HTML",n[n.STYLE=2]="STYLE",n[n.SCRIPT=3]="SCRIPT",n[n.URL=4]="URL",n[n.RESOURCE_URL=5]="RESOURCE_URL",n})(wC||{});function IC(n){let e=P5();return e?e.sanitize(wC.URL,n)||"":Gk(n,"URL")?Hk(n):jk(Dh(n))}function P5(){let n=pt();return n&&n[oo].sanitizer}function L5(n,e,t){let r=n.length;for(;;){let o=n.indexOf(e,t);if(o===-1)return o;if(o===0||n.charCodeAt(o-1)<=32){let s=e.length;if(o+s===r||n.charCodeAt(o+s)<=32)return o}t=o+1}}var qk="ng-template";function B5(n,e,t,r){let o=0;if(r){for(;o<e.length&&typeof e[o]=="string";o+=2)if(e[o]==="class"&&L5(e[o+1].toLowerCase(),t,0)!==-1)return!0}else if(EC(n))return!1;if(o=e.indexOf(1,o),o>-1){let s;for(;++o<e.length&&typeof(s=e[o])=="string";)if(s.toLowerCase()===t)return!0}return!1}function EC(n){return n.type===4&&n.value!==qk}function V5(n,e,t){let r=n.type===4&&!t?qk:n.value;return e===r}function U5(n,e,t){let r=4,o=n.attrs,s=o!==null?G5(o):0,i=!1;for(let a=0;a<e.length;a++){let c=e[a];if(typeof c=="number"){if(!i&&!Fr(r)&&!Fr(c))return!1;if(i&&Fr(c))continue;i=!1,r=c|r&1;continue}if(!i)if(r&4){if(r=2|r&1,c!==""&&!V5(n,c,t)||c===""&&e.length===1){if(Fr(r))return!1;i=!0}}else if(r&8){if(o===null||!B5(n,o,c,t)){if(Fr(r))return!1;i=!0}}else{let u=e[++a],l=z5(c,o,EC(n),t);if(l===-1){if(Fr(r))return!1;i=!0;continue}if(u!==""){let p;if(l>s?p="":p=o[l+1].toLowerCase(),r&2&&u!==p){if(Fr(r))return!1;i=!0}}}}return Fr(r)||i}function Fr(n){return(n&1)===0}function z5(n,e,t,r){if(e===null)return-1;let o=0;if(r||!t){let s=!1;for(;o<e.length;){let i=e[o];if(i===n)return o;if(i===3||i===6)s=!0;else if(i===1||i===2){let a=e[++o];for(;typeof a=="string";)a=e[++o];continue}else{if(i===4)break;if(i===0){o+=4;continue}}o+=s?1:2}return-1}else return W5(e,n)}function H5(n,e,t=!1){for(let r=0;r<e.length;r++)if(U5(n,e[r],t))return!0;return!1}function G5(n){for(let e=0;e<n.length;e++){let t=n[e];if(f5(t))return e}return n.length}function W5(n,e){let t=n.indexOf(4);if(t>-1)for(t++;t<n.length;){let r=n[t];if(typeof r=="number")return-1;if(r===e)return t;t++}return-1}function Y1(n,e){return n?":not("+e.trim()+")":e}function j5(n){let e=n[0],t=1,r=2,o="",s=!1;for(;t<n.length;){let i=n[t];if(typeof i=="string")if(r&2){let a=n[++t];o+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else r&8?o+="."+i:r&4&&(o+=" "+i);else o!==""&&!Fr(i)&&(e+=Y1(s,o),o=""),r=i,s=s||!Fr(r);t++}return o!==""&&(e+=Y1(s,o)),e}function q5(n){return n.map(j5).join(",")}function K5(n){let e=[],t=[],r=1,o=2;for(;r<n.length;){let s=n[r];if(typeof s=="string")o===2?s!==""&&e.push(s,n[++r]):o===8&&t.push(s);else{if(!Fr(o))break;o=s}r++}return t.length&&e.push(1,...t),e}var Ba={};function X5(n,e){return n.createText(e)}function Y5(n,e,t){n.setValue(e,t)}function Kk(n,e,t){return n.createElement(e,t)}function rg(n,e,t,r,o){n.insertBefore(e,t,r,o)}function Xk(n,e,t){n.appendChild(e,t)}function Z1(n,e,t,r,o){r!==null?rg(n,e,t,r,o):Xk(n,e,t)}function Z5(n,e,t){n.removeChild(null,e,t)}function Q5(n,e,t){n.setAttribute(e,"style",t)}function J5(n,e,t){t===""?n.removeAttribute(e,"class"):n.setAttribute(e,"class",t)}function Yk(n,e,t){let{mergedAttrs:r,classes:o,styles:s}=t;r!==null&&d5(n,e,r),o!==null&&J5(n,e,o),s!==null&&Q5(n,e,s)}function TC(n,e,t,r,o,s,i,a,c,u,l){let p=gn+r,d=p+o,f=e8(p,d),m=typeof u=="function"?u():u;return f[Ie]={type:n,blueprint:f,template:t,queries:null,viewQuery:a,declTNode:e,data:f.slice().fill(null,p),bindingStartIndex:p,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:typeof s=="function"?s():s,pipeRegistry:typeof i=="function"?i():i,firstChild:null,schemas:c,consts:m,incompleteFirstPass:!1,ssrId:l}}function e8(n,e){let t=[];for(let r=0;r<e;r++)t.push(r<n?null:Ba);return t}function t8(n){let e=n.tView;return e===null||e.incompleteFirstPass?n.tView=TC(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts,n.id):e}function SC(n,e,t,r,o,s,i,a,c,u,l){let p=e.blueprint.slice();return p[_r]=o,p[we]=r|4|128|8|64|1024,(u!==null||n&&n[we]&2048)&&(p[we]|=2048),S0(p),p[Zt]=p[Ea]=n,p[hn]=t,p[oo]=i||n&&n[oo],p[sn]=a||n&&n[sn],p[Ia]=c||n&&n[Ia]||null,p[pr]=s,p[Md]=D5(),p[Od]=l,p[I0]=u,p[Ar]=e.type==2?n[Ar]:p,p}function n8(n,e,t){let r=io(e,n),o=t8(t),s=n[oo].rendererFactory,i=NC(n,SC(n,o,null,Zk(t),r,e,null,s.createRenderer(r,t),null,null,null));return n[e.index]=i}function Zk(n){let e=16;return n.signals?e=4096:n.onPush&&(e=64),e}function Qk(n,e,t,r){if(t===0)return-1;let o=e.length;for(let s=0;s<t;s++)e.push(r),n.blueprint.push(r),n.data.push(null);return o}function NC(n,e){return n[Ll]?n[w0][lr]=e:n[Ll]=e,n[w0]=e,e}function Ln(n=1){Jk(co(),pt(),Uh()+n,!1)}function Jk(n,e,t,r){if(!r)if((e[we]&3)===3){let s=n.preOrderCheckHooks;s!==null&&jh(e,s,t)}else{let s=n.preOrderHooks;s!==null&&qh(e,s,0,t)}Rs(t)}var fg=(function(n){return n[n.None=0]="None",n[n.SignalBased=1]="SignalBased",n[n.HasDecoratorInputTransform=2]="HasDecoratorInputTransform",n})(fg||{});function nC(n,e,t,r){let o=$e(null);try{let[s,i,a]=n.inputs[t],c=null;(i&fg.SignalBased)!==0&&(c=e[s][Mn]),c!==null&&c.transformFn!==void 0?r=c.transformFn(r):a!==null&&(r=a.call(e,r)),n.setInput!==null?n.setInput(e,c,r,t,s):xk(e,c,s,r)}finally{$e(o)}}var Fs=(function(n){return n[n.Important=1]="Important",n[n.DashCase=2]="DashCase",n})(Fs||{}),r8;function DC(n,e){return r8(n,e)}function zl(n,e,t,r,o){if(r!=null){let s,i=!1;Rr(r)?s=r:Uo(r)&&(i=!0,r=r[_r]);let a=dr(r);n===0&&t!==null?o==null?Xk(e,t,a):rg(e,t,a,o||null,!0):n===1&&t!==null?rg(e,t,a,o||null,!0):n===2?Z5(e,a,i):n===3&&e.destroyNode(a),s!=null&&h8(e,n,s,t,o)}}function o8(n,e){e_(n,e),e[_r]=null,e[pr]=null}function s8(n,e,t,r,o,s){r[_r]=o,r[pr]=e,mg(n,r,t,1,o,s)}function e_(n,e){e[oo].changeDetectionScheduler?.notify(9),mg(n,e,e[sn],2,null,null)}function i8(n){let e=n[Ll];if(!e)return K0(n[Ie],n);for(;e;){let t=null;if(Uo(e))t=e[Ll];else{let r=e[Sn];r&&(t=r)}if(!t){for(;e&&!e[lr]&&e!==n;)Uo(e)&&K0(e[Ie],e),e=e[Zt];e===null&&(e=n),Uo(e)&&K0(e[Ie],e),t=e&&e[lr]}e=t}}function kC(n,e){let t=n[Sa],r=t.indexOf(e);t.splice(r,1)}function t_(n,e){if(ka(e))return;let t=e[sn];t.destroyNode&&mg(n,e,t,3,null,null),i8(e)}function K0(n,e){if(ka(e))return;let t=$e(null);try{e[we]&=-129,e[we]|=256,e[tr]&&pa(e[tr]),c8(n,e),a8(n,e),e[Ie].type===1&&e[sn].destroy();let r=e[_s];if(r!==null&&Rr(e[Zt])){r!==e[Zt]&&kC(r,e);let o=e[so];o!==null&&o.detachView(n)}J0(e)}finally{$e(t)}}function a8(n,e){let t=n.cleanup,r=e[Pl];if(t!==null)for(let i=0;i<t.length-1;i+=2)if(typeof t[i]=="string"){let a=t[i+3];a>=0?r[a]():r[-a].unsubscribe(),i+=2}else{let a=r[t[i+1]];t[i].call(a)}r!==null&&(e[Pl]=null);let o=e[Lo];if(o!==null){e[Lo]=null;for(let i=0;i<o.length;i++){let a=o[i];a()}}let s=e[Vo];if(s!==null){e[Vo]=null;for(let i of s)i.destroy()}}function c8(n,e){let t;if(n!=null&&(t=n.destroyHooks)!=null)for(let r=0;r<t.length;r+=2){let o=e[t[r]];if(!(o instanceof Wd)){let s=t[r+1];if(Array.isArray(s))for(let i=0;i<s.length;i+=2){let a=o[s[i]],c=s[i+1];ot(4,a,c);try{c.call(a)}finally{ot(5,a,c)}}else{ot(4,o,s);try{s.call(o)}finally{ot(5,o,s)}}}}}function u8(n,e,t){return l8(n,e.parent,t)}function l8(n,e,t){let r=e;for(;r!==null&&r.type&168;)e=r,r=e.parent;if(r===null)return t[_r];if(Na(r)){let{encapsulation:o}=n.data[r.directiveStart+r.componentOffset];if(o===Ho.None||o===Ho.Emulated)return null}return io(r,t)}function p8(n,e,t){return f8(n,e,t)}function d8(n,e,t){return n.type&40?io(n,t):null}var f8=d8,Q1;function _C(n,e,t,r){let o=u8(n,r,e),s=e[sn],i=r.parent||e[pr],a=p8(i,r,e);if(o!=null)if(Array.isArray(t))for(let c=0;c<t.length;c++)Z1(s,o,t[c],a,!1);else Z1(s,o,t,a,!1);Q1!==void 0&&Q1(s,r,e,t,o)}function Hd(n,e){if(e!==null){let t=e.type;if(t&3)return io(e,n);if(t&4)return rC(-1,n[e.index]);if(t&8){let r=e.child;if(r!==null)return Hd(n,r);{let o=n[e.index];return Rr(o)?rC(-1,o):dr(o)}}else{if(t&128)return Hd(n,e.next);if(t&32)return DC(e,n)()||dr(n[e.index]);{let r=n_(n,e);if(r!==null){if(Array.isArray(r))return r[0];let o=Ds(n[Ar]);return Hd(o,r)}else return Hd(n,e.next)}}}return null}function n_(n,e){if(e!==null){let r=n[Ar][pr],o=e.projection;return r.projection[o]}return null}function rC(n,e){let t=Sn+n+1;if(t<e.length){let r=e[t],o=r[Ie].firstChild;if(o!==null)return Hd(r,o)}return e[As]}function AC(n,e,t,r,o,s,i){for(;t!=null;){if(t.type===128){t=t.next;continue}let a=r[t.index],c=t.type;if(i&&e===0&&(a&&Gl(dr(a),r),t.flags|=2),!CC(t))if(c&8)AC(n,e,t.child,r,o,s,!1),zl(e,n,o,a,s);else if(c&32){let u=DC(t,r),l;for(;l=u();)zl(e,n,o,l,s);zl(e,n,o,a,s)}else c&16?m8(n,e,r,t,o,s):zl(e,n,o,a,s);t=i?t.projectionNext:t.next}}function mg(n,e,t,r,o,s){AC(t,r,n.firstChild,e,o,s,!1)}function m8(n,e,t,r,o,s){let i=t[Ar],c=i[pr].projection[r.projection];if(Array.isArray(c))for(let u=0;u<c.length;u++){let l=c[u];zl(e,n,o,l,s)}else{let u=c,l=i[Zt];Rk(r)&&(u.flags|=128),AC(n,e,u,l,o,s,!0)}}function h8(n,e,t,r,o){let s=t[As],i=dr(t);s!==i&&zl(e,n,r,s,o);for(let a=Sn;a<t.length;a++){let c=t[a];mg(c[Ie],c,n,e,r,s)}}function r_(n,e,t,r,o){let s=Uh(),i=r&2;try{Rs(-1),i&&e.length>gn&&Jk(n,e,gn,!1),ot(i?2:0,o,t),t(r,o)}finally{Rs(s),ot(i?3:1,o,t)}}function RC(n,e,t){I8(n,e,t),(t.flags&64)===64&&E8(n,e,t)}function FC(n,e,t=io){let r=e.localNames;if(r!==null){let o=e.index+1;for(let s=0;s<r.length;s+=2){let i=r[s+1],a=i===-1?t(e,n):n[i];n[o++]=a}}}function g8(n,e,t,r){let s=r.get(Bk,Lk)||t===Ho.ShadowDom,i=n.selectRootElement(e,s);return x8(i),i}function x8(n){y8(n)}var y8=()=>null;function v8(n){return n==="class"?"className":n==="for"?"htmlFor":n==="formaction"?"formAction":n==="innerHtml"?"innerHTML":n==="readonly"?"readOnly":n==="tabindex"?"tabIndex":n}function b8(n,e,t,r,o,s){let i=e[Ie];if(OC(n,i,e,t,r)){Na(n)&&w8(e,n.index);return}n.type&3&&(t=v8(t)),C8(n,e,t,r,o,s)}function C8(n,e,t,r,o,s){if(n.type&3){let i=io(n,e);r=s!=null?s(r,n.value||"",t):r,o.setProperty(i,t,r)}else n.type&12}function w8(n,e){let t=ao(e,n);t[we]&16||(t[we]|=64)}function I8(n,e,t){let r=t.directiveStart,o=t.directiveEnd;Na(t)&&n8(e,t,n.data[r+t.componentOffset]),n.firstCreatePass||Tk(t,e);let s=t.initialInputs;for(let i=r;i<o;i++){let a=n.data[i],c=eg(e,n,i,t);if(Gl(c,e),s!==null&&S8(e,i-r,c,a,t,s),Da(a)){let u=ao(t.index,e);u[hn]=eg(e,n,i,t)}}}function E8(n,e,t){let r=t.directiveStart,o=t.directiveEnd,s=t.index,i=O1();try{Rs(s);for(let a=r;a<o;a++){let c=n.data[a],u=e[a];Ph(a),(c.hostBindings!==null||c.hostVars!==0||c.hostAttrs!==null)&&T8(c,u)}}finally{Rs(-1),Ph(i)}}function T8(n,e){n.hostBindings!==null&&n.hostBindings(1,e)}function o_(n,e){let t=n.directiveRegistry,r=null;if(t)for(let o=0;o<t.length;o++){let s=t[o];H5(e,s.selectors,!1)&&(r??=[],Da(s)?r.unshift(s):r.push(s))}return r}function S8(n,e,t,r,o,s){let i=s[e];if(i!==null)for(let a=0;a<i.length;a+=2){let c=i[a],u=i[a+1];nC(r,t,c,u)}}function s_(n,e,t,r,o){let s=gn+t,i=e[Ie],a=o(i,e,n,r,t);e[s]=a,Vl(n,!0);let c=n.type===2;return c?(Yk(e[sn],a,n),(T1()===0||Pd(n))&&Gl(a,e),S1()):Gl(a,e),zh()&&(!c||!CC(n))&&_C(i,e,a,n),n}function i_(n){let e=n;return $0()?k1():(e=e.parent,Vl(e,!1)),e}function N8(n,e){let t=n[Ia];if(!t)return;let r;try{r=t.get(po,null)}catch{r=null}r?.(e)}function OC(n,e,t,r,o){let s=n.inputs?.[r],i=n.hostDirectiveInputs?.[r],a=!1;if(i)for(let c=0;c<i.length;c+=2){let u=i[c],l=i[c+1],p=e.data[u];nC(p,t[u],l,o),a=!0}if(s)for(let c of s){let u=t[c],l=e.data[c];nC(l,u,r,o),a=!0}return a}function D8(n,e){let t=ao(e,n),r=t[Ie];k8(r,t);let o=t[_r];o!==null&&t[Od]===null&&(t[Od]=Vk(o,t[Ia])),ot(18),MC(r,t,t[hn]),ot(19,t[hn])}function k8(n,e){for(let t=e.length;t<n.blueprint.length;t++)e.push(n.blueprint[t])}function MC(n,e,t){Bh(e);try{let r=n.viewQuery;r!==null&&tC(1,r,t);let o=n.template;o!==null&&r_(n,e,o,1,t),n.firstCreatePass&&(n.firstCreatePass=!1),e[so]?.finishViewCreation(n),n.staticContentQueries&&Uk(n,e),n.staticViewQueries&&tC(2,n.viewQuery,t);let s=n.components;s!==null&&_8(e,s)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{e[we]&=-5,Vh()}}function _8(n,e){for(let t=0;t<e.length;t++)D8(n,e[t])}function A8(n,e,t,r){let o=$e(null);try{let s=e.tView,a=n[we]&4096?4096:16,c=SC(n,s,t,a,null,e,null,null,r?.injector??null,r?.embeddedViewInjector??null,r?.dehydratedView??null),u=n[e.index];c[_s]=u;let l=n[so];return l!==null&&(c[so]=l.createEmbeddedView(s)),MC(s,c,t),c}finally{$e(o)}}function J1(n,e){return!e||e.firstChild===null||Rk(n)}var ek=!1,R8=new Ge("");function jd(n,e,t,r,o=!1){for(;t!==null;){if(t.type===128){t=o?t.projectionNext:t.next;continue}let s=e[t.index];s!==null&&r.push(dr(s)),Rr(s)&&a_(s,r);let i=t.type;if(i&8)jd(n,e,t.child,r);else if(i&32){let a=DC(t,e),c;for(;c=a();)r.push(c)}else if(i&16){let a=n_(e,t);if(Array.isArray(a))r.push(...a);else{let c=Ds(e[Ar]);jd(c[Ie],c,a,r,!0)}}t=o?t.projectionNext:t.next}return r}function a_(n,e){for(let t=Sn;t<n.length;t++){let r=n[t],o=r[Ie].firstChild;o!==null&&jd(r[Ie],r,o,e)}n[As]!==n[_r]&&e.push(n[As])}function c_(n){if(n[Fh]!==null){for(let e of n[Fh])e.impl.addSequence(e);n[Fh].length=0}}var u_=[];function F8(n){return n[tr]??O8(n)}function O8(n){let e=u_.pop()??Object.create($8);return e.lView=n,e}function M8(n){n.lView[tr]!==n&&(n.lView=null,u_.push(n))}var $8=Yt(Ft({},Sl),{consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:n=>{Aa(n.lView)},consumerOnSignalRead(){this.lView[tr]=this}});function P8(n){let e=n[tr]??Object.create(L8);return e.lView=n,e}var L8=Yt(Ft({},Sl),{consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:n=>{let e=Ds(n.lView);for(;e&&!l_(e[Ie]);)e=Ds(e);e&&N0(e)},consumerOnSignalRead(){this.lView[tr]=this}});function l_(n){return n.type!==2}function p_(n){if(n[Vo]===null)return;let e=!0;for(;e;){let t=!1;for(let r of n[Vo])r.dirty&&(t=!0,r.zone===null||Zone.current===r.zone?r.run():r.zone.run(()=>r.run()));e=t&&!!(n[we]&8192)}}var B8=100;function $C(n,e=0){let r=n[oo].rendererFactory,o=!1;o||r.begin?.();try{V8(n,e)}finally{o||r.end?.()}}function V8(n,e){let t=L0();try{Ul(!0),oC(n,e);let r=0;for(;Ld(n);){if(r===B8)throw new Te(103,!1);r++,oC(n,1)}}finally{Ul(t)}}function d_(n,e){P0(e?Bd.Exhaustive:Bd.OnlyDirtyViews);try{$C(n)}finally{P0(Bd.Off)}}function U8(n,e,t,r){if(ka(e))return;let o=e[we],s=!1,i=!1;Bh(e);let a=!0,c=null,u=null;s||(l_(n)?(u=F8(e),c=Nl(u)):dh()===null?(a=!1,u=P8(e),c=Nl(u)):e[tr]&&(pa(e[tr]),e[tr]=null));try{S0(e),A1(n.bindingStartIndex),t!==null&&r_(n,e,t,2,r);let l=(o&3)===3;if(!s)if(l){let f=n.preOrderCheckHooks;f!==null&&jh(e,f,null)}else{let f=n.preOrderHooks;f!==null&&qh(e,f,0,null),j0(e,0)}if(i||z8(e),p_(e),f_(e,0),n.contentQueries!==null&&Uk(n,e),!s)if(l){let f=n.contentCheckHooks;f!==null&&jh(e,f)}else{let f=n.contentHooks;f!==null&&qh(e,f,1),j0(e,1)}G8(n,e);let p=n.components;p!==null&&h_(e,p,0);let d=n.viewQuery;if(d!==null&&tC(2,d,r),!s)if(l){let f=n.viewCheckHooks;f!==null&&jh(e,f)}else{let f=n.viewHooks;f!==null&&qh(e,f,2),j0(e,2)}if(n.firstUpdatePass===!0&&(n.firstUpdatePass=!1),e[Rh]){for(let f of e[Rh])f();e[Rh]=null}s||(c_(e),e[we]&=-73)}catch(l){throw s||Aa(e),l}finally{u!==null&&(wd(u,c),a&&M8(u)),Vh()}}function f_(n,e){for(let t=Ok(n);t!==null;t=Mk(t))for(let r=Sn;r<t.length;r++){let o=t[r];m_(o,e)}}function z8(n){for(let e=Ok(n);e!==null;e=Mk(e)){if(!(e[we]&2))continue;let t=e[Sa];for(let r=0;r<t.length;r++){let o=t[r];N0(o)}}}function H8(n,e,t){ot(18);let r=ao(e,n);m_(r,t),ot(19,r[hn])}function m_(n,e){Mh(n)&&oC(n,e)}function oC(n,e){let r=n[Ie],o=n[we],s=n[tr],i=!!(e===0&&o&16);if(i||=!!(o&64&&e===0),i||=!!(o&1024),i||=!!(s?.dirty&&Dl(s)),i||=!1,s&&(s.dirty=!1),n[we]&=-9217,i)U8(r,n,r.template,n[hn]);else if(o&8192){let a=$e(null);try{p_(n),f_(n,1);let c=r.components;c!==null&&h_(n,c,1),c_(n)}finally{$e(a)}}}function h_(n,e,t){for(let r=0;r<e.length;r++)H8(n,e[r],t)}function G8(n,e){let t=n.hostBindingOpCodes;if(t!==null)try{for(let r=0;r<t.length;r++){let o=t[r];if(o<0)Rs(~o);else{let s=o,i=t[++r],a=t[++r];F1(i,s);let c=e[s];ot(24,c),a(2,c),ot(25,c)}}}finally{Rs(-1)}}function PC(n,e){let t=L0()?64:1088;for(n[oo].changeDetectionScheduler?.notify(e);n;){n[we]|=t;let r=Ds(n);if(Bl(n)&&!r)return n;n=r}return null}function g_(n,e,t,r){return[n,!0,0,e,null,r,null,t,null,null]}function W8(n,e,t,r=!0){let o=e[Ie];if(j8(o,e,n,t),r){let i=rC(t,n),a=e[sn],c=a.parentNode(n[As]);c!==null&&s8(o,n[pr],a,e,c,i)}let s=e[Od];s!==null&&s.firstChild!==null&&(s.firstChild=null)}function sC(n,e){if(n.length<=Sn)return;let t=Sn+e,r=n[t];if(r){let o=r[_s];o!==null&&o!==n&&kC(o,r),e>0&&(n[t-1][lr]=r[lr]);let s=_d(n,Sn+e);o8(r[Ie],r);let i=s[so];i!==null&&i.detachView(s[Ie]),r[Zt]=null,r[lr]=null,r[we]&=-129}return r}function j8(n,e,t,r){let o=Sn+r,s=t.length;r>0&&(t[o-1][lr]=e),r<s-Sn?(e[lr]=t[o],g0(t,Sn+r,e)):(t.push(e),e[lr]=null),e[Zt]=t;let i=e[_s];i!==null&&t!==i&&x_(i,e);let a=e[so];a!==null&&a.insertView(n),$h(e),e[we]|=128}function x_(n,e){let t=n[Sa],r=e[Zt];if(Uo(r))n[we]|=2;else{let o=r[Zt][Ar];e[Ar]!==o&&(n[we]|=2)}t===null?n[Sa]=[e]:t.push(e)}var Wl=class{_lView;_cdRefInjectingView;_appRef=null;_attachedToViewContainer=!1;exhaustive;get rootNodes(){let e=this._lView,t=e[Ie];return jd(t,e,t.firstChild,[])}constructor(e,t){this._lView=e,this._cdRefInjectingView=t}get context(){return this._lView[hn]}set context(e){this._lView[hn]=e}get destroyed(){return ka(this._lView)}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){let e=this._lView[Zt];if(Rr(e)){let t=e[$d],r=t?t.indexOf(this):-1;r>-1&&(sC(e,r),_d(t,r))}this._attachedToViewContainer=!1}t_(this._lView[Ie],this._lView)}onDestroy(e){D0(this._lView,e)}markForCheck(){PC(this._cdRefInjectingView||this._lView,4)}detach(){this._lView[we]&=-129}reattach(){$h(this._lView),this._lView[we]|=128}detectChanges(){this._lView[we]|=1024,$C(this._lView)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Te(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;let e=Bl(this._lView),t=this._lView[_s];t!==null&&!e&&kC(t,this._lView),e_(this._lView[Ie],this._lView)}attachToAppRef(e){if(this._attachedToViewContainer)throw new Te(902,!1);this._appRef=e;let t=Bl(this._lView),r=this._lView[_s];r!==null&&!t&&x_(r,this._lView),$h(this._lView)}};var Pa=(()=>{class n{_declarationLView;_declarationTContainer;elementRef;static __NG_ELEMENT_ID__=q8;constructor(t,r,o){this._declarationLView=t,this._declarationTContainer=r,this.elementRef=o}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,r){return this.createEmbeddedViewImpl(t,r)}createEmbeddedViewImpl(t,r,o){let s=A8(this._declarationLView,this._declarationTContainer,t,{embeddedViewInjector:r,dehydratedView:o});return new Wl(s)}}return n})();function q8(){return LC(fr(),pt())}function LC(n,e){return n.type&4?new Pa(e,n,jl(n,e)):null}function hg(n,e,t,r,o){let s=n.data[e];if(s===null)s=K8(n,e,t,r,o),R1()&&(s.flags|=32);else if(s.type&64){s.type=t,s.value=r,s.attrs=o;let i=D1();s.injectorIndex=i===null?-1:i.injectorIndex}return Vl(s,!0),s}function K8(n,e,t,r,o){let s=M0(),i=$0(),a=i?s:s&&s.parent,c=n.data[e]=Y8(n,a,t,e,r,o);return X8(n,c,s,i),c}function X8(n,e,t,r){n.firstChild===null&&(n.firstChild=e),t!==null&&(r?t.child==null&&e.parent!==null&&(t.child=e):t.next===null&&(t.next=e,e.prev=t))}function Y8(n,e,t,r,o,s){let i=e?e.injectorIndex:-1,a=0;return N1()&&(a|=128),{type:t,index:r,insertBeforeIndex:null,injectorIndex:i,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:o,attrs:s,mergedAttrs:null,localNames:null,initialInputs:null,inputs:null,hostDirectiveInputs:null,outputs:null,hostDirectiveOutputs:null,directiveToIndex:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}var Tfe=new RegExp(`^(\\d+)*(${R5}|${A5})*(.*)`);var Z8=()=>null;function tk(n,e){return Z8(n,e)}var y_=class{},gg=class{},iC=class{resolveComponentFactory(e){throw new Te(917,!1)}},xg=class{static NULL=new iC},La=class{};var v_=(()=>{class n{static \u0275prov=Et({token:n,providedIn:"root",factory:()=>null})}return n})();var Xh={},aC=class{injector;parentInjector;constructor(e,t){this.injector=e,this.parentInjector=t}get(e,t,r){let o=this.injector.get(e,Xh,r);return o!==Xh||t===Xh?o:this.parentInjector.get(e,t,r)}};function og(n,e,t){let r=t?n.styles:null,o=t?n.classes:null,s=0;if(e!==null)for(let i=0;i<e.length;i++){let a=e[i];if(typeof a=="number")s=a;else if(s==1)o=a0(o,a);else if(s==2){let c=a,u=e[++i];r=a0(r,c+": "+u+";")}}t?n.styles=r:n.stylesWithoutHost=r,t?n.classes=o:n.classesWithoutHost=o}function Va(n,e=0){let t=pt();if(t===null)return Xe(n,e);let r=fr();return kk(r,t,er(n),e)}function b_(n,e,t,r,o){let s=r===null?null:{"":-1},i=o(n,t);if(i!==null){let a=i,c=null,u=null;for(let l of i)if(l.resolveHostDirectives!==null){[a,c,u]=l.resolveHostDirectives(i);break}e6(n,e,t,a,s,c,u)}s!==null&&r!==null&&Q8(t,r,s)}function Q8(n,e,t){let r=n.localNames=[];for(let o=0;o<e.length;o+=2){let s=t[e[o+1]];if(s==null)throw new Te(-301,!1);r.push(e[o],s)}}function J8(n,e,t){e.componentOffset=t,(n.components??=[]).push(e.index)}function e6(n,e,t,r,o,s,i){let a=r.length,c=!1;for(let d=0;d<a;d++){let f=r[d];!c&&Da(f)&&(c=!0,J8(n,t,d)),v5(Tk(t,e),n,f.type)}i6(t,n.data.length,a);for(let d=0;d<a;d++){let f=r[d];f.providersResolver&&f.providersResolver(f)}let u=!1,l=!1,p=Qk(n,e,a,null);a>0&&(t.directiveToIndex=new Map);for(let d=0;d<a;d++){let f=r[d];if(t.mergedAttrs=ug(t.mergedAttrs,f.hostAttrs),n6(n,t,e,p,f),s6(p,f,o),i!==null&&i.has(f)){let[h,g]=i.get(f);t.directiveToIndex.set(f.type,[p,h+t.directiveStart,g+t.directiveStart])}else(s===null||!s.has(f))&&t.directiveToIndex.set(f.type,p);f.contentQueries!==null&&(t.flags|=4),(f.hostBindings!==null||f.hostAttrs!==null||f.hostVars!==0)&&(t.flags|=64);let m=f.type.prototype;!u&&(m.ngOnChanges||m.ngOnInit||m.ngDoCheck)&&((n.preOrderHooks??=[]).push(t.index),u=!0),!l&&(m.ngOnChanges||m.ngDoCheck)&&((n.preOrderCheckHooks??=[]).push(t.index),l=!0),p++}t6(n,t,s)}function t6(n,e,t){for(let r=e.directiveStart;r<e.directiveEnd;r++){let o=n.data[r];if(t===null||!t.has(o))nk(0,e,o,r),nk(1,e,o,r),ok(e,r,!1);else{let s=t.get(o);rk(0,e,s,r),rk(1,e,s,r),ok(e,r,!0)}}}function nk(n,e,t,r){let o=n===0?t.inputs:t.outputs;for(let s in o)if(o.hasOwnProperty(s)){let i;n===0?i=e.inputs??={}:i=e.outputs??={},i[s]??=[],i[s].push(r),C_(e,s)}}function rk(n,e,t,r){let o=n===0?t.inputs:t.outputs;for(let s in o)if(o.hasOwnProperty(s)){let i=o[s],a;n===0?a=e.hostDirectiveInputs??={}:a=e.hostDirectiveOutputs??={},a[i]??=[],a[i].push(r,s),C_(e,i)}}function C_(n,e){e==="class"?n.flags|=8:e==="style"&&(n.flags|=16)}function ok(n,e,t){let{attrs:r,inputs:o,hostDirectiveInputs:s}=n;if(r===null||!t&&o===null||t&&s===null||EC(n)){n.initialInputs??=[],n.initialInputs.push(null);return}let i=null,a=0;for(;a<r.length;){let c=r[a];if(c===0){a+=4;continue}else if(c===5){a+=2;continue}else if(typeof c=="number")break;if(!t&&o.hasOwnProperty(c)){let u=o[c];for(let l of u)if(l===e){i??=[],i.push(c,r[a+1]);break}}else if(t&&s.hasOwnProperty(c)){let u=s[c];for(let l=0;l<u.length;l+=2)if(u[l]===e){i??=[],i.push(u[l+1],r[a+1]);break}}a+=2}n.initialInputs??=[],n.initialInputs.push(i)}function n6(n,e,t,r,o){n.data[r]=o;let s=o.factory||(o.factory=xa(o.type,!0)),i=new Wd(s,Da(o),Va,null);n.blueprint[r]=i,t[r]=i,r6(n,e,r,Qk(n,t,o.hostVars,Ba),o)}function r6(n,e,t,r,o){let s=o.hostBindings;if(s){let i=n.hostBindingOpCodes;i===null&&(i=n.hostBindingOpCodes=[]);let a=~e.index;o6(i)!=a&&i.push(a),i.push(t,r,s)}}function o6(n){let e=n.length;for(;e>0;){let t=n[--e];if(typeof t=="number"&&t<0)return t}return 0}function s6(n,e,t){if(t){if(e.exportAs)for(let r=0;r<e.exportAs.length;r++)t[e.exportAs[r]]=n;Da(e)&&(t[""]=n)}}function i6(n,e,t){n.flags|=1,n.directiveStart=e,n.directiveEnd=e+t,n.providerIndexes=e}function w_(n,e,t,r,o,s,i,a){let c=e[Ie],u=c.consts,l=_a(u,i),p=hg(c,n,t,r,l);return s&&b_(c,e,p,_a(u,a),o),p.mergedAttrs=ug(p.mergedAttrs,p.attrs),p.attrs!==null&&og(p,p.attrs,!1),p.mergedAttrs!==null&&og(p,p.mergedAttrs,!0),c.queries!==null&&c.queries.elementStart(c,p),p}function I_(n,e){bk(n,e),E0(e)&&n.queries.elementEnd(e)}function a6(n,e,t,r,o,s){let i=e.consts,a=_a(i,o),c=hg(e,n,t,r,a);if(c.mergedAttrs=ug(c.mergedAttrs,c.attrs),s!=null){let u=_a(i,s);c.localNames=[];for(let l=0;l<u.length;l+=2)c.localNames.push(u[l],-1)}return c.attrs!==null&&og(c,c.attrs,!1),c.mergedAttrs!==null&&og(c,c.mergedAttrs,!0),e.queries!==null&&e.queries.elementStart(e,c),c}function c6(n,e,t){return n[e]=t}function sg(n,e,t){if(t===Ba)return!1;let r=n[e];return Object.is(r,t)?!1:(n[e]=t,!0)}function u6(n,e,t,r){let o=sg(n,e,t);return sg(n,e+1,r)||o}function X0(n,e,t){return function r(o){let s=Na(n)?ao(n.index,e):e;PC(s,5);let i=e[hn],a=sk(e,i,t,o),c=r.__ngNextListenerFn__;for(;c;)a=sk(e,i,c,o)&&a,c=c.__ngNextListenerFn__;return a}}function sk(n,e,t,r){let o=$e(null);try{return ot(6,e,t),t(r)!==!1}catch(s){return N8(n,s),!1}finally{ot(7,e,t),$e(o)}}function l6(n,e,t,r,o,s,i,a){let c=Pd(n),u=!1,l=null;if(!r&&c&&(l=p6(e,t,s,n.index)),l!==null){let p=l.__ngLastListenerFn__||l;p.__ngNextListenerFn__=i,l.__ngLastListenerFn__=i,u=!0}else{let p=io(n,t),d=r?r(p):p;O5(t,d,s,a);let f=o.listen(d,s,a),m=r?h=>r(dr(h[n.index])):n.index;E_(m,e,t,s,a,f,!1)}return u}function p6(n,e,t,r){let o=n.cleanup;if(o!=null)for(let s=0;s<o.length-1;s+=2){let i=o[s];if(i===t&&o[s+1]===r){let a=e[Pl],c=o[s+2];return a&&a.length>c?a[c]:null}typeof i=="string"&&(s+=2)}return null}function E_(n,e,t,r,o,s,i){let a=e.firstCreatePass?_0(e):null,c=k0(t),u=c.length;c.push(o,s),a&&a.push(r,n,u,(u+1)*(i?-1:1))}function ik(n,e,t,r,o,s){let i=e[t],a=e[Ie],u=a.data[t].outputs[r],p=i[u].subscribe(s);E_(n.index,a,e,o,s,p,!0)}var cC=Symbol("BINDING");var uC=class extends xg{ngModule;constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){let t=wa(e);return new qd(t,this.ngModule)}};function d6(n){return Object.keys(n).map(e=>{let[t,r,o]=n[e],s={propName:t,templateName:e,isSignal:(r&fg.SignalBased)!==0};return o&&(s.transform=o),s})}function f6(n){return Object.keys(n).map(e=>({propName:n[e],templateName:e}))}function m6(n,e,t){let r=e instanceof ur?e:e?.injector;return r&&n.getStandaloneInjector!==null&&(r=n.getStandaloneInjector(r)||r),r?new aC(t,r):t}function h6(n){let e=n.get(La,null);if(e===null)throw new Te(407,!1);let t=n.get(v_,null),r=n.get(ro,null);return{rendererFactory:e,sanitizer:t,changeDetectionScheduler:r,ngReflect:!1}}function g6(n,e){let t=T_(n);return Kk(e,t,t==="svg"?g1:t==="math"?x1:null)}function T_(n){return(n.selectors[0][0]||"div").toLowerCase()}var qd=class extends gg{componentDef;ngModule;selector;componentType;ngContentSelectors;isBoundToModule;cachedInputs=null;cachedOutputs=null;get inputs(){return this.cachedInputs??=d6(this.componentDef.inputs),this.cachedInputs}get outputs(){return this.cachedOutputs??=f6(this.componentDef.outputs),this.cachedOutputs}constructor(e,t){super(),this.componentDef=e,this.ngModule=t,this.componentType=e.type,this.selector=q5(e.selectors),this.ngContentSelectors=e.ngContentSelectors??[],this.isBoundToModule=!!t}create(e,t,r,o,s,i){ot(22);let a=$e(null);try{let c=this.componentDef,u=x6(r,c,i,s),l=m6(c,o||this.ngModule,e),p=h6(l),d=p.rendererFactory.createRenderer(null,c),f=r?g8(d,r,c.encapsulation,l):g6(c,d),m=i?.some(ak)||s?.some(x=>typeof x!="function"&&x.bindings.some(ak)),h=SC(null,u,null,512|Zk(c),null,null,p,d,l,null,Vk(f,l,!0));h[gn]=f,Bh(h);let g=null;try{let x=w_(gn,h,2,"#host",()=>u.directiveRegistry,!0,0);f&&(Yk(d,f,x),Gl(f,h)),RC(u,h,x),zk(u,x,h),I_(u,x),t!==void 0&&v6(x,this.ngContentSelectors,t),g=ao(x.index,h),h[hn]=g[hn],MC(u,h,null)}catch(x){throw g!==null&&J0(g),J0(h),x}finally{ot(23),Vh()}return new ig(this.componentType,h,!!m)}finally{$e(a)}}};function x6(n,e,t,r){let o=n?["ng-version","20.3.0"]:K5(e.selectors[0]),s=null,i=null,a=0;if(t)for(let l of t)a+=l[cC].requiredVars,l.create&&(l.targetIdx=0,(s??=[]).push(l)),l.update&&(l.targetIdx=0,(i??=[]).push(l));if(r)for(let l=0;l<r.length;l++){let p=r[l];if(typeof p!="function")for(let d of p.bindings){a+=d[cC].requiredVars;let f=l+1;d.create&&(d.targetIdx=f,(s??=[]).push(d)),d.update&&(d.targetIdx=f,(i??=[]).push(d))}}let c=[e];if(r)for(let l of r){let p=typeof l=="function"?l:l.type,d=v0(p);c.push(d)}return TC(0,null,y6(s,i),1,a,c,null,null,null,[o],null)}function y6(n,e){return!n&&!e?null:t=>{if(t&1&&n)for(let r of n)r.create();if(t&2&&e)for(let r of e)r.update()}}function ak(n){let e=n[cC].kind;return e==="input"||e==="twoWay"}var ig=class extends y_{_rootLView;_hasInputBindings;instance;hostView;changeDetectorRef;componentType;location;previousInputValues=null;_tNode;constructor(e,t,r){super(),this._rootLView=t,this._hasInputBindings=r,this._tNode=Oh(t[Ie],gn),this.location=jl(this._tNode,t),this.instance=ao(this._tNode.index,t)[hn],this.hostView=this.changeDetectorRef=new Wl(t,void 0),this.componentType=e}setInput(e,t){this._hasInputBindings;let r=this._tNode;if(this.previousInputValues??=new Map,this.previousInputValues.has(e)&&Object.is(this.previousInputValues.get(e),t))return;let o=this._rootLView,s=OC(r,o[Ie],o,e,t);this.previousInputValues.set(e,t);let i=ao(r.index,o);PC(i,1)}get injector(){return new $a(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(e){this.hostView.onDestroy(e)}};function v6(n,e,t){let r=n.projection=[];for(let o=0;o<e.length;o++){let s=t[o];r.push(s!=null&&s.length?Array.from(s):null)}}var Xl=(()=>{class n{static __NG_ELEMENT_ID__=b6}return n})();function b6(){let n=fr();return N_(n,pt())}var C6=Xl,S_=class extends C6{_lContainer;_hostTNode;_hostLView;constructor(e,t,r){super(),this._lContainer=e,this._hostTNode=t,this._hostLView=r}get element(){return jl(this._hostTNode,this._hostLView)}get injector(){return new $a(this._hostTNode,this._hostLView)}get parentInjector(){let e=yC(this._hostTNode,this._hostLView);if(wk(e)){let t=Qh(e,this._hostLView),r=Zh(e),o=t[Ie].data[r+8];return new $a(o,t)}else return new $a(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){let t=ck(this._lContainer);return t!==null&&t[e]||null}get length(){return this._lContainer.length-Sn}createEmbeddedView(e,t,r){let o,s;typeof r=="number"?o=r:r!=null&&(o=r.index,s=r.injector);let i=tk(this._lContainer,e.ssrId),a=e.createEmbeddedViewImpl(t||{},s,i);return this.insertImpl(a,o,J1(this._hostTNode,i)),a}createComponent(e,t,r,o,s,i,a){let c=e&&!r5(e),u;if(c)u=t;else{let g=t||{};u=g.index,r=g.injector,o=g.projectableNodes,s=g.environmentInjector||g.ngModuleRef,i=g.directives,a=g.bindings}let l=c?e:new qd(wa(e)),p=r||this.parentInjector;if(!s&&l.ngModule==null){let x=(c?p:this.parentInjector).get(ur,null);x&&(s=x)}let d=wa(l.componentType??{}),f=tk(this._lContainer,d?.id??null),m=f?.firstChild??null,h=l.create(p,o,m,s,i,a);return this.insertImpl(h.hostView,u,J1(this._hostTNode,f)),h}insert(e,t){return this.insertImpl(e,t,!0)}insertImpl(e,t,r){let o=e._lView;if(C1(o)){let a=this.indexOf(e);if(a!==-1)this.detach(a);else{let c=o[Zt],u=new S_(c,c[pr],c[Zt]);u.detach(u.indexOf(e))}}let s=this._adjustIndex(t),i=this._lContainer;return W8(i,o,s,r),e.attachToViewContainerRef(),g0(Y0(i),s,e),e}move(e,t){return this.insert(e,t)}indexOf(e){let t=ck(this._lContainer);return t!==null?t.indexOf(e):-1}remove(e){let t=this._adjustIndex(e,-1),r=sC(this._lContainer,t);r&&(_d(Y0(this._lContainer),t),t_(r[Ie],r))}detach(e){let t=this._adjustIndex(e,-1),r=sC(this._lContainer,t);return r&&_d(Y0(this._lContainer),t)!=null?new Wl(r):null}_adjustIndex(e,t=0){return e??this.length+t}};function ck(n){return n[$d]}function Y0(n){return n[$d]||(n[$d]=[])}function N_(n,e){let t,r=e[n.index];return Rr(r)?t=r:(t=g_(r,e,null,n),e[n.index]=t,NC(e,t)),I6(t,e,n,r),new S_(t,n,e)}function w6(n,e){let t=n[sn],r=t.createComment(""),o=io(e,n),s=t.parentNode(o);return rg(t,s,r,t.nextSibling(o),!1),r}var I6=S6,E6=()=>!1;function T6(n,e,t){return E6(n,e,t)}function S6(n,e,t,r){if(n[As])return;let o;t.type&8?o=dr(r):o=w6(e,t),n[As]=o}var lC=class n{queryList;matches=null;constructor(e){this.queryList=e}clone(){return new n(this.queryList)}setDirty(){this.queryList.setDirty()}},pC=class n{queries;constructor(e=[]){this.queries=e}createEmbeddedView(e){let t=e.queries;if(t!==null){let r=e.contentQueries!==null?e.contentQueries[0]:t.length,o=[];for(let s=0;s<r;s++){let i=t.getByIndex(s),a=this.queries[i.indexInDeclarationView];o.push(a.clone())}return new n(o)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}finishViewCreation(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let t=0;t<this.queries.length;t++)BC(e,t).matches!==null&&this.queries[t].setDirty()}},dC=class{flags;read;predicate;constructor(e,t,r=null){this.flags=t,this.read=r,typeof e=="string"?this.predicate=O6(e):this.predicate=e}},fC=class n{queries;constructor(e=[]){this.queries=e}elementStart(e,t){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(e,t)}elementEnd(e){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(e)}embeddedTView(e){let t=null;for(let r=0;r<this.length;r++){let o=t!==null?t.length:0,s=this.getByIndex(r).embeddedTView(e,o);s&&(s.indexInDeclarationView=r,t!==null?t.push(s):t=[s])}return t!==null?new n(t):null}template(e,t){for(let r=0;r<this.queries.length;r++)this.queries[r].template(e,t)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}},mC=class n{metadata;matches=null;indexInDeclarationView=-1;crossesNgTemplate=!1;_declarationNodeIndex;_appliesToNextNode=!0;constructor(e,t=-1){this.metadata=e,this._declarationNodeIndex=t}elementStart(e,t){this.isApplyingToNode(t)&&this.matchTNode(e,t)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,t){this.elementStart(e,t)}embeddedTView(e,t){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,t),new n(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&(this.metadata.flags&1)!==1){let t=this._declarationNodeIndex,r=e.parent;for(;r!==null&&r.type&8&&r.index!==t;)r=r.parent;return t===(r!==null?r.index:-1)}return this._appliesToNextNode}matchTNode(e,t){let r=this.metadata.predicate;if(Array.isArray(r))for(let o=0;o<r.length;o++){let s=r[o];this.matchTNodeWithReadOption(e,t,N6(t,s)),this.matchTNodeWithReadOption(e,t,Kh(t,e,s,!1,!1))}else r===Pa?t.type&4&&this.matchTNodeWithReadOption(e,t,-1):this.matchTNodeWithReadOption(e,t,Kh(t,e,r,!1,!1))}matchTNodeWithReadOption(e,t,r){if(r!==null){let o=this.metadata.read;if(o!==null)if(o===ql||o===Xl||o===Pa&&t.type&4)this.addMatch(t.index,-2);else{let s=Kh(t,e,o,!1,!1);s!==null&&this.addMatch(t.index,s)}else this.addMatch(t.index,r)}}addMatch(e,t){this.matches===null?this.matches=[e,t]:this.matches.push(e,t)}};function N6(n,e){let t=n.localNames;if(t!==null){for(let r=0;r<t.length;r+=2)if(t[r]===e)return t[r+1]}return null}function D6(n,e){return n.type&11?jl(n,e):n.type&4?LC(n,e):null}function k6(n,e,t,r){return t===-1?D6(e,n):t===-2?_6(n,e,r):eg(n,n[Ie],t,e)}function _6(n,e,t){if(t===ql)return jl(e,n);if(t===Pa)return LC(e,n);if(t===Xl)return N_(e,n)}function D_(n,e,t,r){let o=e[so].queries[r];if(o.matches===null){let s=n.data,i=t.matches,a=[];for(let c=0;i!==null&&c<i.length;c+=2){let u=i[c];if(u<0)a.push(null);else{let l=s[u];a.push(k6(e,l,i[c+1],t.metadata.read))}}o.matches=a}return o.matches}function hC(n,e,t,r){let o=n.queries.getByIndex(t),s=o.matches;if(s!==null){let i=D_(n,e,o,t);for(let a=0;a<s.length;a+=2){let c=s[a];if(c>0)r.push(i[a/2]);else{let u=s[a+1],l=e[-c];for(let p=Sn;p<l.length;p++){let d=l[p];d[_s]===d[Zt]&&hC(d[Ie],d,u,r)}if(l[Sa]!==null){let p=l[Sa];for(let d=0;d<p.length;d++){let f=p[d];hC(f[Ie],f,u,r)}}}}}return r}function A6(n,e){return n[so].queries[e].queryList}function R6(n,e,t){let r=new tg((t&4)===4);return E1(n,e,r,r.destroy),(e[so]??=new pC).queries.push(new lC(r))-1}function F6(n,e,t){let r=co();return r.firstCreatePass&&(M6(r,new dC(n,e,t),-1),(e&2)===2&&(r.staticViewQueries=!0)),R6(r,pt(),e)}function O6(n){return n.split(",").map(e=>e.trim())}function M6(n,e,t){n.queries===null&&(n.queries=new fC),n.queries.track(new mC(e,t))}function BC(n,e){return n.queries.getByIndex(e)}function $6(n,e){let t=n[Ie],r=BC(t,e);return r.crossesNgTemplate?hC(t,n,e,[]):D_(t,n,r,e)}var uk=new Set;function VC(n){uk.has(n)||(uk.add(n),performance?.mark?.("mark_feature_usage",{detail:{feature:n}}))}var Kd=class{};var Xd=class extends Kd{injector;componentFactoryResolver=new uC(this);instance=null;constructor(e){super();let t=new ya([...e.providers,{provide:Kd,useValue:this},{provide:xg,useValue:this.componentFactoryResolver}],e.parent||Fd(),e.debugName,new Set(["environment"]));this.injector=t,e.runEnvironmentInitializers&&t.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(e){this.injector.onDestroy(e)}};function k_(n,e,t=null){return new Xd({providers:n,parent:e,debugName:t,runEnvironmentInitializers:!0}).injector}var P6=(()=>{class n{_injector;cachedInjectors=new Map;constructor(t){this._injector=t}getOrCreateStandaloneInjector(t){if(!t.standalone)return null;if(!this.cachedInjectors.has(t)){let r=b0(!1,t.type),o=r.length>0?k_([r],this._injector,`Standalone[${t.type.name}]`):null;this.cachedInjectors.set(t,o)}return this.cachedInjectors.get(t)}ngOnDestroy(){try{for(let t of this.cachedInjectors.values())t!==null&&t.destroy()}finally{this.cachedInjectors.clear()}}static \u0275prov=Et({token:n,providedIn:"environment",factory:()=>new n(Xe(ur))})}return n})();function Ua(n){return cg(()=>{let e=__(n),t=Yt(Ft({},e),{decls:n.decls,vars:n.vars,template:n.template,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,onPush:n.changeDetection===vC.OnPush,directiveDefs:null,pipeDefs:null,dependencies:e.standalone&&n.dependencies||null,getStandaloneInjector:e.standalone?o=>o.get(P6).getOrCreateStandaloneInjector(t):null,getExternalStyles:null,signals:n.signals??!1,data:n.data||{},encapsulation:n.encapsulation||Ho.Emulated,styles:n.styles||Dr,_:null,schemas:n.schemas||null,tView:null,id:""});e.standalone&&VC("NgStandalone"),A_(t);let r=n.dependencies;return t.directiveDefs=lk(r,L6),t.pipeDefs=lk(r,c1),t.id=U6(t),t})}function L6(n){return wa(n)||v0(n)}function yg(n){return cg(()=>({type:n.type,bootstrap:n.bootstrap||Dr,declarations:n.declarations||Dr,imports:n.imports||Dr,exports:n.exports||Dr,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function B6(n,e){if(n==null)return Ca;let t={};for(let r in n)if(n.hasOwnProperty(r)){let o=n[r],s,i,a,c;Array.isArray(o)?(a=o[0],s=o[1],i=o[2]??s,c=o[3]||null):(s=o,i=o,a=fg.None,c=null),t[s]=[r,a,c],e[s]=i}return t}function V6(n){if(n==null)return Ca;let e={};for(let t in n)n.hasOwnProperty(t)&&(e[n[t]]=t);return e}function UC(n){return cg(()=>{let e=__(n);return A_(e),e})}function zC(n){return{type:n.type,name:n.name,factory:null,pure:n.pure!==!1,standalone:n.standalone??!0,onDestroy:n.type.prototype.ngOnDestroy||null}}function __(n){let e={};return{type:n.type,providersResolver:null,factory:null,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:e,inputConfig:n.inputs||Ca,exportAs:n.exportAs||null,standalone:n.standalone??!0,signals:n.signals===!0,selectors:n.selectors||Dr,viewQuery:n.viewQuery||null,features:n.features||null,setInput:null,resolveHostDirectives:null,hostDirectives:null,inputs:B6(n.inputs,e),outputs:V6(n.outputs),debugInfo:null}}function A_(n){n.features?.forEach(e=>e(n))}function lk(n,e){return n?()=>{let t=typeof n=="function"?n():n,r=[];for(let o of t){let s=e(o);s!==null&&r.push(s)}return r}:null}function U6(n){let e=0,t=typeof n.consts=="function"?"":n.consts,r=[n.selectors,n.ngContentSelectors,n.hostVars,n.hostAttrs,t,n.vars,n.decls,n.encapsulation,n.standalone,n.signals,n.exportAs,JSON.stringify(n.inputs),JSON.stringify(n.outputs),Object.getOwnPropertyNames(n.type.prototype),!!n.contentQueries,!!n.viewQuery];for(let s of r.join("|"))e=Math.imul(31,e)+s.charCodeAt(0)<<0;return e+=2147483648,"c"+e}function z6(n,e,t,r,o,s,i,a){if(t.firstCreatePass){n.mergedAttrs=ug(n.mergedAttrs,n.attrs);let l=n.tView=TC(2,n,o,s,i,t.directiveRegistry,t.pipeRegistry,null,t.schemas,t.consts,null);t.queries!==null&&(t.queries.template(t,n),l.queries=t.queries.embeddedTView(n))}a&&(n.flags|=a),Vl(n,!1);let c=G6(t,e,n,r);zh()&&_C(t,e,c,n),Gl(c,e);let u=g_(c,e,c,n);e[r+gn]=u,NC(e,u),T6(u,n,e)}function H6(n,e,t,r,o,s,i,a,c,u,l){let p=t+gn,d;return e.firstCreatePass?(d=hg(e,p,4,i||null,a||null),R0()&&b_(e,n,d,_a(e.consts,u),o_),bk(e,d)):d=e.data[p],z6(d,n,e,t,r,o,s,c),Pd(d)&&RC(e,n,d),u!=null&&FC(n,d,l),d}function Zd(n,e,t,r,o,s,i,a){let c=pt(),u=co(),l=_a(u.consts,s);return H6(c,u,n,e,t,r,o,l,void 0,i,a),Zd}var G6=W6;function W6(n,e,t,r){return Hh(!0),e[sn].createComment("")}var HC=(function(n){return n[n.CHANGE_DETECTION=0]="CHANGE_DETECTION",n[n.AFTER_NEXT_RENDER=1]="AFTER_NEXT_RENDER",n})(HC||{}),Qd=new Ge(""),R_=!1,gC=class extends Ns{__isAsync;destroyRef=void 0;pendingTasks=void 0;constructor(e=!1){super(),this.__isAsync=e,m1()&&(this.destroyRef=Fe(Ra,{optional:!0})??void 0,this.pendingTasks=Fe(Fa,{optional:!0})??void 0)}emit(e){let t=$e(null);try{super.next(e)}finally{$e(t)}}subscribe(e,t,r){let o=e,s=t||(()=>null),i=r;if(e&&typeof e=="object"){let c=e;o=c.next?.bind(c),s=c.error?.bind(c),i=c.complete?.bind(c)}this.__isAsync&&(s=this.wrapInTimeout(s),o&&(o=this.wrapInTimeout(o)),i&&(i=this.wrapInTimeout(i)));let a=super.subscribe({next:o,error:s,complete:i});return e instanceof En&&e.add(a),a}wrapInTimeout(e){return t=>{let r=this.pendingTasks?.add();setTimeout(()=>{try{e(t)}finally{r!==void 0&&this.pendingTasks?.remove(r)}})}}},zo=gC;function F_(n){let e,t;function r(){n=Oa;try{t!==void 0&&typeof cancelAnimationFrame=="function"&&cancelAnimationFrame(t),e!==void 0&&clearTimeout(e)}catch{}}return e=setTimeout(()=>{n(),r()}),typeof requestAnimationFrame=="function"&&(t=requestAnimationFrame(()=>{n(),r()})),()=>r()}function pk(n){return queueMicrotask(()=>n()),()=>{n=Oa}}var GC="isAngularZone",ag=GC+"_ID",j6=0,Qt=class n{hasPendingMacrotasks=!1;hasPendingMicrotasks=!1;isStable=!0;onUnstable=new zo(!1);onMicrotaskEmpty=new zo(!1);onStable=new zo(!1);onError=new zo(!1);constructor(e){let{enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:r=!1,shouldCoalesceRunChangeDetection:o=!1,scheduleInRootZone:s=R_}=e;if(typeof Zone>"u")throw new Te(908,!1);Zone.assertZonePatched();let i=this;i._nesting=0,i._outer=i._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(i._inner=i._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(i._inner=i._inner.fork(Zone.longStackTraceZoneSpec)),i.shouldCoalesceEventChangeDetection=!o&&r,i.shouldCoalesceRunChangeDetection=o,i.callbackScheduled=!1,i.scheduleInRootZone=s,X6(i)}static isInAngularZone(){return typeof Zone<"u"&&Zone.current.get(GC)===!0}static assertInAngularZone(){if(!n.isInAngularZone())throw new Te(909,!1)}static assertNotInAngularZone(){if(n.isInAngularZone())throw new Te(909,!1)}run(e,t,r){return this._inner.run(e,t,r)}runTask(e,t,r,o){let s=this._inner,i=s.scheduleEventTask("NgZoneEvent: "+o,e,q6,Oa,Oa);try{return s.runTask(i,t,r)}finally{s.cancelTask(i)}}runGuarded(e,t,r){return this._inner.runGuarded(e,t,r)}runOutsideAngular(e){return this._outer.run(e)}},q6={};function WC(n){if(n._nesting==0&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function K6(n){if(n.isCheckStableRunning||n.callbackScheduled)return;n.callbackScheduled=!0;function e(){F_(()=>{n.callbackScheduled=!1,xC(n),n.isCheckStableRunning=!0,WC(n),n.isCheckStableRunning=!1})}n.scheduleInRootZone?Zone.root.run(()=>{e()}):n._outer.run(()=>{e()}),xC(n)}function X6(n){let e=()=>{K6(n)},t=j6++;n._inner=n._inner.fork({name:"angular",properties:{[GC]:!0,[ag]:t,[ag+t]:!0},onInvokeTask:(r,o,s,i,a,c)=>{if(Y6(c))return r.invokeTask(s,i,a,c);try{return dk(n),r.invokeTask(s,i,a,c)}finally{(n.shouldCoalesceEventChangeDetection&&i.type==="eventTask"||n.shouldCoalesceRunChangeDetection)&&e(),fk(n)}},onInvoke:(r,o,s,i,a,c,u)=>{try{return dk(n),r.invoke(s,i,a,c,u)}finally{n.shouldCoalesceRunChangeDetection&&!n.callbackScheduled&&!Z6(c)&&e(),fk(n)}},onHasTask:(r,o,s,i)=>{r.hasTask(s,i),o===s&&(i.change=="microTask"?(n._hasPendingMicrotasks=i.microTask,xC(n),WC(n)):i.change=="macroTask"&&(n.hasPendingMacrotasks=i.macroTask))},onHandleError:(r,o,s,i)=>(r.handleError(s,i),n.runOutsideAngular(()=>n.onError.emit(i)),!1)})}function xC(n){n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&n.callbackScheduled===!0?n.hasPendingMicrotasks=!0:n.hasPendingMicrotasks=!1}function dk(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function fk(n){n._nesting--,WC(n)}var Yd=class{hasPendingMicrotasks=!1;hasPendingMacrotasks=!1;isStable=!0;onUnstable=new zo;onMicrotaskEmpty=new zo;onStable=new zo;onError=new zo;run(e,t,r){return e.apply(t,r)}runGuarded(e,t,r){return e.apply(t,r)}runOutsideAngular(e){return e()}runTask(e,t,r,o){return e.apply(t,r)}};function Y6(n){return O_(n,"__ignore_ng_zone__")}function Z6(n){return O_(n,"__scheduler_tick__")}function O_(n,e){return!Array.isArray(n)||n.length!==1?!1:n[0]?.data?.[e]===!0}var M_=(()=>{class n{impl=null;execute(){this.impl?.execute()}static \u0275prov=Et({token:n,providedIn:"root",factory:()=>new n})}return n})();var jC=new Ge("");function vg(n){return!!n&&typeof n.then=="function"}function qC(n){return!!n&&typeof n.subscribe=="function"}var $_=new Ge("");var KC=(()=>{class n{resolve;reject;initialized=!1;done=!1;donePromise=new Promise((t,r)=>{this.resolve=t,this.reject=r});appInits=Fe($_,{optional:!0})??[];injector=Fe(Bo);constructor(){}runInitializers(){if(this.initialized)return;let t=[];for(let o of this.appInits){let s=Ah(this.injector,o);if(vg(s))t.push(s);else if(qC(s)){let i=new Promise((a,c)=>{s.subscribe({complete:a,error:c})});t.push(i)}}let r=()=>{this.done=!0,this.resolve()};Promise.all(t).then(()=>{r()}).catch(o=>{this.reject(o)}),t.length===0&&r(),this.initialized=!0}static \u0275fac=function(r){return new(r||n)};static \u0275prov=Et({token:n,factory:n.\u0275fac,providedIn:"root"})}return n})(),P_=new Ge("");function L_(){Bb(()=>{let n="";throw new Te(600,n)})}function B_(n){return n.isBoundToModule}var Q6=10;var Jd=(()=>{class n{_runningTick=!1;_destroyed=!1;_destroyListeners=[];_views=[];internalErrorHandler=Fe(po);afterRenderManager=Fe(M_);zonelessEnabled=Fe(Vd);rootEffectScheduler=Fe(zd);dirtyFlags=0;tracingSnapshot=null;allTestViews=new Set;autoDetectTestViews=new Set;includeAllTestViews=!1;afterTick=new Ns;get allViews(){return[...(this.includeAllTestViews?this.allTestViews:this.autoDetectTestViews).keys(),...this._views]}get destroyed(){return this._destroyed}componentTypes=[];components=[];internalPendingTask=Fe(Fa);get isStable(){return this.internalPendingTask.hasPendingTasksObservable.pipe(Xb(t=>!t))}constructor(){Fe(Qd,{optional:!0})}whenStable(){let t;return new Promise(r=>{t=this.isStable.subscribe({next:o=>{o&&r()}})}).finally(()=>{t.unsubscribe()})}_injector=Fe(ur);_rendererFactory=null;get injector(){return this._injector}bootstrap(t,r){return this.bootstrapImpl(t,r)}bootstrapImpl(t,r,o=Bo.NULL){return this._injector.get(Qt).run(()=>{ot(10);let i=t instanceof gg;if(!this._injector.get(KC).done){let m="";throw new Te(405,m)}let c;i?c=t:c=this._injector.get(xg).resolveComponentFactory(t),this.componentTypes.push(c.componentType);let u=B_(c)?void 0:this._injector.get(Kd),l=r||c.selector,p=c.create(o,[],l,u),d=p.location.nativeElement,f=p.injector.get(jC,null);return f?.registerApplication(d),p.onDestroy(()=>{this.detachView(p.hostView),Gd(this.components,p),f?.unregisterApplication(d)}),this._loadComponent(p),ot(11,p),p})}tick(){this.zonelessEnabled||(this.dirtyFlags|=1),this._tick()}_tick(){ot(12),this.tracingSnapshot!==null?this.tracingSnapshot.run(HC.CHANGE_DETECTION,this.tickImpl):this.tickImpl()}tickImpl=()=>{if(this._runningTick)throw new Te(101,!1);let t=$e(null);try{this._runningTick=!0,this.synchronize()}finally{this._runningTick=!1,this.tracingSnapshot?.dispose(),this.tracingSnapshot=null,$e(t),this.afterTick.next(),ot(13)}};synchronize(){this._rendererFactory===null&&!this._injector.destroyed&&(this._rendererFactory=this._injector.get(La,null,{optional:!0}));let t=0;for(;this.dirtyFlags!==0&&t++<Q6;)ot(14),this.synchronizeOnce(),ot(15)}synchronizeOnce(){this.dirtyFlags&16&&(this.dirtyFlags&=-17,this.rootEffectScheduler.flush());let t=!1;if(this.dirtyFlags&7){let r=!!(this.dirtyFlags&1);this.dirtyFlags&=-8,this.dirtyFlags|=8;for(let{_lView:o}of this.allViews){if(!r&&!Ld(o))continue;let s=r&&!this.zonelessEnabled?0:1;$C(o,s),t=!0}if(this.dirtyFlags&=-5,this.syncDirtyFlagsWithViews(),this.dirtyFlags&23)return}t||(this._rendererFactory?.begin?.(),this._rendererFactory?.end?.()),this.dirtyFlags&8&&(this.dirtyFlags&=-9,this.afterRenderManager.execute()),this.syncDirtyFlagsWithViews()}syncDirtyFlagsWithViews(){if(this.allViews.some(({_lView:t})=>Ld(t))){this.dirtyFlags|=2;return}else this.dirtyFlags&=-8}attachView(t){let r=t;this._views.push(r),r.attachToAppRef(this)}detachView(t){let r=t;Gd(this._views,r),r.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView);try{this.tick()}catch(o){this.internalErrorHandler(o)}this.components.push(t),this._injector.get(P_,[]).forEach(o=>o(t))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(t=>t()),this._views.slice().forEach(t=>t.destroy())}finally{this._destroyed=!0,this._views=[],this._destroyListeners=[]}}onDestroy(t){return this._destroyListeners.push(t),()=>Gd(this._destroyListeners,t)}destroy(){if(this._destroyed)throw new Te(406,!1);let t=this._injector;t.destroy&&!t.destroyed&&t.destroy()}get viewCount(){return this._views.length}static \u0275fac=function(r){return new(r||n)};static \u0275prov=Et({token:n,factory:n.\u0275fac,providedIn:"root"})}return n})();function Gd(n,e){let t=n.indexOf(e);t>-1&&n.splice(t,1)}var XC=new Ge("",{providedIn:"root",factory:()=>!1}),YC=new Ge("",{providedIn:"root",factory:()=>J6}),J6=4e3;var Afe=typeof document<"u"&&typeof document?.documentElement?.getAnimations=="function";function Or(n,e,t){let r=pt(),o=B0();if(sg(r,o,e)){let s=co(),i=B1();b8(i,r,n,e,r[sn],t)}return Or}function mk(n,e,t,r,o){OC(e,n,t,o?"class":"style",r)}function kt(n,e,t,r){let o=pt(),s=o[Ie],i=n+gn,a=s.firstCreatePass?w_(i,o,2,e,o_,R0(),t,r):s.data[i];if(s_(a,o,n,e,V_),Pd(a)){let c=o[Ie];RC(c,o,a),zk(c,a,o)}return r!=null&&FC(o,a),kt}function Ht(){let n=co(),e=fr(),t=i_(e);return n.firstCreatePass&&I_(n,t),F0(t)&&O0(),A0(),t.classesWithoutHost!=null&&l5(t)&&mk(n,t,pt(),t.classesWithoutHost,!0),t.stylesWithoutHost!=null&&p5(t)&&mk(n,t,pt(),t.stylesWithoutHost,!1),Ht}function Mr(n,e,t,r){return kt(n,e,t,r),Ht(),Mr}function ZC(n,e,t,r){let o=pt(),s=o[Ie],i=n+gn,a=s.firstCreatePass?a6(i,s,2,e,t,r):s.data[i];return s_(a,o,n,e,V_),r!=null&&FC(o,a),ZC}function QC(){let n=fr(),e=i_(n);return F0(e)&&O0(),A0(),QC}function bg(n,e,t,r){return ZC(n,e,t,r),QC(),bg}var V_=(n,e,t,r,o)=>(Hh(!0),Kk(e[sn],r,V1()));function ef(){return pt()}var Ma=void 0;function eq(n){let e=Math.floor(Math.abs(n)),t=n.toString().replace(/^[^.]*\.?/,"").length;return e===1&&t===0?1:5}var tq=["en",[["a","p"],["AM","PM"],Ma],[["AM","PM"],Ma,Ma],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Ma,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Ma,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Ma,"{1} 'at' {0}",Ma],[".",",",";","%","+","-","E","\xD7","\u2030","\u221E","NaN",":"],["#,##0.###","#,##0%","\xA4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",eq],Z0={};function Cg(n){let e=nq(n),t=hk(e);if(t)return t;let r=e.split("-")[0];if(t=hk(r),t)return t;if(r==="en")return tq;throw new Te(701,!1)}function hk(n){return n in Z0||(Z0[n]=va.ng&&va.ng.common&&va.ng.common.locales&&va.ng.common.locales[n]),Z0[n]}var za=(function(n){return n[n.LocaleId=0]="LocaleId",n[n.DayPeriodsFormat=1]="DayPeriodsFormat",n[n.DayPeriodsStandalone=2]="DayPeriodsStandalone",n[n.DaysFormat=3]="DaysFormat",n[n.DaysStandalone=4]="DaysStandalone",n[n.MonthsFormat=5]="MonthsFormat",n[n.MonthsStandalone=6]="MonthsStandalone",n[n.Eras=7]="Eras",n[n.FirstDayOfWeek=8]="FirstDayOfWeek",n[n.WeekendRange=9]="WeekendRange",n[n.DateFormat=10]="DateFormat",n[n.TimeFormat=11]="TimeFormat",n[n.DateTimeFormat=12]="DateTimeFormat",n[n.NumberSymbols=13]="NumberSymbols",n[n.NumberFormats=14]="NumberFormats",n[n.CurrencyCode=15]="CurrencyCode",n[n.CurrencySymbol=16]="CurrencySymbol",n[n.CurrencyName=17]="CurrencyName",n[n.Currencies=18]="Currencies",n[n.Directionality=19]="Directionality",n[n.PluralCase=20]="PluralCase",n[n.ExtraData=21]="ExtraData",n})(za||{});function nq(n){return n.toLowerCase().replace(/_/g,"-")}var tf="en-US";var rq=tf;function U_(n){typeof n=="string"&&(rq=n.toLowerCase().replace(/_/g,"-"))}function mo(n,e,t){let r=pt(),o=co(),s=fr();return oq(o,r,r[sn],s,n,e,t),mo}function oq(n,e,t,r,o,s,i){let a=!0,c=null;if((r.type&3||i)&&(c??=X0(r,e,s),l6(r,n,e,i,t,o,s,c)&&(a=!1)),a){let u=r.outputs?.[o],l=r.hostDirectiveOutputs?.[o];if(l&&l.length)for(let p=0;p<l.length;p+=2){let d=l[p],f=l[p+1];c??=X0(r,e,s),ik(r,e,d,f,o,c)}if(u&&u.length)for(let p of u)c??=X0(r,e,s),ik(r,e,p,o,o,c)}}function Ha(n=1){return L1(n)}function Os(n,e,t){F6(n,e,t)}function Ms(n){let e=pt(),t=co(),r=V0();Lh(r+1);let o=BC(t,r);if(n.dirty&&b1(e)===((o.metadata.flags&2)===2)){if(o.matches===null)n.reset([]);else{let s=$6(e,r);n.reset(s,T5),n.notifyOnChanges()}return!0}return!1}function $s(){return A6(pt(),V0())}function nr(n,e=""){let t=pt(),r=co(),o=n+gn,s=r.firstCreatePass?hg(r,o,1,e,null):r.data[o],i=sq(r,t,s,e,n);t[o]=i,zh()&&_C(r,t,i,s),Vl(s,!1)}var sq=(n,e,t,r,o)=>(Hh(!0),X5(e[sn],r));function iq(n,e,t,r=""){return sg(n,B0(),t)?e+Dh(t)+r:Ba}function nf(n){return Yl("",n),nf}function Yl(n,e,t){let r=pt(),o=iq(r,n,e,t);return o!==Ba&&aq(r,Uh(),o),Yl}function aq(n,e,t){let r=y1(e,n);Y5(n[sn],r,t)}function cq(n,e){let t=n[e];return t===Ba?void 0:t}function uq(n,e,t,r,o,s,i){let a=e+t;return u6(n,a,o,s)?c6(n,a+2,i?r.call(i,o,s):r(o,s)):cq(n,a+2)}function wg(n,e){let t=co(),r,o=n+gn;t.firstCreatePass?(r=lq(e,t.pipeRegistry),t.data[o]=r,r.onDestroy&&(t.destroyHooks??=[]).push(o,r.onDestroy)):r=t.data[o];let s=r.factory||(r.factory=xa(r.type,!0)),i,a=Tn(Va);try{let c=Jh(!1),u=s();return Jh(c),T0(t,pt(),o,u),u}finally{Tn(a)}}function lq(n,e){if(e)for(let t=e.length-1;t>=0;t--){let r=e[t];if(n===r.name)return r}}function Ig(n,e,t,r){let o=n+gn,s=pt(),i=v1(s,o);return pq(s,o)?uq(s,_1(),e,i.transform,t,r,i):i.transform(t,r)}function pq(n,e){return n[Ie].data[e].pure}var dq=(()=>{class n{zone=Fe(Qt);changeDetectionScheduler=Fe(ro);applicationRef=Fe(Jd);applicationErrorHandler=Fe(po);_onMicrotaskEmptySubscription;initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.changeDetectionScheduler.runningTick||this.zone.run(()=>{try{this.applicationRef.dirtyFlags|=1,this.applicationRef._tick()}catch(t){this.applicationErrorHandler(t)}})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static \u0275fac=function(r){return new(r||n)};static \u0275prov=Et({token:n,factory:n.\u0275fac,providedIn:"root"})}return n})();function z_({ngZoneFactory:n,ignoreChangesOutsideZone:e,scheduleInRootZone:t}){return n??=()=>new Qt(Yt(Ft({},H_()),{scheduleInRootZone:t})),[{provide:Qt,useFactory:n},{provide:ks,multi:!0,useFactory:()=>{let r=Fe(dq,{optional:!0});return()=>r.initialize()}},{provide:ks,multi:!0,useFactory:()=>{let r=Fe(fq);return()=>{r.initialize()}}},e===!0?{provide:W0,useValue:!0}:[],{provide:Wh,useValue:t??R_},{provide:po,useFactory:()=>{let r=Fe(Qt),o=Fe(ur),s;return i=>{r.runOutsideAngular(()=>{o.destroyed&&!s?setTimeout(()=>{throw i}):(s??=o.get(kr),s.handleError(i))})}}}]}function H_(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:n?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:n?.runCoalescing??!1}}var fq=(()=>{class n{subscription=new En;initialized=!1;zone=Fe(Qt);pendingTasks=Fe(Fa);initialize(){if(this.initialized)return;this.initialized=!0;let t=null;!this.zone.isStable&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(t=this.pendingTasks.add()),this.zone.runOutsideAngular(()=>{this.subscription.add(this.zone.onStable.subscribe(()=>{Qt.assertNotInAngularZone(),queueMicrotask(()=>{t!==null&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(this.pendingTasks.remove(t),t=null)})}))}),this.subscription.add(this.zone.onUnstable.subscribe(()=>{Qt.assertInAngularZone(),t??=this.pendingTasks.add()}))}ngOnDestroy(){this.subscription.unsubscribe()}static \u0275fac=function(r){return new(r||n)};static \u0275prov=Et({token:n,factory:n.\u0275fac,providedIn:"root"})}return n})();var JC=(()=>{class n{applicationErrorHandler=Fe(po);appRef=Fe(Jd);taskService=Fe(Fa);ngZone=Fe(Qt);zonelessEnabled=Fe(Vd);tracing=Fe(Qd,{optional:!0});disableScheduling=Fe(W0,{optional:!0})??!1;zoneIsDefined=typeof Zone<"u"&&!!Zone.root.run;schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}];subscriptions=new En;angularZoneId=this.zoneIsDefined?this.ngZone._inner?.get(ag):null;scheduleInRootZone=!this.zonelessEnabled&&this.zoneIsDefined&&(Fe(Wh,{optional:!0})??!1);cancelScheduledCallback=null;useMicrotaskScheduler=!1;runningTick=!1;pendingRenderTaskId=null;constructor(){this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{this.runningTick||this.cleanup()})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()})),this.disableScheduling||=!this.zonelessEnabled&&(this.ngZone instanceof Yd||!this.zoneIsDefined)}notify(t){if(!this.zonelessEnabled&&t===5)return;let r=!1;switch(t){case 0:{this.appRef.dirtyFlags|=2;break}case 3:case 2:case 4:case 5:case 1:{this.appRef.dirtyFlags|=4;break}case 6:{this.appRef.dirtyFlags|=2,r=!0;break}case 12:{this.appRef.dirtyFlags|=16,r=!0;break}case 13:{this.appRef.dirtyFlags|=2,r=!0;break}case 11:{r=!0;break}case 9:case 8:case 7:case 10:default:this.appRef.dirtyFlags|=8}if(this.appRef.tracingSnapshot=this.tracing?.snapshot(this.appRef.tracingSnapshot)??null,!this.shouldScheduleTick(r))return;let o=this.useMicrotaskScheduler?pk:F_;this.pendingRenderTaskId=this.taskService.add(),this.scheduleInRootZone?this.cancelScheduledCallback=Zone.root.run(()=>o(()=>this.tick())):this.cancelScheduledCallback=this.ngZone.runOutsideAngular(()=>o(()=>this.tick()))}shouldScheduleTick(t){return!(this.disableScheduling&&!t||this.appRef.destroyed||this.pendingRenderTaskId!==null||this.runningTick||this.appRef._runningTick||!this.zonelessEnabled&&this.zoneIsDefined&&Zone.current.get(ag+this.angularZoneId))}tick(){if(this.runningTick||this.appRef.destroyed)return;if(this.appRef.dirtyFlags===0){this.cleanup();return}!this.zonelessEnabled&&this.appRef.dirtyFlags&7&&(this.appRef.dirtyFlags|=1);let t=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick()},void 0,this.schedulerTickApplyArgs)}catch(r){this.taskService.remove(t),this.applicationErrorHandler(r)}finally{this.cleanup()}this.useMicrotaskScheduler=!0,pk(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(t)})}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,this.pendingRenderTaskId!==null){let t=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(t)}}static \u0275fac=function(r){return new(r||n)};static \u0275prov=Et({token:n,factory:n.\u0275fac,providedIn:"root"})}return n})();function ew(){return VC("NgZoneless"),Ad([{provide:ro,useExisting:JC},{provide:Qt,useClass:Yd},{provide:Vd,useValue:!0},{provide:Wh,useValue:!1},[]])}function mq(){return typeof $localize<"u"&&$localize.locale||tf}var rf=new Ge("",{providedIn:"root",factory:()=>Fe(rf,{optional:!0,skipSelf:!0})||mq()});var tw=class{[Mn];constructor(e){this[Mn]=e}destroy(){this[Mn].destroy()}};function nw(n,e){let t=e?.injector??Fe(Bo),r=e?.manualCleanup!==!0?t.get(Ra):null,o,s=t.get(Ud,null,{optional:!0}),i=t.get(ro);return s!==null?(o=xq(s.view,i,n),r instanceof Dd&&r._lView===s.view&&(r=null)):o=yq(n,t.get(zd),i),o.injector=t,r!==null&&(o.onDestroyFn=r.onDestroy(()=>o.destroy())),new tw(o)}var G_=Yt(Ft({},YD),{cleanupFns:void 0,zone:null,onDestroyFn:Oa,run(){let n=Ul(!1);try{ZD(this)}finally{Ul(n)}},cleanup(){if(!this.cleanupFns?.length)return;let n=$e(null);try{for(;this.cleanupFns.length;)this.cleanupFns.pop()()}finally{this.cleanupFns=[],$e(n)}}}),hq=Yt(Ft({},G_),{consumerMarkedDirty(){this.scheduler.schedule(this),this.notifier.notify(12)},destroy(){pa(this),this.onDestroyFn(),this.cleanup(),this.scheduler.remove(this)}}),gq=Yt(Ft({},G_),{consumerMarkedDirty(){this.view[we]|=8192,Aa(this.view),this.notifier.notify(13)},destroy(){pa(this),this.onDestroyFn(),this.cleanup(),this.view[Vo]?.delete(this)}});function xq(n,e,t){let r=Object.create(gq);return r.view=n,r.zone=typeof Zone<"u"?Zone.current:null,r.notifier=e,r.fn=W_(r,t),n[Vo]??=new Set,n[Vo].add(r),r.consumerMarkedDirty(r),r}function yq(n,e,t){let r=Object.create(hq);return r.fn=W_(r,n),r.scheduler=e,r.notifier=t,r.zone=typeof Zone<"u"?Zone.current:null,r.scheduler.add(r),r.notifier.notify(12),r}function W_(n,e){return()=>{e(t=>(n.cleanupFns??=[]).push(t))}}var q_=Symbol("InputSignalNode#UNSET"),Rq=Yt(Ft({},fh),{transformFn:void 0,applyValueToInputSignal(n,e){_l(n,e)}});function K_(n,e){let t=Object.create(Rq);t.value=n,t.transformFn=e?.transform;function r(){if(Cd(t),t.value===q_){let o=null;throw new Te(-950,o)}return t.value}return r[Mn]=t,r}var Fq=new Ge("");Fq.__NG_ELEMENT_ID__=n=>{let e=fr();if(e===null)throw new Te(204,!1);if(e.type&2)return e.value;if(n&8)return null;throw new Te(204,!1)};function j_(n,e){return K_(n,e)}function Oq(n){return K_(q_,n)}var Tg=(j_.required=Oq,j_);var rw=new Ge(""),Mq=new Ge("");function of(n){return!n.moduleRef}function $q(n){let e=of(n)?n.r3Injector:n.moduleRef.injector,t=e.get(Qt);return t.run(()=>{of(n)?n.r3Injector.resolveInjectorInitializers():n.moduleRef.resolveInjectorInitializers();let r=e.get(po),o;if(t.runOutsideAngular(()=>{o=t.onError.subscribe({next:r})}),of(n)){let s=()=>e.destroy(),i=n.platformInjector.get(rw);i.add(s),e.onDestroy(()=>{o.unsubscribe(),i.delete(s)})}else{let s=()=>n.moduleRef.destroy(),i=n.platformInjector.get(rw);i.add(s),n.moduleRef.onDestroy(()=>{Gd(n.allPlatformModules,n.moduleRef),o.unsubscribe(),i.delete(s)})}return Lq(r,t,()=>{let s=e.get(Fa),i=s.add(),a=e.get(KC);return a.runInitializers(),a.donePromise.then(()=>{let c=e.get(rf,tf);if(U_(c||tf),!e.get(Mq,!0))return of(n)?e.get(Jd):(n.allPlatformModules.push(n.moduleRef),n.moduleRef);if(of(n)){let l=e.get(Jd);return n.rootComponent!==void 0&&l.bootstrap(n.rootComponent),l}else return Pq?.(n.moduleRef,n.allPlatformModules),n.moduleRef}).finally(()=>void s.remove(i))})})}var Pq;function Lq(n,e,t){try{let r=t();return vg(r)?r.catch(o=>{throw e.runOutsideAngular(()=>n(o)),o}):r}catch(r){throw e.runOutsideAngular(()=>n(r)),r}}var Eg=null;function Bq(n=[],e){return Bo.create({name:e,providers:[{provide:Rd,useValue:"platform"},{provide:rw,useValue:new Set([()=>Eg=null])},...n]})}function Vq(n=[]){if(Eg)return Eg;let e=Bq(n);return Eg=e,L_(),Uq(e),e}function Uq(n){let e=n.get(pg,null);Ah(n,()=>{e?.forEach(t=>t())})}function X_(n){let{rootComponent:e,appProviders:t,platformProviders:r,platformRef:o}=n;ot(8);try{let s=o?.injector??Vq(r),i=[z_({}),{provide:ro,useExisting:JC},H1,...t||[]],a=new Xd({providers:i,parent:s,debugName:"",runEnvironmentInitializers:!1});return $q({r3Injector:a.injector,platformInjector:s,rootComponent:e})}catch(s){return Promise.reject(s)}finally{ot(9)}}var Y_=null;function af(){return Y_}function sw(n){Y_??=n}var sf=class{};var cw=(function(n){return n[n.Decimal=0]="Decimal",n[n.Percent=1]="Percent",n[n.Currency=2]="Currency",n[n.Scientific=3]="Scientific",n})(cw||{});var ho={Decimal:0,Group:1,List:2,PercentSign:3,PlusSign:4,MinusSign:5,Exponential:6,SuperscriptingExponent:7,PerMille:8,Infinity:9,NaN:10,TimeSeparator:11,CurrencyDecimal:12,CurrencyGroup:13};function Ql(n,e){let t=Cg(n),r=t[za.NumberSymbols][e];if(typeof r>"u"){if(e===ho.CurrencyDecimal)return t[za.NumberSymbols][ho.Decimal];if(e===ho.CurrencyGroup)return t[za.NumberSymbols][ho.Group]}return r}function J_(n,e){return Cg(n)[za.NumberFormats][e]}var zq=/^(\d+)?\.((\d+)(-(\d+))?)?$/,Z_=22,Sg=".",cf="0",Hq=";",Gq=",",iw="#";function Wq(n,e,t,r,o,s,i=!1){let a="",c=!1;if(!isFinite(n))a=Ql(t,ho.Infinity);else{let u=Kq(n);i&&(u=qq(u));let l=e.minInt,p=e.minFrac,d=e.maxFrac;if(s){let v=s.match(zq);if(v===null)throw new Te(2306,!1);let w=v[1],I=v[3],_=v[5];w!=null&&(l=aw(w)),I!=null&&(p=aw(I)),_!=null?d=aw(_):I!=null&&p>d&&(d=p)}Xq(u,p,d);let f=u.digits,m=u.integerLen,h=u.exponent,g=[];for(c=f.every(v=>!v);m<l;m++)f.unshift(0);for(;m<0;m++)f.unshift(0);m>0?g=f.splice(m,f.length):(g=f,f=[0]);let x=[];for(f.length>=e.lgSize&&x.unshift(f.splice(-e.lgSize,f.length).join(""));f.length>e.gSize;)x.unshift(f.splice(-e.gSize,f.length).join(""));f.length&&x.unshift(f.join("")),a=x.join(Ql(t,r)),g.length&&(a+=Ql(t,o)+g.join("")),h&&(a+=Ql(t,ho.Exponential)+"+"+h)}return n<0&&!c?a=e.negPre+a+e.negSuf:a=e.posPre+a+e.posSuf,a}function e2(n,e,t){let r=J_(e,cw.Decimal),o=jq(r,Ql(e,ho.MinusSign));return Wq(n,o,e,ho.Group,ho.Decimal,t)}function jq(n,e="-"){let t={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},r=n.split(Hq),o=r[0],s=r[1],i=o.indexOf(Sg)!==-1?o.split(Sg):[o.substring(0,o.lastIndexOf(cf)+1),o.substring(o.lastIndexOf(cf)+1)],a=i[0],c=i[1]||"";t.posPre=a.substring(0,a.indexOf(iw));for(let l=0;l<c.length;l++){let p=c.charAt(l);p===cf?t.minFrac=t.maxFrac=l+1:p===iw?t.maxFrac=l+1:t.posSuf+=p}let u=a.split(Gq);if(t.gSize=u[1]?u[1].length:0,t.lgSize=u[2]||u[1]?(u[2]||u[1]).length:0,s){let l=o.length-t.posPre.length-t.posSuf.length,p=s.indexOf(iw);t.negPre=s.substring(0,p).replace(/'/g,""),t.negSuf=s.slice(p+l).replace(/'/g,"")}else t.negPre=e+t.posPre,t.negSuf=t.posSuf;return t}function qq(n){if(n.digits[0]===0)return n;let e=n.digits.length-n.integerLen;return n.exponent?n.exponent+=2:(e===0?n.digits.push(0,0):e===1&&n.digits.push(0),n.integerLen+=2),n}function Kq(n){let e=Math.abs(n)+"",t=0,r,o,s,i,a;for((o=e.indexOf(Sg))>-1&&(e=e.replace(Sg,"")),(s=e.search(/e/i))>0?(o<0&&(o=s),o+=+e.slice(s+1),e=e.substring(0,s)):o<0&&(o=e.length),s=0;e.charAt(s)===cf;s++);if(s===(a=e.length))r=[0],o=1;else{for(a--;e.charAt(a)===cf;)a--;for(o-=s,r=[],i=0;s<=a;s++,i++)r[i]=Number(e.charAt(s))}return o>Z_&&(r=r.splice(0,Z_-1),t=o-1,o=1),{digits:r,exponent:t,integerLen:o}}function Xq(n,e,t){if(e>t)throw new Te(2307,!1);let r=n.digits,o=r.length-n.integerLen,s=Math.min(Math.max(e,o),t),i=s+n.integerLen,a=r[i];if(i>0){r.splice(Math.max(n.integerLen,i));for(let p=i;p<r.length;p++)r[p]=0}else{o=Math.max(0,o),n.integerLen=1,r.length=Math.max(1,i=s+1),r[0]=0;for(let p=1;p<i;p++)r[p]=0}if(a>=5)if(i-1<0){for(let p=0;p>i;p--)r.unshift(0),n.integerLen++;r.unshift(1),n.integerLen++}else r[i-1]++;for(;o<Math.max(0,s);o++)r.push(0);let c=s!==0,u=e+n.integerLen,l=r.reduceRight(function(p,d,f,m){return d=d+p,m[f]=d<10?d:d-10,c&&(m[f]===0&&f>=u?m.pop():c=!1),d>=10?1:0},0);l&&(r.unshift(l),n.integerLen++)}function aw(n){let e=parseInt(n);if(isNaN(e))throw new Te(2305,!1);return e}var uw=(()=>{class n{_viewContainer;_context=new Ng;_thenTemplateRef=null;_elseTemplateRef=null;_thenViewRef=null;_elseViewRef=null;constructor(t,r){this._viewContainer=t,this._thenTemplateRef=r}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){Q_(t,!1),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){Q_(t,!1),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngIfUseIfTypeGuard;static ngTemplateGuard_ngIf;static ngTemplateContextGuard(t,r){return!0}static \u0275fac=function(r){return new(r||n)(Va(Xl),Va(Pa))};static \u0275dir=UC({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}})}return n})(),Ng=class{$implicit=null;ngIf=null};function Q_(n,e){if(n&&!n.createEmbeddedView)throw new Te(2020,!1)}function Yq(n,e){return new Te(2100,!1)}var lw=(()=>{class n{_locale;constructor(t){this._locale=t}transform(t,r,o){if(!Zq(t))return null;o||=this._locale;try{let s=Qq(t);return e2(s,o,r)}catch(s){throw Yq(n,s.message)}}static \u0275fac=function(r){return new(r||n)(Va(rf,16))};static \u0275pipe=zC({name:"number",type:n,pure:!0})}return n})();function Zq(n){return!(n==null||n===""||n!==n)}function Qq(n){if(typeof n=="string"&&!isNaN(Number(n)-parseFloat(n)))return Number(n);if(typeof n!="number")throw new Te(2309,!1);return n}var Dg=(()=>{class n{static \u0275fac=function(r){return new(r||n)};static \u0275mod=yg({type:n});static \u0275inj=kd({})}return n})();function pw(n,e){e=encodeURIComponent(e);for(let t of n.split(";")){let r=t.indexOf("="),[o,s]=r==-1?[t,""]:[t.slice(0,r),t.slice(r+1)];if(o.trim()===e)return decodeURIComponent(s)}return null}var uf=class{};var t2="browser";var _g=new Ge(""),gw=(()=>{class n{_zone;_plugins;_eventNameToPlugin=new Map;constructor(t,r){this._zone=r,t.forEach(o=>{o.manager=this}),this._plugins=t.slice().reverse()}addEventListener(t,r,o,s){return this._findPluginFor(r).addEventListener(t,r,o,s)}getZone(){return this._zone}_findPluginFor(t){let r=this._eventNameToPlugin.get(t);if(r)return r;if(r=this._plugins.find(s=>s.supports(t)),!r)throw new Te(5101,!1);return this._eventNameToPlugin.set(t,r),r}static \u0275fac=function(r){return new(r||n)(Xe(_g),Xe(Qt))};static \u0275prov=Et({token:n,factory:n.\u0275fac})}return n})(),lf=class{_doc;constructor(e){this._doc=e}manager},dw="ng-app-id";function n2(n){for(let e of n)e.remove()}function r2(n,e){let t=e.createElement("style");return t.textContent=n,t}function t7(n,e,t,r){let o=n.head?.querySelectorAll(`style[${dw}="${e}"],link[${dw}="${e}"]`);if(o)for(let s of o)s.removeAttribute(dw),s instanceof HTMLLinkElement?r.set(s.href.slice(s.href.lastIndexOf("/")+1),{usage:0,elements:[s]}):s.textContent&&t.set(s.textContent,{usage:0,elements:[s]})}function mw(n,e){let t=e.createElement("link");return t.setAttribute("rel","stylesheet"),t.setAttribute("href",n),t}var xw=(()=>{class n{doc;appId;nonce;inline=new Map;external=new Map;hosts=new Set;constructor(t,r,o,s={}){this.doc=t,this.appId=r,this.nonce=o,t7(t,r,this.inline,this.external),this.hosts.add(t.head)}addStyles(t,r){for(let o of t)this.addUsage(o,this.inline,r2);r?.forEach(o=>this.addUsage(o,this.external,mw))}removeStyles(t,r){for(let o of t)this.removeUsage(o,this.inline);r?.forEach(o=>this.removeUsage(o,this.external))}addUsage(t,r,o){let s=r.get(t);s?s.usage++:r.set(t,{usage:1,elements:[...this.hosts].map(i=>this.addElement(i,o(t,this.doc)))})}removeUsage(t,r){let o=r.get(t);o&&(o.usage--,o.usage<=0&&(n2(o.elements),r.delete(t)))}ngOnDestroy(){for(let[,{elements:t}]of[...this.inline,...this.external])n2(t);this.hosts.clear()}addHost(t){this.hosts.add(t);for(let[r,{elements:o}]of this.inline)o.push(this.addElement(t,r2(r,this.doc)));for(let[r,{elements:o}]of this.external)o.push(this.addElement(t,mw(r,this.doc)))}removeHost(t){this.hosts.delete(t)}addElement(t,r){return this.nonce&&r.setAttribute("nonce",this.nonce),t.appendChild(r)}static \u0275fac=function(r){return new(r||n)(Xe(mr),Xe(lg),Xe(dg,8),Xe(Kl))};static \u0275prov=Et({token:n,factory:n.\u0275fac})}return n})(),fw={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/Math/MathML"},yw=/%COMP%/g;var s2="%COMP%",n7=`_nghost-${s2}`,r7=`_ngcontent-${s2}`,o7=!0,s7=new Ge("",{providedIn:"root",factory:()=>o7});function i7(n){return r7.replace(yw,n)}function a7(n){return n7.replace(yw,n)}function i2(n,e){return e.map(t=>t.replace(yw,n))}var vw=(()=>{class n{eventManager;sharedStylesHost;appId;removeStylesOnCompDestroy;doc;platformId;ngZone;nonce;animationDisabled;maxAnimationTimeout;tracingService;rendererByCompId=new Map;defaultRenderer;platformIsServer;registry;constructor(t,r,o,s,i,a,c,u=null,l,p,d=null){this.eventManager=t,this.sharedStylesHost=r,this.appId=o,this.removeStylesOnCompDestroy=s,this.doc=i,this.platformId=a,this.ngZone=c,this.nonce=u,this.animationDisabled=l,this.maxAnimationTimeout=p,this.tracingService=d,this.platformIsServer=!1,this.defaultRenderer=new pf(t,i,c,this.platformIsServer,this.tracingService,this.registry=Gh(),this.maxAnimationTimeout)}createRenderer(t,r){if(!t||!r)return this.defaultRenderer;let o=this.getOrCreateRenderer(t,r);return o instanceof kg?o.applyToHost(t):o instanceof df&&o.applyStyles(),o}getOrCreateRenderer(t,r){let o=this.rendererByCompId,s=o.get(r.id);if(!s){let i=this.doc,a=this.ngZone,c=this.eventManager,u=this.sharedStylesHost,l=this.removeStylesOnCompDestroy,p=this.platformIsServer,d=this.tracingService;switch(r.encapsulation){case Ho.Emulated:s=new kg(c,u,r,this.appId,l,i,a,p,d,this.registry,this.animationDisabled,this.maxAnimationTimeout);break;case Ho.ShadowDom:return new hw(c,u,t,r,i,a,this.nonce,p,d,this.registry,this.maxAnimationTimeout);default:s=new df(c,u,r,l,i,a,p,d,this.registry,this.animationDisabled,this.maxAnimationTimeout);break}o.set(r.id,s)}return s}ngOnDestroy(){this.rendererByCompId.clear()}componentReplaced(t){this.rendererByCompId.delete(t)}static \u0275fac=function(r){return new(r||n)(Xe(gw),Xe(xw),Xe(lg),Xe(s7),Xe(mr),Xe(Kl),Xe(Qt),Xe(dg),Xe(XC),Xe(YC),Xe(Qd,8))};static \u0275prov=Et({token:n,factory:n.\u0275fac})}return n})(),pf=class{eventManager;doc;ngZone;platformIsServer;tracingService;registry;maxAnimationTimeout;data=Object.create(null);throwOnSyntheticProps=!0;constructor(e,t,r,o,s,i,a){this.eventManager=e,this.doc=t,this.ngZone=r,this.platformIsServer=o,this.tracingService=s,this.registry=i,this.maxAnimationTimeout=a}destroy(){}destroyNode=null;createElement(e,t){return t?this.doc.createElementNS(fw[t]||t,e):this.doc.createElement(e)}createComment(e){return this.doc.createComment(e)}createText(e){return this.doc.createTextNode(e)}appendChild(e,t){(o2(e)?e.content:e).appendChild(t)}insertBefore(e,t,r){e&&(o2(e)?e.content:e).insertBefore(t,r)}removeChild(e,t){let{elements:r}=this.registry;if(r){r.animate(t,()=>t.remove(),this.maxAnimationTimeout);return}t.remove()}selectRootElement(e,t){let r=typeof e=="string"?this.doc.querySelector(e):e;if(!r)throw new Te(-5104,!1);return t||(r.textContent=""),r}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,t,r,o){if(o){t=o+":"+t;let s=fw[o];s?e.setAttributeNS(s,t,r):e.setAttribute(t,r)}else e.setAttribute(t,r)}removeAttribute(e,t,r){if(r){let o=fw[r];o?e.removeAttributeNS(o,t):e.removeAttribute(`${r}:${t}`)}else e.removeAttribute(t)}addClass(e,t){e.classList.add(t)}removeClass(e,t){e.classList.remove(t)}setStyle(e,t,r,o){o&(Fs.DashCase|Fs.Important)?e.style.setProperty(t,r,o&Fs.Important?"important":""):e.style[t]=r}removeStyle(e,t,r){r&Fs.DashCase?e.style.removeProperty(t):e.style[t]=""}setProperty(e,t,r){e!=null&&(e[t]=r)}setValue(e,t){e.nodeValue=t}listen(e,t,r,o){if(typeof e=="string"&&(e=af().getGlobalEventTarget(this.doc,e),!e))throw new Te(5102,!1);let s=this.decoratePreventDefault(r);return this.tracingService?.wrapEventListener&&(s=this.tracingService.wrapEventListener(e,t,s)),this.eventManager.addEventListener(e,t,s,o)}decoratePreventDefault(e){return t=>{if(t==="__ngUnwrap__")return e;e(t)===!1&&t.preventDefault()}}};function o2(n){return n.tagName==="TEMPLATE"&&n.content!==void 0}var hw=class extends pf{sharedStylesHost;hostEl;shadowRoot;constructor(e,t,r,o,s,i,a,c,u,l,p){super(e,s,i,c,u,l,p),this.sharedStylesHost=t,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);let d=o.styles;d=i2(o.id,d);for(let m of d){let h=document.createElement("style");a&&h.setAttribute("nonce",a),h.textContent=m,this.shadowRoot.appendChild(h)}let f=o.getExternalStyles?.();if(f)for(let m of f){let h=mw(m,s);a&&h.setAttribute("nonce",a),this.shadowRoot.appendChild(h)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}appendChild(e,t){return super.appendChild(this.nodeOrShadowRoot(e),t)}insertBefore(e,t,r){return super.insertBefore(this.nodeOrShadowRoot(e),t,r)}removeChild(e,t){return super.removeChild(null,t)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}},df=class extends pf{sharedStylesHost;removeStylesOnCompDestroy;styles;styleUrls;_animationDisabled;constructor(e,t,r,o,s,i,a,c,u,l,p,d){super(e,s,i,a,c,u,p),this.sharedStylesHost=t,this.removeStylesOnCompDestroy=o,this._animationDisabled=l;let f=r.styles;this.styles=d?i2(d,f):f,this.styleUrls=r.getExternalStyles?.(d)}applyStyles(){this.sharedStylesHost.addStyles(this.styles,this.styleUrls)}destroy(){if(this.removeStylesOnCompDestroy){if(!this._animationDisabled&&this.registry.elements){this.ngZone.runOutsideAngular(()=>{setTimeout(()=>{this.sharedStylesHost.removeStyles(this.styles,this.styleUrls)},this.maxAnimationTimeout)});return}this.sharedStylesHost.removeStyles(this.styles,this.styleUrls)}}},kg=class extends df{contentAttr;hostAttr;constructor(e,t,r,o,s,i,a,c,u,l,p,d){let f=o+"-"+r.id;super(e,t,r,s,i,a,c,u,l,p,d,f),this.contentAttr=i7(f),this.hostAttr=a7(f)}applyToHost(e){this.applyStyles(),this.setAttribute(e,this.hostAttr,"")}createElement(e,t){let r=super.createElement(e,t);return super.setAttribute(r,this.contentAttr,""),r}};var Ag=class n extends sf{supportsDOMEvents=!0;static makeCurrent(){sw(new n)}onAndCancel(e,t,r,o){return e.addEventListener(t,r,o),()=>{e.removeEventListener(t,r,o)}}dispatchEvent(e,t){e.dispatchEvent(t)}remove(e){e.remove()}createElement(e,t){return t=t||this.getDefaultDocument(),t.createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,t){return t==="window"?window:t==="document"?e:t==="body"?e.body:null}getBaseHref(e){let t=c7();return t==null?null:u7(t)}resetBaseElement(){ff=null}getUserAgent(){return window.navigator.userAgent}getCookie(e){return pw(document.cookie,e)}},ff=null;function c7(){return ff=ff||document.head.querySelector("base"),ff?ff.getAttribute("href"):null}function u7(n){return new URL(n,document.baseURI).pathname}var l7=(()=>{class n{build(){return new XMLHttpRequest}static \u0275fac=function(r){return new(r||n)};static \u0275prov=Et({token:n,factory:n.\u0275fac})}return n})(),c2=(()=>{class n extends lf{constructor(t){super(t)}supports(t){return!0}addEventListener(t,r,o,s){return t.addEventListener(r,o,s),()=>this.removeEventListener(t,r,o,s)}removeEventListener(t,r,o,s){return t.removeEventListener(r,o,s)}static \u0275fac=function(r){return new(r||n)(Xe(mr))};static \u0275prov=Et({token:n,factory:n.\u0275fac})}return n})(),a2=["alt","control","meta","shift"],p7={"\b":"Backspace","	":"Tab","\x7F":"Delete","\x1B":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},d7={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey},u2=(()=>{class n extends lf{constructor(t){super(t)}supports(t){return n.parseEventName(t)!=null}addEventListener(t,r,o,s){let i=n.parseEventName(r),a=n.eventCallback(i.fullKey,o,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>af().onAndCancel(t,i.domEventName,a,s))}static parseEventName(t){let r=t.toLowerCase().split("."),o=r.shift();if(r.length===0||!(o==="keydown"||o==="keyup"))return null;let s=n._normalizeKey(r.pop()),i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),a2.forEach(u=>{let l=r.indexOf(u);l>-1&&(r.splice(l,1),i+=u+".")}),i+=s,r.length!=0||s.length===0)return null;let c={};return c.domEventName=o,c.fullKey=i,c}static matchEventFullKeyCode(t,r){let o=p7[t.key]||t.key,s="";return r.indexOf("code.")>-1&&(o=t.code,s="code."),o==null||!o?!1:(o=o.toLowerCase(),o===" "?o="space":o==="."&&(o="dot"),a2.forEach(i=>{if(i!==o){let a=d7[i];a(t)&&(s+=i+".")}}),s+=o,s===r)}static eventCallback(t,r,o){return s=>{n.matchEventFullKeyCode(s,t)&&o.runGuarded(()=>r(s))}}static _normalizeKey(t){return t==="esc"?"escape":t}static \u0275fac=function(r){return new(r||n)(Xe(mr))};static \u0275prov=Et({token:n,factory:n.\u0275fac})}return n})();function bw(n,e,t){let r=Ft({rootComponent:n,platformRef:t?.platformRef},f7(e));return X_(r)}function f7(n){return{appProviders:[...y7,...n?.providers??[]],platformProviders:x7}}function m7(){Ag.makeCurrent()}function h7(){return new kr}function g7(){return bC(document),document}var x7=[{provide:Kl,useValue:t2},{provide:pg,useValue:m7,multi:!0},{provide:mr,useFactory:g7}];var y7=[{provide:Rd,useValue:"root"},{provide:kr,useFactory:h7},{provide:_g,useClass:c2,multi:!0,deps:[mr]},{provide:_g,useClass:u2,multi:!0,deps:[mr]},vw,xw,gw,{provide:La,useExisting:vw},{provide:uf,useClass:l7},[]];var l2={providers:[H0(),ew()]};T();T();T();function X(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}var Ree=qt.whereImpl,lP=(()=>{class n extends go{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Ps(this,sr())}write(t,r,o){this.firstUse&&(this.firstUse=!1,M().get("IS_NODE")&&S.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:o,refCount:1}),s}makeTensorInfo(t,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&y.isString(o[0])){let i=o.map(a=>y.encodeString(a));s=this.write(i,t,r)}else s=this.write(o,t,r);return{dataId:s,shape:t,dtype:r}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let r=this.data.get(t);r.refCount++}decRef(t){if(this.data.has(t)){let r=this.data.get(t);r.refCount--}}move(t,r,o,s,i){this.data.set(t,{values:r,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:r,complexTensorInfos:o}=this.data.get(t);if(r==="complex64"){let s=this.readSync(o.real.dataId),i=this.readSync(o.imag.dataId);return S.mergeRealAndImagArrays(s,i)}return y.convertBackendValuesAndArrayBuffer(this.data.get(t).values,r)}bufferSync(t){let r=this.readSync(t.dataId);if(t.dtype==="string")try{let o=r.map(s=>y.decodeString(s));return ue(t.shape,t.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ue(t.shape,t.dtype,r)}makeOutput(t,r,o){return sr().makeTensorFromTensorInfo(this.makeTensorInfo(r,o,t),this)}disposeData(t,r=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!r&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:o}=this.data.get(t);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let r=y.now();return t(),{kernelMs:y.now()-r}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){X([t],"where");let r=this.readSync(t.dataId);return Ree(t.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();var oN={};Le(oN,{addImpl:()=>_S,bincountImpl:()=>jp,bincountReduceImpl:()=>Qx,bitwiseAndImpl:()=>AS,castImpl:()=>kS,ceilImpl:()=>RS,concatImpl:()=>Jx,equalImpl:()=>FS,expImpl:()=>MS,expm1Impl:()=>PS,floorDivImpl:()=>BS,floorImpl:()=>LS,gatherNdImpl:()=>ey,gatherV2Impl:()=>ty,greaterEqualImpl:()=>US,greaterImpl:()=>VS,lessEqualImpl:()=>HS,lessImpl:()=>zS,linSpaceImpl:()=>ny,logImpl:()=>GS,maxImpl:()=>ry,maximumImpl:()=>WS,minimumImpl:()=>jS,multiplyImpl:()=>$m,negImpl:()=>qS,notEqualImpl:()=>KS,prodImpl:()=>XS,raggedGatherImpl:()=>oy,raggedRangeImpl:()=>sy,raggedTensorToTensorImpl:()=>iy,rangeImpl:()=>ay,rsqrtImpl:()=>ZS,scatterImpl:()=>Yr,sigmoidImpl:()=>UP,simpleAbsImpl:()=>DS,sliceImpl:()=>JS,sparseFillEmptyRowsImpl:()=>cy,sparseReshapeImpl:()=>uy,sparseSegmentReductionImpl:()=>Kp,sqrtImpl:()=>GP,squaredDifferenceImpl:()=>eN,staticRegexReplaceImpl:()=>tN,stridedSliceImpl:()=>ly,stringNGramsImpl:()=>py,stringSplitImpl:()=>dy,stringToHashBucketFastImpl:()=>fy,subImpl:()=>rN,tileImpl:()=>my,topKImpl:()=>hy,transposeImpl:()=>qp,uniqueImpl:()=>gy});T();function DS(n){let e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}var Fee=n=>{let{x:e}=n.inputs,t=n.backend;X(e,"abs");let r=new Float32Array(y.sizeFromShape(e.shape)),o=t.data.get(e.dataId).values;return r=DS(o),t.makeOutput(r,e.shape,e.dtype)},pP={kernelName:"Abs",backendName:"cpu",kernelFunc:Fee};T();T();function ke(n){return(e,t,r,o,s)=>{let i=S.assertAndGetBroadcastShape(e,t),a=i.length,c=y.computeStrides(i),u=y.sizeFromShape(i),l=y.getTypedArrayFromDType(s,u),p=e.length,d=t.length,f=y.computeStrides(e),m=y.computeStrides(t),h=S.getBroadcastDims(e,i),g=S.getBroadcastDims(t,i);if(h.length+g.length===0)for(let x=0;x<l.length;++x)l[x]=n(r[x%r.length],o[x%o.length]);else for(let x=0;x<l.length;++x){let v=y.indexToLoc(x,a,c),w=v.slice(-p);h.forEach(R=>w[R]=0);let I=y.locToIndex(w,p,f),_=v.slice(-d);g.forEach(R=>_[R]=0);let A=y.locToIndex(_,d,m);l[x]=n(r[I],o[A])}return[l,i]}}T();T();T();T();function Rt(n){let{inputs:e,backend:t}=n,{real:r,imag:o}=e,s=t.data.get(r.dataId).values,i=t.data.get(o.dataId).values,a=t.makeTensorInfo(r.shape,"complex64"),c=t.data.get(a.dataId);return c.complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",s),imag:t.makeTensorInfo(o.shape,"float32",i)},a}var dP={kernelName:rc,backendName:"cpu",kernelFunc:Rt};function Gp(n,e,t="float32"){if(t==="complex64"){let o=Gp(n,e,"float32"),s=Gp(n,e,"float32");return Rt({inputs:{real:o,imag:s},backend:n})}let r=y.makeZerosTypedArray(y.sizeFromShape(e),t);return n.makeTensorInfo(e,t,r)}T();function rn(n){let{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var fP={kernelName:qo,backendName:"cpu",kernelFunc:rn};T();function Cr(n){let{inputs:e,backend:t}=n,{input:r}=e,o=t.data.get(r.dataId).complexTensorInfos.real,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var mP={kernelName:ou,backendName:"cpu",kernelFunc:Cr};function kS(n,e,t,r){if(r==="int32"){let o=Int32Array.from(n);return[e,"int32",o]}if(r==="bool"){let o=y.toTypedArray([0],t),[s,i]=ke((a,c)=>a!==c?1:0)(e,[],n,o,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}function wr(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return rn({inputs:{x:o},backend:t});let l=Gp(t,o.shape,o.dtype),p=wr({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),d=Rt({inputs:{real:p,imag:l},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),d}if(o.dtype==="complex64"){let l=Cr({inputs:{input:o},backend:t}),p=wr({inputs:{x:l},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(l),p}if(!y.hasEncodingLoss(o.dtype,s)){let l=rn({inputs:{x:o},backend:t});return{dataId:l.dataId,shape:l.shape,dtype:s}}let i=t.data.get(o.dataId).values,[a,c,u]=kS(i,o.shape,o.dtype,s);return t.makeTensorInfo(a,c,u)}var hP={kernelName:jo,backendName:"cpu",kernelFunc:wr};function Pe(n,e,t,r){return t==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,c=s;X([i,a],n);let u=c.data.get(i.dataId).values,l=c.data.get(a.dataId).values,p=i.dtype==="string"?S.fromUint8ToStringArray(u):u,d=i.dtype==="string"?S.fromUint8ToStringArray(l):l,f=r||i.dtype,[m,h]=e(i.shape,a.shape,p,d,f);return c.makeTensorInfo(h,f,m)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,c=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let u=wr({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),l=c.data.get(u.dataId),p=l.complexTensorInfos.real,d=l.complexTensorInfos.imag,f=c.data.get(p.dataId).values,m=c.data.get(d.dataId).values,h=wr({inputs:{x:a},backend:c,attrs:{dtype:"complex64"}}),g=c.data.get(h.dataId),x=g.complexTensorInfos.real,v=g.complexTensorInfos.imag,w=c.data.get(x.dataId).values,I=c.data.get(v.dataId).values,[_,A,R]=t(i.shape,a.shape,f,m,w,I),F=c.makeTensorInfo(R,"float32",_),P=c.makeTensorInfo(R,"float32",A),L=Rt({inputs:{real:F,imag:P},backend:c});return c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(F),c.disposeIntermediateTensorInfo(P),L}else{let u=c.data.get(i.dataId).values,l=c.data.get(a.dataId).values,p=r||i.dtype,[d,f]=e(i.shape,a.shape,u,l,p);return c.makeTensorInfo(f,p,d)}}}function Wp(n){return(e,t,r,o,s,i)=>{let a=S.assertAndGetBroadcastShape(e,t),c=y.sizeFromShape(a),u=a.length,l=y.computeStrides(a),p=y.getTypedArrayFromDType("float32",c),d=y.getTypedArrayFromDType("float32",c),f=S.getBroadcastDims(e,a),m=S.getBroadcastDims(t,a),h=S.mergeRealAndImagArrays(r,o),g=S.mergeRealAndImagArrays(s,i),x=e.length,v=y.computeStrides(e),w=t.length,I=y.computeStrides(t);if(f.length+m.length===0)for(let _=0;_<p.length;_++){let A=_%h.length,R=_%g.length,F=n(h[A*2],h[A*2+1],g[R*2],g[R*2+1]);p[_]=F.real,d[_]=F.imag}else for(let _=0;_<p.length;_++){let A=y.indexToLoc(_,u,l),R=A.slice(-x);f.forEach(z=>R[z]=0);let F=y.locToIndex(R,x,v),P=A.slice(-w);m.forEach(z=>P[z]=0);let L=y.locToIndex(P,w,I),V=n(h[F*2],h[F*2+1],g[L*2],g[L*2+1]);p[_]=V.real,d[_]=V.imag}return[p,d,a]}}var _S=ke((n,e)=>n+e),Oee=Wp((n,e,t,r)=>({real:n+t,imag:e+r})),Ao=Pe("Add",_S,Oee),gP={kernelName:"Add",backendName:"cpu",kernelFunc:Ao};T();function jp(n,e,t,r,o){let s=y.sizeFromShape(r),i=y.makeZerosTypedArray(o,t);for(let a=0;a<n.length;a++){let c=n[a];if(c<0)throw new Error("Input x must be non-negative!");c>=o||(s>0?i[c]+=e[a]:i[c]+=1)}return i}function Qx(n,e,t,r=!1){let o=n.shape[0],s=n.shape[1],i=ue([o,t],e.dtype);for(let a=0;a<o;a++)for(let c=0;c<s;c++){let u=n.get(a,c);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(r?i.set(1,a,u):e.size>0?i.set(i.get(a,u)+e.get(a,c),a,u):i.set(i.get(a,u)+1,a,u))}return i}T();var AS=ke((n,e)=>n&e),Mee=Pe(qs,AS),xP={kernelName:qs,backendName:"cpu",kernelFunc:Mee};T();T();function Ut(n){return(e,t,r)=>{let o=y.getArrayFromDType(t,e.length);for(let s=0;s<e.length;++s)o[s]=n(e[s],r);return o}}T();function he(n,e,t){let r=Ut(e);return An(n,r,t)}function An(n,e,t){return({inputs:r,attrs:o,backend:s})=>{let{x:i}=r;X(i,n);let a=s,c=a.data.get(i.dataId).values,u;if(i.dtype==="string"){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");u=S.fromUint8ToStringArray(c)}else u=c;let l=t||i.dtype,p=e(u,l,o);return a.makeTensorInfo(i.shape,l,p)}}var RS=Ut(n=>Math.ceil(n)),$ee=An(Ks,RS),yP={kernelName:Ks,backendName:"cpu",kernelFunc:$ee};T();function Jx(n,e,t,r){let o=y.getArrayFromDType(t,y.sizeFromShape(e));if(r&&t!=="string"){let s=0;n.forEach(i=>{let a=y.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;n.forEach(i=>{let a=t==="string"?S.fromUint8ToStringArray(i.vals):i.vals,c=0;for(let u=0;u<i.shape[0];++u){let l=u*e[1]+s;for(let p=0;p<i.shape[1];++p)o[l+p]=a[c++]}s+=i.shape[1]})}return o}T();var FS=ke((n,e)=>n===e?1:0),OS=Pe(Qs,FS,null,"bool"),vP={kernelName:Qs,backendName:"cpu",kernelFunc:OS};T();var MS=Ut(n=>Math.exp(n)),$S=An("Exp",MS,"float32"),bP={kernelName:"Exp",backendName:"cpu",kernelFunc:$S};T();var PS=Ut(n=>Math.expm1(n)),Pee=An(Js,PS),CP={kernelName:Js,backendName:"cpu",kernelFunc:Pee};T();var LS=Ut(n=>Math.floor(n)),Lee=An(ei,LS),wP={kernelName:ei,backendName:"cpu",kernelFunc:Lee};T();var BS=ke((n,e)=>Math.floor(n/e)),Bee=Pe(ti,BS,null,"int32"),IP={kernelName:ti,backendName:"cpu",kernelFunc:Bee};T();function ey(n,e,t,r,o,s,i,a,c){let u=ue([r,s],t);for(let l=0;l<r;l++){let p=[],d=0;for(let f=0;f<o;f++){let m=n[l*o+f];d+=m*i[f],p.push(m)}if(d<0||d>=c/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let f=0;f<s;f++)u.values[l*s+f]=e.get(...e.indexToLoc(d*s+f))}return u}T();function ty(n,e,t){let r=ue(t,n.dtype);for(let o=0;o<r.size;++o){let i=r.indexToLoc(o).slice(),a=i[0],c=i[2],u=e.locToIndex([a,c]);i[2]=e.values[u];let l=n.locToIndex(i);0<=l&&l<n.values.length&&(r.values[o]=n.values[l])}return r}T();var VS=ke((n,e)=>n>e?1:0),Vee=Pe(ni,VS,null,"bool"),EP={kernelName:ni,backendName:"cpu",kernelFunc:Vee};T();var US=ke((n,e)=>n>=e?1:0),Uee=Pe(ri,US,null,"bool"),TP={kernelName:ri,backendName:"cpu",kernelFunc:Uee};T();var zS=ke((n,e)=>n<e?1:0),zee=Pe(ai,zS,null,"bool"),SP={kernelName:ai,backendName:"cpu",kernelFunc:zee};T();var HS=ke((n,e)=>n<=e?1:0),Hee=Pe(ci,HS,null,"bool"),NP={kernelName:ci,backendName:"cpu",kernelFunc:Hee};T();function ny(n,e,t){let r=(e-n)/(t-1),o=y.makeZerosTypedArray(t,"float32");o[0]=n;for(let s=1;s<o.length;s++)o[s]=o[s-1]+r;return o}T();var GS=Ut(n=>Math.log(n)),Gee=An("Log",GS),DP={kernelName:"Log",backendName:"cpu",kernelFunc:Gee};T();function ry(n,e,t,r){let o=y.getTypedArrayFromDType(r,y.sizeFromShape(t));for(let s=0;s<o.length;++s){let i=s*e,a=n[i];for(let c=0;c<e;++c){let u=n[i+c];(Number.isNaN(u)||u>a)&&(a=u)}o[s]=a}return o}T();var WS=ke((n,e)=>Math.max(n,e)),Wee=Pe(fi,WS),kP={kernelName:fi,backendName:"cpu",kernelFunc:Wee};T();var jS=ke((n,e)=>Math.min(n,e)),jee=Pe(mi,jS),_P={kernelName:mi,backendName:"cpu",kernelFunc:jee};T();var $m=ke((n,e)=>n*e),qee=Wp((n,e,t,r)=>({real:n*t-e*r,imag:n*r+e*t})),dl=Pe(hi,$m,qee),AP={kernelName:hi,backendName:"cpu",kernelFunc:dl};T();function qS(n,e,t){let r=y.createScalarValue(-1,t);return $m([],e,r,n,t)}function Kee(n){let{inputs:e,backend:t}=n,{x:r}=e;X(r,"neg");let o=t.data.get(r.dataId).values,[s,i]=qS(o,r.shape,r.dtype);return t.makeTensorInfo(i,r.dtype,s)}var RP={kernelName:"Neg",backendName:"cpu",kernelFunc:Kee};T();var KS=ke((n,e)=>n!==e?1:0),Xee=Pe(gi,KS,null,"bool"),FP={kernelName:gi,backendName:"cpu",kernelFunc:Xee};T();T();T();function qp(n,e,t,r,o){let s=e.length,i=y.sizeFromShape(e),a=y.computeStrides(e),c=y.computeStrides(o),u=y.getTypedArrayFromDType(t,y.sizeFromShape(o));for(let l=0;l<i;++l){let p=y.indexToLoc(l,s,a),d=new Array(p.length);for(let m=0;m<d.length;m++)d[m]=p[r[m]];let f=y.locToIndex(d,s,c);u[f]=n[l]}return u}function ut(n){let{inputs:e,attrs:t,backend:r}=n,{x:o}=e,{perm:s}=t;X(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let c=r.data.get(o.dataId).values,u=qp(c,o.shape,o.dtype,s,a);return{dataId:r.write(u,a,o.dtype),shape:a,dtype:o.dtype}}var OP={kernelName:Xo,backendName:"cpu",kernelFunc:ut};function XS(n,e,t,r){let[o,s]=S.computeOutAndReduceShapes(n,r),i=wt(e,"int32"),a=y.makeZerosTypedArray(y.sizeFromShape(o),i),c=y.sizeFromShape(s);for(let u=0;u<a.length;++u){let l=u*c,p=1;for(let d=0;d<c;++d)p*=t[l+d];a[u]=p}return{outVals:a,outShape:o,outDtype:i}}function Yee(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;X(o,"prod");let a=o.shape.length,c=y.parseAxisParam(s,o.shape),u=S.getAxesPermutation(c,a),l=c,p=o,d=[];u!=null&&(p=ut({inputs:{x:o},backend:t,attrs:{perm:u}}),d.push(p),l=S.getInnerMostAxes(l.length,a));let f=t.data.get(p.dataId).values,{outVals:m,outShape:h,outDtype:g}=XS(p.shape,p.dtype,f,l),x=h;return i&&(x=S.expandShapeToKeepDim(h,c)),d.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(x,g,m)}var MP={kernelName:Jc,backendName:"cpu",kernelFunc:Yee};T();function Zee(n,e,t){n.forEach((r,o)=>{if(r<0||r>=t){let s=y.indexToLoc(o,e.length,y.computeStrides(e)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${t})`)}})}function Qee(n,e){for(let t=0;t<n.length;++t){let r=n[t],o=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>o)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function Jee(n,e,t,r){let o=[],s=0,i=e.length-1+t.length,a=new Array(i).fill(null).map(()=>[0]);Qee(t,r);let c=1;for(let u=0;u<e.length-1;++u){c*=e[u];let l=e[u+1];for(let p=1;p<c+1;++p)a[u].push(p*l)}for(let u=0;u<n.length;++u){let l=n[u],p=n[u]+1;for(let d=0;d<t.length;++d){let f=t[d],m=d+e.length-1;if(m>=0){let h=a[m],g=h[h.length-1]-f[l];for(let x=l;x<p;++x)a[m].push(f[x+1]+g)}l=f[l],p=f[p]}p!==l&&(o.push([l,p]),s+=p-l)}return{outSplits:a,valueSlices:o,numValues:s}}function ete(n){let e=[];for(let t=0;t<n.length;++t){let r=n[t].length,o=y.getArrayFromDType("int32",r);e.push(o),n[t].forEach((s,i)=>o[i]=s)}return e}function $P(n,e){let t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function tte(n,e,t,r,o,s){let i=$P(e,2)[1],a=$P(s,2)[1],c=0;for(let u of t)for(let l=u[0];l<u[1];++l){for(let p=0;p<r;++p)o[c*a+p]=n[l*i+p];++c}}function nte(n,e,t,r,o){let s=e.slice();s[0]=o;let i=y.getArrayFromDType(t,y.sizeFromShape(s)),a=n.length,c=a===0?0:a/e[0];return tte(n,e,r,c,i,s),[i,s]}function oy(n,e,t,r,o,s,i,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");let c=e[0][0]-1;if(Zee(s,i,c),r.length===0)throw new Error("params.rank must be nonzero");let u=r[0],{outSplits:l,valueSlices:p,numValues:d}=Jee(s,i,n,u),f=ete(l),m=nte(t,r,o,p,d);return[f,m[0],m[1]]}T();var PP=2147483647;function sy(n,e,t,r,o,s,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let a=e.length===0,c=o.length===0,u=i.length===0,l=[];a||l.push(e[0]),c||l.push(o[0]),u||l.push(i[0]);for(let g=1;g<l.length;++g)if(l[g]!==l[g-1])throw new Error("starts, limits, and deltas must have the same shape");let p=l.length===0?1:l[0],d=y.getArrayFromDType("int32",p+1);d[0]=0;for(let g=0;g<p;++g){let x=a?n[0]:n[g],v=c?r[0]:r[g],w=u?s[0]:s[g];if(w===0)throw new Error("Requires delta != 0");let I;if(w>0&&v<x||w<0&&v>x)I=0;else if(I=Math.ceil(Math.abs((v-x)/w)),I>PP)throw new Error(`Requires ((limit - start) / delta) <= ${PP}`);d[g+1]=d[g]+I}let f=d[p],m=y.getArrayFromDType(t,f),h=0;for(let g=0;g<p;++g){let x=d[g+1]-d[g],v=a?n[0]:n[g],w=u?s[0]:s[g];for(let I=0;I<x;++I)m[h++]=v,v+=w}return[d,m]}T();var Ir=S.RowPartitionType,YS=class n{constructor(e,t,r,o,s,i,a,c,u,l){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=o,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=c,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=S.getRowPartitionTypesHelper(l),this.raggedRank=S.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Ir.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Ir.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Ir.VALUE_ROWIDS:return n.getMaxWidthValueRowID(t);case Ir.ROW_SPLITS:return n.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Ir[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(t===0||t===1)return 0;let r=0;for(let o=0;o<t-1;++o){let s=e[o+1]-e[o];s>r&&(r=s)}return r}static getMaxWidthValueRowID(e){let t=e.length;if(t===0)return 0;let r=0,o=e[0],s=0;for(let i=1;i<t;++i){let a=e[i];a!==o&&(o=a,s=Math.max(i-r,s),r=i)}return Math.max(t-r,s)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return BP(e,r)}calculateOutputSize(e){let t=this.valuesShape,r=this.defaultValueShape;S.validateDefaultValueShape(r,t);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=S.combineRaggedTensorToTensorShapes(this.raggedRank,o,t);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,t,r){let o=Math.min(e,r),s=[],i=0;for(let a=0;a<o;++a,i+=t)s.push(i);for(let a=o;a<e;++a)s.push(-1);return y.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,r,o){let s=e.length,i=[];for(let a=0;a<s-1;++a){let c=e[a+1]-e[a],u=Math.min(o,c),l=t[a];l===-1&&(u=0);for(let p=0;p<u;++p)i.push(l),l+=r;for(let p=0;p<c-u;++p)i.push(-1)}if(s>0&&i.length!==e[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,r,o){let s=e.length,i=[];if(s===0)return[];let a=0,c=e[0];if(c>=t.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${t.length}`);let u=t[c];i.push(u);for(let l=1;l<s;++l){let p=e[l];if(p===c)u>=0&&(++a,a<o?u+=r:u=-1);else{if(a=0,c=p,p>=t.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${t.length}`);u=t[p]}i.push(u)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,r,o){let s=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case Ir.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,r,o);case Ir.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,r,o);default:throw new Error(`Unsupported partition type: ${Ir[i]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case Ir.FIRST_DIM_SIZE:return e[0];case Ir.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ir.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ir[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let c=o.length-2;c>=0;--c)o[c]=o[c+1]*r[c+1];let s=BP(r,!1),i=y.getArrayFromDType(this.valuesDType,y.sizeFromShape(s));if(o[0]*r[0]>0){let c=this.calculateFirstParentOutputIndex(t,o[0],r[0]);for(let u=1;u<=this.raggedRank;++u)c=this.calculateOutputIndex(u-1,c,o[u],r[u]);this.setOutput(this.raggedRank,c,i,s)}return[s,i]}setOutput(e,t,r,o){if(r.length===0)return;let s=this.values,i=r,a=o.slice();a=a.slice(e+1);let c=y.sizeFromShape(a),u=t.length,l=this.defaultValue;if(l.length!==c&&l.length!==1){let m=this.defaultValueShape;Ce(()=>{let h=U(l,m);l=os(h,a).dataSync()})}let p=0,d=0,f=0;for(let m=0;m<=u;++m){let h=m<u?t[m]:-1;if(h===f){++f;continue}if(d<f){let g=s.subarray(p*c),x=i.subarray(d*c),v=(f-d)*c;LP(x,g,v)}if(m>=u){let g=r.length;h=Math.floor(g/c)}if(h>f)if(this.defaultValue.length===1)i.subarray(f*c,h*c).fill(this.defaultValue[0]),f=h;else for(;h>f;){let g=i.slice(f*c);LP(g,l,c),++f}h<0?(p=m+1,d=f):(p=m,d=f,f=d+1)}}};function LP(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function BP(n,e){let t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function iy(n,e,t,r,o,s,i,a,c,u){return new YS(n,e,t,r,o,s,i,a,c,u).compute()}T();function ay(n,e,t,r){let o=n===e,s=n<e&&t<0,i=e<n&&t>1;if(o||s||i)return y.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((e-n)/t)),c=y.makeZerosTypedArray(a,r);e<n&&t===1&&(t=-1),c[0]=n;for(let u=1;u<c.length;u++)c[u]=c[u-1]+t;return c}T();var ZS=Ut(n=>1/Math.sqrt(n)),rte=An(Ci,ZS),VP={kernelName:Ci,backendName:"cpu",kernelFunc:rte};T();function Yr(n,e,t,r,o,s,i,a,c,u){let l=[r/o,o],p=n.values,d=e.values;if(r===0)return ue(t,e.dtype);let f=c instanceof Ve?c:ue(l,e.dtype);typeof c=="string"||typeof c=="number"?f.values.fill(c):typeof c=="boolean"&&f.values.fill(+c);for(let m=0;m<s;m++){let h=[],g=0;for(let x=0;x<i;x++){let v=p[m*i+x];h.push(v),g+=v*a[x]}if(g<0||g>=r/o)throw new Error(`Invalid indices: ${h} does not index into ${t}`);for(let x=0;x<o;x++)u?f.values[g*o+x]+=d[m*o+x]:f.values[g*o+x]=e.rank===0?d[0]:d[m*o+x]}return f}T();var UP=Ut(n=>1/(1+Math.exp(-n))),QS=he(Ti,n=>1/(1+Math.exp(-n))),zP={kernelName:Ti,backendName:"cpu",kernelFunc:QS};T();function JS(n,e,t,r,o){let s=At.isSliceContinous(r,e,t),i=y.sizeFromShape(t),a=y.computeStrides(r);if(s){let p=At.computeFlatOffset(e,a);return o==="string"?n.slice(p,p+i):n.subarray(p,p+i)}let c=o==="string"?S.fromUint8ToStringArray(n):n,u=ue(r,o,c),l=ue(t,o);for(let p=0;p<l.size;++p){let d=l.indexToLoc(p),f=d.map((m,h)=>m+e[h]);l.set(u.get(...f),...d)}return o==="string"?S.fromStringArrayToUint8(l.values):l.values}function Er(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{begin:s,size:i}=r;X(o,"slice");let[a,c]=At.parseSliceParams(o,s,i);At.assertParamsValid(o,a,c);let u=t.data.get(o.dataId).values,l=JS(u,a,c,o.shape,o.dtype);return t.makeTensorInfo(c,o.dtype,l)}var HP={kernelName:fu,backendName:"cpu",kernelFunc:Er};T();function cy(n,e,t,r,o,s,i){let a=e[0],c=s[0],u=new Array(c),l=new Array(a),p=e[1];if(c===0){if(a!==0)throw new Error(S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let g=y.getArrayFromDType(t,0),x=y.getArrayFromDType(o,0);return[g,[0,p],x,u,l]}let d=!0,f=0,m=new Array(c).fill(0);for(let g=0;g<a;++g){let x=n[g*p];if(x<0)throw new Error(S.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,x));if(x>=c)throw new Error(S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,x,c));++m[x],d=d&&x>=f,f=x}let h=!0;for(let g=0;g<c;++g){let x=m[g]===0;u[g]=x,h=h&&!x,m[g]=Math.max(m[g],1),g>0&&(m[g]+=m[g-1])}if(h&&d){let g=n,x=r;for(let v=0;v<a;++v)l[v]=v;return[g,[a,p],x,u,l]}else{let g=m[c-1],x=y.getArrayFromDType(t,g*p),v=y.getArrayFromDType(o,g),w=new Array(c).fill(0);for(let I=0;I<a;++I){let _=n[I*p],A=w[_],R=(_===0?0:m[_-1])+A;w[_]++;for(let F=0;F<p;++F)x[R*p+F]=n[I*p+F];v[R]=r[I],l[I]=R}for(let I=0;I<c;++I)if(w[I]===0){let A=I===0?0:m[I-1];x[A*p+0]=I;for(let R=1;R<p;++R)x[A*p+R]=0;v[A]=i}return[x,[g,p],v,u,l]}}T();function uy(n,e,t,r,o){let s=y.sizeFromShape(r),i=e[0],a=o.length,c=[],u=1,l=-1;for(let g=0;g<a;++g){let x=o[g];if(x===-1){if(l!==-1)throw new Error(S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(l,g));l=g,c.push(1)}else{if(x<0)throw new Error(S.getSparseReshapeNegativeOutputDimErrorMessage(g,x));u*=x,c.push(x)}}if(l!==-1){if(u<=0)throw new Error(S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/u);if(u*g!==s)throw new Error(S.getSparseReshapeInputOutputMultipleErrorMessage(r,c));c[l]=g}if(y.sizeFromShape(c)!==s)throw new Error(S.getSparseReshapeInputOutputMismatchErrorMessage(r,c));let d=r.length,f=[];if(d>0){f[d-1]=1;for(let g=d-2;g>=0;--g)f[g]=f[g+1]*r[g+1]}let m=[];if(a>0){m[a-1]=1;for(let g=a-2;g>=0;--g)m[g]=m[g+1]*c[g+1]}let h=y.getArrayFromDType(t,i*a);for(let g=0;g<i;++g){let x=0;for(let v=0;v<d;++v)x+=n[g*d+v]*f[v];for(let v=0;v<a;++v)h[g*a+v]=Math.trunc(x/m[v]),x%=m[v]}return[h,[i,a],c]}T();function Kp(n,e,t,r,o,s=!1,i=0){let a=r.length,c=[e[0],n.length/e[0]],u=c[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=e.slice();d[0]=p;let f=d.reduce((w,I)=>w*I,1),m=y.getArrayFromDType(t,f);if(a===0)return p>0&&m.fill(i),[m,d];if(p<=0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,x=0,v=o[h];for(;;){let w=0;if(g<a){if(w=o[g],v===w){++g;continue}if(v>=w)throw new Error(S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(v<0||v>=p)throw new Error(S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v,p));v>x&&m.fill(i,x*u,v*u);for(let I=h;I<g;++I){let _=r[I];if(_<0||_>=c[0])throw new Error(S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(I,r[I],c[0]));for(let A=0;A<u;A++)m[v*u+A]+=n[_*u+A]}if(s)for(let I=0;I<u;I++)m[v*u+I]/=g-h;if(h=g,++g,x=v+1,v=w,g>a)break}return x<p&&m.fill(i,x*u,p*u),[m,d]}T();var GP=Ut(n=>Math.sqrt(n)),ote=he(Ni,n=>Math.sqrt(n)),WP={kernelName:Ni,backendName:"cpu",kernelFunc:ote};T();var eN=ke((n,e)=>{let t=n-e;return t*t}),ste=Pe(Di,eN),jP={kernelName:Di,backendName:"cpu",kernelFunc:ste};T();var tN=Ut((n,e)=>{let{pattern:t,replaceGlobal:r,rewrite:o}=e;return n.replace(new RegExp(t,r?"g":""),o)}),ite=An(ki,tN),qP={kernelName:ki,backendName:"cpu",kernelFunc:ite};T();function ly(n,e,t,r){let o=ue(n,e.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let c=0;c<a.length;c++)a[c]=i[c]*t[c]+r[c];o.set(e.get(...a),...i)}return o}T();var nN=class{constructor(e,t,r,o,s,i){this.separator=y.encodeString(e),this.nGramWidths=t,this.leftPad=y.encodeString(r),this.rightPad=y.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,o,s,i){for(let a=0;a<s;++a){let c=this.getPadWidth(i),u=Math.max(0,c-a),l=Math.max(0,c-(s-(a+1))),p=i-(u+l),d=t+(u>0?0:a-c),f=0;f+=u*this.leftPad.length;for(let v=0;v<p;++v)f+=e[d+v].length;f+=l*this.rightPad.length;let m=u+l+p-1;f+=m*this.separator.length,r[o+a]=new Uint8Array(f);let h=r[o+a],g=0,x=v=>v.forEach(w=>h[g++]=w);for(let v=0;v<u;++v)x(this.leftPad),x(this.separator);for(let v=0;v<p-1;++v)x(e[d+v]),x(this.separator);if(p>0){x(e[d+p-1]);for(let v=0;v<l;++v)x(this.separator),x(this.rightPad)}else{for(let v=0;v<l-1;++v)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,t){let r=e.length,o=t.length;if(o>0){let c=t[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let u=1;u<o;++u){let l=t[u]>=c;if(l=l&&t[u]<=r,!l)throw new Error(`Invalid split value ${t[u]}, must be in [${c}, ${r}]`);c=t[u]}if(c!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${c}`)}let s=o-1,i=y.getArrayFromDType("int32",o);if(r===0||o===0){let c=new Array(r);for(let u=0;u<=s;++u)i[u]=0;return[c,i]}i[0]=0;for(let c=1;c<=s;++c){let u=t[c]-t[c-1],l=0;this.nGramWidths.forEach(p=>{l+=this.getNumNGrams(u,p)}),this.preserveShort&&u>0&&l===0&&(l=1),i[c]=i[c-1]+l}let a=new Array(i[s]);for(let c=0;c<s;++c){let u=t[c],l=i[c];if(this.nGramWidths.forEach(p=>{let d=t[c+1]-t[c],f=this.getNumNGrams(d,p);this.createNGrams(e,u,a,l,f,p),l+=f}),this.preserveShort&&l===i[c]){let p=t[c+1]-t[c];if(p===0)continue;let d=p+2*this.padWidth;this.createNGrams(e,u,a,l,1,d)}}return[a,i]}};function py(n,e,t,r,o,s,i,a){return new nN(t,r,o,s,i,a).compute(n,e)}T();function ate(n,e,t,r){if(!n.length)return;if(e.length===0){for(let s=0;s<n.length;++s)r.push(n.subarray(s,s+1));return}if(e.length===1){let s=e[0],i=n.indexOf(s);for(;i!==-1;){let a=n.subarray(0,i);(!t||a.length!==0)&&r.push(a),n=n.subarray(i+1),i=n.indexOf(s)}(!t||n.length!==0)&&r.push(n);return}let o=0;for(let s=0;s<n.length+1;s++)if(s===n.length||e.indexOf(n[s])!==-1){let i=n.subarray(o,s);(!t||i.length!==0)&&r.push(i),o=s+1}}function dy(n,e,t){let r=n.length,o=[],s=0,i=0,a=new Array(r);for(let d=0;d<r;++d){let f=o.length;ate(n[d],e,t,o);let m=o.length-f;a[d]=m,s+=m,i=Math.max(i,m)}let c=y.getArrayFromDType("int32",s*2),u=new Array(s),l=[r,i],p=0;for(let d=0;d<r;++d)for(let f=0;f<a[d];++f)c[p*2]=d,c[p*2+1]=f,u[p]=o[p],++p;return[c,u,l]}T();function fy(n,e){let t=y.getArrayFromDType("int32",n.length);for(let r=0;r<n.length;++r)t[r]=y.fingerPrint64(n[r]).modulo(e).getLowBitsUnsigned();return t}T();var rN=ke((n,e)=>n-e),cte=Wp((n,e,t,r)=>({real:n-t,imag:e-r})),Pm=Pe("Sub",rN,cte),KP={kernelName:"Sub",backendName:"cpu",kernelFunc:Pm};T();function my(n,e){let t=new Array(n.rank);for(let o=0;o<t.length;o++)t[o]=n.shape[o]*e[o];let r=ue(t,n.dtype);for(let o=0;o<r.values.length;++o){let s=r.indexToLoc(o),i=new Array(n.rank);for(let c=0;c<i.length;c++)i[c]=s[c]%n.shape[c];let a=n.locToIndex(i);r.values[o]=n.values[a]}return r}T();var Lm=(n,e)=>{let t=e.value-n.value;return t===0?n.index-e.index:t};function XP(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){let a=r-t+1,c=e-t+1,u=Math.log(a),l=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*l*(a-l)/a)*Math.sign(c-a/2),d=Math.max(t,Math.floor(e-c*l/a+p)),f=Math.min(r,Math.floor(e+(a-c)*l/a+p));XP(n,e,d,f)}let o=n[e],s=t,i=r;for(y.swap(n,t,e),Lm(n[r],o)>0&&y.swap(n,t,r);s<i;){for(y.swap(n,s,i),s++,i--;Lm(n[s],o)<0;)s=s+1;for(;Lm(n[i],o)>0;)i=i-1}Lm(n[t],o)===0?y.swap(n,t,i):(i=i+1,y.swap(n,i,r)),i<=e&&(t=i+1),e<=i&&(r=i-1)}}function hy(n,e,t,r,o){let s=e[e.length-1],[i,a]=[n.length/s,s],c=y.getTypedArrayFromDType(t,i*r),u=y.getTypedArrayFromDType("int32",i*r);for(let p=0;p<i;p++){let d=p*a,f=n.subarray(d,d+a),m=new Array(f.length);f.forEach((v,w)=>m[w]={value:v,index:w}),r<m.length&&(XP(m,r),m=m.slice(0,r)),o&&m.sort(Lm);let h=p*r,g=c.subarray(h,h+r),x=u.subarray(h,h+r);for(let v=0;v<r;v++)g[v]=m[v].value,x[v]=m[v].index}let l=e.slice();return l[l.length-1]=r,[ue(l,t,c),ue(l,"int32",u)]}T();function gy(n,e,t,r){let o=y.parseAxisParam(e,t)[0],s=[1,t[0],1];for(let m=0;m<o;m++)s[0]*=t[m];s[1]=t[o];for(let m=o+1;m<t.length;m++)s[2]*=t[m];let i=new Map,a=new Int32Array(t[o]),c=new Ve(s,r,n),u=[],l=s[0]===1&&s[2]===1;for(let m=0;m<t[o];m++){let h;if(l)h=n[m].toString();else{let x=[];for(let v=0;v<s[0];v++)for(let w=0;w<s[2];w++)x.push(c.get(v,m,w));h=x.join(",")}let g=i.get(h);if(g!=null)a[m]=g;else{let x=i.size;i.set(h,x),a[m]=x,u.push(m)}}let p=s.slice();p[1]=i.size;let d=new Ve(p,r);u.forEach((m,h)=>{for(let g=0;g<s[0];g++)for(let x=0;x<s[2];x++)d.set(c.get(g,m,x),g,h,x)});let f=t.slice();return f[o]=p[1],{outputValues:d.values,outputShape:f,indices:a}}Of("cpu",()=>new lP,1);T();T();T();var sN=he("Elu",n=>n>=0?n:Math.exp(n)-1),YP={kernelName:"Elu",backendName:"cpu",kernelFunc:sN};T();function iN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{alpha:s}=r;X([o],"leakyRelu");let i=y.sizeFromShape(o.shape),a=t.data.get(o.dataId).values,c=y.getTypedArrayFromDType("float32",i);for(let u=0;u<a.length;u++)c[u]=a[u]<0?s*a[u]:a[u];return t.makeTensorInfo(o.shape,"float32",c)}var ZP={kernelName:Oc,backendName:"cpu",kernelFunc:iN};T();var ute=ke((n,e)=>n<0?e*n:n);function aN(n){let{inputs:e,backend:t}=n,{x:r,alpha:o}=e;X([r,o],"prelu");let s=t.data.get(r.dataId).values,i=t.data.get(o.dataId).values,[a,c]=ute(r.shape,o.shape,s,i,"float32");return t.makeTensorInfo(c,"float32",a)}var QP={kernelName:Qc,backendName:"cpu",kernelFunc:aN};T();var cN=he(yi,n=>Math.max(0,n)),JP={kernelName:yi,backendName:"cpu",kernelFunc:cN};T();var uN=he(vi,n=>Math.min(Math.max(0,n),6)),eL={kernelName:vi,backendName:"cpu",kernelFunc:uN};function fl(n,e,t,r,o){if(t==="linear")return rn({inputs:{x:e},backend:n});if(t==="relu")return cN({inputs:{x:e},backend:n});if(t==="elu")return sN({inputs:{x:e},backend:n});if(t==="relu6")return uN({inputs:{x:e},backend:n});if(t==="prelu")return aN({inputs:{x:e,alpha:r},backend:n});if(t==="leakyrelu")return iN({inputs:{x:e},backend:n,attrs:{alpha:o}});if(t==="sigmoid")return QS({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}T();T();function _e(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{shape:s}=r,i=y.sizeFromShape(o.shape),a=y.inferFromImplicitShape(s,i),c=y.sizeFromShape(a);y.assert(i===c,()=>`The new shape (${a}) has ${c} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.incRef(o.dataId);let u=t.data.get(o.dataId);if(u.complexTensorInfos!=null){let l=u.complexTensorInfos.real,p=u.complexTensorInfos.imag;l.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var tL={kernelName:su,backendName:"cpu",kernelFunc:_e};function lN(n){let{inputs:e,backend:t,attrs:r}=n,{a:o,b:s}=e,{transposeA:i,transposeB:a}=r;X([o,s],"matMul");let c=o.shape.length,u=s.shape.length,l=i?o.shape[c-2]:o.shape[c-1],p=a?s.shape[u-1]:s.shape[u-2],d=i?o.shape[c-1]:o.shape[c-2],f=a?s.shape[u-2]:s.shape[u-1],m=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(m),x=y.sizeFromShape(h),w=Gr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,f]);y.assert(l===p,()=>`Error in matMul: inner shapes (${l}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let I=i?[g,l,d]:[g,d,l],_=a?[x,f,p]:[x,p,f],A=_e({inputs:{x:o},backend:t,attrs:{shape:I}}),R=_e({inputs:{x:s},backend:t,attrs:{shape:_}}),F=i?A.shape[1]:A.shape[2],P=i?A.shape[2]:A.shape[1],L=a?R.shape[1]:R.shape[2],V=Math.max(g,x),z=t.data.get(A.dataId).values,H=t.data.get(R.dataId).values,j=y.computeStrides(A.shape),W=y.computeStrides(R.shape),[Y,Z,K]=i?[j[0],1,j[1]]:[j[0],j[1],1],[Q,te,ne]=a?[1,W[1],W[0]]:[W[1],1,W[0]],se=P*L,re=ue([V,P,L],A.dtype),ae=re.values,oe=t.blockSize;for(let le=0;le<V;le++){let xe=le%g,be=le%x;for(let ye=0;ye<P;ye+=oe){let Ae=Math.min(ye+oe,P);for(let Re=0;Re<L;Re+=oe){let Ye=Math.min(Re+oe,L);for(let nt=0;nt<F;nt+=oe){let It=Math.min(nt+oe,F);for(let rt=ye;rt<Ae;rt++)for(let Ze=Re;Ze<Ye;Ze++){let bt=0;for(let mt=nt;mt<It;mt++){let $o=z[xe*Y+rt*Z+mt*K],Xt=H[mt*Q+Ze*te+be*ne];bt+=$o*Xt}ae[le*se+(rt*L+Ze)]+=bt}}}}}return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(R),t.makeTensorInfo(w,re.dtype,re.values)}var nL={kernelName:Ja,backendName:"cpu",kernelFunc:lN};function lte(n){let{inputs:e,backend:t,attrs:r}=n,{a:o,b:s,bias:i,preluActivationWeights:a}=e,{transposeA:c,transposeB:u,activation:l,leakyreluAlpha:p}=r,d,f,m,h=[];d=lN({inputs:{a:o,b:s},attrs:{transposeA:c,transposeB:u},backend:t}),i&&(f=Ao({inputs:{a:d,b:i},backend:t}),h.push(d),d=f),l&&(m=fl(t,d,l,a,p),h.push(d),d=m);for(let x of h)t.disposeIntermediateTensorInfo(x);return d}var rL={kernelName:Ri,backendName:"cpu",kernelFunc:lte};T();var pte=he(Vs,n=>Math.acos(n)),oL={kernelName:Vs,backendName:"cpu",kernelFunc:pte};T();var dte=he(Us,n=>Math.acosh(n)),sL={kernelName:Us,backendName:"cpu",kernelFunc:dte};T();function fte(n){let{inputs:e,backend:t}=n,r=e;X(e,"addN");let o=r.map(a=>t.data.get(a.dataId).values),s=ue(r[0].shape,r[0].dtype),i=s.values;for(let a=0;a<r.length;a++){let c=o[a];for(let u=0;u<i.length;u++)i[u]+=c[u]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}var iL={kernelName:Ka,backendName:"cpu",kernelFunc:fte};T();function mte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;X(o,"all");let a=y.parseAxisParam(s,o.shape),c=a,u=S.getAxesPermutation(c,o.shape.length),l=o;u!=null&&(l=ut({inputs:{x:o},backend:t,attrs:{perm:u}}),c=S.getInnerMostAxes(c.length,o.shape.length)),S.assertAxesAreInnerMostDims("all",c,l.shape.length);let[p,d]=S.computeOutAndReduceShapes(l.shape,c),f=y.sizeFromShape(d),m=y.makeZerosTypedArray(y.sizeFromShape(p),l.dtype),h=t.data.get(l.dataId).values;for(let x=0;x<m.length;++x){let v=x*f,w=h[v];for(let I=0;I<f;++I){let _=h[v+I];w=w&&_}m[x]=w}u!=null&&t.disposeIntermediateTensorInfo(l);let g=t.makeTensorInfo(p,l.dtype,m);if(i){let x=S.expandShapeToKeepDim(p,a),v=_e({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),v}return g}var aL={kernelName:"All",backendName:"cpu",kernelFunc:mte};T();function hte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;X(o,"any");let a=y.parseAxisParam(s,o.shape),c=a,u=S.getAxesPermutation(c,o.shape.length),l=o;u!=null&&(l=ut({inputs:{x:o},backend:t,attrs:{perm:u}}),c=S.getInnerMostAxes(c.length,o.shape.length)),S.assertAxesAreInnerMostDims("any",c,l.shape.length);let[p,d]=S.computeOutAndReduceShapes(l.shape,c),f=y.sizeFromShape(d),m=y.makeZerosTypedArray(y.sizeFromShape(p),l.dtype),h=t.data.get(l.dataId).values;for(let x=0;x<m.length;++x){let v=x*f,w=h[v];for(let I=0;I<f;++I){let _=h[v+I];w=w||_}m[x]=w}u!=null&&t.disposeIntermediateTensorInfo(l);let g=t.makeTensorInfo(p,l.dtype,m);if(i){let x=S.expandShapeToKeepDim(p,a),v=_e({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),v}return g}var cL={kernelName:"Any",backendName:"cpu",kernelFunc:hte};T();function gte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s}=r;X(o,"argMax");let i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,u=[];a!=null&&(c=ut({inputs:{x:o},backend:t,attrs:{perm:a}}),u.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMax",i,c.shape.length);let[l,p]=S.computeOutAndReduceShapes(c.shape,i),d=y.sizeFromShape(l),f=y.makeZerosTypedArray(d,"int32"),m=y.sizeFromShape(p),h=t.data.get(c.dataId).values;for(let g=0;g<f.length;++g){let x=g*m,v=h[x],w=0;for(let I=0;I<m;++I){let _=h[x+I];_>v&&(v=_,w=I)}f[g]=w}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(l,"int32",f)}var uL={kernelName:Xa,backendName:"cpu",kernelFunc:gte};T();function xte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s}=r;X(o,"argMin");let i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,u=[];a!=null&&(c=ut({inputs:{x:o},backend:t,attrs:{perm:a}}),u.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMin",i,c.shape.length);let[l,p]=S.computeOutAndReduceShapes(c.shape,i),d=y.sizeFromShape(l),f=y.makeZerosTypedArray(d,"int32"),m=y.sizeFromShape(p),h=t.data.get(c.dataId).values;for(let g=0;g<f.length;++g){let x=g*m,v=h[x],w=0;for(let I=0;I<m;++I){let _=h[x+I];_<v&&(v=_,w=I)}f[g]=w}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(l,"int32",f)}var lL={kernelName:Ya,backendName:"cpu",kernelFunc:xte};T();var yte=he(zs,n=>Math.asin(n)),pL={kernelName:zs,backendName:"cpu",kernelFunc:yte};T();var vte=he(Hs,n=>Math.asinh(n)),dL={kernelName:Hs,backendName:"cpu",kernelFunc:vte};T();var bte=he(Gs,n=>Math.atan(n)),fL={kernelName:Gs,backendName:"cpu",kernelFunc:bte};T();var Cte=ke((n,e)=>Math.atan2(n,e)),wte=Pe(js,Cte),mL={kernelName:js,backendName:"cpu",kernelFunc:wte};T();var Ite=he(Ws,n=>Math.atanh(n)),hL={kernelName:Ws,backendName:"cpu",kernelFunc:Ite};T();T();function Xp(n,e,t,r,o,s){let i=o.strideHeight,a=o.strideWidth,c=o.dilationHeight,u=o.dilationWidth,l=o.effectiveFilterHeight,p=o.effectiveFilterWidth,d=o.padInfo.top,f=o.padInfo.left,m=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=ue(o.outShape,t),g=h.values,x=o.outShape[1]*o.outShape[2]*o.outShape[3],v=o.outShape[2]*o.outShape[3],w=o.outShape[3];for(let I=0;I<o.batchSize;++I){let _=I*x,A=I*r[0];for(let R=0;R<o.inChannels;++R)for(let F=0;F<o.outHeight;++F){let P=F*i-d,L=Math.max(0,P),V=Math.min(o.inHeight,l+P),z=_+F*v;for(let H=0;H<o.outWidth;++H){let j=H*a-f,W=Math.max(0,j),Y=Math.min(o.inWidth,p+j),Z=m,K=0,Q=0;for(let ne=L;ne<V;ne+=c){let se=A+ne*r[1];for(let re=W;re<Y;re+=u){let ae=se+re*r[2],oe=n[ae+R];s==="max"&&oe>Z?Z=oe:s==="avg"&&(K+=oe,Q++)}if(isNaN(Z))break}let te=z+H*w+R;g[te]=s==="avg"?K/Q:Z}}}return h}function xy(n,e,t,r,o=!1,s=!1){let i=ue(r.outShape,"int32"),a=r.strideHeight,c=r.strideWidth,u=r.dilationHeight,l=r.dilationWidth,p=r.effectiveFilterHeight,d=r.effectiveFilterWidth,f=r.padInfo.top,m=r.padInfo.left,h=ue(e,t,n);for(let g=0;g<r.batchSize;++g)for(let x=0;x<r.inChannels;++x)for(let v=0;v<r.outHeight;++v){let w=v*a-f,I=w;for(;I<0;)I+=u;let _=Math.min(r.inHeight,p+w);for(let A=0;A<r.outWidth;++A){let R=A*c-m,F=R;for(;F<0;)F+=l;let P=Math.min(r.inWidth,d+R),L=Number.NEGATIVE_INFINITY,V=-1;for(let z=I;z<_;z+=u){let H=z-w;for(let j=F;j<P;j+=l){let W=j-R,Y=h.get(g,z,j,x);Y>L&&(L=Y,o?V=s?((g*r.inHeight+z)*r.inWidth+j)*r.inChannels+x:(z*r.inWidth+j)*r.inChannels+x:V=H*d+W)}}i.set(V,g,v,A,x)}}return i}function yy(n,e,t,r,o,s){let i=o.strideDepth,a=o.strideHeight,c=o.strideWidth,u=o.dilationDepth,l=o.dilationHeight,p=o.dilationWidth,d=o.effectiveFilterDepth,f=o.effectiveFilterHeight,m=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,x=o.padInfo.left,v=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=ue(o.outShape,t),I=w.values,_=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],A=o.outShape[2]*o.outShape[3]*o.outShape[4],R=o.outShape[3]*o.outShape[4],F=o.outShape[4];for(let P=0;P<o.batchSize;++P){let L=P*_,V=P*r[0];for(let z=0;z<o.inChannels;++z)for(let H=0;H<o.outDepth;++H){let j=H*i-h,W=j;for(;W<0;)W+=u;let Y=Math.min(o.inDepth,d+j),Z=L+H*A;for(let K=0;K<o.outHeight;++K){let Q=K*a-g,te=Q;for(;te<0;)te+=l;let ne=Math.min(o.inHeight,f+Q),se=Z+K*R;for(let re=0;re<o.outWidth;++re){let ae=re*c-x,oe=ae;for(;oe<0;)oe+=p;let le=Math.min(o.inWidth,m+ae),xe=se+re*F,be=v,ye=0,Ae=0;for(let Ye=W;Ye<Y;Ye+=u){let nt=V+Ye*r[1];for(let It=te;It<ne;It+=l){let rt=nt+It*r[2];for(let Ze=oe;Ze<le;Ze+=p){let bt=rt+Ze*r[3],mt=n[bt+z];if(s==="max"&&mt>be?be=mt:s==="avg"&&(ye+=mt,Ae++),isNaN(be))break}if(isNaN(be))break}if(isNaN(be))break}let Re=xe+z;I[Re]=s==="avg"?ye/Math.max(Ae,1):be}}}}return w}function gL(n,e){let t=ue(e.outShape,"int32"),r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=e.padInfo.front,f=e.padInfo.top,m=e.padInfo.left;for(let h=0;h<e.batchSize;++h)for(let g=0;g<e.inChannels;++g)for(let x=0;x<e.outDepth;++x){let v=x*r-d,w=v;for(;w<0;)w+=i;let I=Math.min(e.inDepth,u+v);for(let _=0;_<e.outHeight;++_){let A=_*o-f,R=A;for(;R<0;)R+=a;let F=Math.min(e.inHeight,l+A);for(let P=0;P<e.outWidth;++P){let L=P*s-m,V=L;for(;V<0;)V+=c;let z=Math.min(e.inWidth,p+L),H=Number.NEGATIVE_INFINITY,j=-1;for(let W=w;W<I;W+=i){let Y=W-v;for(let Z=R;Z<F;Z+=a){let K=Z-A;for(let Q=V;Q<z;Q+=c){let te=Q-L,ne=n.get(h,W,Z,Q,g);ne>=H&&(H=ne,j=Y*l*p+K*l+te)}}}t.set(j,h,x,_,P,g)}}}return t}function Ete(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e;X(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,u=1;y.assert(S.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let l=S.computePool2DInfo(o.shape,s,i,u,a,c),p;if(l.filterWidth===1&&l.filterHeight===1&&y.arraysEqual(l.inShape,l.outShape))p=rn({inputs:{x:o},backend:t});else{let d=t.data.get(o.dataId).values,f=y.computeStrides(o.shape),m=Xp(d,o.shape,o.dtype,f,l,"avg");p=t.makeTensorInfo(l.outShape,o.dtype,m.values)}return p}var xL={kernelName:Za,backendName:"cpu",kernelFunc:Ete};T();function Tte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:c,dataFormat:u}=r;X(o,"avgPool3d");let l=S.computePool3DInfo(o.shape,s,i,1,a,c,u),p=t.data.get(o.dataId).values,d=yy(p,o.shape,o.dtype,y.computeStrides(o.shape),l,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}var yL={kernelName:Qa,backendName:"cpu",kernelFunc:Tte};T();function Ste(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,{filterSize:i,strides:a,pad:c,dimRoundingMode:u}=r;X([o,s],"avgPool3DGrad");let l=S.computePool3DInfo(s.shape,i,a,1,c,u),p=l.strideDepth,d=l.strideHeight,f=l.strideWidth,m=l.filterDepth,h=l.filterHeight,g=l.filterWidth,x=l.dilationDepth,v=l.dilationHeight,w=l.dilationWidth,I=l.effectiveFilterDepth,_=l.effectiveFilterHeight,A=l.effectiveFilterWidth,R=I-1-l.padInfo.front,F=A-1-l.padInfo.left,P=_-1-l.padInfo.top,L=ue(s.shape,"float32"),V=1/(m*h*g),z=t.bufferSync(o);for(let H=0;H<l.batchSize;++H)for(let j=0;j<l.inChannels;++j)for(let W=0;W<l.inDepth;++W)for(let Y=0;Y<l.inHeight;++Y)for(let Z=0;Z<l.inWidth;++Z){let K=W-R,Q=Y-P,te=Z-F,ne=0;for(let se=0;se<I;se+=x){let re=(K+se)/p;if(!(re<0||re>=l.outDepth||Math.floor(re)!==re))for(let ae=0;ae<_;ae+=v){let oe=(Q+ae)/d;if(!(oe<0||oe>=l.outHeight||Math.floor(oe)!==oe))for(let le=0;le<A;le+=w){let xe=(te+le)/f;if(xe<0||xe>=l.outWidth||Math.floor(xe)!==xe)continue;let be=z.get(H,re,oe,xe,j);ne+=be}}}L.set(ne*V,H,W,Y,Z,j)}return t.makeTensorInfo(L.shape,L.dtype,L.values)}var vL={kernelName:xf,backendName:"cpu",kernelFunc:Ste};T();function Nte(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,i=s;X([o,s],"avgPoolGrad");let{filterSize:a,strides:c,pad:u}=r,l=S.computePool2DInfo(i.shape,a,c,1,u),p=l.strideHeight,d=l.strideWidth,f=l.filterHeight,m=l.filterWidth,h=l.dilationHeight,g=l.dilationWidth,x=l.effectiveFilterHeight,v=l.effectiveFilterWidth,w=v-1-l.padInfo.left,I=x-1-l.padInfo.top,_=ue(i.shape,"float32"),A=1/(f*m),R=t.data.get(o.dataId).values,F=ue(o.shape,"float32",R);for(let P=0;P<l.batchSize;++P)for(let L=0;L<l.inChannels;++L)for(let V=0;V<l.inHeight;++V)for(let z=0;z<l.inWidth;++z){let H=V-I,j=z-w,W=0;for(let Y=0;Y<x;Y+=h){let Z=(H+Y)/p;if(!(Z<0||Z>=l.outHeight||Math.floor(Z)!==Z))for(let K=0;K<v;K+=g){let Q=(j+K)/d;if(Q<0||Q>=l.outWidth||Math.floor(Q)!==Q)continue;let te=F.get(P,Z,Q,L);W+=te}}_.set(W*A,P,V,z,L)}return t.makeTensorInfo(_.shape,_.dtype,_.values)}var bL={kernelName:gf,backendName:"cpu",kernelFunc:Nte};T();function Dte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,scale:s,offset:i,mean:a,variance:c}=e;y.assert(a.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),X([o,a,c,s,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);let l=t.data.get(o.dataId).values,p=t.data.get(a.dataId).values,d=t.data.get(c.dataId).values,f=s?t.data.get(s.dataId).values:new Float32Array([1]),m=i?t.data.get(i.dataId).values:new Float32Array([0]),h=new Float32Array(l.length),g=m.length,x=f.length,v=d.length,w=p.length,I=0,_=0,A=0,R=0;for(let F=0;F<l.length;++F)h[F]=m[I++]+(l[F]-p[_++])*f[A++]/Math.sqrt(d[R++]+u),I>=g&&(I=0),_>=w&&(_=0),A>=x&&(A=0),R>=v&&(R=0);return t.makeTensorInfo(o.shape,o.dtype,h)}var CL={kernelName:kc,backendName:"cpu",kernelFunc:Dte};T();function kte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockShape:s,crops:i}=r;X([o],"batchToSpaceND");let a=s.reduce((x,v)=>x*v),c=S.getReshaped(o.shape,s,a),u=S.getPermuted(c.length,s.length),l=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),d=S.getSliceSize(l,i,s.length),f=_e({inputs:{x:o},backend:t,attrs:{shape:c}}),m=ut({inputs:{x:f},backend:t,attrs:{perm:u}}),h=_e({inputs:{x:m},backend:t,attrs:{shape:l}}),g=Er({inputs:{x:h},backend:t,attrs:{begin:p,size:d}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),g}var wL={kernelName:ec,backendName:"cpu",kernelFunc:kte};T();function _te(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,weights:s}=e,{size:i}=r,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,u=jp(a,c,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,u)}var IL={kernelName:tc,backendName:"cpu",kernelFunc:_te};T();function Ate(n){let{inputs:e,backend:t}=n,{s0:r,s1:o}=e,s=t.data.get(r.dataId).values,i=t.data.get(o.dataId).values,a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var EL={kernelName:nc,backendName:"cpu",kernelFunc:Ate};T();var Rte=he(Xs,(n,e)=>{let t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),TL={kernelName:Xs,backendName:"cpu",kernelFunc:Rte};T();var Fte=n=>{let{x:e}=n.inputs,t=n.backend,r=new Float32Array(y.sizeFromShape(e.shape)),o=t.data.get(e.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values;for(let u=0;u<a.length;u++){let l=a[u],p=c[u];r[u]=Math.hypot(l,p)}return t.makeOutput(r,e.shape,"float32")},SL={kernelName:oc,backendName:"cpu",kernelFunc:Fte};T();T();function Ro(n){let{inputs:e,backend:t}=n,{input:r}=e,o=t.data.get(r.dataId).complexTensorInfos.imag,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var NL={kernelName:Fc,backendName:"cpu",kernelFunc:Ro};function ra(n){let{inputs:e,backend:t,attrs:r}=n,{axis:o}=r,s=y.parseAxisParam(o,e[0].shape)[0],i=e.map(h=>h.shape);S.assertParamsConsistent(i,s);let a=S.computeOutShape(e.map(h=>h.shape),s);if(y.sizeFromShape(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);let c=e.filter(h=>y.sizeFromShape(h.shape)>0);if(c.length===1)return rn({inputs:{x:c[0]},backend:t});if(c[0].dtype==="complex64"){let h=c.map(I=>Cr({inputs:{input:I},backend:t})),g=c.map(I=>Ro({inputs:{input:I},backend:t})),x=ra({inputs:h,backend:t,attrs:{axis:s}}),v=ra({inputs:g,backend:t,attrs:{axis:s}}),w=Rt({inputs:{real:x,imag:v},backend:t});return h.forEach(I=>t.disposeIntermediateTensorInfo(I)),g.forEach(I=>t.disposeIntermediateTensorInfo(I)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(v),w}let u=c.map(h=>{let x=[-1,y.sizeFromShape(h.shape.slice(s))];return _e({inputs:{x:h},backend:t,attrs:{shape:x}})}),l=u.map(h=>({vals:t.data.get(h.dataId).values,shape:h.shape}));a=S.computeOutShape(u.map(h=>h.shape),1);let p=u[0].shape[0]===1,d=Jx(l,a,e[0].dtype,p),f=S.computeOutShape(c.map(h=>h.shape),s),m=t.makeTensorInfo(f,e[0].dtype,d);return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),m}var DL={kernelName:sc,backendName:"cpu",kernelFunc:ra};T();function pN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dataFormat:c,dilations:u,dimRoundingMode:l}=r;X([o,s],"conv2d");let p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,s.shape,i,u,a,l,!1,p),f=d.filterHeight,m=d.filterWidth,h=d.dilationHeight,g=d.dilationWidth,x=d.padInfo.left,v=d.padInfo.top,w=d.dataFormat==="channelsLast",I=new Ve(d.outShape,o.dtype),_=y.computeStrides(o.shape),A=y.computeStrides(s.shape),R=_[0],F=w?_[1]:_[2],P=w?_[2]:1,L=w?1:_[1],V=I.strides[0],z=w?I.strides[1]:I.strides[2],H=w?I.strides[2]:1,j=w?1:I.strides[1],W=t.data.get(o.dataId).values,Y=t.data.get(s.dataId).values,Z=I.values;for(let K=0;K<d.batchSize;++K){let Q=K*R,te=K*V;for(let ne=0;ne<d.outHeight;++ne){let se=te+ne*z,re=ne*d.strideHeight-v;for(let ae=0;ae<f;++ae){let oe=re+ae*h;if(oe<0||oe>=d.inHeight)continue;let le=ae*A[0],xe=Q+oe*F;for(let be=0;be<d.outWidth;++be){let ye=se+be*H,Ae=be*d.strideWidth-x;for(let Re=0;Re<m;++Re){let Ye=Ae+Re*g;if(Ye<0||Ye>=d.inWidth)continue;let nt=le+Re*A[1],It=xe+Ye*P,rt=nt;for(let Ze=0;Ze<d.inChannels;++Ze){let bt=W[It+Ze*L];for(let mt=0;mt<d.outChannels;++mt)Z[ye+mt*j]+=bt*Y[rt+mt];rt+=d.outChannels}}}}}}return t.makeTensorInfo(I.shape,I.dtype,Z)}var kL={kernelName:ic,backendName:"cpu",kernelFunc:pN};T();function Ote(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,pad:a,dataFormat:c,dimRoundingMode:u,filterShape:l}=r;X([o,s],"conv2dBackpropFilter");let p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,l,i,1,a,u,!1,p),{strideHeight:f,strideWidth:m,filterHeight:h,filterWidth:g}=d,x=d.dataFormat==="channelsLast",v=new Ve(d.filterShape,"float32"),w=d.padInfo.left,I=d.padInfo.top,_=t.data.get(o.dataId).values,A=t.data.get(s.dataId).values,R=new Ve(o.shape,o.dtype,_),F=new Ve(s.shape,s.dtype,A);for(let P=0;P<h;++P){let L=Math.max(0,Math.ceil((I-P)/f)),V=Math.min(d.outHeight,(d.inHeight+I-P)/f);for(let z=0;z<g;++z){let H=Math.max(0,Math.ceil((w-z)/m)),j=Math.min(d.outWidth,(d.inWidth+w-z)/m);for(let W=0;W<d.inChannels;++W)for(let Y=0;Y<d.outChannels;++Y){let Z=0;for(let K=0;K<d.batchSize;++K)for(let Q=L;Q<V;++Q){let te=P+Q*f-I;for(let ne=H;ne<j;++ne){let se=z+ne*m-w;x?Z+=R.get(K,te,se,W)*F.get(K,Q,ne,Y):Z+=R.get(K,W,te,se)*F.get(K,Y,Q,ne)}}v.set(Z,P,z,W,Y)}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}var _L={kernelName:ac,backendName:"cpu",kernelFunc:Ote};T();function Mte(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{inputShape:i,strides:a,pad:c,dataFormat:u,dimRoundingMode:l}=r;X([o,s],"conv2dBackpropInput");let p=y.computeStrides(s.shape),d=y.computeStrides(o.shape),f=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(i,s.shape,a,1,c,l,!1,f),h=new Ve(m.inShape,"float32"),g=h.values,x=t.data.get(o.dataId).values,v=t.data.get(s.dataId).values,[w,I,_]=p,{batchSize:A,filterHeight:R,filterWidth:F,inChannels:P,inHeight:L,inWidth:V,outChannels:z,outHeight:H,outWidth:j,strideHeight:W,strideWidth:Y}=m;f=m.dataFormat;let Z=R-1-m.padInfo.top,K=F-1-m.padInfo.left,Q=f==="channelsLast",te=h.strides[0],ne=Q?h.strides[1]:h.strides[2],se=Q?h.strides[2]:1,re=Q?1:h.strides[1],ae=d[0],oe=Q?d[1]:d[2],le=Q?d[2]:1,xe=Q?1:d[1];for(let be=0;be<A;++be)for(let ye=0;ye<P;++ye)for(let Ae=0;Ae<L;++Ae){let Re=Ae-Z,Ye=Math.max(0,Math.ceil(Re/W)),nt=Math.min(H,(R+Re)/W);for(let It=0;It<V;++It){let rt=It-K,Ze=Math.max(0,Math.ceil(rt/Y)),bt=Math.min(j,(F+rt)/Y),mt=0;for(let Xt=Ye;Xt<nt;++Xt){let Is=Xt*W-Re;for(let Qn=Ze;Qn<bt;++Qn){let la=Qn*Y-rt,Sr=ae*be+oe*Xt+le*Qn,Po=w*(R-1-Is)+I*(F-1-la)+_*ye;for(let Es=0;Es<z;++Es){let Ts=x[Sr+xe*Es],Ss=v[Po+Es];mt+=Ts*Ss}}}let $o=te*be+ne*Ae+se*It+re*ye;g[$o]=mt}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}var AL={kernelName:cc,backendName:"cpu",kernelFunc:Mte};T();function $te(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dilations:c}=r;X([o,s],"conv3d");let u=S.computeConv3DInfo(o.shape,s.shape,i,c,a),{filterDepth:l,filterHeight:p,filterWidth:d,dilationDepth:f,dilationHeight:m,dilationWidth:h,padInfo:g}=u,x=g.front,v=g.left,w=g.top,I=new Ve(u.outShape,o.dtype),_=t.data.get(o.dataId).values,A=t.data.get(s.dataId).values,R=I.values,F=y.computeStrides(o.shape),P=y.computeStrides(s.shape);for(let L=0;L<u.batchSize;++L){let V=L*F[0],z=L*I.strides[0];for(let H=0;H<u.outDepth;++H){let j=z+H*I.strides[1],W=H*u.strideDepth-x;for(let Y=0;Y<l;++Y){let Z=W+Y*f;if(Z<0||Z>=u.inDepth)continue;let K=Y*P[0],Q=V+Z*F[1];for(let te=0;te<u.outHeight;++te){let ne=j+te*I.strides[2],se=te*u.strideHeight-w;for(let re=0;re<p;++re){let ae=se+re*m;if(ae<0||ae>=u.inHeight)continue;let oe=K+re*P[1],le=Q+ae*F[2];for(let xe=0;xe<u.outWidth;++xe){let be=ne+xe*u.outChannels,ye=xe*u.strideWidth-v;for(let Ae=0;Ae<d;++Ae){let Re=ye+Ae*h;if(Re<0||Re>=u.inWidth)continue;let Ye=oe+Ae*P[2],nt=le+Re*u.inChannels,It=Ye;for(let rt=0;rt<u.inChannels;++rt){let Ze=_[nt+rt];for(let bt=0;bt<u.outChannels;++bt)R[be+bt]+=Ze*A[It+bt];It+=u.outChannels}}}}}}}}return t.makeTensorInfo(I.shape,I.dtype,I.values)}var RL={kernelName:uc,backendName:"cpu",kernelFunc:$te};T();function Pte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,pad:a,filterShape:c}=r;X([o,s],"conv3dBackpropFilterV2");let u=y.computeStrides(o.shape),l=y.computeStrides(s.shape),p=S.computeConv3DInfo(o.shape,c,i,1,a),d=p.strideDepth,f=p.strideHeight,m=p.strideWidth,h=p.filterDepth,g=p.filterHeight,x=p.filterWidth,v=new Ve(p.filterShape,"float32"),w=v.values,[I,_,A,R]=v.strides,F=t.data.get(s.dataId).values,[P,L,V,z]=l,H=t.data.get(o.dataId).values,[j,W,Y,Z]=u,K=p.padInfo.front,Q=p.padInfo.left,te=p.padInfo.top;for(let ne=0;ne<h;++ne){let se=Math.max(0,Math.ceil((K-ne)/d)),re=Math.min(p.outDepth,(p.inDepth+K-ne)/d),ae=ne*I;for(let oe=0;oe<g;++oe){let le=Math.max(0,Math.ceil((te-oe)/f)),xe=Math.min(p.outHeight,(p.inHeight+te-oe)/f),be=oe*_+ae;for(let ye=0;ye<x;++ye){let Ae=Math.max(0,Math.ceil((Q-ye)/m)),Re=Math.min(p.outWidth,(p.inWidth+Q-ye)/m),Ye=ye*A+be;for(let nt=0;nt<p.inChannels;++nt){let It=nt*R+Ye;for(let rt=0;rt<p.outChannels;++rt){let Ze=0;for(let bt=0;bt<p.batchSize;++bt){let mt=bt*j,$o=bt*P;for(let Xt=se;Xt<re;++Xt){let Qn=(ne+Xt*d-K)*W+mt,la=Xt*L+$o;for(let Sr=le;Sr<xe;++Sr){let Es=(oe+Sr*f-te)*Y+Qn,Ts=Sr*V+la;for(let Ss=Ae;Ss<Re;++Ss){let kb=(ye+Ss*m-Q)*Z+Es,_b=Ss*z+Ts;Ze+=H[kb+nt]*F[_b+rt]}}}}w[It+rt]=Ze}}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}var FL={kernelName:yf,backendName:"cpu",kernelFunc:Pte};T();function Lte(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{pad:i,strides:a,inputShape:c}=r;X([o],"conv3dBackpropInputV2");let u=y.computeStrides(o.shape),l=y.computeStrides(s.shape),p=S.computeConv3DInfo(c,s.shape,a,1,i),d=new Ve(p.inShape,"float32"),f=d.values,[m,h,g,x]=d.strides,v=t.data.get(o.dataId).values,[w,I,_,A]=u,R=t.data.get(s.dataId).values,[F,P,L,V]=l,{batchSize:z,filterDepth:H,filterHeight:j,filterWidth:W,inChannels:Y,inDepth:Z,inHeight:K,inWidth:Q,outChannels:te,outDepth:ne,outHeight:se,outWidth:re,strideDepth:ae,strideHeight:oe,strideWidth:le}=p,xe=H-1-p.padInfo.front,be=j-1-p.padInfo.top,ye=W-1-p.padInfo.left;for(let Ae=0;Ae<z;++Ae)for(let Re=0;Re<Y;++Re)for(let Ye=0;Ye<Z;++Ye){let nt=Ye-xe,It=Math.max(0,Math.ceil(nt/ae)),rt=Math.min(ne,(H+nt)/ae);for(let Ze=0;Ze<K;++Ze){let bt=Ze-be,mt=Math.max(0,Math.ceil(bt/oe)),$o=Math.min(se,(j+bt)/oe);for(let Xt=0;Xt<Q;++Xt){let Is=Xt-ye,Qn=Math.max(0,Math.ceil(Is/le)),la=Math.min(re,(W+Is)/le),Sr=0;for(let Po=It;Po<rt;++Po){let Es=Po*ae-nt;for(let Ts=mt;Ts<$o;++Ts){let Ss=Ts*oe-bt;for(let vd=Qn;vd<la;++vd){let kb=vd*le-Is,_b=w*Ae+I*Po+_*Ts+A*vd,QW=F*(H-1-Es)+P*(j-1-Ss)+L*(W-1-kb)+V*Re;for(let ah=0;ah<te;++ah){let JW=v[_b+ah],ej=R[QW+ah];Sr+=JW*ej}}}}f[m*Ae+h*Ye+g*Ze+x*Xt+Re]=Sr}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}var OL={kernelName:lc,backendName:"cpu",kernelFunc:Lte};T();var Bte=he("Cos",n=>Math.cos(n)),ML={kernelName:"Cos",backendName:"cpu",kernelFunc:Bte};T();var Vte=he(Ys,n=>Math.cosh(n)),$L={kernelName:Ys,backendName:"cpu",kernelFunc:Vte};T();function Ute(n){let{inputs:e,backend:t,attrs:r}=n,{image:o,boxes:s,boxInd:i}=e,{cropSize:a,method:c,extrapolationValue:u}=r,[l,p,d,f]=o.shape,m=s.shape[0],[h,g]=a,x=ue([m,h,g,f],"float32"),v=t.data.get(s.dataId).values,w=t.data.get(i.dataId).values,I=t.data.get(o.dataId).values,_=y.computeStrides(o.shape),A=y.computeStrides(x.shape);for(let R=0;R<m;R++){let F=R*4,P=v[F],L=v[F+1],V=v[F+2],z=v[F+3],H=w[R];if(H>=l)continue;let j=h>1?(V-P)*(p-1)/(h-1):0,W=g>1?(z-L)*(d-1)/(g-1):0;for(let Y=0;Y<h;Y++){let Z=h>1?P*(p-1)+Y*j:.5*(P+V)*(p-1);if(Z<0||Z>p-1){for(let K=0;K<g;K++)for(let Q=0;Q<f;Q++){let te=Q+K*A[2]+Y*A[1]+R*A[0];x.values[te]=u}continue}if(c==="bilinear"){let K=Math.floor(Z),Q=Math.ceil(Z),te=Z-K;for(let ne=0;ne<g;ne++){let se=g>1?L*(d-1)+ne*W:.5*(L+z)*(d-1);if(se<0||se>d-1){for(let le=0;le<f;le++){let xe=le+ne*A[2]+Y*A[1]+R*A[0];x.values[xe]=u}continue}let re=Math.floor(se),ae=Math.ceil(se),oe=se-re;for(let le=0;le<f;le++){let xe=le+re*_[2]+K*_[1]+H*_[0],be=I[xe];xe=le+ae*_[2]+K*_[1]+H*_[0];let ye=I[xe];xe=le+re*_[2]+Q*_[1]+H*_[0];let Ae=I[xe];xe=le+ae*_[2]+Q*_[1]+H*_[0];let Re=I[xe],Ye=be+(ye-be)*oe,nt=Ae+(Re-Ae)*oe;xe=le+ne*A[2]+Y*A[1]+R*A[0],x.values[xe]=Ye+(nt-Ye)*te}}}else for(let K=0;K<g;++K){let Q=g>1?L*(d-1)+K*W:.5*(L+z)*(d-1);if(Q<0||Q>d-1){for(let se=0;se<f;se++){let re=se+K*A[2]+Y*A[1]+R*A[0];x.values[re]=u}continue}let te=Math.round(Q),ne=Math.round(Z);for(let se=0;se<f;se++){let re=se+te*_[2]+ne*_[1]+H*_[0],ae=se+K*A[2]+Y*A[1]+R*A[0];x.values[ae]=I[re]}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}var PL={kernelName:mc,backendName:"cpu",kernelFunc:Ute};T();function zte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,exclusive:i,reverse:a}=r;X(o,"cumprod");let c=S.getAxesPermutation([s],o.shape.length),u=o;c!=null&&(u=ut({inputs:{x:o},backend:t,attrs:{perm:c}}));let l=S.getInnerMostAxes(1,o.shape.length)[0];if(l!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${l}`);let p=wt(u.dtype,"int32"),d=y.makeOnesTypedArray(y.sizeFromShape(u.shape),p),f=t.data.get(u.dataId).values,m=u.shape[u.shape.length-1],h=a?(x,v)=>x+m-v-1:(x,v)=>x+v;for(let x=0;x<f.length;x+=m)for(let v=0;v<m;v++){let w=h(x,v);if(v===0)d[w]=i?1:f[w];else{let I=h(x,v-1);d[w]=i?f[I]*d[I]:f[w]*d[I]}}let g=t.makeTensorInfo(u.shape,p,d);if(c!=null){let x=S.getUndoAxesPermutation(c),v=ut({inputs:{x:g},backend:t,attrs:{perm:x}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),v}return g}var LL={kernelName:dc,backendName:"cpu",kernelFunc:zte};T();function Hte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,exclusive:i,reverse:a}=r;X(o,"cumsum");let c=S.getAxesPermutation([s],o.shape.length),u=o;c!=null&&(u=ut({inputs:{x:o},backend:t,attrs:{perm:c}}));let l=S.getInnerMostAxes(1,o.shape.length)[0];if(l!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${l}`);let p=wt(u.dtype,"int32"),d=y.makeZerosTypedArray(y.sizeFromShape(u.shape),p),f=t.data.get(u.dataId).values,m=u.shape[u.shape.length-1],h=a?(x,v)=>x+m-v-1:(x,v)=>x+v;for(let x=0;x<f.length;x+=m)for(let v=0;v<m;v++){let w=h(x,v);if(v===0)d[w]=i?0:f[w];else{let I=h(x,v-1);d[w]=i?f[I]+d[I]:f[w]+d[I]}}let g=t.makeTensorInfo(u.shape,p,d);if(c!=null){let x=S.getUndoAxesPermutation(c),v=ut({inputs:{x:g},backend:t,attrs:{perm:x}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),v}return g}var BL={kernelName:fc,backendName:"cpu",kernelFunc:Hte};T();function Gte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,weights:s}=e,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let c=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,l=jp(c,u,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,l)}else if(o.shape.length===2){let c=t.bufferSync(o),u=t.bufferSync(s),l=Qx(c,u,i,a);return t.makeTensorInfo(l.shape,s.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var VL={kernelName:hc,backendName:"cpu",kernelFunc:Gte};T();function Wte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockSize:s,dataFormat:i}=r;y.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],c=o.shape[1],u=o.shape[2],l=o.shape[3],p=c*s,d=u*s,f=l/(s*s),m=t.data.get(o.dataId).values,h=new Float32Array(a*p*d*f),g=0;for(let x=0;x<a;++x)for(let v=0;v<p;++v){let w=Math.floor(v/s),I=v%s;for(let _=0;_<d;++_){let A=Math.floor(_/s),R=_%s,F=(I*s+R)*f;for(let P=0;P<f;++P){let V=P+F+l*(A+u*(w+c*x));h[g++]=m[V]}}}return t.makeTensorInfo([a,p,d,f],o.dtype,h)}var UL={kernelName:gc,backendName:"cpu",kernelFunc:Wte};T();function dN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dilations:c,dimRoundingMode:u}=r;X([o,s],"depthwiseConv2DNative");let l=y.computeStrides(o.shape),p=y.computeStrides(s.shape),d=c;d==null&&(d=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let f=S.computeConv2DInfo(o.shape,s.shape,i,d,a,u,!0),{filterHeight:m,filterWidth:h,dilationHeight:g,dilationWidth:x,padInfo:v}=f,w=v.left,I=v.top,_=f.outChannels/f.inChannels,A=new Ve(f.outShape,o.dtype),R=t.data.get(o.dataId).values,F=t.data.get(s.dataId).values,P=A.values;for(let L=0;L<f.batchSize;++L){let V=L*l[0],z=L*A.strides[0];for(let H=0;H<f.outHeight;++H){let j=z+H*A.strides[1],W=H*f.strideHeight-I;for(let Y=0;Y<m;++Y){let Z=W+Y*g;if(Z<0||Z>=f.inHeight)continue;let K=Y*p[0],Q=V+Z*l[1];for(let te=0;te<f.outWidth;++te){let ne=j+te*A.strides[2],se=te*f.strideWidth-w;for(let re=0;re<h;++re){let ae=se+re*x;if(ae<0||ae>=f.inWidth)continue;let oe=K+re*p[1],le=Q+ae*f.inChannels,xe=ne,be=oe;for(let ye=0;ye<f.inChannels;++ye){let Ae=R[le+ye];for(let Re=0;Re<_;++Re)P[xe+Re]+=Ae*F[be+Re];xe+=_,be+=_}}}}}}return t.makeTensorInfo(A.shape,A.dtype,A.values)}var zL={kernelName:xc,backendName:"cpu",kernelFunc:dN};T();function jte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,dilations:a,pad:c,dimRoundingMode:u,filterShape:l}=r;X([o,s],"depthwiseConv2dNativeBackpropFilter");let p=S.computeConv2DInfo(o.shape,l,i,a,c,u,!0),{strideHeight:d,strideWidth:f,filterHeight:m,filterWidth:h}=p,g=new Ve(p.filterShape,"float32"),x=p.padInfo.left,v=p.padInfo.top,w=p.outChannels/p.inChannels,I=t.data.get(o.dataId).values,_=new Ve(o.shape,o.dtype,I),A=t.data.get(s.dataId).values,R=new Ve(s.shape,s.dtype,A);for(let F=0;F<m;++F){let P=Math.max(0,Math.ceil((v-F)/d)),L=Math.min(p.outHeight,(p.inHeight+v-F)/d);for(let V=0;V<h;++V){let z=Math.max(0,Math.ceil((x-V)/f)),H=Math.min(p.outWidth,(p.inWidth+x-V)/f);for(let j=0;j<p.outChannels;++j){let W=Math.trunc(j/w),Y=j%w,Z=0;for(let K=0;K<p.batchSize;++K)for(let Q=P;Q<L;++Q){let te=F+Q*d-v;for(let ne=z;ne<H;++ne){let se=V+ne*f-x;Z+=_.get(K,te,se,W)*R.get(K,Q,ne,j)}}g.set(Z,F,V,W,Y)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}var HL={kernelName:yc,backendName:"cpu",kernelFunc:jte};T();function qte(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{strides:i,dilations:a,pad:c,dimRoundingMode:u,inputShape:l}=r;X([o,s],"depthwiseConv2DNativeBackpropInput");let p=y.computeStrides(o.shape),d=y.computeStrides(s.shape),f=S.computeConv2DInfo(l,s.shape,i,a,c,u,!0),m=new Ve(f.inShape,"float32"),h=m.values,[g,x,v]=m.strides,w=t.data.get(o.dataId).values,[I,_,A]=p,R=t.data.get(s.dataId).values,[F,P,L]=d,{batchSize:V,filterHeight:z,filterWidth:H,inChannels:j,inHeight:W,inWidth:Y,outChannels:Z,outHeight:K,outWidth:Q,strideHeight:te,strideWidth:ne}=f,se=z-1-f.padInfo.top,re=H-1-f.padInfo.left,ae=Z/j;for(let oe=0;oe<V;++oe)for(let le=0;le<j;++le)for(let xe=0;xe<W;++xe){let be=xe-se,ye=Math.max(0,Math.ceil(be/te)),Ae=Math.min(K,(z+be)/te);for(let Re=0;Re<Y;++Re){let Ye=Re-re,nt=Math.max(0,Math.ceil(Ye/ne)),It=Math.min(Q,(H+Ye)/ne),rt=0;for(let Ze=ye;Ze<Ae;++Ze){let bt=Ze*te-be;for(let mt=nt;mt<It;++mt){let $o=mt*ne-Ye,Xt=I*oe+_*Ze+A*mt,Is=F*(z-1-bt)+P*(H-1-$o)+L*le;for(let Qn=0;Qn<ae;++Qn){let la=le*ae+Qn,Sr=w[Xt+la],Po=R[Is+Qn];rt+=Sr*Po}}}h[g*oe+x*xe+v*Re+le]=rt}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}var GL={kernelName:vc,backendName:"cpu",kernelFunc:qte};T();function Kte(n){let{inputs:e,backend:t}=n,{x:r}=e,o=y.sizeFromShape(r.shape),s=t.data.get(r.dataId).values,i=ue([o,o],r.dtype),a=i.values;for(let u=0;u<s.length;u++)a[u*o+u]=s[u];let c=[...r.shape,...r.shape];return t.makeTensorInfo(c,i.dtype,i.values)}var WL={kernelName:bc,backendName:"cpu",kernelFunc:Kte};T();var jL={kernelName:Cc,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{let{x:r,filter:o}=n,{strides:s,pad:i,dilations:a}=t,c=e,u=c.data.get(r.dataId).values,l=r.shape.length,p=c.data.get(o.dataId).values,d=o.shape.length,{batchSize:f,inHeight:m,inWidth:h,inChannels:g,outHeight:x,outWidth:v,padInfo:w,strideHeight:I,strideWidth:_,filterHeight:A,filterWidth:R,dilationHeight:F,dilationWidth:P,outShape:L}=S.computeDilation2DInfo(r.shape,o.shape,s,i,"NHWC",a),V=y.sizeFromShape(L),z=L.length,H=y.getArrayFromDType(r.dtype,V);for(let W=0;W<f;++W)for(let Y=0;Y<x;++Y){let Z=Y*I-w.top;for(let K=0;K<v;++K){let Q=K*_-w.left;for(let te=0;te<g;++te){let ne=Number.MIN_SAFE_INTEGER;for(let re=0;re<A;++re){let ae=Z+re*F;if(ae>=0&&ae<m)for(let oe=0;oe<R;++oe){let le=Q+oe*P;if(le>=0&&le<h){let xe=y.locToIndex([W,ae,le,te],l,y.computeStrides(r.shape)),be=y.locToIndex([re,oe,te],d,y.computeStrides(o.shape)),ye=u[xe]+p[be];ye>ne&&(ne=ye)}}}let se=y.locToIndex([W,Y,K,te],z,y.computeStrides(L));H[se]=ne}}}return{dataId:c.write(y.toTypedArray(H,r.dtype),L,r.dtype),shape:L,dtype:r.dtype}}};T();var qL={kernelName:Pg,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{let{x:r,filter:o,dy:s}=n,{strides:i,pad:a,dilations:c}=t,u=e,l=y.toNestedArray(r.shape,u.data.get(r.dataId).values),p=y.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:h,outHeight:g,outWidth:x,padInfo:v,strideHeight:w,strideWidth:I,filterHeight:_,filterWidth:A,dilationHeight:R,dilationWidth:F,outShape:P}=S.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",c);y.assert(s.rank===P.length,()=>`Error in ${Pg}, dy must have the same rank as output ${P.length}, but got ${s.rank}`);let L=y.toNestedArray(P,u.data.get(s.dataId).values),V=y.makeZerosNestedTypedArray(o.shape,o.dtype);for(let H=0;H<d;++H)for(let j=0;j<g;++j){let W=j*w-v.top;for(let Y=0;Y<x;++Y){let Z=Y*I-v.left;for(let K=0;K<h;++K){let Q=Number.MIN_SAFE_INTEGER,te=0,ne=0;for(let se=0;se<_;++se){let re=W+se*R;if(re>=0&&re<f)for(let ae=0;ae<A;++ae){let oe=Z+ae*F;if(oe>=0&&oe<m){let le=l[H][re][oe][K]+p[se][ae][K];le>Q&&(Q=le,te=se,ne=ae)}}}V[te][ne][K]+=L[H][j][Y][K]}}}return{dataId:u.write(y.toTypedArray(V,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};T();var KL={kernelName:$g,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{let{x:r,filter:o,dy:s}=n,{strides:i,pad:a,dilations:c}=t,u=e,l=y.toNestedArray(r.shape,u.data.get(r.dataId).values),p=y.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:h,outHeight:g,outWidth:x,padInfo:v,strideHeight:w,strideWidth:I,filterHeight:_,filterWidth:A,dilationHeight:R,dilationWidth:F,outShape:P}=S.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",c);y.assert(s.rank===P.length,()=>`Error in ${$g}, dy must have the same rank as output ${P.length}, but got ${s.rank}`);let L=y.toNestedArray(P,u.data.get(s.dataId).values),V=y.makeZerosNestedTypedArray(r.shape,r.dtype);for(let H=0;H<d;++H)for(let j=0;j<g;++j){let W=j*w-v.top;for(let Y=0;Y<x;++Y){let Z=Y*I-v.left;for(let K=0;K<h;++K){let Q=Number.MIN_SAFE_INTEGER,te=W<0?0:W,ne=Z<0?0:Z;for(let se=0;se<_;++se){let re=W+se*R;if(re>=0&&re<f)for(let ae=0;ae<A;++ae){let oe=Z+ae*F;if(oe>=0&&oe<m){let le=l[H][re][oe][K]+p[se][ae][K];le>Q&&(Q=le,te=re,ne=oe)}}}V[H][te][ne][K]+=L[H][j][Y][K]}}}return{dataId:u.write(y.toTypedArray(V,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};T();function Xte(n){let{inputs:e,backend:t,attrs:r}=n,{image:o}=e,{canvas:s,options:i}=r,{contextOptions:a,imageOptions:c}=i||{},u=c?.alpha||1,l=a?.contextType||"2d";if(l!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);let p=s.getContext(l,a?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${l} type.`);let[d,f]=o.shape.slice(0,2),m=o.shape.length===2?1:o.shape[2],h=t.data.get(o.dataId).values,g=o.dtype==="float32"?255:1,x=new Uint8ClampedArray(f*d*4);for(let w=0;w<d*f;++w){let I=[0,0,0,255*u];for(let A=0;A<m;A++){let R=h[w*m+A];if(o.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(o.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);m===1?(I[0]=R*g,I[1]=R*g,I[2]=R*g):I[A]=R*g}let _=w*4;x[_+0]=Math.round(I[0]),x[_+1]=Math.round(I[1]),x[_+2]=Math.round(I[2]),x[_+3]=Math.round(I[3])}s.width=f,s.height=d;let v=new ImageData(x,f,d);return p.putImageData(v,0,0),o}var XL={kernelName:ip,backendName:"cpu",kernelFunc:Xte};T();T();function ys(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;X(o,"sum");let a;o.dtype==="bool"?a=wr({inputs:{x:o},backend:t,attrs:{dtype:"int32"}}):a=rn({inputs:{x:o},backend:t});let c=a.shape.length,u=y.parseAxisParam(s,a.shape),l=S.getAxesPermutation(u,c),p=u,d=a;l!=null&&(d=ut({inputs:{x:a},backend:t,attrs:{perm:l}}),p=S.getInnerMostAxes(p.length,c)),S.assertAxesAreInnerMostDims("sum",p,d.shape.length);let[f,m]=S.computeOutAndReduceShapes(d.shape,p),h=S.upcastType(d.dtype,"int32"),g=Gp(t,f,h),x=y.sizeFromShape(m),v=t.data.get(g.dataId).values,w=t.data.get(d.dataId).values;for(let I=0;I<v.length;++I){let _=I*x,A=0;for(let R=0;R<x;++R)A+=w[_+R];v[I]=A}if(i){let I=S.expandShapeToKeepDim(g.shape,u),_=g;g=_e({inputs:{x:g},backend:t,attrs:{shape:I}}),t.disposeIntermediateTensorInfo(_)}return t.disposeIntermediateTensorInfo(a),l!=null&&t.disposeIntermediateTensorInfo(d),g}var YL={kernelName:"Sum",backendName:"cpu",kernelFunc:ys};function Yte(n){let{inputs:e,backend:t,attrs:r}=n,{equation:o}=r,s=e,{allDims:i,summedDims:a,idDims:c}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,c,s);let{path:u,steps:l}=S.getEinsumComputePath(a,c),p=l.length,d=null,f=i.length,m=[];for(let h=0;h<p;++h){for(let g of l[h]){let{permutationIndices:x,expandDims:v}=S.getEinsumPermutation(f,c[g]),w;S.isIdentityPermutation(x)?w=s[g]:(w=ut({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),m.push(w));let I=w.shape.slice();for(let _=0;_<v.length;++_)I.splice(v[_],0,1);y.arraysEqual(w.shape,I)||(w=_e({inputs:{x:w},backend:t,attrs:{shape:I}}),m.push(w)),d===null?d=w:(d=dl({inputs:{a:w,b:d},backend:t}),m.push(d))}h<p-1&&(u[h]>=0&&(d=ys({inputs:{x:d},backend:t,attrs:{axis:u[h]-(i.length-f),keepDims:!1}}),m.push(d)),f--)}for(let h of m)h!==d&&t.disposeIntermediateTensorInfo(h);return d}var ZL={kernelName:wc,backendName:"cpu",kernelFunc:Yte};T();function Zte(n){let{inputs:e,backend:t}=n,{dy:r,y:o}=e;X([r,o],"eluGrad");let s=new Float32Array(y.sizeFromShape(o.shape)),i=t.data.get(o.dataId).values,a=t.data.get(r.dataId).values;for(let c=0;c<i.length;++c){let u=i[c];u>=0?s[c]=a[c]:s[c]=a[c]*(u+1)}return t.makeTensorInfo(o.shape,"float32",s)}var QL={kernelName:vf,backendName:"cpu",kernelFunc:Zte};T();var Qte=S.ERF_P,Jte=S.ERF_A1,ene=S.ERF_A2,tne=S.ERF_A3,nne=S.ERF_A4,rne=S.ERF_A5,one=he("Erf",n=>{let e=Math.sign(n),t=Math.abs(n),r=1/(1+Qte*t);return e*(1-((((rne*r+nne)*r+tne)*r+ene)*r+Jte)*r*Math.exp(-t*t))}),JL={kernelName:"Erf",backendName:"cpu",kernelFunc:one};T();function Yp(n){let{inputs:e,backend:t,attrs:r}=n,{input:o}=e,{dim:s}=r,i=o.shape.length,a=o.shape.slice(),c=s;return s<0&&(y.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),c=i+s+1),a.splice(c,0,1),_e({inputs:{x:o},backend:t,attrs:{shape:a}})}var e3={kernelName:Sc,backendName:"cpu",kernelFunc:Yp};T();T();T();var sne=ke((n,e)=>n/e),Bm=Pe(Zs,sne),Vm={kernelName:Zs,backendName:"cpu",kernelFunc:Bm};function vy(n,e,t){let r=n.shape,o=r[0],s=r[1],i=t.data.get(n.dataId),a=i.complexTensorInfos.real,c=i.complexTensorInfos.imag,u=[o,s],l=y.sizeFromShape(u),p=y.getTypedArrayFromDType("float32",l),d=y.getTypedArrayFromDType("float32",l);for(let g=0;g<o;g++){let x=Er({inputs:{x:a},backend:t,attrs:{begin:[g,0],size:[1,s]}}),v=Er({inputs:{x:c},backend:t,attrs:{begin:[g,0],size:[1,s]}}),w=Rt({inputs:{real:x,imag:v},backend:t}),{real:I,imag:_}=ine(w,e,t),A=S.mergeRealAndImagArrays(I,_);for(let R=0;R<s;R++){let F=S.getComplexWithIndex(A,R);p[g*s+R]=F.real,d[g*s+R]=F.imag}t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(w)}let f=t.makeTensorInfo(u,"float32",p),m=t.makeTensorInfo(u,"float32",d),h=Rt({inputs:{real:f,imag:m},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),h}function ine(n,e,t){let r=y.sizeFromShape(n.shape),o=t.data.get(n.dataId),s=t.data.get(o.complexTensorInfos.real.dataId).values,i=t.data.get(o.complexTensorInfos.imag.dataId).values;if(ane(r)){let a=fN(s,i,r,e,t),c=[n.shape[0],n.shape[1]];if(e){let u=t.makeTensorInfo(c,"float32",a.real),l=t.makeTensorInfo(c,"float32",a.imag),p=t.makeTensorInfo([],"float32",y.createScalarValue(r,"float32")),d=rn({inputs:{x:p},backend:t}),f=Vm.kernelFunc({inputs:{a:u,b:p},backend:t}),m=Vm.kernelFunc({inputs:{a:l,b:d},backend:t}),h=t.data.get(f.dataId).values,g=t.data.get(m.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),{real:h,imag:g}}return a}else{let a=S.mergeRealAndImagArrays(s,i),c=cne(a,r,e);return S.splitRealAndImagArrays(c)}}function ane(n){return(n&n-1)===0}function fN(n,e,t,r,o){if(t===1)return{real:n,imag:e};let s=S.mergeRealAndImagArrays(n,e),i=t/2,a=S.complexWithEvenIndex(s),c=a.real,u=a.imag,l=[c.length],p=o.makeTensorInfo(l,"float32",c),d=o.makeTensorInfo(l,"float32",u),f=Rt({inputs:{real:p,imag:d},backend:o}),m=S.complexWithOddIndex(s),h=m.real,g=m.imag,x=[h.length],v=o.makeTensorInfo(x,"float32",h),w=o.makeTensorInfo(x,"float32",g),I=Rt({inputs:{real:v,imag:w},backend:o}),_=fN(c,u,i,r,o),A=_.real,R=_.imag,F=[A.length],P=o.makeTensorInfo(F,"float32",A),L=o.makeTensorInfo(F,"float32",R),V=Rt({inputs:{real:P,imag:L},backend:o}),z=fN(h,g,i,r,o),H=z.real,j=z.imag,W=[H.length],Y=o.makeTensorInfo(W,"float32",H),Z=o.makeTensorInfo(W,"float32",j),K=Rt({inputs:{real:Y,imag:Z},backend:o}),Q=S.exponents(t,r),te=[Q.real.length],ne=o.makeTensorInfo(te,"float32",Q.real),se=o.makeTensorInfo(te,"float32",Q.imag),re=Rt({inputs:{real:ne,imag:se},backend:o}),ae=dl({inputs:{a:re,b:K},backend:o}),oe=Ao({inputs:{a:V,b:ae},backend:o}),le=Pm({inputs:{a:V,b:ae},backend:o}),xe=Cr({inputs:{input:oe},backend:o}),be=Cr({inputs:{input:le},backend:o}),ye=Ro({inputs:{input:oe},backend:o}),Ae=Ro({inputs:{input:le},backend:o}),Re=ra({inputs:[xe,be],backend:o,attrs:{axis:0}}),Ye=ra({inputs:[ye,Ae],backend:o,attrs:{axis:0}}),nt=o.data.get(Re.dataId).values,It=o.data.get(Ye.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(I),o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(L),o.disposeIntermediateTensorInfo(V),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(Z),o.disposeIntermediateTensorInfo(K),o.disposeIntermediateTensorInfo(ne),o.disposeIntermediateTensorInfo(se),o.disposeIntermediateTensorInfo(re),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(oe),o.disposeIntermediateTensorInfo(le),o.disposeIntermediateTensorInfo(xe),o.disposeIntermediateTensorInfo(ye),o.disposeIntermediateTensorInfo(be),o.disposeIntermediateTensorInfo(Ae),o.disposeIntermediateTensorInfo(Re),o.disposeIntermediateTensorInfo(Ye),{real:nt,imag:It}}function cne(n,e,t){let r=new Float32Array(e*2);for(let o=0;o<e;o++){let s=0,i=0;for(let a=0;a<e;a++){let c=S.exponent(o*a,e,t),u=S.getComplexWithIndex(n,a);s+=u.real*c.real-u.imag*c.imag,i+=u.real*c.imag+u.imag*c.real}t&&(s/=e,i/=e),S.assignToTypedArray(r,s,i,o)}return r}function une(n){let{inputs:e,backend:t}=n,{input:r}=e,o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=_e({inputs:{x:r},backend:t,attrs:{shape:[i,s]}}),c=vy(a,!1,t),u=_e({inputs:{x:c},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),u}var t3={kernelName:"FFT",backendName:"cpu",kernelFunc:une};T();function Um(n){let{backend:e,attrs:t}=n,{shape:r,value:o,dtype:s}=t,i=s||y.inferDtype(o),a=y.getArrayFromDType(i,y.sizeFromShape(r));return lne(a,o,i),e.makeTensorInfo(r,i,a)}var n3={kernelName:Nc,backendName:"cpu",kernelFunc:Um};function lne(n,e,t){n.fill(e)}T();var r3={kernelName:Dc,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{image:r}=n,o=t,s=y.getTypedArrayFromDType(r.dtype,y.sizeFromShape(r.shape)),[i,a,c,u]=r.shape,l=o.data.get(r.dataId).values;for(let d=0;d<i;d++){let f=d*c*a*u;for(let m=0;m<a;m++){let h=m*(c*u);for(let g=0;g<c;g++){let x=g*u;for(let v=0;v<u;v++){let w=Math.round(c-g-1),I=f+h+x+v,_=l[I];if(w>=0&&w<c){let A=w*u,R=f+h+A+v;_=l[R]}s[I]=_}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};T();function pne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:c,pad:u,dataFormat:l,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,h=pN({inputs:{x:o,filter:s},backend:t,attrs:{strides:c,pad:u,dataFormat:l,dilations:p,dimRoundingMode:d}});if(i){let g=h;if(l==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let x=_e({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});h=Ao({inputs:{a:h,b:x},backend:t}),t.disposeIntermediateTensorInfo(x)}else h=Ao({inputs:{a:h,b:i},backend:t});t.disposeIntermediateTensorInfo(g)}if(f){let g=h;if(l==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){let x=_e({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});h=fl(t,h,f,x,m),t.disposeIntermediateTensorInfo(x)}else h=fl(t,h,f,a,m);t.disposeIntermediateTensorInfo(g)}return h}var o3={kernelName:Fi,backendName:"cpu",kernelFunc:pne};T();function dne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:c,pad:u,dataFormat:l,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,h=dN({inputs:{x:o,filter:s},backend:t,attrs:{strides:c,pad:u,dataFormat:l,dilations:p,dimRoundingMode:d}});if(i){let g=h;h=Ao({inputs:{a:h,b:i},backend:t}),t.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=fl(t,h,f,a,m),t.disposeIntermediateTensorInfo(g)}return h}var s3={kernelName:Oi,backendName:"cpu",kernelFunc:dne};T();function fne(n){let{inputs:e,backend:t}=n,{params:r,indices:o}=e,s=y.sizeFromShape(r.shape),i=o.shape,a=i[i.length-1],[c,u,l,p]=S.prepareAndValidate(r,o);if(u===0)return t.makeTensorInfo(c,r.dtype,[]);let d=t.data.get(o.dataId).values,f=t.bufferSync(r),m=ey(d,f,r.dtype,u,a,l,p,r.shape,s);return t.makeTensorInfo(c,r.dtype,m.values)}var i3={kernelName:Ac,backendName:"cpu",kernelFunc:fne};T();function mne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,indices:s}=e,{axis:i,batchDims:a}=r;X([o,s],"gatherV2");let c=y.parseAxisParam(i,o.shape)[0],u=t.data.get(s.dataId).values,l=o.shape[c];for(let I=0;I<u.length;++I){let _=u[I];y.assert(_<=l-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${l-1}]`)}let p=a;a==null&&(p=0);let d=y.sizeFromShape(s.shape),f=S.segment_util.collectGatherOpShapeInfo(o,s,c,p),m=_e({inputs:{x:o},backend:t,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),h=_e({inputs:{x:s},backend:t,attrs:{shape:[f.batchSize,d/f.batchSize]}}),g=[f.batchSize,f.outerSize,d/f.batchSize,f.sliceSize],x=t.bufferSync(h),v=t.bufferSync(m),w=ty(v,x,g);return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),t.makeTensorInfo(f.outputShape,w.dtype,w.values)}var a3={kernelName:_c,backendName:"cpu",kernelFunc:mne};T();function hne(n){let{inputs:e,backend:t}=n,{input:r}=e,o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=_e({inputs:{x:r},backend:t,attrs:{shape:[i,s]}}),c=vy(a,!0,t),u=_e({inputs:{x:c},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),u}var c3={kernelName:Rc,backendName:"cpu",kernelFunc:hne};T();var gne=he(oi,n=>Number.isFinite(n)?1:0,"bool"),u3={kernelName:oi,backendName:"cpu",kernelFunc:gne};T();var xne=he(si,n=>Math.abs(n)===1/0?1:0,"bool"),l3={kernelName:si,backendName:"cpu",kernelFunc:xne};T();var yne=he(ii,n=>Number.isNaN(n)?1:0,"bool"),p3={kernelName:ii,backendName:"cpu",kernelFunc:yne};T();function vne(n){let{backend:e,attrs:t}=n,{start:r,stop:o,num:s}=t,i=ny(r,o,s);return e.makeTensorInfo([i.length],"float32",i)}var d3={kernelName:Mc,backendName:"cpu",kernelFunc:vne};T();var bne=he(ui,n=>Math.log1p(n)),f3={kernelName:ui,backendName:"cpu",kernelFunc:bne};T();var Cne=ke((n,e)=>n&&e),wne=Pe(li,Cne,null,"bool"),m3={kernelName:li,backendName:"cpu",kernelFunc:wne};T();var Ine=he(pi,n=>n?0:1,"bool"),h3={kernelName:pi,backendName:"cpu",kernelFunc:Ine};T();var Ene=ke((n,e)=>n||e),Tne=Pe(di,Ene,null,"bool"),g3={kernelName:di,backendName:"cpu",kernelFunc:Tne};T();function Sne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{depthRadius:s,bias:i,alpha:a,beta:c}=r;X(o,"LRN");let u=o.shape[3],l=u-1,p=t.data.get(o.dataId).values,d=y.sizeFromShape(o.shape),f=new Float32Array(d);function m(h){let g=h%u,x=h-g+Math.max(0,g-s),v=h-g+Math.min(g+s,l),w=0;for(;x<=v;x++){let I=p[x];w+=I*I}return w}for(let h=0;h<d;h++){let g=m(h),x=p[h]*Math.pow(i+a*g,-c);f[h]=x}return t.makeTensorInfo(o.shape,o.dtype,f)}var x3={kernelName:"LRN",backendName:"cpu",kernelFunc:Sne};T();function Nne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,y:s,dy:i}=e,{depthRadius:a,bias:c,alpha:u,beta:l}=r;X(i,"LRNGrad");let p=y.sizeFromShape(i.shape),d=i.shape[3],f=t.data.get(i.dataId).values,m=t.data.get(o.dataId).values,h=t.data.get(s.dataId).values,g=new Float32Array(p),x=p;for(let v=0;v<x;v++){let w=v%d,I=v-w+Math.max(0,w-a),_=v-w+Math.min(d,w+a+1),A=0;for(let R=I;R<_;R++)A+=Math.pow(m[R],2);A=u*A+c;for(let R=I;R<_;R++){let F=-2*u*l*m[R]*h[v]/A;v===R&&(F+=Math.pow(A,-l)),F*=f[v],g[R]+=F}}return t.makeTensorInfo(i.shape,o.dtype,g)}var y3={kernelName:bf,backendName:"cpu",kernelFunc:Nne};T();T();T();function mN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{reductionIndices:s,keepDims:i}=r,a=t,c=o.shape,u=c.length,l=y.parseAxisParam(s,c),p=l,d=S.getAxesPermutation(p,u),f=a.data.get(o.dataId).values;if(d!=null){let I=new Array(u);for(let _=0;_<I.length;_++)I[_]=c[d[_]];f=qp(f,c,o.dtype,d,I),p=S.getInnerMostAxes(p.length,u),c=I}X(o,"max"),S.assertAxesAreInnerMostDims("max",p,u);let[m,h]=S.computeOutAndReduceShapes(c,p),g=y.sizeFromShape(h),x=ry(f,g,m,o.dtype),v=a.write(x,m,o.dtype),w=m;return i&&(w=S.expandShapeToKeepDim(m,l)),{dataId:v,shape:w,dtype:o.dtype}}var v3={kernelName:"Max",backendName:"cpu",kernelFunc:mN};T();function Dne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e;X(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,u=1;y.assert(S.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let l=S.computePool2DInfo(o.shape,s,i,u,a,c),p;if(l.filterWidth===1&&l.filterHeight===1&&y.arraysEqual(l.inShape,l.outShape))p=rn({inputs:{x:o},backend:t});else{let d=t.data.get(o.dataId).values,f=y.computeStrides(o.shape),m=Xp(d,o.shape,o.dtype,f,l,"max");p=t.makeTensorInfo(l.outShape,o.dtype,m.values)}return p}var b3={kernelName:Pc,backendName:"cpu",kernelFunc:Dne};T();function kne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:c,dataFormat:u}=r;X(o,"maxPool3d");let l=S.computePool3DInfo(o.shape,s,i,1,a,c,u),p=t.data.get(o.dataId).values,d=yy(p,o.shape,o.dtype,y.computeStrides(o.shape),l,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}var C3={kernelName:Lc,backendName:"cpu",kernelFunc:kne};T();function _ne(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,{filterSize:i,strides:a,pad:c,dimRoundingMode:u}=r;X([o,s],"maxPool3DGrad");let l=S.computePool3DInfo(s.shape,i,a,1,c,u),p=t.bufferSync(s),d=gL(p,l),f=l.strideDepth,m=l.strideHeight,h=l.strideWidth,g=l.dilationDepth,x=l.dilationHeight,v=l.dilationWidth,w=l.effectiveFilterDepth,I=l.effectiveFilterHeight,_=l.effectiveFilterWidth,A=w-1-l.padInfo.front,R=_-1-l.padInfo.left,F=I-1-l.padInfo.top,P=ue(s.shape,"float32"),L=t.bufferSync(o);for(let V=0;V<l.batchSize;++V)for(let z=0;z<l.inChannels;++z)for(let H=0;H<l.inDepth;++H)for(let j=0;j<l.inHeight;++j)for(let W=0;W<l.inWidth;++W){let Y=H-A,Z=j-F,K=W-R,Q=0;for(let te=0;te<w;te+=g){let ne=(Y+te)/f;if(!(ne<0||ne>=l.outDepth||Math.floor(ne)!==ne))for(let se=0;se<I;se+=x){let re=(Z+se)/m;if(!(re<0||re>=l.outHeight||Math.floor(re)!==re))for(let ae=0;ae<_;ae+=v){let oe=(K+ae)/h;if(oe<0||oe>=l.outWidth||Math.floor(oe)!==oe)continue;let le=w*I*_-1-d.get(V,ne,re,oe,z),xe=te*I*_+se*_+ae,be=le===xe?1:0;if(be===0)continue;let ye=L.get(V,ne,re,oe,z);Q+=ye*be}}}P.set(Q,V,H,j,W,z)}return t.makeTensorInfo(P.shape,P.dtype,P.values)}var w3={kernelName:wf,backendName:"cpu",kernelFunc:_ne};T();function Ane(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s,output:i}=e,a=s;X([s,i],"maxPoolGrad");let{filterSize:c,strides:u,pad:l,dimRoundingMode:p}=r,d=S.computePool2DInfo(a.shape,c,u,1,l,p),f=t.data.get(a.dataId).values,m=ue(d.outShape,a.dtype,xy(f,a.shape,a.dtype,d).values),h=d.strideHeight,g=d.strideWidth,x=d.dilationHeight,v=d.dilationWidth,w=d.effectiveFilterHeight,I=d.effectiveFilterWidth,_=I-1-d.padInfo.left,A=w-1-d.padInfo.top,R=ue(a.shape,"float32"),F=t.data.get(o.dataId).values,P=ue(o.shape,"float32",F);for(let L=0;L<d.batchSize;++L)for(let V=0;V<d.inChannels;++V)for(let z=0;z<d.inHeight;++z)for(let H=0;H<d.inWidth;++H){let j=z-A,W=H-_,Y=0;for(let Z=0;Z<w;Z+=x){let K=(j+Z)/h;if(!(K<0||K>=d.outHeight||Math.floor(K)!==K))for(let Q=0;Q<I;Q+=v){let te=(W+Q)/g;if(te<0||te>=d.outWidth||Math.floor(te)!==te)continue;let ne=w*I-1-m.get(L,K,te,V),se=Z*I+Q,re=ne===se?1:0;if(re===0)continue;let ae=P.get(L,K,te,V);Y+=ae*re}}R.set(Y,L,z,H,V)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}var I3={kernelName:Cf,backendName:"cpu",kernelFunc:Ane};T();T();T();function E3(n,e,t,r,o){let s=y.computeStrides(e),i=Xp(n,e,t,s,o,"max"),a=xy(n,e,t,o,!0,r);return[i.values,a.values]}var T3={kernelName:Bc,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{x:r}=n,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=e,c=t;X(r,"MaxPoolWithArgmax");let u=c.data.get(r.dataId).values,l=S.computePool2DInfo(r.shape,o,s,[1,1],i),[p,d]=E3(u,r.shape,r.dtype,a,l),f=c.write(p,l.outShape,r.dtype),m=c.write(d,l.outShape,r.dtype);return[{dataId:f,shape:l.outShape,dtype:r.dtype},{dataId:m,shape:l.outShape,dtype:"int32"}]}};T();function Rne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r,a=y.parseAxisParam(s,o.shape),u=S.computeOutAndReduceShapes(o.shape,a)[1],l=y.sizeFromShape(u),p=[],d=t.makeTensorInfo([],"float32",new Float32Array([l]));p.push(d);let f=wr({inputs:{x:o},backend:t,attrs:{dtype:"float32"}});p.push(f);let m=Bm({inputs:{a:f,b:d},backend:t});p.push(m);let h=ys({inputs:{x:m},backend:t,attrs:{axis:s,keepDims:i}});return p.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}var S3={kernelName:Vc,backendName:"cpu",kernelFunc:Rne};T();function Fne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;X(o,"min");let a=y.parseAxisParam(s,o.shape),c=a,u=S.getAxesPermutation(c,o.shape.length),l=o;u!=null&&(l=ut({inputs:{x:o},backend:t,attrs:{perm:u}}),c=S.getInnerMostAxes(c.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",c,l.shape.length);let[p,d]=S.computeOutAndReduceShapes(l.shape,c),f=y.sizeFromShape(d),m=y.makeZerosTypedArray(y.sizeFromShape(p),l.dtype),h=t.data.get(l.dataId).values;for(let x=0;x<m.length;++x){let v=x*f,w=h[v];for(let I=0;I<f;++I){let _=h[v+I];(Number.isNaN(_)||_<w)&&(w=_)}m[x]=w}u!=null&&t.disposeIntermediateTensorInfo(l);let g=t.makeTensorInfo(p,l.dtype,m);if(i){let x=S.expandShapeToKeepDim(p,a),v=_e({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),v}return g}var N3={kernelName:"Min",backendName:"cpu",kernelFunc:Fne};T();function One(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{paddings:s,mode:i}=r;X(o,"mirrorPad");let a=s.map((w,I)=>w[0]+o.shape[I]+w[1]),c=s.map(w=>w[0]),u=s.map((w,I)=>w[0]+o.shape[I]),l=i==="reflect"?0:1,p=t.data.get(o.dataId).values,d=o.shape.length,f=y.computeStrides(o.shape),m=y.sizeFromShape(a),h=a.length,g=y.computeStrides(a),x=y.getTypedArrayFromDType(o.dtype,m);for(let w=0;w<m;w++){let I=y.indexToLoc(w,h,g);for(let A=0;A<h;A++)I[A]<c[A]?I[A]=c[A]*2-I[A]-l:I[A]>=u[A]&&(I[A]=(u[A]-1)*2-I[A]+l);I=I.map((A,R)=>A-c[R]);let _=y.locToIndex(I,d,f);x[w]=p[_]}return{dataId:t.write(x,a,o.dtype),shape:a,dtype:o.dtype}}var D3={kernelName:Uc,backendName:"cpu",kernelFunc:One};T();var Mne=ke((n,e)=>{let t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),$ne=Pe("Mod",Mne),k3={kernelName:"Mod",backendName:"cpu",kernelFunc:$ne};T();var A3=ch(pT());T();function hN(n){let{inputs:e,backend:t,attrs:r}=n,{logits:o}=e,{dim:s}=r,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let c=y.parseAxisParam([a],o.shape),u=mN({inputs:{x:o},backend:t,attrs:{reductionIndices:c,keepDims:!1}}),l=S.expandShapeToKeepDim(u.shape,c),p=_e({inputs:{x:u},backend:t,attrs:{shape:l}}),d=Pm({inputs:{a:o,b:p},backend:t}),f=$S({inputs:{x:d},backend:t}),m=ys({inputs:{x:f},backend:t,attrs:{axis:c,keepDims:!1}}),h=_e({inputs:{x:m},backend:t,attrs:{shape:l}}),g=Bm({inputs:{a:f,b:h},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),g}var _3={kernelName:xu,backendName:"cpu",kernelFunc:hN};function Pne(n){let{inputs:e,backend:t,attrs:r}=n,{logits:o}=e,{numSamples:s,seed:i,normalized:a}=r;X(o,"multinomial");let c=a?o:hN({inputs:{logits:o},backend:t,attrs:{dim:-1}}),u=c.shape[0],l=c.shape[1],p=t.data.get(c.dataId).values,d=[u,s],f=y.makeZerosTypedArray(y.sizeFromShape(d),"int32");for(let m=0;m<u;++m){let h=m*l,g=new Float32Array(l-1);g[0]=p[h];for(let w=1;w<g.length;++w)g[w]=g[w-1]+p[h+w];let x=A3.alea(i.toString()),v=m*s;for(let w=0;w<s;++w){let I=x();f[v+w]=g.length;for(let _=0;_<g.length;_++)if(I<g[_]){f[v+w]=_;break}}}return a||t.disposeIntermediateTensorInfo(c),t.makeTensorInfo(d,"int32",f)}var R3={kernelName:Hc,backendName:"cpu",kernelFunc:Pne};T();var Lne=qt.nonMaxSuppressionV3Impl;function Bne(n){let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c}=r;X(o,"NonMaxSuppression");let u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,{selectedIndices:p}=Lne(u,l,i,a,c);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}var F3={kernelName:Gc,backendName:"cpu",kernelFunc:Bne};T();var Vne=qt.nonMaxSuppressionV4Impl;function Une(n){let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,padToMaxOutputSize:u}=r;X(o,"NonMaxSuppressionPadded");let l=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,{selectedIndices:d,validOutputs:f}=Vne(l,p,i,a,c,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var O3={kernelName:Wc,backendName:"cpu",kernelFunc:Une};T();var zne=qt.nonMaxSuppressionV5Impl;function Hne(n){let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,softNmsSigma:u}=r;X(o,"NonMaxSuppressionWithScore");let l=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,d=i,f=a,m=c,h=u,{selectedIndices:g,selectedScores:x}=zne(l,p,d,f,m,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var M3={kernelName:jc,backendName:"cpu",kernelFunc:Hne};T();function Gne(n){let{inputs:e,backend:t,attrs:r}=n,{indices:o}=e,{dtype:s,depth:i,onValue:a,offValue:c}=r;X(o,"oneHot");let u=y.sizeFromShape(o.shape),l=new Float32Array(u*i);l.fill(c);let p=t.data.get(o.dataId).values;for(let d=0;d<u;++d)p[d]>=0&&p[d]<i&&(l[d*i+p[d]]=a);return t.makeTensorInfo([...o.shape,i],s,l)}var $3={kernelName:Kc,backendName:"cpu",kernelFunc:Gne};T();T();function zm(n){let{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let o=Cr({inputs:{input:r},backend:t}),s=zm({inputs:{x:o},backend:t}),i=Ro({inputs:{input:r},backend:t}),a=zm({inputs:{x:i},backend:t}),c=Rt({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return Um({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var P3={kernelName:Ou,backendName:"cpu",kernelFunc:zm};function L3(n){let{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let o=Cr({inputs:{input:r},backend:t}),s=L3({inputs:{x:o},backend:t}),i=Ro({inputs:{input:r},backend:t}),a=zm({inputs:{x:i},backend:t}),c=Rt({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return Um({backend:t,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var B3={kernelName:qc,backendName:"cpu",kernelFunc:L3};T();function gN(n){let{inputs:e,backend:t,attrs:r}=n,{axis:o}=r;if(e.length===1)return Yp({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,i=e[0].dtype;e.forEach(l=>{y.assertShapesMatch(s,l.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],c=e.map(l=>{let p=Yp({inputs:{input:l},backend:t,attrs:{dim:o}});return a.push(p),p}),u=ra({inputs:c,backend:t,attrs:{axis:o}});return a.forEach(l=>t.disposeIntermediateTensorInfo(l)),u}var V3={kernelName:Xc,backendName:"cpu",kernelFunc:gN};T();function Wne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{paddings:s,constantValue:i}=r;X(o,"pad");let a=s.map((v,w)=>v[0]+o.shape[w]+v[1]),c=s.map(v=>v[0]),u=t.data.get(o.dataId).values,l=y.sizeFromShape(o.shape),p=o.shape.length,d=y.computeStrides(o.shape),f=y.sizeFromShape(a),m=a.length,h=y.computeStrides(a),g=y.getTypedArrayFromDType(o.dtype,f);i!==0&&g.fill(i);for(let v=0;v<l;v++){let I=y.indexToLoc(v,p,d).map((A,R)=>A+c[R]),_=y.locToIndex(I,m,h);g[_]=u[v]}return{dataId:t.write(g,a,o.dtype),shape:a,dtype:o.dtype}}var by={kernelName:Yc,backendName:"cpu",kernelFunc:Wne};T();var jne=ke((n,e)=>Math.pow(n,e)),qne=Pe("Pow",jne),U3={kernelName:"Pow",backendName:"cpu",kernelFunc:qne};T();function Kne(n){let{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=e,{outputRaggedRank:a}=r,c=o.map(x=>t.data.get(x.dataId).values),u=o.map(x=>x.shape),l=t.data.get(s.dataId).values,p=t.data.get(i.dataId).values,[d,f,m]=oy(c,u,l,s.shape,s.dtype,p,i.shape,a),h=d.map(x=>t.makeTensorInfo([x.length],"int32",x)),g=t.makeTensorInfo(m,s.dtype,f);return h.concat([g])}var z3={kernelName:eu,backendName:"cpu",kernelFunc:Kne};T();function Xne(n){let{inputs:e,backend:t}=n,{starts:r,limits:o,deltas:s}=e,i=t.data.get(r.dataId).values,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,[u,l]=sy(i,r.shape,r.dtype,a,o.shape,c,s.shape),p=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([l.length],r.dtype,l);return[p,d]}var H3={kernelName:tu,backendName:"cpu",kernelFunc:Xne};T();function Yne(n){let{inputs:e,backend:t,attrs:r}=n,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:c}=r,u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=t.data.get(i.dataId).values,d=a.map(g=>t.data.get(g.dataId).values),f=a.map(g=>g.shape),[m,h]=iy(u,o.shape,l,s.shape,s.dtype,p,i.shape,d,f,c);return t.makeTensorInfo(m,s.dtype,h)}var G3={kernelName:nu,backendName:"cpu",kernelFunc:Yne};T();function Zne(n){let{backend:e,attrs:t}=n,{start:r,stop:o,dtype:s,step:i}=t,a=ay(r,o,i,s);return e.makeTensorInfo([a.length],s,a)}var W3={kernelName:ru,backendName:"cpu",kernelFunc:Zne};T();var Qne=he(xi,n=>1/n),j3={kernelName:xi,backendName:"cpu",kernelFunc:Qne};T();function Jne(n){let{inputs:e,backend:t,attrs:r}=n,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=r;X(o,"resizeBilinear");let c=y.computeStrides(o.shape),[u,l]=a,[p,d,f,m]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(y.sizeFromShape([p,u,l,m])),x=[s&&u>1?d-1:d,s&&l>1?f-1:f],v=[s&&u>1?u-1:u,s&&l>1?l-1:l],w=0,I=x[0]/v[0],_=x[1]/v[1];for(let A=0;A<p;A++)for(let R=0;R<u;R++){let F;i?F=I*(R+.5)-.5:F=I*R;let P=Math.max(0,Math.floor(F)),L=F-P,V=Math.min(d-1,Math.ceil(F)),z=A*c[0]+P*c[1],H=A*c[0]+V*c[1];for(let j=0;j<l;j++){let W;i?W=_*(j+.5)-.5:W=_*j;let Y=Math.max(0,Math.floor(W)),Z=W-Y,K=Math.min(f-1,Math.ceil(W)),Q=z+Y*c[2],te=H+Y*c[2],ne=z+K*c[2],se=H+K*c[2];for(let re=0;re<m;re++){let ae=h[Q+re],oe=h[te+re],le=h[ne+re],xe=h[se+re],be=ae+(le-ae)*Z,ye=oe+(xe-oe)*Z,Ae=be+(ye-be)*L;g[w++]=Ae}}}return t.makeTensorInfo([p,u,l,m],"float32",g)}var q3={kernelName:au,backendName:"cpu",kernelFunc:Jne};T();function ere(n){let{inputs:e,backend:t,attrs:r}=n,{images:o,dy:s}=e,{alignCorners:i}=r;X([s,o],"resizeBilinearGrad");let a=y.computeStrides(o.shape),[c,u,l,p]=o.shape,[,d,f]=s.shape,m=new Float32Array(c*u*l*p),h=[i&&d>1?u-1:u,i&&f>1?l-1:l],g=[i&&d>1?d-1:d,i&&f>1?f-1:f],x=h[0]/g[0],v=h[1]/g[1],w=t.data.get(s.dataId).values,I=0;for(let _=0;_<c;_++){let A=_*a[0];for(let R=0;R<d;R++){let F=R*x,P=Math.floor(F),L=Math.min(Math.ceil(F),u-1),V=A+P*a[1],z=A+L*a[1],H=F-P,j=1-H;for(let W=0;W<f;W++){let Y=W*v,Z=Math.floor(Y),K=Math.min(Math.ceil(Y),l-1),Q=Y-Z,te=1-Q,ne=V+Z*a[2],se=V+K*a[2],re=z+Z*a[2],ae=z+K*a[2],oe=j*te,le=j*Q,xe=H*te,be=H*Q;for(let ye=0;ye<p;ye++){let Ae=w[I++];m[ne+ye]+=Ae*oe,m[se+ye]+=Ae*le,m[re+ye]+=Ae*xe,m[ae+ye]+=Ae*be}}}}return t.makeTensorInfo([c,l,u,p],"float32",m)}var K3={kernelName:Ef,backendName:"cpu",kernelFunc:ere};T();function tre(n){let{inputs:e,backend:t,attrs:r}=n,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=r;X(o,"resizeNearestNeighbor");let c=y.computeStrides(o.shape),[u,l]=a,[p,d,f,m]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(p*u*l*m),x=[s&&u>1?d-1:d,s&&l>1?f-1:f],v=[s&&u>1?u-1:u,s&&l>1?l-1:l],w=x[0]/v[0],I=x[1]/v[1],_=0;for(let A=0;A<p;A++){let R=A*c[0];for(let F=0;F<u;F++){let P=i?w*(F+.5):w*F,L=Math.min(d-1,s?Math.round(P):Math.floor(P));i&&(L=Math.max(0,L));let V=R+L*c[1];for(let z=0;z<l;z++){let H=i?I*(z+.5):I*z,j=Math.min(f-1,s?Math.round(H):Math.floor(H));i&&(j=Math.max(0,j));let W=V+j*c[2];for(let Y=0;Y<m;Y++){let Z=h[W+Y];g[_++]=Z}}}}return t.makeTensorInfo([p,u,l,m],o.dtype,g)}var X3={kernelName:iu,backendName:"cpu",kernelFunc:tre};T();function nre(n){let{inputs:e,backend:t,attrs:r}=n,{images:o,dy:s}=e,{alignCorners:i}=r;X([s,o],"resizeNearestNeighborGrad");let a=y.computeStrides(o.shape),c=y.computeStrides(s.shape),[u,l,p,d]=o.shape,[,f,m]=s.shape,h=new Float32Array(u*l*p*d),g=t.data.get(s.dataId).values,x=[i&&f>1?l-1:l,i&&m>1?p-1:p],v=[i&&f>1?f-1:f,i&&m>1?m-1:m],w=x[0]/v[0],I=x[1]/v[1],_=1/w,A=1/I,R=Math.ceil(_)*2+2,F=Math.ceil(A)*2+2;for(let P=0;P<u;P++){let L=P*a[0];for(let V=0;V<l;V++){let z=L+V*a[1],H=Math.floor(V*_),j=Math.floor(H-R/2);for(let W=0;W<p;W++){let Y=z+W*a[2],Z=Math.floor(W*A),K=Math.floor(Z-F/2);for(let Q=0;Q<d;Q++){let te=0;for(let ne=0;ne<R;ne++){let se=ne+j;if(se<0||se>=f)continue;let re=L+se*c[1],ae=se*w,oe=Math.min(l-1,i?Math.round(ae):Math.floor(ae));if(V===oe)for(let le=0;le<F;le++){let xe=le+K;if(xe<0||xe>=m)continue;let be=re+xe*c[2],ye=xe*I,Ae=Math.min(p-1,i?Math.round(ye):Math.floor(ye));W===Ae&&(te+=g[be+Q])}}h[Y+Q]=te}}}}return t.makeTensorInfo(o.shape,o.dtype,h)}var Y3={kernelName:If,backendName:"cpu",kernelFunc:nre};T();function rre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{dims:s}=r;X(o,"reverse");let i=o.shape.length,a=y.parseAxisParam(s,o.shape);if(i===0)return rn({inputs:{x:o},backend:t});let c=new Ve(o.shape,o.dtype),u=t.bufferSync(o);for(let l=0;l<c.size;l++){let p=c.indexToLoc(l),d=p.slice();a.forEach(f=>d[f]=o.shape[f]-1-d[f]),c.set(u.get(...d),...p)}return t.makeTensorInfo(c.shape,c.dtype,c.values)}var Z3={kernelName:cu,backendName:"cpu",kernelFunc:rre};T();var Q3={kernelName:Mu,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{image:r}=n,{radians:o,fillValue:s,center:i}=e,a=t,c=y.getTypedArrayFromDType(r.dtype,y.sizeFromShape(r.shape)),[u,l,p,d]=r.shape,[f,m]=S.getImageCenter(i,l,p),h=255,g=Math.sin(o),x=Math.cos(o),v=a.data.get(r.dataId).values;for(let I=0;I<u;I++){let _=I*p*l*d;for(let A=0;A<l;A++){let R=A*(p*d);for(let F=0;F<p;F++){let P=F*d;for(let L=0;L<d;L++){let V=[u,A,F,L],z=V[2],H=V[1],j=(z-f)*x-(H-m)*g,W=(z-f)*g+(H-m)*x;j=Math.round(j+f),W=Math.round(W+m);let Y=s;if(typeof s!="number"&&(L===3?Y=h:Y=s[L]),j>=0&&j<p&&W>=0&&W<l){let K=W*(p*d),Q=j*d,te=_+K+Q+L;Y=v[te]}let Z=_+R+P+L;c[Z]=Y}}}}return{dataId:a.write(c,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};T();var ore=he(bi,n=>{let e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),J3={kernelName:bi,backendName:"cpu",kernelFunc:ore};T();function sre(n){let{inputs:e,backend:t,attrs:r}=n,{indices:o,updates:s}=e,{shape:i}=r,{sliceRank:a,numUpdates:c,sliceSize:u,strides:l,outputSize:p}=S.calculateShapes(s,o,i),d=!0,f=t.bufferSync(o),m=t.bufferSync(s),h=Yr(f,m,i,p,u,c,a,l,0,d);return t.makeTensorInfo(i,h.dtype,h.values)}var eB={kernelName:uu,backendName:"cpu",kernelFunc:sre};T();T();function ire(n,e){let t=0,r=n.length,o=0;for(;t<r;)o=Math.floor((t+r)/2),n[o]<e?t=o+1:r=o;return r}function are(n,e){let t=0,r=n.length,o=0;for(;t<r;)o=Math.floor((t+r)/2),n[o]<=e?t=o+1:r=o;return r}function tB(n,e,t,r,o,s){let i=y.getArrayFromDType("int32",t*o);for(let a=0;a<t;++a){let c=n.slice(a*r,(a+1)*r),u=a*o;for(let l=0;l<o;++l)i[u+l]=s==="left"?ire(c,e[l+u]):are(c,e[l+u])}return i}function cre(n){let{inputs:e,backend:t,attrs:r}=n,{sortedSequence:o,values:s}=e,{side:i}=r,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,u=tB(a,c,o.shape[0],o.shape[1],s.shape[1],i);return t.makeTensorInfo(s.shape,"int32",u)}var nB={kernelName:pu,backendName:"cpu",kernelFunc:cre};T();function ure(n){let{inputs:e,backend:t}=n,{condition:r,t:o,e:s}=e;X([r,o,s],"select");let i=r.shape.length,a=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,l=wt(o.dtype,s.dtype),p=y.makeZerosTypedArray(y.sizeFromShape(o.shape),l),d=0,f=i===0||i>1||o.shape.length===1?1:y.sizeFromShape(o.shape.slice(1));for(let m=0;m<a.length;m++)for(let h=0;h<f;h++)a[m]===1?p[d++]=c[m]:p[d++]=u[m];return t.makeTensorInfo(o.shape,l,p)}var rB={kernelName:du,backendName:"cpu",kernelFunc:ure};T();var lre=S.SELU_SCALEALPHA,pre=S.SELU_SCALE,dre=he(wi,n=>n>=0?pre*n:lre*(Math.exp(n)-1)),oB={kernelName:wi,backendName:"cpu",kernelFunc:dre};T();var fre=he(Ei,n=>n<0?-1:n>0?1:0),sB={kernelName:Ei,backendName:"cpu",kernelFunc:fre};T();var mre=he("Sin",n=>Math.sin(n)),iB={kernelName:"Sin",backendName:"cpu",kernelFunc:mre};T();var hre=he(Ii,n=>Math.sinh(n)),aB={kernelName:Ii,backendName:"cpu",kernelFunc:hre};T();var gre=11920928955078125e-23,cB=Math.log(gre)+2,xre=he(Si,n=>{let e=n>-cB,t=n<cB,r=Math.exp(n),o;return t?o=r:e?o=n:o=Math.log(1+r),o}),uB={kernelName:Si,backendName:"cpu",kernelFunc:xre};T();function yre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockShape:s,paddings:i}=r;X([o],"spaceToBatchND");let a=y.sizeFromShape(s),c=[[0,0]];c.push(...i);for(let A=1+s.length;A<o.shape.length;++A)c.push([0,0]);let u=by.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:c,constantValue:0}}),l=S.getReshaped(u.shape,s,a,!1),p=S.getPermuted(l.length,s.length,!1),d=S.getReshapedPermuted(u.shape,s,a,!1),h=_e({inputs:{x:u},backend:t,attrs:{shape:l}}),v=ut({inputs:{x:h},backend:t,attrs:{perm:p}}),_=_e({inputs:{x:v},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(v),_}var lB={kernelName:hu,backendName:"cpu",kernelFunc:yre};T();function vre(n){let{inputs:e,backend:t}=n,{indices:r,values:o,denseShape:s,defaultValue:i}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values[0],[p,d,f,m,h]=cy(a,r.shape,r.dtype,c,o.dtype,u,l);return[t.makeTensorInfo(d,r.dtype,p),t.makeTensorInfo([d[0]],o.dtype,f),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}var pB={kernelName:yu,backendName:"cpu",kernelFunc:vre};T();function bre(n){let{inputs:e,backend:t}=n,{inputIndices:r,inputShape:o,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(t.data.get(o.dataId).values),a=t.data.get(r.dataId).values,c=Array.from(t.data.get(s.dataId).values),[u,l,p]=uy(a,r.shape,r.dtype,i,c);return[t.makeTensorInfo(l,r.dtype,u),t.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var dB={kernelName:vu,backendName:"cpu",kernelFunc:bre};T();function Cre(n){let{inputs:e,backend:t}=n,{data:r,indices:o,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=t.data.get(r.dataId).values,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,[u,l]=Kp(i,r.shape,r.dtype,a,c,!0);return t.makeTensorInfo(l,r.dtype,u)}var fB={kernelName:bu,backendName:"cpu",kernelFunc:Cre};T();function wre(n){let{inputs:e,backend:t}=n,{data:r,indices:o,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=t.data.get(r.dataId).values,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,[u,l]=Kp(i,r.shape,r.dtype,a,c);return t.makeTensorInfo(l,r.dtype,u)}var mB={kernelName:Cu,backendName:"cpu",kernelFunc:wre};T();function Ire(n){let{inputs:e,backend:t,attrs:r}=n,{sparseIndices:o,sparseValues:s,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:c,numUpdates:u,sliceSize:l,strides:p,outputSize:d}=S.calculateShapes(s,o,a),f=!1,m=t.bufferSync(o),h;switch(s.dtype){case"bool":{let g=t.bufferSync(s),x=!!t.data.get(i.dataId).values[0];h=Yr(m,g,a,d,l,u,c,p,x,f);break}case"float32":{let g=t.bufferSync(s),x=t.data.get(i.dataId).values[0];h=Yr(m,g,a,d,l,u,c,p,x,f);break}case"int32":{let g=t.bufferSync(s),x=t.data.get(i.dataId).values[0];h=Yr(m,g,a,d,l,u,c,p,x,f);break}case"string":{let g=t.bufferSync(s),x=y.decodeString(t.data.get(i.dataId).values[0]);h=Yr(m,g,a,d,l,u,c,p,x,f);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return t.makeTensorInfo(a,h.dtype,h.values)}var hB={kernelName:wu,backendName:"cpu",kernelFunc:Ire};T();T();function Ere(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{numOrSizeSplits:s,axis:i}=r,a=y.parseAxisParam(i,o.shape)[0],c=S.prepareSplitSize(o,s,a),u=new Array(o.shape.length).fill(0),l=o.shape.slice();return c.map(p=>{let d=[...l];d[a]=p;let f=Er({inputs:{x:o},backend:t,attrs:{begin:u,size:d}});return u[a]+=p,f})}var gB={kernelName:gu,backendName:"cpu",kernelFunc:Ere};T();var xB={kernelName:Tf,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{let{x:t}=n,r=e;X(t,"square");let o=r.data.get(t.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let c=o[a];s[a]=c*c}return{dataId:r.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};T();var Tre=he(Ai,(n,e)=>{let t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),yB={kernelName:Ai,backendName:"cpu",kernelFunc:Tre};T();function Sre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{begin:s,end:i,strides:a,beginMask:c,endMask:u,ellipsisMask:l,newAxisMask:p,shrinkAxisMask:d}=r;X(o,"stridedSlice");let{finalShapeSparse:f,finalShape:m,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:v,end:w,strides:I}=At.sliceInfo(o.shape,s,i,a,c,u,l,p,d),_;if(h)_=_e({inputs:{x:o},backend:t,attrs:{shape:m}});else if(g||x){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let A=At.computeOutShape(v,w,I),R=Er({inputs:{x:o},backend:t,attrs:{begin:v,size:A}});_=_e({inputs:{x:R},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(R)}else{let A=t.bufferSync(o),R=ly(f,A,I,v);_=t.makeTensorInfo(m,R.dtype,R.values)}return _}var vB={kernelName:Iu,backendName:"cpu",kernelFunc:Sre};T();function Nre(n){let{inputs:e,backend:t,attrs:r}=n,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:c,preserveShortSequences:u}=r,{data:l,dataSplits:p}=e,d=t.data.get(l.dataId).values,f=t.data.get(p.dataId).values,[m,h]=py(d,f,o,s,i,a,c,u);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(p.shape,"int32",h)]}var bB={kernelName:Eu,backendName:"cpu",kernelFunc:Nre};T();function Dre(n){let{inputs:e,backend:t,attrs:r}=n,{skipEmpty:o}=r,{input:s,delimiter:i}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values[0],[u,l,p]=dy(a,c,o),d=l.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",l),t.makeTensorInfo([2],"int32",new Int32Array(p))]}var CB={kernelName:Tu,backendName:"cpu",kernelFunc:Dre};T();function kre(n){let{inputs:e,backend:t,attrs:r}=n,{numBuckets:o}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=t.data.get(s.dataId).values,a=fy(i,o);return t.makeTensorInfo(s.shape,"int32",a)}var wB={kernelName:Su,backendName:"cpu",kernelFunc:kre};T();var _re=he("Tan",n=>Math.tan(n)),IB={kernelName:"Tan",backendName:"cpu",kernelFunc:_re};T();var Are=he(_i,n=>Math.tanh(n)),EB={kernelName:_i,backendName:"cpu",kernelFunc:Are};T();function Rre(n){let{inputs:e,backend:t}=n,{tensor:r,indices:o,updates:s}=e,{sliceRank:i,numUpdates:a,sliceSize:c,strides:u,outputSize:l}=S.calculateShapes(s,o,r.shape),p=!1,d=t.bufferSync(o),f=t.bufferSync(s),m=t.bufferSync(r),h=Yr(d,f,r.shape,l,c,a,i,u,m,p);return t.makeTensorInfo(r.shape,h.dtype,h.values)}var TB={kernelName:lu,backendName:"cpu",kernelFunc:Rre};T();function Fre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{reps:s}=r;X(o,"tile");let i=my(t.bufferSync(o),s);return t.makeTensorInfo(i.shape,i.dtype,i.values)}var SB={kernelName:Ko,backendName:"cpu",kernelFunc:Fre};T();function Ore(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{k:s,sorted:i}=r;X(o,"topk");let a=t.data.get(o.dataId).values,[c,u]=hy(a,o.shape,o.dtype,s,i);return[t.makeTensorInfo(c.shape,c.dtype,c.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}var NB={kernelName:ku,backendName:"cpu",kernelFunc:Ore};T();function Mre(n){let{inputs:e,attrs:t,backend:r}=n,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:c,outputShape:u}=t,[l,p,d,f]=o.shape,[m,h]=u??[p,d],g=[l,m,h,f],x=y.computeStrides(o.shape),v=x[0],w=x[1],I=x[2],_=y.computeStrides(g),A=_[0],R=_[1],F=_[2],P=y.getTypedArrayFromDType(o.dtype,y.sizeFromShape(g));P.fill(c);let L=r.data.get(o.dataId).values,V=r.data.get(s.dataId).values;for(let H=0;H<l;++H){let j=s.shape[0]===1?V:V.subarray(H*8,H*8+8);for(let W=0;W<m;++W)for(let Y=0;Y<h;++Y)for(let Z=0;Z<f;++Z){let K,Q=j[6]*Y+j[7]*W+1;if(Q===0)continue;let te=(j[0]*Y+j[1]*W+j[2])/Q,ne=(j[3]*Y+j[4]*W+j[5])/Q,se=DB(te,d,a),re=DB(ne,p,a);switch(i){case"nearest":K=Vre(L,p,d,v,w,I,H,re,se,Z,c);break;case"bilinear":K=Ure(L,p,d,v,w,I,H,re,se,Z,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let ae=H*A+W*R+Y*F+Z;P[ae]=K}return r.makeTensorInfo(g,o.dtype,P)}return{dataId:r.write(P,g,o.dtype),shape:o.shape,dtype:o.dtype}}var kB={kernelName:_u,backendName:"cpu",kernelFunc:Mre};function DB(n,e,t){switch(t){case"reflect":return $re(n,e);case"wrap":return Pre(n,e);case"nearest":return Bre(n,e);case"constant":default:return Lre(n,e)}}function $re(n,e){let t=n;if(t<0)if(e<=1)t=0;else{let r=2*e;t<r&&(t=r*Math.trunc(-t/r)+t),t=t<-e?t+r:-t-1}else if(t>e-1)if(e<=1)t=0;else{let r=2*e;t-=r*Math.trunc(t/r),t>=e&&(t=r-t-1)}return y.clamp(0,t,e-1)}function Pre(n,e){let t=n;if(t<0)if(e<=1)t=0;else{let r=e-1;t+=e*(Math.trunc(-t/r)+1)}else if(t>e-1)if(e<=1)t=0;else{let r=e-1;t-=e*Math.trunc(t/r)}return y.clamp(0,t,e-1)}function Lre(n,e){return n}function Bre(n,e){return y.clamp(0,n,e-1)}function Hm(n,e,t,r,o,s,i,a,c,u,l){let p=i*r+a*o+c*s+u;return 0<=a&&a<e&&0<=c&&c<t?n[p]:l}function Vre(n,e,t,r,o,s,i,a,c,u,l){let p=Math.round(a),d=Math.round(c);return Hm(n,e,t,r,o,s,i,p,d,u,l)}function Ure(n,e,t,r,o,s,i,a,c,u,l){let p=Math.floor(a),d=Math.floor(c),f=p+1,m=d+1,h=(m-c)*Hm(n,e,t,r,o,s,i,p,d,u,l)+(c-d)*Hm(n,e,t,r,o,s,i,p,m,u,l),g=(m-c)*Hm(n,e,t,r,o,s,i,f,d,u,l)+(c-d)*Hm(n,e,t,r,o,s,i,f,m,u,l);return(f-a)*h+(a-p)*g}T();function zre(n){let{inputs:e,attrs:t,backend:r}=n,{axis:o}=t,{x:s}=e;X(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:a,outputShape:c,indices:u}=gy(i,o,s.shape,s.dtype);return[r.makeTensorInfo(c,s.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}var _B={kernelName:Au,backendName:"cpu",kernelFunc:zre};T();function Hre(n){let{inputs:e,backend:t,attrs:r}=n,{value:o}=e,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],c=new Array(i-1),u=0;for(let f=0;f<i;f++)f!==s&&(c[u++]=o.shape[f]);let l=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let d=new Array(a);for(let f=0;f<d.length;f++){l[s]=f;let m=Er({inputs:{x:o},backend:t,attrs:{begin:l,size:p}});d[f]=_e({inputs:{x:m},backend:t,attrs:{shape:c}}),t.disposeIntermediateTensorInfo(m)}return d}var AB={kernelName:Ru,backendName:"cpu",kernelFunc:Hre};T();function Gre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,segmentIds:s}=e,{numSegments:i}=r;X(o,"unsortedSegmentSum");let a=o.shape.length,c=s.shape.length,u=[],l=[],p=a-c,d=s;for(let m=0;m<p;++m){let h=Yp({inputs:{input:d},backend:t,attrs:{dim:m+1}});d=h,l.push(h)}for(let m=0;m<i;++m){let h=y.createScalarValue(m,"int32"),g=t.makeTensorInfo([],"int32",h),x=OS({inputs:{a:g,b:d},backend:t}),v=wr({inputs:{x},backend:t,attrs:{dtype:"float32"}}),w=dl({inputs:{a:v,b:o},backend:t}),I=ys({inputs:{x:w},backend:t,attrs:{axis:0,keepDims:!1}});u.push(I),l.push(g),l.push(x),l.push(v),l.push(w),l.push(I)}let f=gN({inputs:u,backend:t,attrs:{axis:0}});return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}var RB={kernelName:Fu,backendName:"cpu",kernelFunc:Gre};var Wre=[rL,pP,oL,sL,gP,iL,aL,cL,uL,lL,pL,dL,fL,mL,hL,xL,yL,vL,bL,nL,CL,wL,IL,xP,EL,hP,yP,TL,dP,SL,DL,kL,_L,AL,RL,FL,OL,ML,$L,PL,LL,BL,VL,UL,zL,HL,GL,WL,jL,qL,KL,XL,ZL,YP,QL,vP,JL,bP,e3,CP,t3,n3,r3,wP,IP,o3,s3,i3,a3,EP,TP,fP,c3,NL,u3,l3,p3,ZP,SP,NP,d3,DP,f3,m3,h3,g3,x3,y3,v3,kP,b3,C3,w3,I3,T3,S3,N3,_P,D3,k3,R3,AP,RP,F3,O3,M3,FP,$3,B3,V3,by,U3,QP,MP,z3,H3,G3,W3,mP,Vm,j3,JP,eL,tL,q3,K3,X3,Y3,Z3,Q3,J3,VP,eB,nB,rB,oB,zP,sB,iB,aB,HP,_3,uB,lB,pB,dB,fB,mB,hB,gB,WP,xB,jP,qP,yB,vB,bB,CB,wB,KP,YL,IB,EB,TB,SB,NB,kB,OP,_B,AB,RB,P3];for(let n of Wre)hp(n);T();T();T();T();var ml={},Cy={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function FB(n,e){ml[n]=e}function jn(n,e){if(!(n in ml)||e!=null){let r=qre(n,e);if(r!==null)ml[n]=r;else return console.log("Could not get context for WebGL version",n),null}let t=ml[n];return t==null||t.isContextLost()?(delete ml[n],jn(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),ml[n])}function jre(n){if(!M().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function qre(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=e??jre(n);return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete ml[n]},!1),M().getBool("SOFTWARE_WEBGL_ENABLED")&&(Cy.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Cy)||t.getContext("experimental-webgl",Cy):t.getContext("webgl2",Cy)}T();var hl=(function(n){return n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",n})(hl||{}),fn=(function(n){return n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",n})(fn||{}),on=(function(n){return n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",n})(on||{});function gl(n,e){return[e,n]}function OB(n,e){return n*e}function Gm(n){let e=y.sizeFromShape(n),t=Math.ceil(e/4);return y.sizeToSquarishShape(t)}function Fo(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function MB(n,e){let[t,r]=Fo(n,e);return t*r*4}function Wm(n,e){let t=n,r,o,s,i,a,c,u,l,p,d;return M().getNumber("WEBGL_VERSION")===2?(r=t.R32F,o=t.R16F,s=t.RGBA16F,i=t.RGBA32F,a=t.RED,u=4,l=1,p=t.HALF_FLOAT,d=t.FLOAT,c=t.RGBA8):(r=n.RGBA,o=n.RGBA,s=n.RGBA,i=t.RGBA,a=n.RGBA,u=4,l=4,p=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,c=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:c,downloadUnpackNumChannels:u,defaultNumChannels:l,textureTypeHalfFloat:p,textureTypeFloat:d}}function ce(n,e){let t=e();return M().getBool("DEBUG")&&Kre(n),t}function Kre(n){let e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+Zre(n,e))}var Xre=596e-10,Yre=65504;function $B(n){return!!(M().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Xre<Math.abs(n)&&Math.abs(n)<Yre)}function Zre(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function jm(n,e){return vs(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function PB(n,e){let t=vs(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ce(n,()=>n.shaderSource(t,e)),ce(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function LB(n,e){let t=vs(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ce(n,()=>n.shaderSource(t,e)),ce(n,()=>n.compileShader(t)),M().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw CN(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var Qre=/ERROR: [0-9]+:([0-9]+):/g;function CN(n,e){let t=Qre.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}let r=+t[1],o=n.split(`
`),s=o.length.toString().length+2,i=o.map((p,d)=>y.rightPad((d+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let c=i.slice(0,r-1),u=i.slice(r-1,r),l=i.slice(r);console.log(c.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${y.rightPad(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join(`
`))}function BB(n){return vs(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function VB(n,e){if(ce(n,()=>n.linkProgram(e)),!M().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Iy(n,e){if(ce(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function UB(n,e){let t=vs(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ce(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),ce(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function zB(n,e){let t=vs(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ce(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),ce(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function HB(n){return vs(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function GB(n,e){let t=M().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){let r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){let r=`[${n}x${e}]`,o=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+o+".")}}function WB(n){return vs(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function wN(n,e,t,r,o,s,i){let a=n.getAttribLocation(e,t);return a===-1?!1:(ce(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),ce(n,()=>n.vertexAttribPointer(a,o,n.FLOAT,!1,s,i)),ce(n,()=>n.enableVertexAttribArray(a)),!0)}function Jre(n,e,t){toe(n,t),ce(n,()=>n.activeTexture(n.TEXTURE0+t)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function jB(n,e,t){return vs(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function qB(n,e,t){return n.getUniformLocation(e,t)}function KB(n,e,t,r){ce(n,()=>Jre(n,e,r)),ce(n,()=>n.uniform1i(t,r))}function Ey(n,e,t){ce(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ce(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function IN(n,e){ce(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ce(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function qm(n){let e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+eoe(n,e))}function eoe(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function vs(n,e,t){let r=ce(n,()=>e());if(r==null)throw new Error(t);return r}function toe(n,e){let t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){let o=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${o}.`)}}function oa(n,e=2){return y.sizeFromShape(n.slice(0,n.length-e))}function sa(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Km(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[oa(n),...sa(n)]),e}function XB(n,e=!1){let t=M().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=M().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&M().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),e&&(t=t*2,r=r*2,n=n.map((a,c)=>c>=n.length-2?y.nearestLargerEven(n[c]):n[c]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=y.squeezeShape(n).newShape);let o=y.sizeFromShape(n),s=null;n.length<=1&&o<=t?s=[1,o]:n.length===2&&n[0]<=t&&n[1]<=t?s=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?s=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?s=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?s=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(s=[n[0],n[1]*n[2]*n[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(s==null||i)if(e){let a=oa(n),c=2,u=2;n.length&&([c,u]=sa(n)),o=a*(c/2)*(u/2),s=y.sizeToSquarishShape(o).map(l=>l*2)}else s=y.sizeToSquarishShape(o);return s}function wy(n){return n%2===0}function xl(n,e){if(n=n.slice(-2),e=e.slice(-2),y.arraysEqual(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){let t=n[n.length-1],r=e[e.length-1];if(t===r||wy(t)&&wy(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&wy(n[0])&&wy(e[0])}var yN,vN;function YB(n){if(yN==null){let e=jn(n);yN=e.getParameter(e.MAX_TEXTURE_SIZE)}return yN}function ZB(n){if(vN==null){let e=jn(n);vN=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,vN)}function QB(n){if(n===0)return 0;let e,t=jn(n);return cr(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:cr(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function cr(n,e){return n.getExtension(e)!=null}function EN(n){try{if(jn(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function JB(n){if(n===0)return!1;let e=jn(n);if(n===1){if(!cr(e,"OES_texture_float"))return!1}else if(!cr(e,"EXT_color_buffer_float"))return!1;return bN(e)}function eV(n){if(n===0)return!1;let e=jn(n);if(n===1){if(!cr(e,"OES_texture_float")||!cr(e,"WEBGL_color_buffer_float"))return!1}else{if(cr(e,"EXT_color_buffer_float"))return bN(e);let r="EXT_color_buffer_half_float";if(cr(e,r)){let o=e.getExtension(r);return noe(e,o)}return!1}return bN(e)}function bN(n){let e=Wm(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);let s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);let i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(s),i}function noe(n,e){let t=Wm(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);let i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);let a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(i),a}function tV(n){return n!==2?!1:jn(n).fenceSync!=null}function Oo(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}var fe=M();fe.registerFlag("HAS_WEBGL",()=>fe.getNumber("WEBGL_VERSION")>0);fe.registerFlag("WEBGL_VERSION",()=>EN(2)?2:EN(1)?1:0);fe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);fe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>fe.get("WEBGL_VERSION")===2);fe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);fe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);fe.registerFlag("WEBGL_PACK",()=>fe.getBool("HAS_WEBGL"));fe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_CLIP",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_REDUCE",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_LAZILY_UNPACK",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_CONV_IM2COL",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>YB(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>ZB(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let n=fe.getNumber("WEBGL_VERSION");return n===0?0:QB(n)});fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>fe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Yo.isMobile());fe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>JB(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>fe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:fe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));fe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>eV(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>tV(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>fe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);fe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});fe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Yo.isMobile()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});fe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);fe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);fe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);fe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);fe.registerFlag("WEBGL_EXP_CONV",()=>!1);fe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>fe.getBool("IS_TEST"));fe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);fe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);fe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);fe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);T();T();function lt(){let n,e,t,r,o,s,i,a,c,u;return M().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=M().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:c,defineRound:u}}T();T();T();function Zr(n,e,t="index"){let r=y.computeStrides(e);return r.map((o,s)=>{let i=`int ${n[s]} = ${t} / ${o}`,a=s===r.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * ${o}`:`index -= ${n[s]} * ${o}`;return`${i}; ${a};`}).join("")}function yl(n,e,t="index"){let r=y.computeStrides(e);return r.map((o,s)=>{let i=`int ${n[s]} = ${t} / outShapeStrides[${s}]`,a=s===r.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * outShapeStrides[${s}]`:`index -= ${n[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function roe(n,e){let t=n.length,r=n.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=r[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${r[s+1]})`;return o}function nV(n,e,t="index"){let r=n.map((s,i)=>i),o=roe(r,e);return o.map((s,i)=>{let a=`int ${n[i]} = ${t} / ${o[i]}`,c=i===o.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${o[i]}`:`index -= ${n[i]} * ${o[i]}`;return`${a}; ${c};`}).join("")}function Zp(n){let e=y.computeStrides(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Qp(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Sy=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:rV}=S;function oV(n,e,t){let r=[];if(n.forEach(f=>{let m=y.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${m>1?`[${m}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),t.enableShapeUniforms){let{uniformShape:h}=Ny(t.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(h.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let o=r.join(`
`),s=n.map(f=>ooe(f,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=e.texShape,a=lt(),c=aoe(a),u,l,p=loe(a);return e.isPacked?(u=soe(e.logicalShape,i,t.enableShapeUniforms),l=uoe(a)):(u=ioe(e.logicalShape,i,t.enableShapeUniforms),l=coe(a)),t.packedInputs&&(p+=moe),[p,c,l,o,u,s,t.userCode].join(`
`)}function ed(n,e=!1){let t=n.shapeInfo.logicalShape;switch(t.length){case 0:return Soe(n,e);case 1:return Doe(n,e);case 2:return _oe(n,e);case 3:return Roe(n,e);case 4:return Ooe(n,e);case 5:return Moe(n);case 6:return $oe(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function sV(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return Toe(n);case 1:return Noe(n,e);case 2:return koe(n,e);case 3:return Aoe(n,e);default:return Foe(n,e)}}function ooe(n,e,t=!1,r){let o="";t?o+=sV(n,r):o+=ed(n,r);let s=n.shapeInfo.logicalShape,i=e.logicalShape;return s.length<=i.length&&(t?o+=Poe(n,e):o+=Loe(n,e)),o}function soe(n,e,t){switch(n.length){case 0:return iV();case 1:return hoe(n,e,t);case 2:return Ioe(n,e,t);case 3:return xoe(n,e,t);default:return voe(n,e,t)}}function ioe(n,e,t){switch(n.length){case 0:return iV();case 1:return goe(n,e,t);case 2:return Eoe(n,e,t);case 3:return yoe(n,e,t);case 4:return boe(n,e,t);case 5:return Coe(n,e);case 6:return woe(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function aoe(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function coe(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function uoe(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function loe(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${poe}
    ${doe}
    ${foe}
  `}var poe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,doe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,foe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,moe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function iV(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function hoe(n,e,t){let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function goe(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function xoe(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(n[2]/2),s=o*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function yoe(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${yl(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;let r=Zr(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function voe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(n[n.length-1]/2),s=o*Math.ceil(n[n.length-2]/2),i=s,a="",c="b, r, c";for(let u=2;u<n.length-1;u++)i*=n[n.length-u-1],a=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+a,c=`b${u}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${n.length}(${c});
    }
  `}function boe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${yl(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;let r=Zr(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function Coe(n,e){let t=Zr(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function woe(n,e){let t=Zr(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Ioe(n,e,t){let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(y.arraysEqual(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let o=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function Eoe(n,e,t){return y.arraysEqual(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function vl(n){return`offset${n}`}function Toe(n){let e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=lt();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function Soe(n,e){let t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;let[o,s]=n.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let i=vl(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;let[a,c]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${c}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function Noe(n,e){let t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=n.shapeInfo.texShape,s=lt();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function Doe(n,e){let t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${td(n)}
      }
    `;let o=n.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=vl(t);return i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function koe(n,e){let t=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,i=s[0],a=s[1],c=lt();if(s!=null&&y.arraysEqual(t,s))return e?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${c.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${c.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],l=Math.ceil(t[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${l}, ${u[0]}, ${u[1]}, row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `}function _oe(n,e){let t=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape;if(s!=null&&y.arraysEqual(t,s)){if(e)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let d=s[0],f=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:a}=y.squeezeShape(t),c=i;if(c.length<t.length){let d=nd(n,c),f=["row","col"];return`
      ${ed(d,e)}
      float ${o}(int row, int col) {
        return ${o}(${rd(f,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${td(n)}
      }
    `;let u=s[0],l=s[1],p=vl(r);return l===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${p};
    vec2 uv = uvFromFlat(${u}, ${l}, index);
    return sampleTexture(${r}, uv);
  }
`}function Aoe(n,e){let t=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let d=t.slice(1),f=[1,2],m=nd(n,d),h=["b","row","col"];return`
        ${sV(m,e)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${rd(h,f)});
        }
      `}let a=lt();if(e)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;let c=i[0],u=i[1],l=Math.ceil(t[2]/2),p=l*Math.ceil(t[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${u}, ${p}, ${l}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function Roe(n,e){let t=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t[1]*t[2],i=t[2],{newShape:a,keptDims:c}=y.squeezeShape(t),u=a;if(u.length<t.length){let h=nd(n,u),g=["row","col","depth"];return`
        ${ed(h,e)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${rd(g,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${td(n)}
      }
    `;let l=n.shapeInfo.texShape,p=l[0],d=l[1],f=n.shapeInfo.flatOffset;if(d===s&&f==null)return e?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===i&&f==null)return e?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;let m=vl(r);return e?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${m};
        vec2 uv = uvFromFlat(${p}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Foe(n,e){let t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=lt();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);
    }
  `;let s=n.shapeInfo.logicalShape,i=s.length,a=n.shapeInfo.texShape,c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=c[0],l=c[1],p=Math.ceil(s[i-1]/2),d=p*Math.ceil(s[i-2]/2),f="int b, int row, int col",m=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let h=2;h<i-1;h++)f=`int b${h}, `+f,d*=s[i-h-1],m=`b${h} * ${d} + `+m;return`
    vec4 ${r}(${f}) {
      int index = ${m};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${u});
      return ${o.texture2D}(${t}, uv);
    }
  `}function Ooe(n,e){let t=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t[3],i=t[2]*s,a=t[1]*i,{newShape:c,keptDims:u}=y.squeezeShape(t);if(c.length<t.length){let v=nd(n,c),w=["row","col","depth","depth2"];return`
      ${ed(v,e)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${rd(w,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${td(n)}
      }
    `;let l=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,d=p[0],f=p[1],m=`int stride2 = ${r}Shape[3];`,h=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===a&&l==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${m}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(f===s&&l==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;let x=vl(r);return e?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${x});
      return sampleTexture(${r}, uv);
    }
  `}function Moe(n){let e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e[4],s=e[3]*o,i=e[2]*s,a=e[1]*i,{newShape:c,keptDims:u}=y.squeezeShape(e);if(c.length<e.length){let h=nd(n,c),g=["row","col","depth","depth2","depth3"];return`
      ${ed(h)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${rd(g,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${td(n)}
      }
    `;let l=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,d=p[0],f=p[1];if(f===a&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&l==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;let m=vl(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${m};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function $oe(n){let e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:s}=y.squeezeShape(e);if(o.length<e.length){let g=nd(n,o),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${ed(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${rd(x,s)});
      }
    `}let i=e[5],a=e[4]*i,c=e[3]*a,u=e[2]*c,l=e[1]*u;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${u}, ${c}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${td(n)}
      }
    `;let p=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,f=d[0],m=d[1];if(m===l&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${c}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(m===i&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;let h=vl(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${u} + depth * ${c} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${t}, uv);
    }
  `}function td(n){let e=n.name,t=y.sizeFromShape(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Poe(n,e){let t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),o="get"+r+"AtOutCoords",s=n.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=rV(n.shapeInfo.logicalShape,e.logicalShape),c=ve(i),u=i-s,l,p=["x","y","z","w","u","v"];s===0?l="":i<2&&a.length>=1?l="coords = 0;":l=a.map(v=>`coords.${p[v+u]} = 0;`).join(`
`);let d="";i<2&&s>0?d="coords":d=n.shapeInfo.logicalShape.map((v,w)=>`coords.${p[w+u]}`).join(", ");let f="return outputValue;",h=y.sizeFromShape(n.shapeInfo.logicalShape)===1,x=y.sizeFromShape(e.logicalShape)===1;if(s===1&&!h&&!x)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!x)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){let v=s-2,w=s-1;a.indexOf(v)>-1&&a.indexOf(w)>-1?f="return vec4(outputValue.x);":a.indexOf(v)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${c} coords = getOutputCoords();
      ${l}
      vec4 outputValue = get${r}(${d});
      ${f}
    }
  `}function Loe(n,e){let t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),o="get"+r+"AtOutCoords",s=e.texShape,i=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,c=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===c&&n.shapeInfo.flatOffset==null&&y.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${t}, resultUV);
      }
    `;let u=ve(c),l=rV(n.shapeInfo.logicalShape,e.logicalShape),p=c-a,d,f=["x","y","z","w","u","v"];a===0?d="":c<2&&l.length>=1?d="coords = 0;":d=l.map(h=>`coords.${f[h+p]} = 0;`).join(`
`);let m="";return c<2&&a>0?m="coords":m=n.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${o}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${r}(${m});
    }
  `}function ve(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Ny(n,e,t){let{newShape:r,keptDims:o}=y.squeezeShape(e),s=e.length,i=n&&s===3&&e[0]===1,a=i?e.slice(1):r,c=!n&&s>1&&!y.arraysEqual(e,t)&&r.length<s||i;return{useSqueezeShape:c,uniformShape:c?a:e,keptDims:o}}function nd(n,e){let t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function rd(n,e){return e.map(t=>n[t]).join(", ")}function cV(n,e,t,r){let o=t.map((l,p)=>{let d={logicalShape:l.shape,texShape:l.isUniform?null:l.texData.texShape,isUniform:l.isUniform,isPacked:l.isUniform?!1:l.texData.isPacked,flatOffset:null};return l.texData!=null&&l.texData.slice!=null&&l.texData.slice.flatOffset>0&&(d.flatOffset=l.texData.slice.flatOffset),{name:e.variableNames[p],shapeInfo:d}}),s=o.map(l=>l.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=oV(o,i,e),c=LB(n.gl,a),u=n.createProgram(c);return M().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:c,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:e,fragmentShader:c,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},TN(n,e,u)))}function TN(n,e,t){let r=[],o=[],s,i,a,c=null,u=null;u=n.getUniformLocation(t,"NAN",!1),M().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(t,"INFINITY",!1));let l=!1;for(let p of e.variableNames){let d={name:p,uniform:n.getUniformLocation(t,p,l),offset:n.getUniformLocation(t,`offset${p}`,l)};e.enableShapeUniforms&&(d.shape=n.getUniformLocation(t,`${p}Shape`,l),d.texShape=n.getUniformLocation(t,`${p}TexShape`,l)),r.push(d)}if(e.enableShapeUniforms&&(s=n.getUniformLocation(t,"outShape",l),a=n.getUniformLocation(t,"outShapeStrides",l),i=n.getUniformLocation(t,"outTexShape",l)),e.customUniforms)for(let p of e.customUniforms)o.push(n.getUniformLocation(t,p.name,l));return{variablesLocations:r,customUniformLocations:o,infLoc:c,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:i}}function aV(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{let o=t.logicalShape,s=e[r],i=s.shape;if(!y.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(t.isUniform&&s.isUniform)return;let a=t.texShape,c=s.isUniform?null:s.texData.texShape;if(!y.arraysEqual(a,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${c} must match`)})}function uV(n,e,t,r,o){e.program.enableShapeUniforms||(aV(e.inShapeInfos,t),aV([e.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):n.setOutputMatrixTexture(s.texture,i[0],i[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),M().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let c=0;c<t.length;++c){let u=t[c],{uniform:l,offset:p,shape:d,texShape:f}=e.variablesLocations[c];if(d){let{uniformShape:m}=Ny(e.program.packedInputs,u.shape,u.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(d,new Int32Array(m));break;case 2:n.gl.uniform2iv(d,new Int32Array(m));break;case 3:n.gl.uniform3iv(d,new Int32Array(m));break;case 4:n.gl.uniform4iv(d,new Int32Array(m));break;default:break}}if(f&&n.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),l!=null){if(u.isUniform){if(y.sizeFromShape(u.shape)<2)n.gl.uniform1f(l,u.uniformValues[0]);else{let m=u.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(l,m)}continue}u.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,l,c)}}let a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape));break;default:break}if(e.outShapeStridesLocation){let c=y.computeStrides(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(c));break;default:break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&o)for(let c=0;c<e.program.customUniforms.length;++c){let u=e.program.customUniforms[c],l=e.customUniformLocations[c],p=o[c];if(u.type==="float")n.gl.uniform1fv(l,p);else if(u.type==="vec2")n.gl.uniform2fv(l,p);else if(u.type==="vec3")n.gl.uniform3fv(l,p);else if(u.type==="vec4")n.gl.uniform4fv(l,p);else if(u.type==="int")n.gl.uniform1iv(l,p);else if(u.type==="ivec2")n.gl.uniform2iv(l,p);else if(u.type==="ivec3")n.gl.uniform3iv(l,p);else if(u.type==="ivec4")n.gl.uniform4iv(l,p);else throw Error(`uniform type ${u.type} is not supported yet.`)}n.executeProgram()}function lV(n,e,t){let r="";e.concat(t).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){let c=i.texData.texShape,{useSqueezeShape:u,uniformShape:l,keptDims:p}=Ny(n.packedInputs,i.shape,c),d="",f="",m="";if(l.length===1&&n.packedInputs){let _=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];d=`${_[0]>1}_${_[1]>1}`}else if(l.length===2&&!n.packedInputs)f=`${l[0]>1}_${l[1]>1}`;else if(l.length>2&&!n.packedInputs){let _=y.computeStrides(l);m=`${_[0]===c[1]}_${_[_.length-1]===c[1]}`}let h=i.shape.length,g=l.length===2&&y.arraysEqual(i.shape,c),x=y.sizeFromShape(i.shape)===1,v=S.getBroadcastDims(i.shape,t.shape),w=!n.packedInputs&&h===t.shape.length&&y.arraysEqual(c,t.texData.texShape),I=n.packedInputs||l.length>2?"":`${c[0]>1}_${c[1]>1}`;r+=`${h}_${w}_${u?p:""}_${l.length}_${x}_${v}_${g}_${d}_${f}_${m}_${I}_${a}`}else{let c=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${c}_${a}`}});let o=n.userCode,s=n.constructor.name;return s+="_"+r+"_"+o+`${M().getNumber("WEBGL_VERSION")}`,s}function qe(n){return M().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}var Dy=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=hl.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=lt();this.outputShape=e,this.enableShapeUniforms=qe(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?yl(["r","c","d"],e):Zr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}};var ky=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=hl.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=lt();this.outputShape=e,this.enableShapeUniforms=qe(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?yl(["r","c","d"],e):Zr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}};var _y=class{constructor(e){this.variableNames=["A"],this.outTexUsage=fn.DOWNLOAD;let t=lt();this.outputShape=e,this.userCode=`
      ${Sy}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}};var Ay=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=fn.DOWNLOAD;let t=lt();this.outputShape=e,this.userCode=`
      ${Sy}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}};var Uoe={R:0,G:1,B:2,A:3},Xm=class{constructor(e,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let o=lt();this.outputShape=e,this.enableShapeUniforms=qe(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++){let c=r[a];i+=`
          if(offset == ${a}) {
            result = values[${Uoe[c]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Qp():Zp(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${i}
        }
        ${o.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var Ry=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=lt();this.outputShape=e,this.enableShapeUniforms=qe(this.outputShape.length);let o="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let c=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Qp():Zp(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${r.output} = ${s};
        }
    `}};T();T();function pV(n){let e=lt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return PB(n,t)}function dV(n){let e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return UB(n,e)}function fV(n){let e=new Uint16Array([0,1,2,2,1,3]);return zB(n,e)}function Ym(n,e,t,r,o,s){GB(e,t);let i=HB(n),a=n.TEXTURE_2D;return ce(n,()=>n.bindTexture(a,i)),ce(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ce(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ce(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),ce(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),M().getNumber("WEBGL_VERSION")===1?ce(n,()=>n.texImage2D(a,0,r,e,t,0,o,s,null)):ce(n,()=>n.texStorage2D(a,1,r,e,t)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[t,e]}}function SN(n){return n.internalFormatFloat}function mV(n,e,t,r){let[o,s]=gl(e,t);return Ym(n,o,s,SN(r),r.textureFormatFloat,n.FLOAT)}function NN(n){return n.internalFormatHalfFloat}function hV(n,e,t,r){let[o,s]=gl(e,t);return Ym(n,o,s,NN(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function DN(n){return n.downloadTextureFormat}function gV(n,e,t,r){let[o,s]=gl(e,t);return Ym(n,o,s,DN(r),n.RGBA,n.UNSIGNED_BYTE)}function kN(n){return n.internalFormatPackedFloat}function xV(n,e,t,r){let[o,s]=Fo(e,t);return Ym(n,o,s,kN(r),n.RGBA,n.FLOAT)}function _N(n){return n.internalFormatPackedHalfFloat}function yV(n,e,t,r){let[o,s]=Fo(e,t);return Ym(n,o,s,_N(r),n.RGBA,r.textureTypeHalfFloat)}function vV(n,e,t){return ce(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),wN(n,e,"clipSpacePos",t,3,20,0)&&wN(n,e,"uv",t,2,20,12)}function bV(n,e,t,r,o,s){ce(n,()=>n.bindTexture(n.TEXTURE_2D,e));let i,a,c;o instanceof Uint8Array?(i=new Uint8Array(t*r*4),a=n.UNSIGNED_BYTE,c=n.RGBA):(i=new Float32Array(t*r*4),a=n.FLOAT,c=s.internalFormatPackedFloat),i.set(o),M().getNumber("WEBGL_VERSION")===2?ce(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,a,i)):ce(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,t,r,0,n.RGBA,a,i)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function CV(n,e,t){ce(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?M().getNumber("WEBGL_VERSION")===2?ce(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):ce(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):M().getNumber("WEBGL_VERSION")===2?ce(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):ce(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function wV(n,e,t,r){let o=n.createBuffer();ce(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,o));let a=4*4*e*t;return ce(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),ce(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),ce(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),o}function IV(n,e,t){let r=n,o=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function EV(n,e,t,r){let[o,s]=gl(e,t),i=4,a=new Uint8Array(OB(e*t,i));return ce(n,()=>n.readPixels(0,0,o,s,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function TV(n,e,t,r,o,s,i,a){let c=n,u=new Float32Array(MB(s,i));return c.bindBuffer(c.PIXEL_PACK_BUFFER,e),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,u),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),u}function SV(n,e,t){let r=new Float32Array(e*t*4);return ce(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}var od=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=M().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,FB(t,e)):this.gl=jn(t),e=this.gl,M().getNumber("WEBGL_VERSION")===2){let s=e;this.createVertexArray=()=>ce(s,()=>s.createVertexArray()),this.bindVertexArray=i=>ce(s,()=>s.bindVertexArray(i)),this.deleteVertexArray=i=>ce(s,()=>s.deleteVertexArray(i)),this.getVertexArray=()=>ce(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){let s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ce(e,()=>s.createVertexArrayOES()),this.bindVertexArray=i=>ce(e,()=>s.bindVertexArrayOES(i)),this.deleteVertexArray=i=>ce(e,()=>s.deleteVertexArrayOES(i)),this.getVertexArray=()=>ce(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),M().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=jm(this.gl,s),cr(this.gl,i))this.textureHalfFloatExtension=jm(this.gl,i);else if(M().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),cr(this.gl,o))this.colorBufferHalfFloatExtension=jm(this.gl,o);else if(M().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",cr(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(cr(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=dV(this.gl),this.indexBuffer=fV(this.gl),this.framebuffer=WB(this.gl),this.textureConfig=Wm(this.gl,this.textureHalfFloatExtension)}get debug(){return M().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;ce(e,()=>e.finish()),ce(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ce(e,()=>e.deleteFramebuffer(this.framebuffer)),ce(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ce(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ce(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),mV(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),hV(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),gV(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),CV(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,o){this.throwIfDisposed(),bV(this.gl,e,t,r,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),yV(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),xV(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(IN(this.gl,this.framebuffer),this.outputTexture=null),ce(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>EV(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,o,s,i){return TV(this.gl,e,t,r,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return IV(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);let o=wV(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(M().getBool("WEBGL_FENCE_API_ENABLED")){let o=e,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},t=s}else M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>SV(this.gl,t,r))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=pV(t));let r=BB(t);ce(t,()=>t.attachShader(r,this.vertexShader)),ce(t,()=>t.attachShader(r,e)),VB(t,r);let o=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Iy(t,o),o}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;ce(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),vV(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(ce(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Iy(this.gl,this.program),ce(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?jB(this.gl,e,t):qB(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ce(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),KB(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();let[o,s]=Fo(t,r);this.setOutputMatrixTextureDriver(e,o,s)}setOutputMatrixWriteRegion(e,t,r,o){this.setOutputMatrixWriteRegionDriver(r,e,o,t)}setOutputPackedMatrixWriteRegion(e,t,r,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Iy(this.gl,this.program),qm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ce(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ce(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=jm(this.gl,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(o.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await y.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{let r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let r=this.getQueryTimerExtensionWebGL1(),o=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=Hoe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in M().platform&&(r=M().platform.setTimeoutCustom.bind(M().platform)),y.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ey(this.gl,e,this.framebuffer),this.debug&&qm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ey(this.gl,this.outputTexture,this.framebuffer),this.debug&&qm(this.gl)):IN(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();let o=this.gl;Ey(o,e,this.framebuffer),this.debug&&qm(o),this.outputTexture=e,ce(o,()=>o.viewport(0,0,t,r)),ce(o,()=>o.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,o){this.throwIfDisposed(),ce(this.gl,()=>this.gl.scissor(e,t,r,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Hoe(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}var{addImpl:NV,bincountImpl:Fy,bincountReduceImpl:DV,bitwiseAndImpl:kV,castImpl:_V,ceilImpl:AV,concatImpl:RV,equalImpl:FV,expImpl:OV,expm1Impl:MV,floorImpl:$V,gatherNdImpl:PV,gatherV2Impl:LV,greaterImpl:BV,greaterEqualImpl:VV,lessImpl:UV,lessEqualImpl:zV,linSpaceImpl:HV,logImpl:GV,maxImpl:WV,maximumImpl:jV,minimumImpl:qV,multiplyImpl:KV,negImpl:XV,notEqualImpl:YV,prodImpl:ZV,raggedGatherImpl:QV,raggedRangeImpl:JV,raggedTensorToTensorImpl:e4,rangeImpl:t4,rsqrtImpl:n4,scatterImpl:r4,sigmoidImpl:o4,simpleAbsImpl:Oy,sliceImpl:s4,sparseFillEmptyRowsImpl:i4,sparseReshapeImpl:a4,sparseSegmentReductionImpl:My,sqrtImpl:c4,staticRegexReplaceImpl:u4,stridedSliceImpl:l4,stringNGramsImpl:p4,stringSplitImpl:d4,stringToHashBucketFastImpl:f4,subImpl:m4,tileImpl:h4,topKImpl:g4,transposeImpl:bl,uniqueImpl:x4}=oN;function AN(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function xt(n,e){return e===1?[n]:AN(n,e)}function y4(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}var $y=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=qe(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=xt("rc",this.rank),r=ve(this.rank),o=this.getOutOfBoundsCondition(t),s=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){let s=`${r===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${e[e.length-1-i]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${o};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}};var sd=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=qe(this.outputShape.length);let r="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),r+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Goe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Qp():Zp(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}};function Goe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?nV(["r","c","d"],"inputShape"):Zr(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}T();var Py=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,r){let o=b4(t,r),s=C4(e,o,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=v4(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let c=this.freeTextures[s].pop();return this.usedTextures[s].push(c),c}let a;return o===on.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===on.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===on.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===on.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===on.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,r,o){if(this.freeTextures==null)return;let s=b4(r,o),i=C4(t,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=v4(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),c=M().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let u=this.usedTextures[i],l=u&&u.indexOf(e);if(l==null||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[l]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Woe(n,e){let t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function v4(n,e,t,r,o){let s=joe(e,r),i;if(o){let[c,u]=Fo(n[0],n[1]);i=c*u}else{let[c,u]=gl(n[0],n[1]);i=c*u}let a=Woe(t,s);return i*a}function joe(n,e){switch(n){case on.PACKED_2X2_FLOAT32:return kN(e);case on.PACKED_2X2_FLOAT16:return _N(e);case on.UNPACKED_FLOAT32:return SN(e);case on.UNPACKED_FLOAT16:return NN(e);case on.PACKED_4X1_UNSIGNED_BYTE:return DN(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function qoe(n){return M().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?on.PACKED_2X2_FLOAT32:on.UNPACKED_FLOAT32:n?on.PACKED_2X2_FLOAT16:on.UNPACKED_FLOAT16}function b4(n,e){if(n===fn.UPLOAD)return on.PACKED_2X2_FLOAT32;if(n===fn.RENDER||n==null)return qoe(e);if(n===fn.DOWNLOAD||n===fn.PIXELS)return on.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function C4(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}var Kt=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=qe(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Dt="if (isnan(x)) return x;",w4="return x;",RN="return abs(x);";var I4="return (x >= 0.0) ? x : (exp(x) - 1.0);",E4=Dt+`
  return (x < 0.0) ? 0.0 : x;
`,T4=Dt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Mo="return x;",S4="return 1.0 / (1.0 + exp(-1.0 * x));";var D4="return x;",k4=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,_4=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,A4=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,R4="return 1.0 / (1.0 + exp(-1.0 * x));",Rn=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=qe(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var Ly=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=qe(this.outputShape.length);let t=e.length,r=xt("rc",t),o=ve(t),s=y4(t,r),i=r.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var Xoe=qt.whereImpl,Yoe=1e-7,Zoe=1e-4,By={};function Qoe(n){return n in By||(By[n]={}),By[n]}var Joe=M().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),ese=600;function tse(){return M().global.screen==null?1024:M().global.screen.height*M().global.screen.width*window.devicePixelRatio*ese/1024/1024}var F4=(()=>{class n extends go{nextDataId(){return n.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!M().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(t!=null){if(t instanceof od)r=t;else{let o=jn(M().getNumber("WEBGL_VERSION"),t);r=new od(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let o=jn(M().getNumber("WEBGL_VERSION"));r=new od(o),this.binaryCache=Qoe(M().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Py(this.gpgpu),this.numMBBeforeWarning=tse(),this.texData=new Ps(this,sr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,r,o,s,i,a){let c=this.makeTensorInfo(r,o),u=this.texData.get(c.dataId);u.isPacked=!1,u.texture={texture:t,texShape:[s,i]},u.texShape=[s,i];let l=Km(r),p=new Xm(l,!1,a),d=this.runWebGLProgram(p,[c],o,[[s,i]]);return d.shape=r,u.texture=null,this.disposeIntermediateTensorInfo(c),d.dataId}write(t,r,o){if((M().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||M().getBool("DEBUG"))&&this.checkNumericalProblems(t),o==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:r,dtype:o,values:t,usage:fn.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let r=this.texData.get(t);r.refCount++}decRef(t){if(this.texData.has(t)){let r=this.texData.get(t);r.refCount--}}move(t,r,o,s,i){if(M().getBool("DEBUG")&&this.checkNumericalProblems(r),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:o,dtype:s,values:r,usage:fn.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let r=this.texData.get(t),{values:o,dtype:s,complexTensorInfos:i,slice:a,shape:c,isPacked:u}=r;if(a!=null){let f;u?f=new Rn(c,Mo):f=new Kt(c,Mo);let m=this.runWebGLProgram(f,[{dataId:t,shape:c,dtype:s}],s),h=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),h}if(o!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return o;let l=this.activeTimers!=null,p;l&&(p=y.now());let d;if(s==="complex64"){let f=this.readSync(i.real.dataId),m=this.readSync(i.imag.dataId);d=S.mergeRealAndImagArrays(f,m)}else d=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=y.now()-p),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){let h=this.pendingRead.get(t);return new Promise(g=>h.push(g))}let r=this.texData.get(t),{values:o,shape:s,slice:i,dtype:a,complexTensorInfos:c,isPacked:u}=r;if(i!=null){let h;u?h=new Rn(s,Mo):h=new Kt(s,Mo);let g=this.runWebGLProgram(h,[{dataId:t,shape:s,dtype:a}],a),x=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),x}if(o!=null)return this.convertAndCacheOnCPU(t);if(M().getBool("DEBUG")&&!M().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&M().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,p;if(a!=="complex64"&&M().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(t);let h=this.texData.get(p.dataId);l=this.gpgpu.createBufferFromTexture(h.texture.texture,...Gm(s))}this.pendingRead.set(t,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(a==="complex64"){let h=await Promise.all([this.read(c.real.dataId),this.read(c.imag.dataId)]),g=h[0],x=h[1];d=S.mergeRealAndImagArrays(g,x)}else if(l==null)d=this.getValuesFromTexture(t);else{let h=y.sizeFromShape(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(l,h)}if(p!=null&&this.disposeIntermediateTensorInfo(p),l!=null){let h=this.gpgpu.gl;ce(h,()=>h.deleteBuffer(l))}let f=this.convertAndCacheOnCPU(t,d),m=this.pendingRead.get(t);return this.pendingRead.delete(t),m.forEach(h=>h(f)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&sr().removeDataId(t,this),this.pendingDeletes--),f}readToGPU(t,r={}){let o=this.texData.get(t),{values:s,shape:i,slice:a,dtype:c,isPacked:u,texture:l}=o;if(c==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let m;u?m=new Rn(i,Mo):m=new Kt(i,Mo);let h=this.runWebGLProgram(m,[{dataId:t,shape:i,dtype:c}],c),g=this.readToGPU(h,r);return this.disposeIntermediateTensorInfo(h),g}if(l==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(t,r.customTexShape),d=sr().makeTensorFromTensorInfo(p),f=this.texData.get(p.dataId);return Object.assign({tensorRef:d},f.texture)}bufferSync(t){let r=this.readSync(t.dataId);if(t.dtype==="string")try{let o=r.map(s=>y.decodeString(s));return ue(t.shape,t.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ue(t.shape,t.dtype,r)}checkNumericalProblems(t){if(t!=null)for(let r=0;r<t.length;r++){let o=t[r];if(!$B(o))throw M().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:r,dtype:o,isPacked:s}=this.texData.get(t),i=y.sizeFromShape(r);if(M().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let f=this.decode(t),m=this.texData.get(f.dataId),h=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...Gm(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),h}let a=M().getBool("WEBGL_PACK")&&s===!0,c=a?Km(r):r,u=a?new Ay(c):new _y(c),l=this.runWebGLProgram(u,[{shape:c,dtype:o,dataId:t}],"float32"),p=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let r=this.activeTimers,o=[],s=!1;this.programTimersStack==null?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,t();let i=y.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=y.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=r,s&&(this.programTimersStack=null);let c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(i);c.kernelMs=y.sum(u),c.getExtraProfileInfo=()=>u.map((l,p)=>({name:a[p],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:y.now(),endMs:null}}endTimer(t){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=y.now(),t)}async getQueryTime(t){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let r=t;return r.endMs-r.startMs}disposeData(t,r=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(r?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!r&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:o}=this.texData.get(t);return o!=null&&(this.disposeData(o.real.dataId,r),this.disposeData(o.imag.dataId,r)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:r,dtype:o,texShape:s,usage:i,isPacked:a,slice:c}=this.texData.get(t),u=c&&c.origDataId||t,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),r!=null&&(this.numBytesInGPU-=this.computeBytes(s,o),this.textureManager.releaseTexture(r,s,i,a)));let p=this.texData.get(t);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,r=Joe){return M().getBool("WEBGL_CPU_FORWARD")&&t.every(o=>this.texData.get(o.dataId).texture==null&&y.sizeFromShape(o.shape)<r)}getGPGPUContext(){return this.gpgpu}where(t){S.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let r=t.dataSync();return Xoe(t.shape,r)}packedUnaryOp(t,r,o){let s=new Rn(t.shape,r),i=this.compileAndRun(s,[t],o);return sr().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let s=Oy(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if(M().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,RN,t.dtype);let r=new Kt(t.shape,RN),o=this.compileAndRun(r,[t]);return sr().makeTensorFromTensorInfo(o)}makeTensorInfo(t,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&y.isString(o[0])){let i=o.map(a=>y.encodeString(a));s=this.write(i,t,r)}else s=this.write(o,t,r);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:r}}makeOutput(t,r,o){return sr().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,o),this)}unpackTensor(t){let r=new Ly(t.shape);return this.runWebGLProgram(r,[t],t.dtype)}packTensor(t){let r=new $y(t.shape);return this.runWebGLProgram(r,[t],t.dtype,null,!0)}packedReshape(t,r){let o=[oa(t.shape),...sa(t.shape)],s={dtype:t.dtype,shape:o,dataId:t.dataId},i=[oa(r),...sa(r)],a=new sd(i,o),c=!0,u=[o],l=this.runWebGLProgram(a,[s],t.dtype,u,c);return{dataId:l.dataId,shape:r,dtype:l.dtype}}decode(t,r){let o=this.texData.get(t),{isPacked:s,shape:i,dtype:a}=o;if(r!=null){let f=y.sizeFromShape(i),m=r[0]*r[1]*4;y.assert(f<=m,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let c=Km(i),u;s?u=new ky(c):u=new Dy(c);let l=!0,p=[r??Gm(c)],d=this.runWebGLProgram(u,[{shape:c,dtype:a,dataId:t}],a,p,l,r);return{dtype:a,shape:i,dataId:d.dataId}}runWebGLProgram(t,r,o,s,i=!1,a){let c=this.makeTensorInfo(t.outputShape,o),u=this.texData.get(c.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===hl.DENSE){let v=a??Gm(t.outputShape);u.texShape=v.map(w=>w*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),y.sizeFromShape(c.shape)===0)return u.values=y.getTypedArrayFromDType(c.dtype,0),c;let l=[],p=r.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(v.dataId);if(w.texture==null){if(!t.packedInputs&&y.sizeFromShape(v.shape)<=M().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:w.values};t.packedInputs&&(w.isPacked=!0,w.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!w.isPacked!=!!t.packedInputs)v=w.isPacked?this.unpackTensor(v):this.packTensor(v),l.push(v),w=this.texData.get(v.dataId);else if(w.isPacked&&!xl(w.shape,v.shape)){let I=v,_=v.shape;v.shape=w.shape,v=this.packedReshape(v,_),l.push(v),w=this.texData.get(v.dataId),I.shape=_}return{shape:v.shape,texData:w,isUniform:!1}});this.uploadToGPU(c.dataId);let d={shape:c.shape,texData:u,isUniform:!1},f=lV(t,p,d),m=this.getAndSaveBinary(f,()=>cV(this.gpgpu,t,p,d)),h=this.activeTimers!=null,g;h&&(g=this.startTimer()),M().get("ENGINE_COMPILE_ONLY")||uV(this.gpgpu,m,p,d,s),l.forEach(v=>this.disposeIntermediateTensorInfo(v)),h&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));let x=M().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){let v=y.now();v-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!M().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&i===!1){let v=this.unpackTensor(c);return this.disposeIntermediateTensorInfo(c),v}return c}compileAndRun(t,r,o,s,i=!1){return o=o||r[0].dtype,this.runWebGLProgram(t,r,o,s,i)}getAndSaveBinary(t,r){return t in this.binaryCache||(this.binaryCache[t]=r()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(M().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Ce(()=>{if(!M().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=M().getBool("DEBUG");M().set("DEBUG",!1);let r=this.abs(me(1e-8)).dataSync()[0];if(M().set("DEBUG",t),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Yoe:Zoe}uploadToGPU(t){let r=this.texData.get(t),{shape:o,dtype:s,values:i,texture:a,usage:c,isPacked:u}=r;if(a!=null)return;let l=this.activeTimers!=null,p;l&&(p=y.now());let d=r.texShape;if(d==null&&(d=XB(o,u),r.texShape=d),i!=null){let f=Km(o),m,h=d[1],g=d[0],x=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!x)&&([h,g]=Fo(d[0],d[1])),u?m=new Ry(f,x):m=new Xm(f,x);let v=x?[g,h]:d,w=this.makeTensorInfo(v,s),I=this.texData.get(w.dataId);x?I.usage=fn.PIXELS:I.usage=fn.UPLOAD,I.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),h,g,i);let _=[[g,h]],R=this.runWebGLProgram(m,[w],s,_,!0),F=this.texData.get(R.dataId);r.texShape=F.texShape,r.isPacked=F.isPacked,r.usage=F.usage,M().get("ENGINE_COMPILE_ONLY")?this.disposeData(R.dataId):(r.texture=F.texture,r.values=null,this.texData.delete(R.dataId)),this.disposeIntermediateTensorInfo(w),l&&(this.uploadWaitMs+=y.now()-p)}else{let f=this.acquireTexture(d,c,s,u);r.texture=f}}convertAndCacheOnCPU(t,r){let o=this.texData.get(t),{dtype:s}=o;return r!=null&&(o.values=nse(r,s)),o.values}acquireTexture(t,r,o,s){if(this.numBytesInGPU+=this.computeBytes(t,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,r,s)}computeBytes(t,r){return t[0]*t[1]*y.bytesPerElement(r)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,r]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(r));return Promise.all(t)}else{for(let[,r]of Object.entries(this.binaryCache)){let o=new Promise(s=>{try{this.checkCompletion_(r),s(!0)}catch(i){throw i}});t.push(o)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Xx(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(CN(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:r,customUniformLocations:o,infLoc:s,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:u}=TN(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=r,t.customUniformLocations=o,t.infLoc=s,t.nanLoc=i,t.outShapeLocation=a,t.outShapeStridesLocation=c,t.outTexShapeLocation=u}}createTensorFromGPUData(t,r,o){t.channels=t.channels||"RGBA";let{texture:s,height:i,width:a,channels:c}=t,u=sr().backend;if(!u.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=u.writeTexture(s,r,o,i,a,c);return sr().makeTensorFromDataId(l,r,o,u)}}return n.nextDataId=0,n})();function nse(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){let t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}Yo.isBrowser()&&Of("webgl",()=>new F4,2);T();T();T();T();T();var id=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Fn=class{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=S.assertAndGetBroadcastShape(t,r),this.enableShapeUniforms=qe(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};T();var Kn=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var qn=class{constructor(e,t,r,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S.assertAndGetBroadcastShape(t,r);let s=this.outputShape.length;this.enableShapeUniforms=qe(s);let i="";if(o)if(s===0||y.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${ve(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let c=xt("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${c[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${c[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${c[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${c[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};T();T();function yt(n){let{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var O4={kernelName:qo,backendName:"webgl",kernelFunc:yt};function On(n){let{inputs:e,backend:t}=n,{real:r,imag:o}=e,s=t.makeTensorInfo(r.shape,"complex64"),i=t.texData.get(s.dataId),a=yt({inputs:{x:r},backend:t}),c=yt({inputs:{x:o},backend:t});return i.complexTensorInfos={real:a,imag:c},s}var M4={kernelName:rc,backendName:"webgl",kernelFunc:On};T();var FN="return (a < 0.) ? b * a : a;",ON=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function rse(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{alpha:s}=r,i=t.makeTensorInfo([],"float32",y.createScalarValue(s,"float32")),a=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new qn(ON,o.shape,i.shape):new Fn(FN,o.shape,i.shape),c=t.runWebGLProgram(a,[o,i],"float32");return t.disposeIntermediateTensorInfo(i),c}var $4={kernelName:Oc,backendName:"webgl",kernelFunc:rse};T();var MN="return (a < 0.) ? b * a : a;",$N=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function ose(n){let{inputs:e,backend:t}=n,{x:r,alpha:o}=e,s=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new qn($N,r.shape,o.shape):new Fn(MN,r.shape,o.shape);return t.runWebGLProgram(s,[r,o],"float32")}var P4={kernelName:Qc,backendName:"webgl",kernelFunc:ose};var Tr="if (isnan(x)) return x;";function pe({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,c=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){let p=a.texData.get(i.dataId),d=t(p.values,c);return a.makeTensorInfo(i.shape,c,d)}let u=M().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null,l;return u?l=new Rn(i.shape,e):l=new Kt(i.shape,n),a.runWebGLProgram(l,[i],c)}}function je({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:c,b:u}=i,l=a;if(r&&c.dtype==="complex64"){let m=l.texData.get(c.dataId),h=l.texData.get(u.dataId),[g,x]=[[m.complexTensorInfos.real,h.complexTensorInfos.real],[m.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(w=>{let[I,_]=w,A={dataId:I.dataId,dtype:I.dtype,shape:c.shape},R={dataId:_.dataId,dtype:_.dtype,shape:u.shape},F=new Fn(n,c.shape,u.shape);return l.runWebGLProgram(F,[A,R],wt(I.dtype,_.dtype))}),v=On({inputs:{real:g,imag:x},backend:l});return l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(x),v}let p=s||wt(c.dtype,u.dtype);if((c.dtype==="string"||u.dtype==="string"||l.shouldExecuteOnCPU([c,u]))&&o!=null){let m=l.texData.get(c.dataId).values,h=l.texData.get(u.dataId).values,g=c.dtype==="string"?S.fromUint8ToStringArray(m):m,x=c.dtype==="string"?S.fromUint8ToStringArray(h):h,[v,w]=o(c.shape,u.shape,g,x,p),I=l.makeTensorInfo(w,p),_=l.texData.get(I.dataId);return _.values=v,I}let d=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null,f;return d?f=new qn(e,c.shape,u.shape,t):f=new Fn(n,c.shape,u.shape),l.runWebGLProgram(f,[c,u],p)}}function bs(n,e=!1){if(n==="linear")return e?D4:w4;if(n==="relu")return e?_4:E4;if(n==="elu")return e?k4:I4;if(n==="relu6")return e?A4:T4;if(n==="prelu")return e?$N:MN;if(n==="leakyrelu")return e?ON:FN;if(n==="sigmoid")return e?R4:S4;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}var ad=class{constructor(e,t,r,o=!1,s=!1,i=!1,a=null,c=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=qe(this.outputShape.length);let l=o?e[1]:e[2],p=Math.ceil(l/2),d=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",m=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",x="";a&&(c?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");let v=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let w="rc.x",I="rc.x";e[0]<t[0]?w=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(I=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w};
        int batchB = ${I};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${h[0]});
          result += (${m[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${v}

        ${x}

        setOutput(result);
      }
    `}};T();T();var PN={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},Zm=class{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=S.assertAndGetBroadcastShape(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var L4="return a * b;";function Qm(n){let{inputs:e,backend:t}=n,{a:r,b:o}=e,s=S.upcastType(r.dtype,o.dtype);if(r.dtype==="complex64"){let a=t.texData.get(r.dataId),c=t.texData.get(o.dataId),u=new Zm(PN.REAL,r.shape,o.shape),l=new Zm(PN.IMAG,r.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:o.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:o.shape}],d=t.runWebGLProgram(u,p,"float32"),f=t.runWebGLProgram(l,p,"float32"),m=On({inputs:{real:d,imag:f},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),m}if(t.shouldExecuteOnCPU([r,o])){let a=t.texData.get(r.dataId),c=t.texData.get(o.dataId),[u,l]=KV(r.shape,o.shape,a.values,c.values,s),p=t.makeTensorInfo(l,s),d=t.texData.get(p.dataId);return d.values=u,p}let i;return M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new qn(L4,r.shape,o.shape):i=new Fn(L4,r.shape,o.shape),t.runWebGLProgram(i,[r,o],s)}var B4={kernelName:hi,backendName:"webgl",kernelFunc:Qm};T();function V4(n,e,t){let r=[oa(n.shape),...sa(n.shape)],o={dtype:n.dtype,shape:r,dataId:n.dataId},s=[oa(e),...sa(e)],i=new sd(s,r),a=!0,c=[r],u=t.runWebGLProgram(i,[o],n.dtype,c,a);return{dataId:u.dataId,shape:e,dtype:u.dtype}}function J(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{shape:s}=r,i=t,a=y.sizeFromShape(o.shape),c=y.inferFromImplicitShape(s,a),u=y.sizeFromShape(c);y.assert(a===u,()=>`The new shape (${c}) has ${u} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let l=i.texData.get(o.dataId);return l.isPacked&&!xl(o.shape,c)&&!(l.texture!==null&&xl(l.shape,c))?V4(o,c,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:c,dtype:o.dtype})}var U4={kernelName:su,backendName:"webgl",kernelFunc:J};T();T();T();T();var Jm=class{constructor(e,t){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=e;this.outputShape=[o,i];let a=Math.floor(r/4)*4,c=r%4,u="sumValue += dot(values, ones);";if(t!=null){let p=1/t;u=`sumValue += dot(values * ${y.isInt(p)?p.toPrecision(2):p}, ones);`}let l="";s%r>0&&(l=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${l}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}};var Vy=class{constructor(e,t){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=e;this.outputShape=[o,i];let a="0.0",c="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",c="min"):t==="max"&&(a="-1.0 / 1e-20",c="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");let l=Math.floor(r/4)*4,p=r%4,d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let m="";s%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${l};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}};function ise(n){let e=[];for(;e.length===0||e[e.length-1].outSize!==1;){let t=e.length?e[e.length-1].outSize:n[1],r=S.computeOptimalWindowSize(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function Xn(n,e,t,r){let o=ise(n.shape),s=n;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:c,outSize:u}=o[i],l,p;t==="mean"?l=i===0?new Jm({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:u},a):new Jm({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:u}):l=new Vy({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:u},t),p=s,s=r.runWebGLProgram(l,[s],e),p.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(p)}return s}T();var Uy=class{constructor(e,t){this.variableNames=["A"];let r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[t[i]];this.outputShape=r,this.rank=r.length;let o=ve(this.rank),s=ase(t);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function ase(n){let e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let o=0;o<n.length;o++)r[n[o]]=t[o];return r.join()}var zy=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let r=new Array(e.length);for(let l=0;l<r.length;l++)r[l]=e[t[l]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=ve(this.rank),s=AN("rc",this.rank),i=new Array(this.rank);for(let l=0;l<t.length;l++)i[t[l]]=s[l];let a=`vec2(${i.slice(-2).join()})`,c=`++${s[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${c}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${c}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function ia(n,e,t){let r=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zy(n.shape,e):new Uy(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}function z4(n,e,t,r){let o=e,s=n.shape.length,i=y.parseAxisParam(o,n.shape),a=i,c=S.getAxesPermutation(a,s),u=c!=null,l=n;u&&(l=ia(n,c,r),a=S.getInnerMostAxes(a.length,s)),S.assertAxesAreInnerMostDims("sum",a,s);let[p,d]=S.computeOutAndReduceShapes(l.shape,a),f=p;t&&(f=S.expandShapeToKeepDim(p,i));let m=y.sizeFromShape(d),g=y.sizeFromShape(n.shape)/m,x=J({inputs:{x:l},attrs:{shape:[g,m]},backend:r}),v=Pi(n.dtype),w=Xn(x,v,"sum",r),I=J({inputs:{x:w},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(w),u&&r.disposeIntermediateTensorInfo(l),I}function Cl(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;return z4(o,s,i,t)}var H4={kernelName:"Sum",backendName:"webgl",kernelFunc:Cl};T();function tt(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{perm:s}=r,i=t,a=o.shape.length,c=new Array(a);for(let l=0;l<c.length;l++)c[l]=o.shape[s[l]];let u;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,d=bl(p,o.shape,o.dtype,s,c);u=i.makeTensorInfo(c,o.dtype);let f=i.texData.get(u.dataId);f.values=d}else u=ia(o,s,i);return u}var G4={kernelName:Xo,backendName:"webgl",kernelFunc:tt};var LN=1e3;function wl({a:n,b:e,transposeA:t,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:c=null}){let u=n.shape.length,l=e.shape.length,p=t?n.shape[u-2]:n.shape[u-1],d=r?e.shape[l-1]:e.shape[l-2],f=t?n.shape[u-1]:n.shape[u-2],m=r?e.shape[l-2]:e.shape[l-1],h=n.shape.slice(0,-2),g=e.shape.slice(0,-2),x=y.sizeFromShape(h),v=y.sizeFromShape(g),I=Gr.assertAndGetBroadcastShape(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,m]);y.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);let _=t?[x,p,f]:[x,f,p],A=r?[v,m,d]:[v,d,m],R=J({inputs:{x:n},backend:o,attrs:{shape:_}}),F=J({inputs:{x:e},backend:o,attrs:{shape:A}}),P=[R,F],L=Math.max(x,v),V=t?R.shape[1]:R.shape[2],z=s!=null,H=i!=null,j=c==="leakyrelu",W=c!=null?bs(c,!0):null,Y=z||H||j||W!=null,Z;if((f===1||m===1)&&V>LN&&Y===!1){let Q=R,te=F;t&&(Q=tt({inputs:{x:R},backend:o,attrs:{perm:[0,2,1]}}),P.push(Q)),r&&(te=tt({inputs:{x:F},backend:o,attrs:{perm:[0,2,1]}}),P.push(te));let ne=m!==1,se=m===1,re=Q;ne&&(re=J({inputs:{x:Q},backend:o,attrs:{shape:[L,V,1]}}),P.push(re));let ae=m===1?2:1,oe=te;se&&(oe=J({inputs:{x:te},backend:o,attrs:{shape:[L,1,V]}}),P.push(oe));let le=Qm({inputs:{a:re,b:oe},backend:o});Z=Cl({inputs:{x:le},backend:o,attrs:{axis:ae,keepDims:!0}}),P.push(le)}else{let Q=wt(n.dtype,e.dtype),te=new ad(_,A,[L,f,m],t,r,z,W,H,j),ne=[R,F];if(s!=null&&ne.push(s),H&&ne.push(i),j){let se=o.makeTensorInfo([],"float32",y.createScalarValue(a,"float32"));ne.push(se),P.push(se)}Z=o.runWebGLProgram(te,ne,Q)}let K=J({inputs:{x:Z},backend:o,attrs:{shape:I}});P.push(Z);for(let Q of P)o.disposeIntermediateTensorInfo(Q);return K}function cse(n){let{inputs:e,backend:t,attrs:r}=n,{a:o,b:s,bias:i,preluActivationWeights:a}=e,{transposeA:c,transposeB:u,activation:l,leakyreluAlpha:p}=r;return wl({a:o,b:s,transposeA:c,transposeB:u,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:l})}var W4={kernelName:Ri,backendName:"webgl",kernelFunc:cse};T();var j4="return abs(x);";function use(n){let{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=t.texData.get(r.dataId),i=Oy(s.values);return t.makeTensorInfo(r.shape,r.dtype,i)}let o;return M().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Rn(r.shape,j4):o=new Kt(r.shape,j4),t.runWebGLProgram(o,[r],r.dtype)}var q4={kernelName:"Abs",backendName:"webgl",kernelFunc:use};T();var lse=Dt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,pse=pe({opSnippet:lse}),K4={kernelName:Vs,backendName:"webgl",kernelFunc:pse};T();var dse=Dt+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,fse=pe({opSnippet:dse}),X4={kernelName:Us,backendName:"webgl",kernelFunc:fse};T();var Y4="return a + b;",mse=je({opSnippet:Y4,packedOpSnippet:Y4,supportsComplex:!0,cpuKernelImpl:NV}),Z4={kernelName:"Add",backendName:"webgl",kernelFunc:mse};T();var Hy=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var Gy=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function Wy(n){let{inputs:e,backend:t}=n,r=e;if(r.length===1)return yt({inputs:{x:r[0]},backend:t});if(r.length>M().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(r.length/2),u=Wy({inputs:r.slice(0,c),backend:t}),l=Wy({inputs:r.slice(c),backend:t});return Wy({inputs:[u,l],backend:t})}let o=r.map(c=>c.dtype).reduce((c,u)=>wt(c,u)),s=r.map(c=>c.shape),a=M().getBool("WEBGL_PACK")?new Gy(r[0].shape,s):new Hy(r[0].shape,s);return t.runWebGLProgram(a,r,o)}var Q4={kernelName:Ka,backendName:"webgl",kernelFunc:Wy};T();function hse(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),u=c,l=S.getAxesPermutation(u,a),p=o;l!=null&&(p=tt({inputs:{x:o},backend:t,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,a)),S.assertAxesAreInnerMostDims("all",u,a);let[d,f]=S.computeOutAndReduceShapes(p.shape,u),m=y.sizeFromShape(f),h=J({inputs:{x:p},backend:t,attrs:{shape:[-1,m]}}),g=Xn(h,h.dtype,"all",t),x;if(i){let v=S.expandShapeToKeepDim(d,c);x=J({inputs:{x:g},backend:t,attrs:{shape:v}})}else x=J({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),l!=null&&t.disposeIntermediateTensorInfo(p),x}var J4={kernelName:"All",backendName:"webgl",kernelFunc:hse};T();function gse(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),u=c,l=S.getAxesPermutation(u,a),p=o;l!=null&&(p=tt({inputs:{x:o},backend:t,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,a)),S.assertAxesAreInnerMostDims("any",u,a);let[d,f]=S.computeOutAndReduceShapes(p.shape,u),m=y.sizeFromShape(f),h=J({inputs:{x:p},backend:t,attrs:{shape:[-1,m]}}),g=Xn(h,h.dtype,"any",t),x;if(i){let v=S.expandShapeToKeepDim(d,c);x=J({inputs:{x:g},backend:t,attrs:{shape:v}})}else x=J({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),l!=null&&t.disposeIntermediateTensorInfo(p),x}var eU={kernelName:"Any",backendName:"webgl",kernelFunc:gse};T();T();var jy=class{constructor(e,t,r){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=t==="max"?">":"<",c=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};T();var qy=class{constructor(e,t,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,y.assert(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],i=Math.ceil(s/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,c=a.length,u=ve(c),l=xt("coords",c),p,d;if(i===1){d=c+1;let F=ve(d);p=`
        ${F} sourceLocR = ${F}(${l.join()}, 0);
        ++${l[c-1]};
        ${F} sourceLocG = ${F}(${l.join()}, 0);
        ++${l[c-2]};
        ${F} sourceLocA = ${F}(${l.join()}, 0);
        --${l[c-1]};
        ${F} sourceLocB = ${F}(${l.join()}, 0);
        --${l[c-2]};`}else d=c,p=`
        ${u} sourceLocR = coords;
        ++${l[c-1]};
        ${u} sourceLocG = coords;
        ++${l[c-2]};
        ${u} sourceLocA = coords;
        --${l[c-1]};
        ${u} sourceLocB = coords;
        --${l[c-2]};`;let f=["x","y","z","w","u","v"].slice(0,d),m="."+f[d-1],h=f.map(F=>"int "+F),g=xt("sourceLocR",d-1).concat("inIdx.r"),x=xt("sourceLocG",d-1).concat("inIdx.g"),v=xt("sourceLocB",d-1).concat("inIdx.b"),w=xt("sourceLocA",d-1).concat("inIdx.a"),I=r==="max"?"greaterThan":"lessThan",_=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()})));`,A=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${v.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,R=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${l[c-1]} < ${a[c-1]-1};
        bool hasNextRow = ${l[c-2]} < ${a[c-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${A};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${_}
          vec4 candidate = ${A};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${I}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function tU(n,e,t,r=null){let o=e.shape[0],s=e.shape[1];r!=null&&(o=r.shape[0],s=r.shape[1]);let i=S.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},c=new jy(a,t,r==null),u=[e];r!=null&&u.push(r);let l=n.runWebGLProgram(c,u,"int32");if(l.shape[1]===1)return l;let p=tU(n,e,t,l);return n.disposeIntermediateTensorInfo(l),p}function nU(n,e,t,r=null){let o=r!=null?r.shape:e.shape,s=o[o.length-1],i=S.computeOptimalWindowSize(s),a=new qy(o,i,t,r==null),c=r==null?[e]:[e,r],u=n.runWebGLProgram(a,c,"int32");if(u.shape.length===e.shape.length){let l=nU(n,e,t,u);return n.disposeIntermediateTensorInfo(u),l}return u}function Ky(n,e,t,r){let o=[t];if(S.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,e.shape.length),!M().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){let s=[],i=n.texData.get(e.dataId),a=i!==null&&i.isPacked,c=e;a&&(c=n.unpackTensor(e),s.push(c));let[u,l]=S.computeOutAndReduceShapes(c.shape,o),p=y.sizeFromShape(l),d=J({inputs:{x:c},backend:n,attrs:{shape:[-1,p]}});s.push(d);let f=tU(n,d,r);s.push(f);let m=J({inputs:{x:f},backend:n,attrs:{shape:u}});return s.forEach(h=>n.disposeIntermediateTensorInfo(h)),m}return nU(n,e,r)}function xse(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s}=r,i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,u=[];a!=null&&(c=tt({inputs:{x:o},backend:t,attrs:{perm:a}}),u.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),S.assertAxesAreInnerMostDims("argMax",[i[0]],c.shape.length);let l=Ky(t,c,i[0],"max");return u.forEach(p=>t.disposeIntermediateTensorInfo(p)),l}var rU={kernelName:Xa,backendName:"webgl",kernelFunc:xse};T();function yse(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s}=r,i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,u=[];a!=null&&(c=tt({inputs:{x:o},backend:t,attrs:{perm:a}}),u.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),S.assertAxesAreInnerMostDims("argMin",[i[0]],c.shape.length);let l=Ky(t,c,i[0],"min");return u.forEach(p=>t.disposeIntermediateTensorInfo(p)),l}var oU={kernelName:Ya,backendName:"webgl",kernelFunc:yse};T();var vse=Dt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,bse=pe({opSnippet:vse}),sU={kernelName:zs,backendName:"webgl",kernelFunc:bse};T();var Cse=Dt+"return log(x + sqrt(x * x + 1.0));",wse=pe({opSnippet:Cse}),iU={kernelName:Hs,backendName:"webgl",kernelFunc:wse};T();var Ise=Dt+`
  return atan(x);
`,Ese=pe({opSnippet:Ise}),aU={kernelName:Gs,backendName:"webgl",kernelFunc:Ese};T();var Tse=id+`
  return atan(a, b);
`,Sse=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Kn+`
  return result;
`,Nse=je({opSnippet:Tse,packedOpSnippet:Sse}),cU={kernelName:js,backendName:"webgl",kernelFunc:Nse};T();var Dse=Dt+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,kse=pe({opSnippet:Dse}),uU={kernelName:Ws,backendName:"webgl",kernelFunc:kse};T();var Qr=class{constructor(e,t,r,o=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,a=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;let h=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,v="0.0";if(h||(v="-1.0 / 1e-20"),r){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${c});
        const ivec2 pads = ivec2(${f}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:x:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(I="avgValue / max(count, 1.0)");let _=Math.floor(i/4)*4,A=i%4,R=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${c});
      const ivec2 pads = ivec2(${f}, ${m});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC += 4) {
            int xC = xCCorner + wC * ${l};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              getValue(batch, xR, xC + 3 * ${l}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${_};
          if (${A===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${A===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${A===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${I});
      }
    `}},aa=class{constructor(e,t,r,o=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,a=e.strideDepth,c=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,p=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,m=e.effectiveFilterHeight,h=e.effectiveFilterWidth,g=e.padInfo.front,x=e.padInfo.top,v=e.padInfo.left;this.outputShape=e.outShape;let w=t==="avg",I="0.0";if(w||(I="-1.0 / 1e-20"),r){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${c}, ${u});
        const ivec3 pads = ivec3(${g}, ${x}, ${v});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${l}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${m} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let _="max",A=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(A="avgValue / max(count, 1.0)");let R=Math.floor(i/4)*4,F=i%4,P=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${c}, ${u});
      const ivec3 pads = ivec3(${g}, ${x}, ${v});
      const float initializationValue = ${I};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${I});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${l}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${P}
            }

            int xC = xCCorner + ${R};
            if (${F===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${P}
            } else if (${F===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${P}
            } else if (${F===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${P}
            }
          }
        }
        setOutput(${A});
      }
    `}};function _se(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e;Oo(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,u=1;y.assert(S.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let l=S.computePool2DInfo(o.shape,s,i,u,a,c);if(l.filterWidth===1&&l.filterHeight===1&&y.arraysEqual(l.inShape,l.outShape))return yt({inputs:{x:o},backend:t});let p=new Qr(l,"avg",!1);return t.runWebGLProgram(p,[o],"float32")}var lU={kernelName:Za,backendName:"webgl",kernelFunc:_se};T();function Ase(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:c,dataFormat:u}=r,l=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,l,a,c,u),d=new aa(p,"avg",!1);return t.runWebGLProgram(d,[o],"float32")}var pU={kernelName:Qa,backendName:"webgl",kernelFunc:Ase};T();var Xy=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,r=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=c-1-e.padInfo.top,p=u-1-e.padInfo.left,d=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${l}, ${p});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Yy=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,r=e.filterHeight,o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,c=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,p=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=p-1-e.padInfo.front,h=d-1-e.padInfo.top,g=f-1-e.padInfo.left,x=1/(t*r*o);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${h}, ${g});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Rse(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,i=s,{filterSize:a,strides:c,pad:u,dimRoundingMode:l}=r,p=[1,1,1],d=S.computePool3DInfo(i.shape,a,c,p,u,l),f=new Yy(d);return t.runWebGLProgram(f,[o],i.dtype)}var dU={kernelName:xf,backendName:"webgl",kernelFunc:Rse};T();function Fse(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,i=s;Oo([o,s],"avgPoolGrad");let{filterSize:a,strides:c,pad:u}=r,l=S.computePool2DInfo(i.shape,a,c,1,u),p=new Xy(l);return t.runWebGLProgram(p,[o],i.dtype)}var fU={kernelName:gf,backendName:"webgl",kernelFunc:Fse};T();function Ose(n){let{inputs:e,backend:t,attrs:r}=n,{a:o,b:s}=e,{transposeA:i,transposeB:a}=r;return wl({a:o,b:s,transposeA:i,transposeB:a,backend:t})}var mU={kernelName:Ja,backendName:"webgl",kernelFunc:Ose};T();T();var Zy=class{constructor(e,t,r,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(e,t),S.assertAndGetBroadcastShape(e,r);let a="0.0";o!=null&&(S.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let c="1.0";s!=null&&(S.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};T();var Qy=class{constructor(e,t,r,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(e,t),S.assertAndGetBroadcastShape(e,r);let a="vec4(0.0)";o!=null&&(S.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let c="vec4(1.0)";s!=null&&(S.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var Mse=({inputs:n,backend:e,attrs:t})=>{let{x:r,mean:o,variance:s,offset:i,scale:a}=n;y.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=t;c==null&&(c=.001);let u=[r,o,s],l=null;i!=null&&(l=i.shape,u.push(i));let p=null;a!=null&&(p=a.shape,u.push(a));let d=M().getBool("WEBGL_PACK_NORMALIZATION")?new Qy(r.shape,o.shape,s.shape,l,p,c):new Zy(r.shape,o.shape,s.shape,l,p,c);return e.runWebGLProgram(d,u,u[0].dtype)},hU={kernelName:kc,backendName:"webgl",kernelFunc:Mse};T();T();var Jy=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=ve(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let r=$se(this.rank),o,s=e.map((i,a)=>`sourceLoc.${BN[a]} = start[${a}] + coords.${BN[a]};`);o=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${r}));
      }
    `}},BN=["x","y","z","w","u","v"];function $se(n){if(n===1)return"sourceLoc";if(n<=6)return BN.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}var ev=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=ve(this.rank),r=xt("coords",this.rank),o=xt("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((l,p)=>`start[${p}]`).join()});`:e.map((l,p)=>`${o[p]} = ${r[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${c}
        setOutput(result);
      }
    `}};function Pse(n,e,t,r){let o=r.texData.get(n.dataId),s=r.makeTensorInfo(t,n.dtype),i=r.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=t,i.dtype=n.dtype;let a=At.computeFlatOffset(e,y.computeStrides(n.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||n.dataId};let c=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,c+1),s}function Jr(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{begin:s,size:i}=r,[a,c]=At.parseSliceParams(o,s,i);if(At.assertParamsValid(o,a,c),y.sizeFromShape(c)===0)return t.makeTensorInfo(c,o.dtype,[]);if(t.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=t.texData.get(o.dataId),d=s4(p.values,a,c,o.shape,o.dtype);return t.makeTensorInfo(c,o.dtype,d)}let{isPacked:u}=t.texData.get(o.dataId),l=At.isSliceContinous(o.shape,a,c);if(u||!l){let p=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ev(c):new Jy(c),d=[a];return t.runWebGLProgram(p,[o],o.dtype,d)}return t.uploadToGPU(o.dataId),Pse(o,a,c,t)}var gU={kernelName:fu,backendName:"webgl",kernelFunc:Jr};var Lse=n=>{let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockShape:s,crops:i}=r;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((v,w)=>v*w),c=S.getReshaped(o.shape,s,a),u=S.getPermuted(c.length,s.length),l=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),d=S.getSliceSize(l,i,s.length),f=[],m=J({inputs:{x:o},backend:t,attrs:{shape:c}}),h=tt({inputs:{x:m},backend:t,attrs:{perm:u}}),g=J({inputs:{x:h},backend:t,attrs:{shape:l}}),x=Jr({inputs:{x:g},backend:t,attrs:{begin:p,size:d}});return f.push(m),f.push(h),f.push(g),f.forEach(v=>t.disposeIntermediateTensorInfo(v)),x},xU={kernelName:ec,backendName:"webgl",kernelFunc:Lse};T();function Bse(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,weights:s}=e,{size:i}=r,a=t.readSync(o.dataId),c=t.readSync(s.dataId),u=Fy(a,c,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,u)}var yU={kernelName:tc,backendName:"webgl",kernelFunc:Bse};T();var Vse=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Use=`
  return float(int(a.r) & int(b.r));
`;function zse(n){let{inputs:e,backend:t}=n,{a:r,b:o}=e,s=M().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=M().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([r,o])||i===1){let c=t.texData.get(r.dataId).values,u=t.texData.get(o.dataId).values,[l,p]=kV(r.shape,o.shape,c,u,r.dtype),d=t.makeTensorInfo(p,r.dtype),f=t.texData.get(d.dataId);return f.values=l,d}let a;return s?a=new qn(Vse,r.shape,o.shape,!1):a=new Fn(Use,r.shape,o.shape),t.runWebGLProgram(a,[r,o],r.dtype)}var vU={kernelName:qs,backendName:"webgl",kernelFunc:zse};T();function Hse(n){let{inputs:e,backend:t}=n,{s0:r,s1:o}=e,s=t.readSync(r.dataId),i=t.readSync(o.dataId),a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var bU={kernelName:nc,backendName:"webgl",kernelFunc:Hse};T();T();T();var Gse="return float(a != b);",VN=je({opSnippet:Gse,cpuKernelImpl:YV,dtype:"bool"}),CU={kernelName:gi,backendName:"webgl",kernelFunc:VN};T();function Cs(n){let{inputs:e,backend:t}=n,{input:r}=e,o=t.texData.get(r.dataId);return yt({inputs:{x:o.complexTensorInfos.real},backend:t})}var wU={kernelName:ou,backendName:"webgl",kernelFunc:Cs};var Wse="return float(int(x));";function IU(n,e){let t=new Kt(n.shape,Wse),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function UN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return yt({inputs:{x:o},backend:t});let i=ar(o.shape),a=UN({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),c=On({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),c}if(o.dtype==="complex64"){let i=Cs({inputs:{input:o},backend:t}),a=UN({inputs:{x:i},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(i),a}if(!y.hasEncodingLoss(o.dtype,s)){let i=yt({inputs:{x:o},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(t.shouldExecuteOnCPU([o])){let i=t.texData.get(o.dataId).values,[a,c,u]=_V(i,o.shape,o.dtype,s);return t.makeTensorInfo(a,c,u)}if(s==="int32")return IU(o,t);if(s==="bool"){let i=t.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),c=VN({inputs:{a:o,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),c}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var EU={kernelName:jo,backendName:"webgl",kernelFunc:UN};T();var TU="return ceil(x);",jse=pe({opSnippet:TU,packedOpSnippet:TU,cpuKernelImpl:AV}),SU={kernelName:Ks,backendName:"webgl",kernelFunc:jse};T();var tv=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var nv=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function qse(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{clipValueMin:s,clipValueMax:i}=r,a;M().getBool("WEBGL_PACK_CLIP")?a=new nv(o.shape):a=new tv(o.shape);let c=[[s],[i]];return t.runWebGLProgram(a,[o],o.dtype,c)}var NU={kernelName:Xs,backendName:"webgl",kernelFunc:qse};T();var rv=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function DU(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Kse(n){let{inputs:e,backend:t}=n,{x:r}=e,o=t.texData.get(r.dataId),s=new rv(r.shape),i=[DU(r,o.complexTensorInfos.real),DU(r,o.complexTensorInfos.imag)];return t.runWebGLProgram(s,i,i[0].dtype)}var kU={kernelName:oc,backendName:"webgl",kernelFunc:Kse};T();T();T();var ov=class{constructor(e){this.outputShape=[],this.outputShape=S.computeOutShape(e,1),this.variableNames=e.map((i,a)=>`T${a}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];let r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){let a=t[i-1];r.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=t.length,s=t[t.length-1];r.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};T();var iv=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=S.computeOutShape(e,t);let r=this.outputShape,o=r.length,s=ve(o),i=xt("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((h,g)=>`T${g}`);let c=new Array(e.length-1);c[0]=e[0][t];for(let h=1;h<c.length;h++)c[h]=c[h-1]+e[h][t];let u=a[t],l=a.slice(-2),p=a.join(),d=`if (${u} < ${c[0]}) {
        return getChannel(
            getT0(${p}), vec2(${l.join()}));
        }`;for(let h=1;h<c.length;h++){let g=c[h-1];d+=`
        if (${u} < ${c[h]}  && ${u} >= ${c[h-1]}) {
          return getChannel(
            getT${h}(${sv(a,u,g)}),
            vec2(${sv(l,u,g)}));
        }`}let f=c.length,m=c[c.length-1];d+=`
        return getChannel(
          getT${f}(${sv(a,u,m)}),
          vec2(${sv(l,u,m)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${r[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${r[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${r[o-2]} &&
            ${i[o-1]} < ${r[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function sv(n,e,t){let r=n.indexOf(e);return n.map((s,i)=>i===r?`${s} - ${t}`:s).join()}T();function Il(n){let{inputs:e,backend:t}=n,{input:r}=e,o=t.texData.get(r.dataId);return yt({inputs:{x:o.complexTensorInfos.imag},backend:t})}var _U={kernelName:Fc,backendName:"webgl",kernelFunc:Il};function cd(n,e,t){let r=n[0].dtype;if(r==="complex64"){let f=n.map(v=>Cs({inputs:{input:v},backend:t})),m=n.map(v=>Il({inputs:{input:v},backend:t})),h=cd(f,e,t),g=cd(m,e,t),x=On({inputs:{real:h,imag:g},backend:t});return f.forEach(v=>t.disposeIntermediateTensorInfo(v)),m.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),x}let o=t.shouldExecuteOnCPU(n);if(r==="string"&&(o=!0),o){let f=n.map(I=>{let A=[-1,y.sizeFromShape(I.shape.slice(e))];return J({inputs:{x:I},backend:t,attrs:{shape:A}})}),m=f.map(I=>({vals:t.readSync(I.dataId),shape:I.shape})),h=S.computeOutShape(f.map(I=>I.shape),1),g=f[0].shape[0]===1,x=RV(m,h,r,g),v=S.computeOutShape(n.map(I=>I.shape),e),w=t.makeTensorInfo(v,r,x);return f.forEach(I=>t.disposeIntermediateTensorInfo(I)),w}let s=n.filter(f=>y.sizeFromShape(f.shape)>0),i=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let f=i?new Kt(n[0].shape,Mo):new Rn(n[0].shape,Mo);return t.runWebGLProgram(f,n,r)}let a=M().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){let f=[];for(let h=0;h<s.length;h+=a){let g=s.slice(h,h+a);f.push(cd(g,e,t))}let m=cd(f,e,t);for(let h of f)t.disposeIntermediateTensorInfo(h);return m}if(i){let f=new iv(s.map(m=>m.shape),e);return t.runWebGLProgram(f,s,r)}let{tensors2D:c,outShape:u}=Xse(s,e,t),l=new ov(c.map(f=>f.shape)),p=t.runWebGLProgram(l,c,r);c.forEach(f=>t.disposeIntermediateTensorInfo(f));let d=J({inputs:{x:p},attrs:{shape:u},backend:t});return t.disposeIntermediateTensorInfo(p),d}function Xse(n,e,t){let r=S.computeOutShape(n.map(s=>s.shape),e);return{tensors2D:n.map(s=>J({inputs:{x:s},attrs:{shape:[-1,y.sizeFromShape(s.shape.slice(e))]},backend:t})),outShape:r}}function zN(n){let{inputs:e,backend:t,attrs:r}=n,{axis:o}=r,s=y.parseAxisParam(o,e[0].shape)[0],i=e.map(u=>u.shape);S.assertParamsConsistent(i,s);let a=S.computeOutShape(e.map(u=>u.shape),s);if(y.sizeFromShape(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);let c=e.filter(u=>y.sizeFromShape(u.shape)>0);return c.length===1?yt({inputs:{x:c[0]},backend:t}):cd(c,s,t)}var AU={kernelName:sc,backendName:"webgl",kernelFunc:zN};T();var ud=class{constructor(e,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let i=e.padInfo.top,a=e.padInfo.left,c=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,p=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,m=Math.floor(e.inChannels/4)*4,h=e.inChannels%4,g=e.dataFormat==="channelsLast",x=g?1:2,v=g?2:3,w=g?3:1,I="",_="";r&&(o?I=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?I=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:I=`
          float activation(float x) {
            ${r}
          }
        `,_="result = activation(result);");let A=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${I}

      const ivec2 strides = ivec2(${c}, ${u});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${v}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${l};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${A}
        ${_}
        setOutput(result);
      }
    `}},av=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,r=e.padInfo.top,o=e.padInfo.left,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,c=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,p=e.filterDepth,d=e.filterHeight,f=e.filterWidth,m=Math.floor(e.inChannels/4)*4,h=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${t}, ${r}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${l};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};T();var ld=class{constructor(e,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qe(this.outputShape.length);let i=e.padInfo.left,a=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,l=e.filterWidth,p=l,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<l;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<l;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(p+1)/2;g++){let x=g*2;if(d+=`
           xC = xCCorner + ${x*c};
           `,a===1){if(x<l&&(i%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,c===1&&x>0?d+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<l)){let v=i%2===0?y.nearestLargerEven(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${v};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,c>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:d+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):v===1?d+=`
                     xC${x+1} = xTexelC${x};
                     `:d+=`
                     xCOffset = xC + ${v};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<l&&(i%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<l&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<l&&(d+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<l&&(d+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<l&&(d+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let f="",m="";r&&(o?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:s?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:f=`vec4 activation(vec4 x) {
           ${r}
         }`,m="result = activation(result);");let h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${h}
         ${m}
         setOutput(result);
       }
     `}};T();var cv=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=qe(this.outputShape.length);let{dataFormat:r}=t,o=lt(),s=r==="channelsLast",i=s?1:2,a=s?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,u="";for(let l=0;l<=1;l++)for(let p=0;p<=1;p++)u+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${l};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${l*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${l*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${o.output} = result;
      }
    `}};function uv(n,e){let t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function lv({x:n,filter:e,convInfo:t,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let c=n.shape,u=r.texData.get(n.dataId),l=t.inChannels,p=c[0]*c[1]*c[2],d=t.outChannels,f=t.dataFormat==="channelsLast",m=!1,h=!1,g,x=[];if(s!=null){let I=uv(s.shape,f);I!=null&&(s=J({inputs:{x:s},backend:r,attrs:{shape:I}}),x.push(s))}if(o!=null){let I=uv(o.shape,f);I!=null&&(o=J({inputs:{x:o},backend:r,attrs:{shape:I}}),x.push(o))}if(!((p===1||d===1)&&l>LN)&&u.isPacked&&f&&u.texture!=null&&c[2]%2!==0&&y.arraysEqual(u.shape.slice(-3),c.slice(-3))){let I=c[0]*c[1]*(c[2]+1),_={dataId:n.dataId,shape:[1,I,t.inChannels],dtype:n.dtype},A=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,y.assert(xl(u.shape,_.shape),()=>`packed reshape ${u.shape} to ${_.shape} isn't free`);let R=J({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});x.push(R);let F=wl({a:_,b:R,backend:r,transposeA:m,transposeB:h,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),P=r.texData.get(F.dataId);y.assert(P.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=A,P.shape=t.outShape,g=yt({inputs:{x:F},backend:r}),g.shape=t.outShape,x.push(F)}else{let I=t.outHeight*t.outWidth,_=J({inputs:{x:n},backend:r,attrs:{shape:f?[t.batchSize,I,t.inChannels]:[t.batchSize,t.inChannels,I]}}),A=J({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),R=wl({a:f?_:A,b:f?A:_,transposeA:!f,transposeB:h,backend:r,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});g=J({inputs:{x:R},backend:r,attrs:{shape:t.outShape}}),x.push(_),x.push(A),x.push(R)}for(let I of x)r.disposeIntermediateTensorInfo(I);return g}function pv({x:n,filter:e,convInfo:t,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:c,filterHeight:u,inChannels:l,outWidth:p,outHeight:d,dataFormat:f}=t,m=f==="channelsLast",h=c*u*l,g=d*p,x=[t.batchSize,h,g],v=!0,w=!1,I=[];if(s!=null){let K=uv(s.shape,m);K!=null&&(s=J({inputs:{x:s},backend:r,attrs:{shape:K}}),I.push(s))}if(o!=null){let K=uv(o.shape,m);K!=null&&(o=J({inputs:{x:o},backend:r,attrs:{shape:K}}),I.push(o))}let _=J({inputs:{x:e},backend:r,attrs:{shape:[1,h,y.sizeFromShape(e.shape)/h]}});I.push(_);let A=new cv(x,t),R=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],F=r.runWebGLProgram(A,[n],"float32",R),P=J({inputs:{x:F},backend:r,attrs:{shape:x}});I.push(F),I.push(P);let L=o!=null,V=s!=null,z=a==="leakyrelu",H=a?bs(a,!0):null,j=new ad(m?P.shape:_.shape,m?_.shape:P.shape,m?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],v,w,L,H,V,z),W=m?[P,_]:[_,P];if(o&&W.push(o),V&&W.push(s),z){let K=r.makeTensorInfo([],"float32",y.createScalarValue(i,"float32"));W.push(K),I.push(K)}let Y=r.runWebGLProgram(j,W,"float32"),Z=J({inputs:{x:Y},backend:r,attrs:{shape:t.outShape}});I.push(Y);for(let K of I)r.disposeIntermediateTensorInfo(K);return Z}function Yse(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dataFormat:c,dilations:u,dimRoundingMode:l}=r,p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,s.shape,i,u,a,l,!1,p),f;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))f=lv({x:o,filter:s,convInfo:d,backend:t});else if(d.strideWidth<=2&&p==="channelsLast"&&M().getBool("WEBGL_EXP_CONV")){let h=new ld(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];f=t.runWebGLProgram(h,[o,s],"float32",g)}else if(M().getBool("WEBGL_CONV_IM2COL"))f=pv({x:o,filter:s,convInfo:d,backend:t});else{let h=new ud(d);f=t.runWebGLProgram(h,[o,s],"float32")}let m=J({inputs:{x:f},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(f),m}var RU={kernelName:ic,backendName:"webgl",kernelFunc:Yse};T();var dv=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,r=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},fv=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,r=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,c=r-1-e.padInfo.left,u=i?1:2,l=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},mv=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,r=e.strideHeight,o=e.strideWidth,s=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},hv=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,r=e.filterHeight,o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,c=t-1-e.padInfo.front,u=r-1-e.padInfo.top,l=o-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${u}, ${l});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Zse(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,pad:a,dataFormat:c,dimRoundingMode:u,filterShape:l}=r,p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,l,i,1,a,u,!1,p),f=new dv(d);return t.runWebGLProgram(f,[o,s],"float32")}var FU={kernelName:ac,backendName:"webgl",kernelFunc:Zse};T();var gv=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=qe(this.outputShape.length);let t=e.filterHeight,r=e.filterWidth,o=t-1-e.padInfo.top,s=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function Qse(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{inputShape:i,strides:a,pad:c,dataFormat:u,dimRoundingMode:l}=r,p=S.convertConv2DDataFormat(u),d=S.computeConv2DInfo(i,s.shape,a,1,c,l,!1,p);if(M().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){let f=[[d.strideHeight,d.strideWidth]],m=new gv(d);return t.runWebGLProgram(m,[o,s],"float32",f)}else{let f=new fv(d);return t.runWebGLProgram(f,[o,s],"float32")}}var OU={kernelName:cc,backendName:"webgl",kernelFunc:Qse};T();function Jse(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dilations:c}=r,u=S.computeConv3DInfo(o.shape,s.shape,i,c,a),l=new av(u);return t.runWebGLProgram(l,[o,s],"float32")}var MU={kernelName:uc,backendName:"webgl",kernelFunc:Jse};T();function eie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,pad:a,filterShape:c}=r,u=S.computeConv3DInfo(o.shape,c,i,1,a),l=new mv(u);return t.runWebGLProgram(l,[o,s],"float32")}var $U={kernelName:yf,backendName:"webgl",kernelFunc:eie};T();function tie(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{pad:i,strides:a,inputShape:c}=r,u=S.computeConv3DInfo(c,s.shape,a,1,i),l=new hv(u);return t.runWebGLProgram(l,[o,s],"float32")}var PU={kernelName:lc,backendName:"webgl",kernelFunc:tie};T();var nie=Tr+`
  return cos(x);
`,rie=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Kn}
  return result;
`,oie=pe({opSnippet:nie,packedOpSnippet:rie}),LU={kernelName:"Cos",backendName:"webgl",kernelFunc:oie};T();var sie=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,iie=pe({opSnippet:sie}),BU={kernelName:Ys,backendName:"webgl",kernelFunc:iie};T();var xv=class{constructor(e,t,r,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,c,u]=e,[l]=t,[p,d]=r;this.outputShape=[l,p,d,u];let f=o==="bilinear"?1:0,[m,h]=[`${a-1}.0`,`${c-1}.0`],[g,x,v]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[w,I,_]=d>1?[`${(c-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${I};

        float in_y = ${v};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${_};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var aie=n=>{let{inputs:e,backend:t,attrs:r}=n,{image:o,boxes:s,boxInd:i}=e,{cropSize:a,method:c,extrapolationValue:u}=r,l=new xv(o.shape,s.shape,a,c,u);return t.runWebGLProgram(l,[o,s,i],"float32")},VU={kernelName:mc,backendName:"webgl",kernelFunc:aie};T();var pd=(function(n){return n.Prod="*",n.Sum="+",n})(pd||{}),eh=class{constructor(e,t,r,o){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,i=this.op===pd.Prod?"1.0":"0.0",a=r?i:`getX(${UU(s,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1],u="",l="";r?(u=o?`end != ${c-1}`:"end != 0",l=o?"end + 1":"end - 1"):(u=o?`end + pow2 < ${c}`:"end >= pow2",l=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ve(s)} coords = getOutputCoords();
        int end = ${zU(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${l};
          ${zU(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${UU(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function UU(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function zU(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}T();function yv(n,e,t,r,o,s){let i=e.shape.length,a=S.getAxesPermutation([r],i),c=e;a!=null&&(c=tt({inputs:{x:e},backend:t,attrs:{perm:a}}));let u=S.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);let l=c.shape[u],p=yt({inputs:{x:c},backend:t});for(let d=0;d<=Math.ceil(Math.log2(l))-1;d++){let f=new eh(n,c.shape,!1,s),m=[[d]],h=p;p=t.runWebGLProgram(f,[p],p.dtype,m),t.disposeIntermediateTensorInfo(h)}if(o){let d=new eh(n,c.shape,o,s),f=p;p=t.runWebGLProgram(d,[p],p.dtype),t.disposeIntermediateTensorInfo(f)}if(a!=null){let d=S.getUndoAxesPermutation(a),f=tt({inputs:{x:p},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(c),f}return p}function cie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,exclusive:i,reverse:a}=r;return yv(pd.Prod,o,t,s,i,a)}var HU={kernelName:dc,backendName:"webgl",kernelFunc:cie};T();function uie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,exclusive:i,reverse:a}=r;return yv(pd.Sum,o,t,s,i,a)}var GU={kernelName:fc,backendName:"webgl",kernelFunc:uie};T();function lie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,weights:s}=e,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let c=t.readSync(o.dataId),u=t.readSync(s.dataId),l=Fy(c,u,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,l)}else if(o.shape.length===2){let c=t.bufferSync(o),u=t.bufferSync(s),l=DV(c,u,i,a);return t.makeTensorInfo(l.shape,s.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var WU={kernelName:hc,backendName:"webgl",kernelFunc:lie};T();var vv=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function pie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockSize:s,dataFormat:i}=r,a=o.shape[0],c=i==="NHWC"?o.shape[1]:o.shape[2],u=i==="NHWC"?o.shape[2]:o.shape[3],l=i==="NHWC"?o.shape[3]:o.shape[1],p=c*s,d=u*s,f=l/(s*s),m=i==="NHWC"?[a,p,d,f]:[a,f,p,d],h=new vv(m,s,i);return t.runWebGLProgram(h,[o],o.dtype)}var jU={kernelName:gc,backendName:"webgl",kernelFunc:pie};T();var dd=class{constructor(e,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qe(this.outputShape.length);let i=e.filterHeight,a=e.filterWidth,c=e.outChannels/e.inChannels,u="",l="";r&&(o?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:u=`
          float activation(float x) {
            ${r}
          }
        `,l="result = activation(result);");let p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${l}
        setOutput(result);
      }
    `}};T();var fd=class{constructor(e,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qe(this.outputShape.length);let i=e.outChannels/e.inChannels,a=e.padInfo.left,c=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,p=e.filterWidth,d=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<p;x++)f+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;f+=`
    for (int r = 0; r < ${l}; r++) {
      `;for(let x=0;x<p;x++)f+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(d+1)/2;x++){let v=x*2;if(f+=`
          xC = xCCorner + ${v*u};
          `,c===1){if(v<p&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }
              `,u===1&&v>0?f+=`
                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                  } else {
                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xC${v} = xTexelC${v};
                `,v+1<p)){let w=a%2===0?y.nearestLargerEven(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${v+1}.zw = vec2(0.0);
                    }
                    xTexelC${v+1}Ready = 1;
                  }
                  `,u>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                    } else {
                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                    }
                    `:f+=`
                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                    `):w===1?f+=`
                    xC${v+1} = xTexelC${v};
                    `:f+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${v+1}.zw = vec2(0.0);
                      }
                      xTexelC${v+1}Ready = 1;
                    }

                    xC${v+1} = xTexelC${v+1};
                    `}}else v<p&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.0);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
              `,v+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(
                  xTexelC${v}.xy, xTexelC${v+1}.xy);
              `,v+1<p&&(f+=`
                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                `)));v<p&&(f+=`
            wTexel = getW(r, ${v}, d1, q);
            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);
          `,v+1<p&&(f+=`
              wTexel = getW(r, ${v+1}, d1, q);
              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let m="",h="";r&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:m=`vec4 activation(vec4 x) {
          ${r}
        }`,h="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function die(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dilations:c,dimRoundingMode:u}=r,l=c;l==null&&(l=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let p=S.computeConv2DInfo(o.shape,s.shape,i,l,a,u,!0),d;M().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?d=new fd(p):d=new dd(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return t.runWebGLProgram(d,[o,s],"float32",f)}var qU={kernelName:xc,backendName:"webgl",kernelFunc:die};T();var bv=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,r=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Cv=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,r=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.top,a=r-1-e.padInfo.left,c=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function fie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,dilations:a,pad:c,dimRoundingMode:u,filterShape:l}=r,p=S.computeConv2DInfo(o.shape,l,i,a,c,u,!0),d=new bv(p);return t.runWebGLProgram(d,[o,s],"float32")}var KU={kernelName:yc,backendName:"webgl",kernelFunc:fie};T();function mie(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{strides:i,dilations:a,pad:c,dimRoundingMode:u,inputShape:l}=r,p=S.computeConv2DInfo(l,s.shape,i,a,c,u,!0),d=new Cv(p);return t.runWebGLProgram(d,[o,s],"float32")}var XU={kernelName:vc,backendName:"webgl",kernelFunc:mie};T();var wv=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function hie(n){let{inputs:e,backend:t}=n,{x:r}=e,o=[...r.shape,...r.shape],s=y.sizeFromShape(r.shape),i=J({inputs:{x:r},backend:t,attrs:{shape:[s]}}),a=new wv(s),c=t.runWebGLProgram(a,[i],i.dtype),u=J({inputs:{x:c},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),u}var YU={kernelName:bc,backendName:"webgl",kernelFunc:hie};T();var Iv=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:r,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:c,dilationHeight:u,dilationWidth:l}=e,{top:p,left:d}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${l};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function gie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dilations:c}=r,u=S.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",c),l,p=new Iv(u);l=t.runWebGLProgram(p,[o,s],"float32");let d=J({inputs:{x:l},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(l),d}var ZU={kernelName:Cc,backendName:"webgl",kernelFunc:gie};T();function xie(n){let{inputs:e,backend:t,attrs:r}=n,{equation:o}=r,s=e,{allDims:i,summedDims:a,idDims:c}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,c,s);let{path:u,steps:l}=S.getEinsumComputePath(a,c),p=l.length,d=null,f=i.length,m=[];for(let h=0;h<p;++h){for(let g of l[h]){let{permutationIndices:x,expandDims:v}=S.getEinsumPermutation(f,c[g]),w;S.isIdentityPermutation(x)?w=s[g]:(w=tt({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),m.push(w));let I=w.shape.slice();for(let _=0;_<v.length;++_)I.splice(v[_],0,1);y.arraysEqual(w.shape,I)||(w=J({inputs:{x:w},backend:t,attrs:{shape:I}}),m.push(w)),d===null?d=w:(d=Qm({inputs:{a:w,b:d},backend:t}),m.push(d))}h<p-1&&(u[h]>=0&&(d=Cl({inputs:{x:d},backend:t,attrs:{axis:u[h]-(i.length-f),keepDims:!1}}),m.push(d)),f--)}for(let h of m)h!==d&&t.disposeIntermediateTensorInfo(h);return d}var QU={kernelName:wc,backendName:"webgl",kernelFunc:xie};T();var yie="return (x >= 0.0) ? x : (exp(x) - 1.0);",vie=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,bie=pe({opSnippet:yie,packedOpSnippet:vie}),JU={kernelName:"Elu",backendName:"webgl",kernelFunc:bie};T();var Cie="return (b >= 0.0) ? a : a * (b + 1.0);",wie=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Iie=n=>{let{inputs:e,backend:t}=n,{dy:r,y:o}=e,s=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new qn(wie,r.shape,o.shape):new Fn(Cie,r.shape,o.shape);return t.runWebGLProgram(s,[r,o],r.dtype)},ez={kernelName:vf,backendName:"webgl",kernelFunc:Iie};T();var Eie=`
  return vec4(equal(a, b));
`,Tie="return float(a == b);",Sie=je({opSnippet:Tie,packedOpSnippet:Eie,dtype:"bool",cpuKernelImpl:FV}),tz={kernelName:Qs,backendName:"webgl",kernelFunc:Sie};T();var Nie=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${S.ERF_P};
  float a1 = ${S.ERF_A1};
  float a2 = ${S.ERF_A2};
  float a3 = ${S.ERF_A3};
  float a4 = ${S.ERF_A4};
  float a5 = ${S.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Die=pe({opSnippet:Nie}),nz={kernelName:"Erf",backendName:"webgl",kernelFunc:Die};T();var kie=Tr+`
  return exp(x);
`,_ie=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,HN=pe({opSnippet:kie,packedOpSnippet:_ie,cpuKernelImpl:OV,dtype:"float32"}),rz={kernelName:"Exp",backendName:"webgl",kernelFunc:HN};T();function Ev(n){let{inputs:e,attrs:t,backend:r}=n,{dim:o}=t,{input:s}=e,i=s.shape.length,a=s.shape.slice(),c=o;return o<0&&(y.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),c=i+o+1),a.splice(c,0,1),J({inputs:{x:s},backend:r,attrs:{shape:a}})}var oz={kernelName:Sc,backendName:"webgl",kernelFunc:Ev};T();var sz="return exp(x) - 1.0;",Aie=pe({opSnippet:sz,packedOpSnippet:sz,cpuKernelImpl:MV}),iz={kernelName:Js,backendName:"webgl",kernelFunc:Aie};T();T();var th=class{constructor(e,t,r){this.variableNames=["real","imag"];let o=t[1];this.outputShape=t;let s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${o}.0`:"1.0",a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function Tv(n,e,t){let r=t.texData.get(n.dataId),o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=J({inputs:{x:n},backend:t,attrs:{shape:[i,s]}}),c=a.shape,u=new th("real",c,e),l=new th("imag",c,e),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],d=t.runWebGLProgram(u,p,"float32"),f=t.runWebGLProgram(l,p,"float32"),m=On({inputs:{real:d,imag:f},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f);let h=J({inputs:{x:m},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(m),h}function Rie(n){let{inputs:e,backend:t}=n,{input:r}=e;return Tv(r,!1,t)}var az={kernelName:"FFT",backendName:"webgl",kernelFunc:Rie};T();var Sv=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function ws(n){let{backend:e,attrs:t}=n,{shape:r,value:o}=t,{dtype:s}=t;if(s=s||y.inferDtype(o),s==="string"){let i=y.getArrayFromDType(s,y.sizeFromShape(r));return i.fill(o),e.makeTensorInfo(r,s,i)}else{let i=new Sv(r,o),a=[[o]];return e.runWebGLProgram(i,[],s,a)}}var cz={kernelName:Nc,backendName:"webgl",kernelFunc:ws};T();var Nv=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var uz={kernelName:Dc,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{let{image:t}=n,r=e,o=new Nv(t.shape);return r.runWebGLProgram(o,[t],t.dtype)}};T();var lz="return floor(x);",Fie=pe({opSnippet:lz,packedOpSnippet:lz,cpuKernelImpl:$V}),pz={kernelName:ei,backendName:"webgl",kernelFunc:Fie};T();var Oie=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Mie=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,$ie=je({opSnippet:Oie,packedOpSnippet:Mie,dtype:"int32"}),dz={kernelName:ti,backendName:"webgl",kernelFunc:$ie};T();T();var Dv=class{constructor(e){this.variableNames=["A"];let t=lt(),[r,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var kv=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=lt(),[r,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};var fz={kernelName:fp,backendName:"webgl",kernelFunc:Pie},md,GN=M().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Pie(n){let{inputs:e,backend:t,attrs:r}=n,{pixels:o}=e,{numChannels:s}=r,i=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[c,u]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],l=[u,c],p=[u,c,s];if(a||i){let h=M().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(md==null||h!==GN)&&(GN=h,md=document.createElement("canvas").getContext("2d",{willReadFrequently:GN})),md.canvas.width=c,md.canvas.height=u,md.drawImage(o,0,0,c,u),o=md.canvas}let d=t.makeTensorInfo(l,"int32");t.texData.get(d.dataId).usage=fn.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),o);let f=M().getBool("WEBGL_PACK")?new kv(p):new Dv(p),m=t.runWebGLProgram(f,[d],"int32");return t.disposeData(d.dataId),m}T();function Lie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:c,pad:u,dataFormat:l,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,h=S.convertConv2DDataFormat(l),g=S.computeConv2DInfo(o.shape,s.shape,c,p,u,d,!1,h),x,v=[],w=i!=null,I=a!=null,_=f==="leakyrelu",A=()=>{let F=[o,s],P=(L,V)=>{if(V==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){let z=J({inputs:{x:L},backend:t,attrs:{shape:[L.shape[0],1,1]}});return v.push(z),z}return L};if(w&&F.push(P(i,l)),I&&F.push(P(a,l)),_){let L=t.makeTensorInfo([],"float32",y.createScalarValue(m,"float32"));F.push(L),v.push(L)}return F};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))x=lv({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:m});else if(g.strideWidth<=2&&h==="channelsLast"&&M().getBool("WEBGL_EXP_CONV")){let F=f?bs(f,!0):null,P=new ld(g,w,F,I,_),L=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],V=A();x=t.runWebGLProgram(P,V,"float32",L)}else if(M().getBool("WEBGL_CONV_IM2COL"))x=pv({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:m});else{let F=f?bs(f,!1):null,P=new ud(g,w,F,I,_),L=A();x=t.runWebGLProgram(P,L,"float32")}let R=J({inputs:{x},backend:t,attrs:{shape:g.outShape}});return v.push(x),v.forEach(F=>t.disposeIntermediateTensorInfo(F)),R}var mz={kernelName:Fi,backendName:"webgl",kernelFunc:Lie};T();function Bie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:c,pad:u,dilations:l,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r,m=[],h=l;h==null&&(h=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(c,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${h}'`);let g=S.computeConv2DInfo(o.shape,s.shape,c,h,u,p,!0),x=M().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,v=d?bs(d,x):null,w=[o,s],I=i!=null,_=a!=null,A=d==="leakyrelu";if(I&&w.push(i),_&&w.push(a),A){let L=t.makeTensorInfo([],"float32",y.createScalarValue(f,"float32"));w.push(L),m.push(L)}let R;x?R=new fd(g,I,v,_,A):R=new dd(g,I,v,_,A);let F=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],P=t.runWebGLProgram(R,w,"float32",F);return m.forEach(L=>t.disposeIntermediateTensorInfo(L)),P}var hz={kernelName:Oi,backendName:"webgl",kernelFunc:Bie};T();var _v=class{constructor(e,t,r,o){this.sliceDim=e,this.strides=t,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=r;let s=ve(r.length),i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function Vie(n){let{inputs:e,backend:t}=n,{params:r,indices:o}=e,s=o.shape,i=s[s.length-1],a=y.sizeFromShape(r.shape),[c,u,l,p]=S.prepareAndValidate(r,o),d=J({inputs:{x:o},backend:t,attrs:{shape:[u,i]}}),f=J({inputs:{x:r},backend:t,attrs:{shape:[y.sizeFromShape(r.shape)/l,l]}});if(t.shouldExecuteOnCPU([r,o])||r.dtype==="string"){let x=t.readSync(o.dataId),v=t.bufferSync(r),w=PV(x,v,r.dtype,u,i,l,p,r.shape,a);return t.makeTensorInfo(c,r.dtype,w.values)}let m=new _v(i,p,[u,l],r.shape),h=t.runWebGLProgram(m,[f,d],f.dtype),g=J({inputs:{x:h},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var gz={kernelName:Ac,backendName:"webgl",kernelFunc:Vie};T();var Av=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let r=ve(this.rank),o=Uie(e,2);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function Uie(n,e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let o=0;o<n.length;o++)o===2?r.push("index"):r.push(`${t[o]}`);return r.join()}function WN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,indices:s}=e,{axis:i,batchDims:a}=r,c=y.parseAxisParam(i,o.shape)[0];if(M().get("DEBUG")){let v=t.readSync(s.dataId),w=o.shape[c];for(let I=0;I<v.length;++I){let _=v[I];y.assert(_<=w-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${w-1}]`)}}let u=S.segment_util.collectGatherOpShapeInfo(o,s,c,a),l=y.sizeFromShape(s.shape),p=[],d=J({inputs:{x:o},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=J({inputs:{x:s},backend:t,attrs:{shape:[u.batchSize,l/u.batchSize]}});p.push(d),p.push(f);let m=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let v=t.bufferSync(f),w=t.bufferSync(d),I=LV(w,v,m);return p.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.makeTensorInfo(u.outputShape,I.dtype,I.values)}let h=new Av(d.shape,m),g=t.runWebGLProgram(h,[d,f],d.dtype);p.push(g);let x=J({inputs:{x:g},backend:t,attrs:{shape:u.outputShape}});return p.forEach(v=>t.disposeIntermediateTensorInfo(v)),x}var xz={kernelName:_c,backendName:"webgl",kernelFunc:WN};T();var zie="return float(a > b);",Hie=`
  return vec4(greaterThan(a, b));
`,Gie=je({opSnippet:zie,packedOpSnippet:Hie,cpuKernelImpl:BV,dtype:"bool"}),yz={kernelName:ni,backendName:"webgl",kernelFunc:Gie};T();var Wie="return float(a >= b);",jie=`
  return vec4(greaterThanEqual(a, b));
`,qie=je({opSnippet:Wie,packedOpSnippet:jie,dtype:"bool",cpuKernelImpl:VV}),vz={kernelName:ri,backendName:"webgl",kernelFunc:qie};T();function Kie(n){let{inputs:e,backend:t}=n,{input:r}=e;return Tv(r,!0,t)}var bz={kernelName:Rc,backendName:"webgl",kernelFunc:Kie};T();var Xie="return float(!isnan(x) && !isinf(x));",Yie=pe({opSnippet:Xie,dtype:"bool"}),Cz={kernelName:oi,backendName:"webgl",kernelFunc:Yie};T();var Zie="return float(isinf(x));",Qie=pe({opSnippet:Zie,dtype:"bool"}),wz={kernelName:si,backendName:"webgl",kernelFunc:Qie};T();var Jie="return float(isnan(x));",eae=pe({opSnippet:Jie,dtype:"bool"}),Iz={kernelName:ii,backendName:"webgl",kernelFunc:eae};T();var tae="return float(a < b);",nae=`
  return vec4(lessThan(a, b));
`,rae=je({opSnippet:tae,packedOpSnippet:nae,cpuKernelImpl:UV,dtype:"bool"}),Ez={kernelName:ai,backendName:"webgl",kernelFunc:rae};T();var oae="return float(a <= b);",sae=`
  return vec4(lessThanEqual(a, b));
`,iae=je({opSnippet:oae,packedOpSnippet:sae,cpuKernelImpl:zV,dtype:"bool"}),Tz={kernelName:ci,backendName:"webgl",kernelFunc:iae};T();function aae(n){let{backend:e,attrs:t}=n,{start:r,stop:o,num:s}=t,i=HV(r,o,s);return e.makeTensorInfo([i.length],"float32",i)}var Sz={kernelName:Mc,backendName:"webgl",kernelFunc:aae};T();var cae=Tr+`
  return x < 0.0 ? 0./0. : log(x);
`,uae=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,lae=pe({opSnippet:cae,packedOpSnippet:uae,cpuKernelImpl:GV}),Nz={kernelName:"Log",backendName:"webgl",kernelFunc:lae};T();var pae=Tr+`
  return log(1.0 + x);
`,dae=pe({opSnippet:pae}),Dz={kernelName:ui,backendName:"webgl",kernelFunc:dae};T();var fae="return float(a >= 1.0 && b >= 1.0);",mae=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,hae=je({opSnippet:fae,packedOpSnippet:mae,dtype:"bool"}),kz={kernelName:li,backendName:"webgl",kernelFunc:hae};T();var gae="return float(!(x >= 1.0));",xae=pe({opSnippet:gae}),_z={kernelName:pi,backendName:"webgl",kernelFunc:xae};T();var yae="return float(a >= 1.0 || b >= 1.0);",vae=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,bae=je({opSnippet:yae,packedOpSnippet:vae,dtype:"bool"}),Az={kernelName:di,backendName:"webgl",kernelFunc:bae};T();var Rv=class{constructor(e,t,r,o,s){this.variableNames=["x"],this.outputShape=[];let i=t,a=e[3]-1;this.outputShape=e;let c,u=`float(${r}) + float(${o}) * sum`;s===.5?c=`inversesqrt(${u})`:s===1?c=`1.0/(${u})`:c=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}};var Fv=class{constructor(e,t,r,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=t,a=e[3]-1;this.outputShape=e;let c,u=`float(${r}) + float(${o}) * sum`;s===.5?c=`inversesqrt(${u})`:s===1?c=`1.0/(${u})`:c=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}};var Cae=n=>{let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{depthRadius:s,bias:i,alpha:a,beta:c}=r,u=M().getBool("WEBGL_PACK_NORMALIZATION")?new Fv(o.shape,s,i,a,c):new Rv(o.shape,s,i,a,c);return t.runWebGLProgram(u,[o],o.dtype)},Rz={kernelName:"LRN",backendName:"webgl",kernelFunc:Cae};T();var Ov=class{constructor(e,t,r,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var wae=n=>{let{inputs:e,backend:t,attrs:r}=n,{x:o,y:s,dy:i}=e,{depthRadius:a,bias:c,alpha:u,beta:l}=r,p=new Ov(o.shape,a,c,u,l);return t.runWebGLProgram(p,[o,s,i],o.dtype)},Fz={kernelName:bf,backendName:"webgl",kernelFunc:wae};T();T();T();function Oz(n,e,t,r){let o=y.sizeFromShape(e),i=y.sizeFromShape(n.shape)/o,a=J({inputs:{x:n},attrs:{shape:[i,o]},backend:r}),c=Xn(a,n.dtype,"max",r),u=J({inputs:{x:c},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(c),u}function jN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{reductionIndices:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),u=c,l=S.getAxesPermutation(u,a),p=l!=null,d=t.shouldExecuteOnCPU([o]),f=o;if(p){if(d){let w=t.texData.get(f.dataId).values,I=new Array(a);for(let R=0;R<I.length;R++)I[R]=o.shape[l[R]];let _=bl(w,o.shape,o.dtype,l,I);f=t.makeTensorInfo(I,o.dtype);let A=t.texData.get(f.dataId);A.values=_}else f=ia(o,l,t);u=S.getInnerMostAxes(u.length,a)}S.assertAxesAreInnerMostDims("max",u,a);let[m,h]=S.computeOutAndReduceShapes(f.shape,u),g=m;i&&(g=S.expandShapeToKeepDim(m,c));let x;if(d){let w=t.texData.get(f.dataId).values,I=WV(w,y.sizeFromShape(h),g,o.dtype);x=t.makeTensorInfo(g,o.dtype);let _=t.texData.get(x.dataId);_.values=I}else x=Oz(f,h,g,t);return p&&t.disposeIntermediateTensorInfo(f),x}var Mz={kernelName:"Max",backendName:"webgl",kernelFunc:jN};T();var Iae=id+`
  return max(a, b);
`,Eae=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Kn+`
  return result;
`,Tae=je({opSnippet:Iae,packedOpSnippet:Eae,cpuKernelImpl:jV}),$z={kernelName:fi,backendName:"webgl",kernelFunc:Tae};T();function Sae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e;Oo(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,u=1;y.assert(S.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let l=S.computePool2DInfo(o.shape,s,i,u,a,c);if(l.filterWidth===1&&l.filterHeight===1&&y.arraysEqual(l.inShape,l.outShape))return yt({inputs:{x:o},backend:t});let p=new Qr(l,"max",!1);return t.runWebGLProgram(p,[o],o.dtype)}var Pz={kernelName:Pc,backendName:"webgl",kernelFunc:Sae};T();function Nae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{filterSize:s,strides:i,pad:a,dataFormat:c,dimRoundingMode:u}=r,l=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,l,a,u,c),d=new aa(p,"max",!1);return t.runWebGLProgram(d,[o],o.dtype)}var Lz={kernelName:Lc,backendName:"webgl",kernelFunc:Nae};T();var Mv=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,s=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=s-1-e.padInfo.top,c=i-1-e.padInfo.left,u=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},$v=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,r=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,p=c-1-e.padInfo.front,d=u-1-e.padInfo.top,f=l-1-e.padInfo.left,m=c*u*l-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${l};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${l} +
                  wR * ${l} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Dae(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,i=s,{filterSize:a,strides:c,pad:u,dimRoundingMode:l}=r,p=[1,1,1],d=S.computePool3DInfo(i.shape,a,c,p,u,l),f=new aa(d,"max",!0),m=t.runWebGLProgram(f,[i],i.dtype),h=new $v(d),g=t.runWebGLProgram(h,[o,m],i.dtype);return t.disposeIntermediateTensorInfo(m),g}var Bz={kernelName:wf,backendName:"webgl",kernelFunc:Dae};T();function kae(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s,output:i}=e,a=s;Oo([s,i],"maxPoolGrad");let{filterSize:c,strides:u,pad:l,dimRoundingMode:p}=r,d=S.computePool2DInfo(a.shape,c,u,1,l,p),f=!0,m=new Qr(d,"max",f),h=t.runWebGLProgram(m,[a],a.dtype),g=new Mv(d),x=t.runWebGLProgram(g,[o,h],a.dtype);return t.disposeIntermediateTensorInfo(h),x}var Vz={kernelName:Cf,backendName:"webgl",kernelFunc:kae};T();T();function Uz(n,e,t,r){let o=new Qr(t,"max",!1),s=r.runWebGLProgram(o,[n],"float32");o=new Qr(t,"max",!0,!0,e);let i=r.runWebGLProgram(o,[n],"float32");return[s,i]}var zz={kernelName:Bc,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{x:r}=n,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=e,c=t;y.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];y.assert(S.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let l=S.computePool2DInfo(r.shape,o,s,u,i),[p,d]=Uz(r,a,l,c);return[p,d]}};T();T();function Hz(n,e,t,r){let o=y.sizeFromShape(e),i=y.sizeFromShape(n.shape)/o,a=J({inputs:{x:n},attrs:{shape:[i,o]},backend:r}),c=Xn(a,"float32","mean",r),u=J({inputs:{x:c},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(c),u}var Gz={kernelName:Vc,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{x:r}=n,{keepDims:o,axis:s}=e,i=t,a=r.shape.length,c=y.parseAxisParam(s,r.shape),u=c,l=S.getAxesPermutation(u,a),p=l!=null,d=i.shouldExecuteOnCPU([r]),f=[],m=r;if(p){if(d){let I=i.texData.get(m.dataId).values,_=new Array(a);for(let F=0;F<_.length;F++)_[F]=r.shape[l[F]];let A=bl(I,r.shape,r.dtype,l,_);m=i.makeTensorInfo(_,r.dtype);let R=i.texData.get(m.dataId);R.values=A}else m=ia(r,l,i);f.push(m),u=S.getInnerMostAxes(u.length,a)}S.assertAxesAreInnerMostDims("sum",u,a);let[h,g]=S.computeOutAndReduceShapes(m.shape,u),x=h;o&&(x=S.expandShapeToKeepDim(h,c));let v=Hz(m,g,x,i);for(let w of f)i.disposeIntermediateTensorInfo(w);return v}};T();function _ae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),u=c,l=S.getAxesPermutation(u,a),p=o;l!=null&&(p=tt({inputs:{x:o},backend:t,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",u,a);let[d,f]=S.computeOutAndReduceShapes(p.shape,u),m=y.sizeFromShape(f),h=J({inputs:{x:p},backend:t,attrs:{shape:[-1,m]}}),g=Xn(h,h.dtype,"min",t),x;if(i){let v=S.expandShapeToKeepDim(d,c);x=J({inputs:{x:g},backend:t,attrs:{shape:v}})}else x=J({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),l!=null&&t.disposeIntermediateTensorInfo(p),x}var Wz={kernelName:"Min",backendName:"webgl",kernelFunc:_ae};T();var Aae=id+`
  return min(a, b);
`,Rae=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Kn+`
  return result;
`,Fae=je({opSnippet:Aae,packedOpSnippet:Rae,cpuKernelImpl:qV}),jz={kernelName:mi,backendName:"webgl",kernelFunc:Fae};T();var Pv=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((l,p)=>l[0]+e[p]+l[1]);let o=e.length,s=ve(o),i=t.map(l=>l[0]).join(","),a=t.map((l,p)=>l[0]+e[p]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),u=r==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}};var Lv=class{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((m,h)=>m[0]+e[h]+m[1]);let o=e.length,s=ve(o),i=t.map(m=>m[0]).join(","),a=t.map((m,h)=>m[0]+e[h]).join(","),c=xt("rc",o),u=xt("source",o),l=`${c[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${u.slice(-2).join()})`,d=r==="reflect"?0:1,f="";if(o===1){let m=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${c[o-1]} += 1;
        if(${l}) {
          ${m}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
      `}else{let m=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${c[o-1]} += 1;
        if(${l}) {
          ${m}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
        rc = outputLoc;
        ${c[o-2]} += 1;
        if(${c[o-2]} < ${this.outputShape[o-2]}) {
          ${m}
          result[2] = getChannel(getX(${u.join()}), ${p});
          ${c[o-1]} += 1;
          if(${l}) {
            ${m}
            result[3] = getChannel(getX(${u.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var Oae=({inputs:n,backend:e,attrs:t})=>{let{x:r}=n,{paddings:o,mode:s}=t,i=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Lv(r.shape,o,s):new Pv(r.shape,o,s);return e.runWebGLProgram(i,[r],r.dtype)},qz={kernelName:Uc,backendName:"webgl",kernelFunc:Oae};T();var Mae=`if (b == 0.0) return NAN;
  return mod(a, b);`,$ae=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Kn+`
  return result;
`,Pae=je({opSnippet:Mae,packedOpSnippet:$ae}),Kz={kernelName:"Mod",backendName:"webgl",kernelFunc:Pae};T();var Bv=class{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};T();T();var Lae=`
if (a == b) {
  return 1.0;
};
return a / b;`,Bae=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,qN=je({opSnippet:Lae,packedOpSnippet:Bae,checkOutOfBounds:!0}),Xz={kernelName:Zs,backendName:"webgl",kernelFunc:qN};T();var Yz="return a - b;",KN=je({opSnippet:Yz,packedOpSnippet:Yz,supportsComplex:!0,cpuKernelImpl:m4}),Zz={kernelName:"Sub",backendName:"webgl",kernelFunc:KN};function XN(n){let{inputs:e,backend:t,attrs:r}=n,{logits:o}=e,{dim:s}=r,i=y.parseAxisParam([s],o.shape),a=jN({inputs:{x:o},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),c=S.expandShapeToKeepDim(a.shape,i),u=J({inputs:{x:a},backend:t,attrs:{shape:c}}),l=KN({inputs:{a:o,b:u},backend:t}),p=HN({inputs:{x:l},backend:t}),d=Cl({inputs:{x:p},backend:t,attrs:{axis:i,keepDims:!1}}),f=J({inputs:{x:d},backend:t,attrs:{shape:c}}),m=qN({inputs:{a:p,b:f},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),m}var Qz={kernelName:xu,backendName:"webgl",kernelFunc:XN};function Vae(n){let{inputs:e,backend:t,attrs:r}=n,{logits:o}=e,{numSamples:s,seed:i,normalized:a}=r,c=a?o:XN({inputs:{logits:o},backend:t,attrs:{dim:o.shape.length-1}}),u=c.shape[0],l=c.shape[1],p=new Bv(u,l,s),d=[[i]],f=t.runWebGLProgram(p,[c],"int32",d);return a||t.disposeIntermediateTensorInfo(c),f}var Jz={kernelName:Hc,backendName:"webgl",kernelFunc:Vae};T();var Uae=Dt+`
  return -x;
`,zae=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Hae(n){let{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){let s=t.texData.get(r.dataId),[i,a]=XV(s.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,i)}let o;return M().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Rn(r.shape,zae):o=new Kt(r.shape,Uae),t.runWebGLProgram(o,[r],r.dtype)}var eH={kernelName:"Neg",backendName:"webgl",kernelFunc:Hae};T();var Gae=qt.nonMaxSuppressionV3Impl;function Wae(n){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c}=r,u=t.readSync(o.dataId),l=t.readSync(s.dataId),{selectedIndices:p}=Gae(u,l,i,a,c);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}var tH={kernelName:Gc,backendName:"webgl",kernelFunc:Wae};T();var jae=qt.nonMaxSuppressionV4Impl;function qae(n){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,padToMaxOutputSize:u}=r,l=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:d,validOutputs:f}=jae(l,p,i,a,c,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var nH={kernelName:Wc,backendName:"webgl",kernelFunc:qae};T();var Kae=qt.nonMaxSuppressionV5Impl;function Xae(n){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,softNmsSigma:u}=r,l=t.readSync(o.dataId),p=t.readSync(s.dataId),d=i,f=a,m=c,h=u,{selectedIndices:g,selectedScores:x}=Kae(l,p,d,f,m,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var rH={kernelName:jc,backendName:"webgl",kernelFunc:Xae};T();var Vv=class{constructor(e,t,r,o){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${r}),
                      float(index == coords.y)));
      }
    `}};var Yae=n=>{let{inputs:e,backend:t,attrs:r}=n,{indices:o}=e,{dtype:s,depth:i,onValue:a,offValue:c}=r,u=y.sizeFromShape(o.shape),l=new Vv(u,i,a,c),p=J({inputs:{x:o},backend:t,attrs:{shape:[u]}}),d=t.runWebGLProgram(l,[p],s);t.disposeIntermediateTensorInfo(p);let f=[...o.shape,i],m=J({inputs:{x:d},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(d),m},oH={kernelName:Kc,backendName:"webgl",kernelFunc:Yae};T();T();function nh(n){let{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){let o=Cs({inputs:{input:r},backend:t}),s=nh({inputs:{x:o},backend:t}),i=Il({inputs:{input:r},backend:t}),a=nh({inputs:{x:i},backend:t}),c=On({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return ws({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}var sH={kernelName:Ou,backendName:"webgl",kernelFunc:nh};function iH(n){let{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let o=Cs({inputs:{input:r},backend:t}),s=iH({inputs:{x:o},backend:t}),i=Il({inputs:{input:r},backend:t}),a=nh({inputs:{x:i},backend:t}),c=On({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return ws({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}var aH={kernelName:qc,backendName:"webgl",kernelFunc:iH};T();function Zae(n){let{inputs:e,backend:t,attrs:r}=n,{axis:o}=r;if(e.length===1)return Ev({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,i=e[0].dtype;e.forEach(l=>{y.assertShapesMatch(s,l.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],c=e.map(l=>{let p=Ev({inputs:{input:l},backend:t,attrs:{dim:o}});return a.push(p),p}),u=zN({inputs:c,backend:t,attrs:{axis:o}});return a.forEach(l=>t.disposeIntermediateTensorInfo(l)),u}var cH={kernelName:Xc,backendName:"webgl",kernelFunc:Zae};T();var Uv=class{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,l)=>u[0]+e[l]+u[1]);let o=e.length,s=ve(o),i=t.map(u=>u[0]).join(","),a=t.map((u,l)=>u[0]+e[l]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}};var zv=class{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((h,g)=>h[0]+e[g]+h[1]);let o=e.length,s=ve(o),i=t.map(h=>h[0]).join(","),a=t.map((h,g)=>h[0]+e[g]).join(","),c=xt("rc",o),u=xt("source",o),l=`${c[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${c[o-1]} += 1;
       if(${l}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${c[o-2]} += 1;
       if(${c[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${c[o-1]} += 1;
         if(${l}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",m="";for(let h=0,g=o===1?2:4;h<g;h++)m+=`
        ${d[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${u.join()}), ${p});
        }
      `;m+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}};var YN=n=>{let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{paddings:s,constantValue:i}=r;if(y.sizeFromShape(o.shape)===0){let u=s.map((l,p)=>l[0]+o.shape[p]+l[1]);return ws({backend:t,attrs:{shape:u,value:i,dtype:o.dtype}})}let a=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zv(o.shape,s,i):new Uv(o.shape,s,i),c=[[i]];return t.runWebGLProgram(a,[o],o.dtype,c)},uH={kernelName:Yc,backendName:"webgl",kernelFunc:YN};T();var Qae=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Jae=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Kn+`
  return result;
`,ece=je({opSnippet:Qae,packedOpSnippet:Jae}),lH={kernelName:"Pow",backendName:"webgl",kernelFunc:ece};T();function tce(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r,a=o.shape.length,c=[],u=y.parseAxisParam(s,o.shape),l=u,p=S.getAxesPermutation(l,a),d=o;p!=null&&(d=tt({inputs:{x:o},backend:t,attrs:{perm:p}}),l=S.getInnerMostAxes(l.length,a),c.push(d)),S.assertAxesAreInnerMostDims("prod",l,a);let f;if(t.shouldExecuteOnCPU([d])){let m=t.texData.get(d.dataId).values,{outVals:h,outShape:g,outDtype:x}=ZV(d.shape,d.dtype,m,l);f=t.makeTensorInfo(g,x,h)}else{let[m,h]=S.computeOutAndReduceShapes(d.shape,l),g=y.sizeFromShape(h),x=J({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),v=Pi(o.dtype),w=Xn(x,v,"prod",t);f=J({inputs:{x:w},backend:t,attrs:{shape:m}}),c.push(x),c.push(w)}if(i){c.push(f);let m=S.expandShapeToKeepDim(f.shape,u);f=J({inputs:{x:f},backend:t,attrs:{shape:m}})}return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}var pH={kernelName:Jc,backendName:"webgl",kernelFunc:tce};T();function nce(n){let{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=e,{outputRaggedRank:a}=r,c=o.map(x=>t.readSync(x.dataId)),u=o.map(x=>x.shape),l=t.readSync(s.dataId),p=t.readSync(i.dataId),[d,f,m]=QV(c,u,l,s.shape,s.dtype,p,i.shape,a),h=d.map(x=>t.makeTensorInfo([x.length],"int32",x)),g=t.makeTensorInfo(m,s.dtype,f);return h.concat([g])}var dH={kernelName:eu,backendName:"webgl",kernelFunc:nce};T();function rce(n){let{inputs:e,backend:t}=n,{starts:r,limits:o,deltas:s}=e,i=t.readSync(r.dataId),a=t.readSync(o.dataId),c=t.readSync(s.dataId),[u,l]=JV(i,r.shape,r.dtype,a,o.shape,c,s.shape),p=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([l.length],r.dtype,l);return[p,d]}var fH={kernelName:tu,backendName:"webgl",kernelFunc:rce};T();function oce(n){let{inputs:e,backend:t,attrs:r}=n,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:c}=r,u=t.readSync(o.dataId),l=t.readSync(s.dataId),p=t.readSync(i.dataId),d=a.map(g=>t.readSync(g.dataId)),f=a.map(g=>g.shape),[m,h]=e4(u,o.shape,l,s.shape,s.dtype,p,i.shape,d,f,c);return t.makeTensorInfo(m,s.dtype,h)}var mH={kernelName:nu,backendName:"webgl",kernelFunc:oce};T();var ZN=n=>{let{backend:e,attrs:t}=n,{start:r,stop:o,step:s,dtype:i}=t,a=t4(r,o,s,i);return e.makeTensorInfo([a.length],i,a)},hH={kernelName:ru,backendName:"webgl",kernelFunc:ZN};T();var sce="return 1.0 / x;",ice=pe({opSnippet:sce}),gH={kernelName:xi,backendName:"webgl",kernelFunc:ice};T();var ace=Dt+`
  return (x < 0.0) ? 0.0 : x;
`,cce=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uce=pe({opSnippet:ace,packedOpSnippet:cce}),xH={kernelName:yi,backendName:"webgl",kernelFunc:uce};T();var lce=Dt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,pce=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dce=pe({opSnippet:lce,packedOpSnippet:pce}),yH={kernelName:vi,backendName:"webgl",kernelFunc:dce};T();var Hv=class{constructor(e,t,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,c,u]=e;this.outputShape=[i,t,r,u];let l=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/p[0]},
          ${l[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var Gv=class{constructor(e,t,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,c,u]=e;this.outputShape=[i,t,r,u];let l=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/p[0]},
          ${l[1]/p[1]},
          ${l[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function fce(n){let{inputs:e,backend:t,attrs:r}=n,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=r,[c,u]=a,l=M().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Gv(o.shape,c,u,s,i):new Hv(o.shape,c,u,s,i);return t.runWebGLProgram(l,[o],"float32")}var vH={kernelName:au,backendName:"webgl",kernelFunc:fce};T();var Wv=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,o,s]=t,[,i,a]=e,c=[r&&i>1?o-1:o,r&&a>1?s-1:s],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],l=c[0]/u[0],p=c[1]/u[1],d=1/l,f=1/p,m=Math.ceil(d)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function mce(n){let{inputs:e,backend:t,attrs:r}=n,{images:o,dy:s}=e,{alignCorners:i}=r,a=new Wv(s.shape,o.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}var bH={kernelName:Ef,backendName:"webgl",kernelFunc:mce};T();var jv=class{constructor(e,t,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,c,u]=e;this.outputShape=[i,t,r,u];let l=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/p[0]},
          ${l[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var qv=class{constructor(e,t,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,c,u]=e;this.outputShape=[i,t,r,u];let l=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d=o?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/p[0]},
          ${l[1]/p[1]},
          ${l[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function hce(n){let{inputs:e,backend:t,attrs:r}=n,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=r,[c,u]=a,l=M().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qv(o.shape,c,u,s,i):new jv(o.shape,c,u,s,i);return t.runWebGLProgram(l,[o],o.dtype)}var CH={kernelName:iu,backendName:"webgl",kernelFunc:hce};T();var Kv=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,o,s]=t,[,i,a]=e,c=[r&&i>1?o-1:o,r&&a>1?s-1:s],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],l=c[0]/u[0],p=c[1]/u[1],d=1/l,f=1/p,m=Math.ceil(d)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function gce(n){let{inputs:e,backend:t,attrs:r}=n,{images:o,dy:s}=e,{alignCorners:i}=r,a=new Kv(s.shape,o.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}var wH={kernelName:If,backendName:"webgl",kernelFunc:gce};T();var Xv=class{constructor(e,t){this.variableNames=["x"];let r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let o=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,s=e.map((a,c)=>o(c)).join(","),i=ve(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var Yv=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;let o=xt("rc",r),s=`${o[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${o[r-2]} + 1 < ${this.outputShape[r-2]}`,a=ve(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(o.slice())};
          if(${s}){
            result.g = ${u(o.slice())};
          }
          if(${i}) {
            result.b = ${l(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(m){return d(m)}function u(m){return m[r-1]="("+m[r-1]+" + 1)",d(m)}function l(m){return m[r-2]="("+m[r-2]+" + 1)",d(m)}function p(m){return m[r-1]="("+m[r-1]+" + 1)",m[r-2]="("+m[r-2]+" + 1)",d(m)}function d(m){let h=e.map((v,w)=>f(w,m)),g=h.join(","),x=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${x}))`}function f(m,h){return t.indexOf(m)!==-1&&e[m]!==1?`${e[m]} - ${h[m]} - 1`:`${h[m]}`}}};function xce(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{dims:s}=r,i=o.shape.length,a=y.parseAxisParam(s,o.shape);if(i===0)return yt({inputs:{x:o},backend:t});let c=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Yv(o.shape,a):new Xv(o.shape,a);return t.runWebGLProgram(c,[o],o.dtype)}var IH={kernelName:cu,backendName:"webgl",kernelFunc:xce};T();T();var Zv=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let r=e[1],o=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var EH={kernelName:Mu,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{image:r}=n,{radians:o,fillValue:s,center:i}=e,a=t,c=new Zv(r.shape,s),[u,l]=S.getImageCenter(i,r.shape[1],r.shape[2]),p=[[u,l,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(c,[r],r.dtype,p)}};T();var yce=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,vce=pe({opSnippet:yce}),TH={kernelName:bi,backendName:"webgl",kernelFunc:vce};T();var bce="return inversesqrt(x);",Cce=pe({opSnippet:bce,cpuKernelImpl:n4}),SH={kernelName:Ci,backendName:"webgl",kernelFunc:Cce};T();var ca=class{constructor(e,t,r,o,s,i,a=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let u=ve(s.length),l=ve(i.length),p="";r===1?p="i":r===2&&(p="i, j");let d=`getIndices(${p})`,f="";o===1?f="i":o===2&&(f="i, coords[1]");let m=`getUpdates(${f})`,h="";c&&(h="coords[0], coords[1]");let g=`getDefaultValue(${h})`,x=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${x};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${m};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}};var Qv=class{constructor(e,t,r,o,s,i,a=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let u=ve(s.length),l=ve(i.length),p="";r===1?p="i":r===2&&(p="i, j");let d=`getIndices(${p})`,f="";o===1?f="i":o===2&&(f="i, coords[1]");let m=`getUpdates(${f})`,h="";c&&(h="coords[0], coords[1]");let g=`getDefaultValue(${h})`,x=t>1?"strides[j]":"strides",v=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${x};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${v};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${m};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}};function wce(n){let{inputs:e,backend:t,attrs:r}=n,{indices:o,updates:s}=e,{shape:i}=r,{sliceRank:a,numUpdates:c,sliceSize:u,strides:l,outputSize:p}=S.calculateShapes(s,o,i),d=[p/u,u];if(p===0)return t.makeTensorInfo(i,o.dtype);let f=J({inputs:{x:o},backend:t,attrs:{shape:[c,a]}}),m=J({inputs:{x:s},backend:t,attrs:{shape:[c,u]}}),h=t.makeTensorInfo([],"float32",new Float32Array([0])),g;M().getBool("WEBGL_PACK")?g=new Qv(c,a,f.shape.length,m.shape.length,l,d):g=new ca(c,a,f.shape.length,m.shape.length,l,d);let x=t.runWebGLProgram(g,[m,f,h],m.dtype),v=J({inputs:{x},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(h),v}var NH={kernelName:uu,backendName:"webgl",kernelFunc:wce};T();T();var Jv=class{constructor(e,t,r,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=M().getNumber("WEBGL_VERSION")===2?s:i,c=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Ice(n){let{inputs:e,backend:t,attrs:r}=n,{sortedSequence:o,values:s}=e,{side:i}=r,a=new Jv(o.shape[0],o.shape[1],s.shape[1],i),c=[[o.shape[1]]];return t.runWebGLProgram(a,[o,s],"int32",c)}var DH={kernelName:pu,backendName:"webgl",kernelFunc:Ice};T();var eb=class{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let o,s;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],u=[];for(let l=0;l<t.length;l++)u.push(`${a[l]}`),l<e&&c.push(`${a[l]}`);o=c.join(),s=u.join()}let i=ve(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Ece(n){let{inputs:e,backend:t}=n,{condition:r,t:o,e:s}=e,i=new eb(r.shape.length,o.shape,o.shape.length);return t.runWebGLProgram(i,[r,o,s],wt(o.dtype,s.dtype))}var kH={kernelName:du,backendName:"webgl",kernelFunc:Ece};T();var Tce=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${S.SELU_SCALEALPHA};
  float scale = ${S.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Sce=pe({opSnippet:Tce}),_H={kernelName:wi,backendName:"webgl",kernelFunc:Sce};T();var Nce=Tr+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Dce=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,kce=pe({opSnippet:Nce,packedOpSnippet:Dce,cpuKernelImpl:o4}),AH={kernelName:Ti,backendName:"webgl",kernelFunc:kce};T();var _ce=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Ace=pe({opSnippet:_ce}),RH={kernelName:Ei,backendName:"webgl",kernelFunc:Ace};T();var Rce=Tr+`
  return sin(x);
`,Fce=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Kn}
  return result;
`,Oce=pe({opSnippet:Rce,packedOpSnippet:Fce}),FH={kernelName:"Sin",backendName:"webgl",kernelFunc:Oce};T();var Mce=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,$ce=pe({opSnippet:Mce}),OH={kernelName:Ii,backendName:"webgl",kernelFunc:$ce};T();var Pce=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Lce=pe({opSnippet:Pce}),MH={kernelName:Si,backendName:"webgl",kernelFunc:Lce};T();var Bce=n=>{let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockShape:s,paddings:i}=r;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((x,v)=>x*v),c=[[0,0]];c.push(...i);for(let x=1+s.length;x<o.shape.length;++x)c.push([0,0]);let u=[],l=YN({inputs:{x:o},backend:t,attrs:{paddings:c,constantValue:0}}),p=S.getReshaped(l.shape,s,a,!1),d=S.getPermuted(p.length,s.length,!1),f=S.getReshapedPermuted(l.shape,s,a,!1),m=J({inputs:{x:l},backend:t,attrs:{shape:p}}),h=tt({inputs:{x:m},backend:t,attrs:{perm:d}}),g=J({inputs:{x:h},backend:t,attrs:{shape:f}});return u.push(l),u.push(m),u.push(h),u.forEach(x=>t.disposeIntermediateTensorInfo(x)),g},$H={kernelName:hu,backendName:"webgl",kernelFunc:Bce};T();function Vce(n){let{inputs:e,backend:t}=n,{indices:r,values:o,denseShape:s,defaultValue:i}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=t.readSync(r.dataId),c=t.readSync(o.dataId),u=t.readSync(s.dataId),l=t.readSync(i.dataId)[0],[p,d,f,m,h]=i4(a,r.shape,r.dtype,c,o.dtype,u,l);return[t.makeTensorInfo(d,r.dtype,p),t.makeTensorInfo([d[0]],o.dtype,f),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}var PH={kernelName:yu,backendName:"webgl",kernelFunc:Vce};T();function Uce(n){let{inputs:e,backend:t}=n,{inputIndices:r,inputShape:o,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(t.readSync(o.dataId)),a=t.readSync(r.dataId),c=Array.from(t.readSync(s.dataId)),[u,l,p]=a4(a,r.shape,r.dtype,i,c);return[t.makeTensorInfo(l,r.dtype,u),t.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var LH={kernelName:vu,backendName:"webgl",kernelFunc:Uce};T();function zce(n){let{inputs:e,backend:t}=n,{data:r,indices:o,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=t.readSync(r.dataId),a=t.readSync(o.dataId),c=t.readSync(s.dataId),[u,l]=My(i,r.shape,r.dtype,a,c,!0);return t.makeTensorInfo(l,r.dtype,u)}var BH={kernelName:bu,backendName:"webgl",kernelFunc:zce};T();function Hce(n){let{inputs:e,backend:t}=n,{data:r,indices:o,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=t.readSync(r.dataId),a=t.readSync(o.dataId),c=t.readSync(s.dataId),[u,l]=My(i,r.shape,r.dtype,a,c);return t.makeTensorInfo(l,r.dtype,u)}var VH={kernelName:Cu,backendName:"webgl",kernelFunc:Hce};T();function Gce(n){let{inputs:e,backend:t,attrs:r}=n,{sparseIndices:o,sparseValues:s,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:c,numUpdates:u,sliceSize:l,strides:p,outputSize:d}=S.calculateShapes(s,o,a),f=!1;if(s.dtype==="string"){let x=t.bufferSync(o),v=t.bufferSync(s),w=y.decodeString(t.readSync(i.dataId)[0]),I=r4(x,v,a,d,l,u,c,p,w,f);return t.makeTensorInfo(a,I.dtype,I.values)}let m=new ca(u,c,o.shape.length,s.shape.length,p,[d,1],f),h=t.runWebGLProgram(m,[s,o,i],s.dtype),g=J({inputs:{x:h},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(h),g}var UH={kernelName:wu,backendName:"webgl",kernelFunc:Gce};T();function Wce(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{numOrSizeSplits:s,axis:i}=r,a=y.parseAxisParam(i,o.shape)[0],c=S.prepareSplitSize(o,s,a),u=o.shape.length,l=new Array(u).fill(0),p=o.shape.slice();return c.map(d=>{let f=[...p];f[a]=d;let m=Jr({inputs:{x:o},backend:t,attrs:{begin:l,size:f}});return l[a]+=d,m})}var zH={kernelName:gu,backendName:"webgl",kernelFunc:Wce};T();var HH="return sqrt(x);",jce=pe({opSnippet:HH,packedOpSnippet:HH,cpuKernelImpl:c4}),GH={kernelName:Ni,backendName:"webgl",kernelFunc:jce};T();var qce="return x * x;",Kce=pe({opSnippet:qce}),WH={kernelName:Tf,backendName:"webgl",kernelFunc:Kce};T();var jH="return (a - b) * (a - b);",Xce=je({opSnippet:jH,packedOpSnippet:jH}),qH={kernelName:Di,backendName:"webgl",kernelFunc:Xce};T();function Yce(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");let s=t.readSync(o.dataId),i=S.fromUint8ToStringArray(s),a=u4(i,"string",r);return t.makeTensorInfo(o.shape,"string",a)}var KH={kernelName:ki,backendName:"webgl",kernelFunc:Yce};T();function Zce({inputs:n,attrs:e,backend:t}){let{x:r}=n,o=Dt+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new Kt(r.shape,o);return t.runWebGLProgram(s,[r],r.dtype)}var XH={kernelName:Ai,backendName:"webgl",kernelFunc:Zce};T();var tb=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;let o=r.length,s=ve(r.length),i=ve(r.length),a="";if(o===1)a="coords * strides + begin";else{let c=0;a=r.map((u,l)=>(c++,r.length===1?`coords * strides[${l}] + begin[${l}]`:`coords[${c-1}] * strides[${l}] + begin[${l}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function Qce(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{begin:s,end:i,strides:a,beginMask:c,endMask:u,ellipsisMask:l,newAxisMask:p,shrinkAxisMask:d}=r,{finalShapeSparse:f,finalShape:m,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:v,end:w,strides:I}=At.sliceInfo(o.shape,s,i,a,c,u,l,p,d),_;if(h)_=J({inputs:{x:o},backend:t,attrs:{shape:m}});else if(g||x){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let R=At.computeOutShape(v,w,I),F=Jr({inputs:{x:o},backend:t,attrs:{begin:v,size:R}});_=J({inputs:{x:F},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(F)}else if(t.shouldExecuteOnCPU([o])){let F=t.readSync(o.dataId),P=ue(o.shape,o.dtype,F),L=l4(f,P,I,v);_=t.makeTensorInfo(m,o.dtype,L.values)}else{let F=new tb(v,I,f);_=t.runWebGLProgram(F,[o],o.dtype)}let A=J({inputs:{x:_},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(_),A}var YH={kernelName:Iu,backendName:"webgl",kernelFunc:Qce};T();function Jce(n){let{inputs:e,backend:t,attrs:r}=n,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:c,preserveShortSequences:u}=r,{data:l,dataSplits:p}=e,d=t.readSync(l.dataId),f=t.readSync(p.dataId),[m,h]=p4(d,f,o,s,i,a,c,u);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(p.shape,"int32",h)]}var ZH={kernelName:Eu,backendName:"webgl",kernelFunc:Jce};T();function eue(n){let{inputs:e,backend:t,attrs:r}=n,{skipEmpty:o}=r,{input:s,delimiter:i}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=t.readSync(s.dataId),c=t.readSync(i.dataId)[0],[u,l,p]=d4(a,c,o),d=l.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",l),t.makeTensorInfo([2],"int32",new Int32Array(p))]}var QH={kernelName:Tu,backendName:"webgl",kernelFunc:eue};T();function tue(n){let{inputs:e,backend:t,attrs:r}=n,{numBuckets:o}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=t.readSync(s.dataId),a=f4(i,o);return t.makeTensorInfo(s.shape,"int32",a)}var JH={kernelName:Su,backendName:"webgl",kernelFunc:tue};T();var nue="return tan(x);",rue=pe({opSnippet:nue}),eG={kernelName:"Tan",backendName:"webgl",kernelFunc:rue};T();var oue=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,sue=pe({opSnippet:oue}),tG={kernelName:_i,backendName:"webgl",kernelFunc:sue};T();function iue(n){let{inputs:e,backend:t,attrs:r}=n,{tensor:o,indices:s,updates:i}=e,{}=r,{sliceRank:a,numUpdates:c,sliceSize:u,strides:l,outputSize:p}=S.calculateShapes(i,s,o.shape),d=[p/u,u];if(p===0)return t.makeTensorInfo(o.shape,s.dtype);let f=J({inputs:{x:s},backend:t,attrs:{shape:[c,a]}}),m=J({inputs:{x:i},backend:t,attrs:{shape:[c,u]}}),h=J({inputs:{x:o},backend:t,attrs:{shape:d}}),g=new ca(c,a,f.shape.length,m.shape.length,l,d,!1,!0),x=t.runWebGLProgram(g,[m,f,h],h.dtype),v=J({inputs:{x},backend:t,attrs:{shape:o.shape}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(x),v}var nG={kernelName:lu,backendName:"webgl",kernelFunc:iue};T();var nb=class{constructor(e,t){this.variableNames=["A"];let r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[i]*t[i];this.outputShape=r,this.rank=r.length;let o=ve(this.rank),s=aue(e);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function aue(n){let e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<n.length;o++)r.push(`imod(${t[o]}, ${n[o]})`);return r.join()}function QN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{reps:s}=r;if(o.dtype==="string"||o.shape.length>5){let c=t.readSync(o.dataId),u=o.dtype==="string"?c.map(d=>y.decodeString(d)):c,l=ue(o.shape,o.dtype,u),p=h4(l,s);return t.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new nb(o.shape,s);return t.runWebGLProgram(i,[o],o.dtype)}var rG={kernelName:Ko,backendName:"webgl",kernelFunc:QN};T();var rb=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},ob=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function El(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function oG(n){let e=1;for(;e<n;)e*=2;return e}function cue(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{k:s,sorted:i}=r,a=M().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=M().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=o.shape,l=u[u.length-1];if(t.shouldExecuteOnCPU([o])||l<a||s>c){let L=t.readSync(o.dataId),[V,z]=g4(L,u,o.dtype,s,i);return[t.makeTensorInfo(V.shape,V.dtype,V.values),t.makeTensorInfo(z.shape,z.dtype,z.values)]}if(s===0)return u[u.length-1]=0,[t.makeTensorInfo(u,o.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(l===1)return[o,ws({attrs:{shape:u,dtype:"int32",value:0},backend:t})];let p=t.texData.get(o.dataId),d=p!==null&&p.isPacked,f=d?t.unpackTensor(o):o,h=y.sizeFromShape(u)/l,g=J({inputs:{x:f},attrs:{shape:[h,l]},backend:t});d&&El(t,f);let x=oG(s),v=oG(l),w=null,I=()=>w===null?[g,g]:[g,w],_=(L,V,z)=>{let H=I(),j=new rb(z),Y=[[l],[w===null?1:0],[Number.NEGATIVE_INFINITY],[L],[V]],Z=w;w=t.runWebGLProgram(j,H,"int32",Y),El(t,Z)};for(let L=1;L<x;L*=2){let V=L*2;for(let z=L;z>=1;z/=2)_(V,z,[h,v])}for(let L=v;L>x;L/=2){let V=I(),z=new ob([h,L/2]),j=[[l],[w===null?1:0],[x]],W=w;w=t.runWebGLProgram(z,V,"int32",j),El(t,W);let Y=x/2,Z=Y*2;for(let K=Y;K>=1;K/=2)_(Z,K,w.shape)}let A=w;w=Jr({inputs:{x:w},backend:t,attrs:{begin:0,size:[h,s]}}),El(t,A);let R=WN({inputs:{x:g,indices:w},backend:t,attrs:{axis:1,batchDims:1}});El(t,g);let F=u.slice(0,-1);F.push(s),A=w,w=J({inputs:{x:w},attrs:{shape:F},backend:t}),El(t,A);let P=R;return R=J({inputs:{x:R},attrs:{shape:F},backend:t}),El(t,P),[R,w]}var sG={kernelName:ku,backendName:"webgl",kernelFunc:cue};T();var sb=class{constructor(e,t,r,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=r==="nearest"?1:2,c;switch(o){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function uue(n){let{inputs:e,backend:t,attrs:r}=n,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:c,outputShape:u}=r,[l,p,d,f]=o.shape,[m,h]=u??[p,d],g=[l,m,h,f],x=new sb(p,d,i,a,c,g);return t.runWebGLProgram(x,[o,s],"float32")}var iG={kernelName:_u,backendName:"webgl",kernelFunc:uue};T();function lue(n){let{inputs:e,attrs:t,backend:r}=n,{axis:o}=t,{x:s}=e;Oo(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:a,outputShape:c,indices:u}=x4(i,o,s.shape,s.dtype);return[r.makeTensorInfo(c,s.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}var aG={kernelName:Au,backendName:"webgl",kernelFunc:lue};T();function pue(n){let{inputs:e,backend:t,attrs:r}=n,{value:o}=e,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,c=o.shape[s],u=new Array(a-1),l=0;for(let h=0;h<a;h++)h!==s&&(u[l++]=i.shape[h]);let p=[],d=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let m=new Array(c);for(let h=0;h<m.length;h++){d[s]=h;let g=Jr({inputs:{x:i},backend:t,attrs:{begin:d,size:f}}),x=J({inputs:{x:g},backend:t,attrs:{shape:u}});m[h]=x,p.push(g)}return p.forEach(h=>t.disposeIntermediateTensorInfo(h)),m}var cG={kernelName:Ru,backendName:"webgl",kernelFunc:pue};T();var ib=class{constructor(e,t){this.variableNames=["x","segmentIds"];let r=e.windowSize,o=e.batchSize,s=e.inSize,i=e.numSegments,a=i*Math.ceil(s/r);this.outputShape=[o,a];let c="0.0",u="sumValue",l=Math.floor(r/4)*4,p=r%4,d=`
        sumValue += dot(values, segFilter);
    `,f="";s%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let m="";s%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${l};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}};function due(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,segmentIds:s}=e,{numSegments:i}=r,a=o.shape.length,c=[],u=0,l=S.getAxesPermutation([u],a),p=o;l!=null&&(p=tt({inputs:{x:o},backend:t,attrs:{perm:l}}),c.push(p),u=S.getInnerMostAxes(1,a)[0]);let d=S.segment_util.computeOutShape(p.shape,u,i),f=y.sizeFromShape([p.shape[u]]),m=J({inputs:{x:p},backend:t,attrs:{shape:[-1,f]}});c.push(m);let h=Pi(o.dtype),g=(I,_,A,R,F)=>{let P=I.shape[0],L=I.shape[1],V=S.segment_util.segOpComputeOptimalWindowSize(L,F),z={windowSize:V,inSize:L,batchSize:P,numSegments:F},H=new ib(z,_),j=t.compileAndRun(H,[I,A],R);if(c.push(j),j.shape[1]===F)return j;let W=ZN({backend:t,attrs:{start:0,stop:F,step:1,dtype:"float32"}}),Y=QN({inputs:{x:W},backend:t,attrs:{reps:[L/V]}});return c.push(W),c.push(Y),g(j,_,Y,R,F)},x=g(m,"unsortedSegmentSum",s,h,i),v=J({inputs:{x},backend:t,attrs:{shape:d}}),w=v;if(l!=null){c.push(v);let I=S.getUndoAxesPermutation(l);w=tt({inputs:{x:w},backend:t,attrs:{perm:I}})}return c.forEach(I=>t.disposeIntermediateTensorInfo(I)),w}var uG={kernelName:Fu,backendName:"webgl",kernelFunc:due};var fue=[W4,q4,K4,X4,Z4,Q4,J4,eU,rU,oU,sU,iU,aU,cU,uU,lU,pU,dU,fU,mU,hU,xU,yU,vU,bU,EU,SU,NU,M4,kU,AU,RU,FU,OU,MU,$U,PU,LU,BU,VU,HU,GU,WU,jU,qU,KU,XU,YU,ZU,QU,JU,ez,tz,nz,rz,oz,iz,az,cz,uz,pz,dz,fz,mz,hz,gz,xz,yz,vz,O4,bz,_U,Cz,wz,Iz,$4,Ez,Tz,Sz,Nz,Dz,kz,_z,Az,Rz,Fz,Mz,$z,Pz,Lz,Bz,Vz,zz,Gz,Wz,jz,qz,Kz,Jz,B4,eH,tH,nH,rH,CU,oH,aH,cH,uH,lH,P4,pH,dH,fH,mH,hH,wU,Xz,gH,xH,yH,U4,vH,bH,CH,wH,IH,EH,TH,SH,NH,DH,kH,_H,AH,RH,FH,OH,gU,Qz,MH,$H,PH,LH,BH,VH,UH,zH,GH,WH,qH,KH,XH,YH,ZH,QH,JH,Zz,H4,eG,tG,nG,rG,sG,iG,G4,aG,cG,uG,sH];for(let n of fue)hp(n);var ZW=ch(KW());var dle=["proportionChart"],Sb=class n{canvasRef;newValue=Tg(null);nearThreshold=Tg(.9);farThreshold=Tg(.7);ctx;history=[];maxPoints=50;yMin=.5;yMax=1;updateEffect=nw(()=>{let e=this.newValue();e!==null&&!Number.isNaN(e)&&this.ctx&&this.updateChart(e)});ngAfterViewInit(){this.ctx=this.canvasRef.nativeElement.getContext("2d"),this.drawAxes()}drawAxes(){let e=this.canvasRef.nativeElement;this.ctx.clearRect(0,0,e.width,e.height);let t=[{value:this.farThreshold(),color:"orange"},{value:this.nearThreshold(),color:"red"}];console.log(`${t[0].value}, ${t[1].value}`),t.forEach(r=>{console.log(typeof r.value);let o=this.valueToY(r.value);this.ctx.beginPath(),this.ctx.strokeStyle=r.color,this.ctx.setLineDash([4,4]),this.ctx.moveTo(0,o),this.ctx.lineTo(e.width,o),this.ctx.stroke(),this.ctx.setLineDash([]),this.ctx.fillStyle=r.color,this.ctx.font="12px Arial",this.ctx.fillText(r.value.toFixed(2),5,o-5)}),this.ctx.setLineDash([])}valueToY(e){let t=this.canvasRef.nativeElement,r=this.yMax-this.yMin,o=Math.max(this.yMin,Math.min(this.yMax,e));return t.height-(o-this.yMin)/r*t.height}updateChart(e){this.history.push(e),this.history.length>this.maxPoints&&this.history.shift(),this.drawAxes(),this.ctx.beginPath(),this.ctx.strokeStyle="#0ff",this.ctx.lineWidth=2,this.history.forEach((t,r)=>{let o=r/(this.maxPoints-1)*this.canvasRef.nativeElement.width,s=this.valueToY(t);r===0?this.ctx.moveTo(o,s):this.ctx.lineTo(o,s)}),this.ctx.stroke()}static \u0275fac=function(t){return new(t||n)};static \u0275cmp=Ua({type:n,selectors:[["app-chart"]],viewQuery:function(t,r){if(t&1&&Os(dle,7),t&2){let o;Ms(o=$s())&&(r.canvasRef=o.first)}},inputs:{newValue:[1,"newValue"],nearThreshold:[1,"nearThreshold"],farThreshold:[1,"farThreshold"]},decls:2,vars:0,consts:[["proportionChart",""],["width","400","height","120"]],template:function(t,r){t&1&&bg(0,"canvas",1,0)},styles:["[_nghost-%COMP%]{display:block;margin:8px auto;text-align:center}canvas[_ngcontent-%COMP%]{width:100%;max-width:400px;height:auto;border:1px solid #555;border-radius:6px;background:#111}"]})};var XW=`M 0.73,0.73
  C 0.73,0.73 595.16,1.10 595.16,1.10
    595.16,1.10 594.79,286.96 594.79,286.96
    594.79,286.96 2.20,286.60 2.20,286.60
    2.20,286.60 0.73,0.73 0.73,0.73 Z`;var YW=`M 404.02,0.81
           C 404.02,0.81 279.92,1.17 279.92,1.17
             279.92,1.17 262.47,3.51 262.47,3.51
             262.47,3.51 246.29,6.75 246.29,6.75
             246.29,6.75 236.93,10.17 236.93,10.17
             236.93,10.17 228.12,14.66 228.12,14.66
             228.12,14.66 218.77,20.06 218.77,20.06
             218.77,20.06 209.42,26.35 209.42,26.35
             209.42,26.35 199.52,33.91 199.52,33.91
             199.52,33.91 190.89,40.92 190.89,40.92
             190.89,40.92 178.84,50.99 178.84,50.99
             178.84,50.99 168.23,61.25 168.23,61.25
             168.23,61.25 165.71,57.83 165.71,57.83
             165.71,57.83 162.65,56.39 162.65,56.39
             162.65,56.39 157.98,56.03 157.98,56.03
             157.98,56.03 153.66,56.57 153.66,56.57
             153.66,56.57 148.08,59.63 148.08,59.63
             148.08,59.63 144.31,62.32 144.31,62.32
             144.31,62.32 142.51,65.38 142.51,65.38
             142.51,65.38 142.15,69.34 142.15,69.34
             142.15,69.34 142.33,76.35 142.51,76.35
             142.69,76.35 138.37,77.07 138.37,77.07
             138.37,77.07 134.77,77.79 134.77,77.79
             134.77,77.79 129.92,79.05 129.92,79.05
             129.92,79.05 125.24,80.31 125.24,80.31
             125.24,80.31 118.59,81.57 118.59,81.57
             118.59,81.57 111.39,83.37 111.39,83.37
             111.39,83.37 106.54,84.81 106.54,84.81
             106.54,84.81 98.62,87.51 98.62,87.51
             98.62,87.51 92.15,90.74 92.15,90.74
             92.15,90.74 86.21,92.72 86.21,92.72
             86.21,92.72 81.36,95.06 81.36,95.06
             81.36,95.06 75.06,97.76 75.06,97.76
             75.06,97.76 68.23,100.63 68.23,100.63
             68.23,100.63 63.91,102.97 63.91,102.97
             63.91,102.97 58.87,105.13 58.87,105.13
             58.87,105.13 53.66,107.83 53.66,107.83
             53.66,107.83 48.08,109.99 48.08,109.99
             48.08,109.99 44.30,111.07 44.30,111.07
             44.30,111.07 40.35,113.22 40.35,113.22
             40.35,113.22 36.39,115.56 36.39,115.56
             36.39,115.56 34.05,118.98 34.05,118.98
             34.05,118.98 33.33,122.04 33.33,122.04
             33.33,122.04 29.74,124.02 29.74,124.02
             29.74,124.02 27.04,127.79 27.04,127.79
             27.04,127.79 26.14,131.21 26.14,131.21
             26.14,131.21 24.88,134.63 24.88,134.63
             24.88,134.63 24.16,139.12 24.16,139.12
             24.16,139.12 23.08,142.90 23.08,142.90
             23.08,142.90 22.00,146.86 22.00,147.04
             22.00,147.22 20.20,151.89 20.20,151.89
             20.20,151.89 18.76,155.49 18.76,155.49
             18.76,155.49 16.61,158.19 16.61,158.19
             16.61,158.19 15.53,161.43 15.53,161.43
             15.53,161.43 13.19,165.56 13.19,165.56
             13.19,165.56 11.39,170.60 11.39,170.60
             11.39,170.60 9.77,176.18 9.77,176.18
             8.44,175.60 8.08,181.28 8.33,181.39
             8.33,181.39 8.33,187.69 8.33,187.69
             8.33,187.69 9.41,196.32 9.41,196.32
             9.41,196.32 10.49,201.18 10.49,201.36
             10.49,201.54 11.57,207.29 11.57,207.47
             11.57,207.65 11.93,211.79 11.93,211.79
             11.93,211.79 9.41,215.74 9.41,215.74
             9.41,215.74 7.97,220.06 7.97,220.06
             7.97,220.06 5.64,222.22 5.64,222.22
             5.64,222.22 2.04,226.18 2.04,226.18
             2.04,226.18 0.96,229.59 0.96,229.59
             0.96,229.59 1.32,233.19 1.32,233.19
             1.32,233.19 3.12,236.07 3.30,236.07
             3.48,236.07 5.64,237.87 5.81,237.87
             5.99,237.87 11.03,240.03 11.03,240.03
             11.03,240.03 15.71,242.18 15.71,242.18
             15.71,242.18 21.46,243.98 21.46,243.98
             21.46,243.98 25.06,244.70 25.24,244.70
             25.42,244.70 33.33,245.06 33.51,245.06
             33.69,245.06 37.47,245.42 37.47,245.42
             37.47,245.42 40.53,247.76 40.53,247.76
             40.53,247.76 42.33,249.74 42.33,249.74
             42.33,249.74 44.48,250.64 44.66,250.64
             44.84,250.64 49.52,250.82 49.52,250.82
             49.52,250.82 51.14,251.90 51.14,251.90
             51.14,251.90 52.58,253.33 52.58,253.33
             52.58,253.33 56.00,256.03 56.00,256.03
             56.00,256.03 59.23,258.37 59.23,258.37
             59.23,258.37 60.67,260.53 60.67,260.53
             60.67,260.53 64.09,262.33 64.09,262.33
             64.09,262.33 68.59,263.77 68.59,263.77
             68.59,263.77 72.36,264.31 72.36,264.31
             72.51,265.45 77.43,265.63 77.40,265.39
             77.40,265.39 81.18,265.57 81.18,265.57
             81.18,265.57 84.77,265.75 84.95,265.75
             85.13,265.75 88.55,266.10 88.55,266.10
             88.55,266.10 110.49,266.10 110.49,266.10
             110.49,266.10 115.53,263.95 115.53,263.95
             115.53,263.95 118.95,261.97 118.95,261.97
             118.95,261.97 122.18,259.81 122.18,259.81
             122.18,259.81 123.98,257.83 123.98,257.83
             123.98,257.83 127.04,255.67 127.04,255.67
             127.04,255.67 128.48,254.59 128.48,254.59
             128.48,254.59 135.49,254.95 135.49,254.95
             135.49,254.95 284.42,262.69 284.42,262.69
             284.42,262.69 287.29,266.28 287.29,266.28
             287.29,266.28 288.19,267.90 288.19,267.90
             288.19,267.90 290.89,268.98 290.89,268.98
             290.89,268.98 297.73,269.34 297.73,269.34
             297.73,269.34 316.79,270.06 316.79,270.06
             316.79,270.06 318.59,272.40 318.59,272.40
             318.59,272.40 321.65,275.28 321.65,275.28
             321.65,275.28 323.99,278.16 323.99,278.16
             323.99,278.16 327.22,280.13 327.22,280.13
             327.22,280.13 331.18,282.65 331.18,282.65
             331.18,282.65 336.76,285.35 336.76,285.35
             336.76,285.35 339.45,286.25 339.45,286.25
             339.45,286.25 344.67,287.15 344.67,287.15
             344.67,287.15 352.04,287.15 352.04,287.15
             352.04,287.15 358.16,287.51 358.16,287.51
             358.16,287.51 363.19,287.51 363.19,287.51
             363.19,287.51 376.32,287.51 376.32,287.51
             376.32,287.51 381.54,286.07 381.54,286.07
             381.54,286.07 388.91,281.57 388.91,281.57
             388.91,281.57 392.51,278.87 392.51,278.87
             392.51,278.87 396.11,273.84 396.11,273.84
             396.11,273.84 398.81,270.06 398.81,270.06
             398.81,270.06 401.50,265.75 401.50,265.75
             401.50,265.75 404.38,259.81 404.38,259.81
             404.38,259.81 407.62,253.15 407.62,253.15
             407.62,253.15 410.32,247.04 410.32,247.04
             410.32,247.04 411.40,242.72 411.40,242.72
             411.40,242.72 412.66,238.95 412.66,238.95
             412.66,238.95 419.85,236.97 419.85,236.97
             419.85,236.97 518.41,211.97 518.41,211.97
             518.41,211.97 519.31,216.82 519.31,216.82
             519.31,216.82 520.75,221.14 520.75,221.14
             520.75,221.14 523.63,224.92 523.63,224.92
             523.63,224.92 527.59,229.23 527.59,229.23
             527.59,229.23 531.36,230.67 531.36,230.67
             531.36,230.67 535.50,231.93 535.50,231.93
             535.50,231.93 539.46,232.65 539.46,232.65
             539.46,232.65 543.23,232.65 543.23,232.65
             543.23,232.65 550.43,233.19 550.43,233.19
             550.43,233.19 557.26,232.83 557.26,232.83
             557.26,232.83 563.74,233.01 563.74,233.01
             563.74,233.01 569.49,230.49 569.49,230.49
             569.49,230.49 573.45,225.28 573.45,225.28
             573.93,225.69 577.26,220.00 576.51,219.34
             576.51,219.34 578.49,214.49 578.49,214.49
             578.49,214.49 579.20,210.17 579.20,210.17
             579.20,210.17 580.10,204.23 580.10,204.23
             580.10,204.23 581.00,196.14 581.00,196.14
             581.00,196.14 582.08,191.10 582.08,191.10
             582.08,191.10 592.87,179.05 592.87,179.05
             592.87,179.05 593.77,176.89 593.77,176.89
             593.77,176.89 593.77,173.48 593.77,173.48
             593.77,173.48 593.23,170.06 593.23,170.06
             593.23,170.06 592.33,164.84 592.33,164.84
             592.33,164.84 592.33,158.01 592.33,158.01
             592.33,158.01 593.23,152.25 593.23,152.25
             593.23,152.25 594.85,143.98 594.85,143.98
             594.85,143.98 595.75,137.51 595.75,137.51
             595.75,137.51 595.57,131.57 595.57,131.57
             595.57,131.57 593.23,123.66 593.23,123.66
             593.23,123.66 592.51,118.62 592.51,118.62
             592.51,118.62 589.64,112.87 589.64,112.87
             589.64,112.87 588.92,109.99 588.92,109.99
             588.92,109.99 589.64,95.60 589.64,95.60
             589.64,95.60 590.00,89.66 590.00,89.66
             590.00,89.66 590.36,86.25 590.36,86.25
             590.36,86.25 588.74,83.73 588.74,83.73
             588.74,83.73 586.76,82.11 586.76,82.11
             586.76,82.11 584.06,81.39 584.06,81.39
             584.06,81.39 581.18,80.67 581.18,80.67
             581.18,80.67 578.67,77.61 578.67,77.61
             578.67,77.61 574.35,72.76 574.35,72.76
             574.35,72.76 570.21,68.62 570.21,68.62
             570.21,68.62 567.15,64.84 567.15,64.84
             567.15,64.84 563.20,60.53 563.20,60.53
             563.20,60.53 559.42,57.29 559.42,57.29
             559.42,57.29 556.18,54.41 556.18,54.41
             556.18,54.41 553.48,51.17 553.48,51.17
             553.48,51.17 547.73,46.50 547.73,46.50
             547.73,46.50 543.77,42.90 543.77,42.90
             543.77,42.90 540.71,40.38 540.71,40.38
             540.71,40.38 536.94,38.04 536.94,38.04
             536.94,38.04 531.90,33.73 531.90,33.73
             531.90,33.73 528.30,30.31 528.30,30.31
             528.30,30.31 524.53,28.33 524.53,28.33
             524.53,28.33 520.93,25.27 520.93,25.27
             520.93,25.27 517.15,22.76 517.15,22.76
             517.15,22.76 513.56,20.24 513.56,20.24
             513.56,20.24 509.78,18.26 509.78,18.26
             509.78,18.26 505.28,15.20 505.28,15.20
             505.28,15.20 500.79,12.86 500.79,12.86
             500.79,12.86 495.57,10.71 495.57,10.71
             495.57,10.71 488.02,8.01 488.02,8.01
             488.02,8.01 484.24,6.21 484.24,6.21
             484.24,6.21 479.38,4.23 479.38,4.23
             479.38,4.23 471.11,2.25 471.11,2.25
             471.11,2.25 465.35,1.71 465.35,1.71
             465.35,1.71 460.68,1.17 460.68,1.17
             460.68,1.17 404.02,0.81 404.02,0.81 Z`;var fle=["video"],mle=["canvas"],hle=["overlayCanvas"],gle=["startBtn"];function xle(n,e){if(n&1){let t=ef();kt(0,"div",20),Mr(1,"img",21),kt(2,"div",22)(3,"button",23),mo("click",function(){uo(t);let o=Ha();return lo(o.capturedImage.set(null))}),nr(4,"\u21BB Retry"),Ht(),kt(5,"button",24),mo("click",function(){uo(t);let o=Ha();return lo(o.usePhoto())}),nr(6,"\u2714 Use photo"),Ht()()()}if(n&2){let t=e.ngIf;Ln(),Or("src",t,IC)}}function yle(n,e){if(n&1){let t=ef();kt(0,"div",25)(1,"div",26),nr(2," Proportion: "),kt(3,"span"),nr(4),Ht(),Mr(5,"app-chart",27),Ht(),kt(6,"div",28)(7,"label"),nr(8),wg(9,"number"),kt(10,"input",29),mo("input",function(o){uo(t);let s=Ha();return lo(s.setNearThreshold(o.target.value))}),Ht()(),kt(11,"label"),nr(12),wg(13,"number"),kt(14,"input",30),mo("input",function(o){uo(t);let s=Ha();return lo(s.setFarThreshold(o.target.value))}),Ht()()()()}if(n&2){let t=Ha();Ln(4),nf(t.proportion()!==null?t.proportion():"N/A"),Ln(),Or("newValue",t.proportion())("nearThreshold",t.nearThreshold())("farThreshold",t.farThreshold()),Ln(3),Yl(" Near threshold (",Ig(9,8,t.nearThreshold(),"1.2-2"),") "),Ln(2),Or("value",t.nearThreshold()),Ln(2),Yl(" Far threshold (",Ig(13,11,t.farThreshold(),"1.2-2"),") "),Ln(2),Or("value",t.farThreshold())}}var Nb=class n{videoRef;canvasRef;overlayCanvasRef;startBtnRef;feedback=Pn("Loading ODM...");detections=Pn([]);proportion=Pn(null);capturedImage=Pn(null);showDetections=Pn(!1);showBoxes=Pn(!1);nearThreshold=Pn(.9);farThreshold=Pn(.7);ctx;overlayCtx;model;detectionTimer;stream=null;marcoPath;rectPath;rectScaleX=1;rectScaleY=1;frontLeftOutlinePathData=new Path2D(YW);rectPathData=new Path2D(XW);svgWidth=597;svgHeight=289;async ngAfterViewInit(){try{this.feedback.set("Requesting camera access..."),this.stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}}),this.feedback.set("Camera ready. Press START.")}catch(e){console.error(e),this.feedback.set("\u274C Couldn't access the camera.");return}}ngOnDestroy(){this.detectionTimer&&clearInterval(this.detectionTimer),this.stream&&this.stream.getTracks().forEach(e=>e.stop())}toggleDetections(){this.showDetections.update(e=>!e)}toggleBoxes(){this.showBoxes.update(e=>!e)}setNearThreshold(e){this.nearThreshold.set(Number(e))}setFarThreshold(e){this.farThreshold.set(Number(e))}createScaledPath(e,t,r){let o=t*.08,s=r*.08,i=t-2*o,a=r-2*s,c=i/this.svgWidth,u=a/this.svgHeight,l=this.svgWidth*c,p=this.svgHeight*u,d=o+(i-l)/2,f=16,m=new Path2D;return m.addPath(e,new DOMMatrix().translate(d,f).scale(c,u)),{path:m,scaleX:c,scaleY:u,offsetX:d,offsetY:f,scaledWidth:l,scaledHeight:p}}async startCapture(){let e=this.startBtnRef?.nativeElement;e&&(e.style.display="none"),await this.requestFullscreenAndOrientation(),await this.initCameraAndCanvases(),await this.loadModel(),this.initReferenceShapes(),this.runDetectionLoop()}async requestFullscreenAndOrientation(){try{await(document.documentElement.requestFullScreen?.()||document.documentElement.webkitRequestFullscreen?.()||document.documentElement.mozRequestFullScreen?.()||document.documentElement.msRequestFullscreen?.())}catch(e){console.warn("Can't force fullscreen/orientation:",e)}}async initCameraAndCanvases(){if(!this.stream){this.feedback.set("\u274C No camera stream.");return}let e=this.videoRef.nativeElement,t=this.canvasRef.nativeElement,r=this.overlayCanvasRef.nativeElement;e.srcObject=this.stream,await new Promise(o=>{e.onloadedmetadata=()=>{t.width=e.videoWidth,t.height=e.videoHeight,r.width=e.videoWidth,r.height=e.videoHeight,this.ctx=t.getContext("2d"),this.overlayCtx=r.getContext("2d"),o()}}),this.overlayCtx.clearRect(0,0,r.width,r.height)}async loadModel(){this.feedback.set("Loading model..."),this.model=await ZW.load({base:"mobilenet_v2"}),this.feedback.set("ODM completely loaded. Press Start to search car...")}initReferenceShapes(){let e=this.overlayCanvasRef.nativeElement,t=e.width,r=e.height,o=this.createScaledPath(this.rectPathData,t,r);this.rectPath=o.path,this.rectScaleX=o.scaleX,this.rectScaleY=o.scaleY;let s=this.createScaledPath(this.frontLeftOutlinePathData,t,r);this.marcoPath=s.path,this.overlayCtx.clearRect(0,0,t,r),this.overlayCtx.save(),this.overlayCtx.fillStyle="rgba(39, 39, 39, 0.50)",this.overlayCtx.fillRect(0,0,e.width,e.height),this.overlayCtx.globalCompositeOperation="destination-out",this.overlayCtx.fill(this.marcoPath),this.overlayCtx.globalCompositeOperation="source-over",this.showBoxes()?this.overlayCtx.strokeStyle="rgba(255, 255, 0, 1)":this.overlayCtx.strokeStyle="rgba(255, 255, 0, 0)",this.overlayCtx.lineWidth=0,this.overlayCtx.stroke(this.rectPath),this.overlayCtx.strokeStyle="white",this.overlayCtx.lineWidth=1,this.overlayCtx.setLineDash([]),this.overlayCtx.stroke(this.marcoPath),this.overlayCtx.restore()}runDetectionLoop(){let e=this.canvasRef.nativeElement,t=this.overlayCanvasRef.nativeElement,r=this.videoRef.nativeElement;this.detectionTimer=setInterval(async()=>{this.ctx.drawImage(r,0,0,e.width,e.height);let o=await this.model.detect(e);this.detections.set(o.map(i=>`${i.class} (${(i.score*100).toFixed(1)}%)`)),this.overlayCtx.clearRect(0,0,t.width,t.height),this.overlayCtx.save(),this.overlayCtx.fillStyle="rgba(39, 39, 39, 0.50)",this.overlayCtx.fillRect(0,0,t.width,t.height),this.overlayCtx.globalCompositeOperation="destination-out",this.overlayCtx.fill(this.marcoPath),this.overlayCtx.globalCompositeOperation="source-over",this.showBoxes()?this.overlayCtx.strokeStyle="rgba(255, 255, 0, 1)":this.overlayCtx.strokeStyle="rgba(255, 255, 0 , 0)",this.overlayCtx.lineWidth=1,this.overlayCtx.stroke(this.rectPath),this.overlayCtx.strokeStyle="white",this.overlayCtx.lineWidth=1,this.overlayCtx.setLineDash([]),this.overlayCtx.stroke(this.marcoPath),this.overlayCtx.restore(),this.showBoxes()&&o.forEach(i=>{let[a,c,u,l]=i.bbox;this.overlayCtx.strokeStyle="red",this.overlayCtx.lineWidth=2,this.overlayCtx.strokeRect(a,c,u,l),this.overlayCtx.fillStyle="red",this.overlayCtx.font="16px monospace";let p=c>20?c-6:c+16;this.overlayCtx.fillText(`${i.class} ${(i.score*100).toFixed(1)}%`,a,p)});let s=o.find(i=>["car","truck","bus"].includes(i.class));if(s){let[i,a,c,u]=s.bbox,l=[[i,a],[i+c,a],[i,a+u],[i+c,a+u]].every(([h,g])=>this.overlayCtx.isPointInPath(this.rectPath,h,g)),p=c*u,d=this.svgWidth*this.rectScaleX*(this.svgHeight*this.rectScaleY),f=p/d;this.proportion.set(+f.toFixed(3));let m=f;!l||m>this.nearThreshold()?this.feedback.set("Adjust the framing or step back a little. \u{1F697}\u2B05\uFE0F"):m<this.farThreshold()?this.feedback.set("You're too far \u{1F697}\u27A1\uFE0F"):(this.feedback.set("Perfect! Don't move, capturing... \u{1F4F8}"),this.capturedImage()||this.capturePhoto())}else this.feedback.set("I cannot detect the car, adjust the framing."),this.proportion.set(null)},1e3)}capturePhoto(){let e=this.videoRef.nativeElement,t=document.createElement("canvas");t.width=e.videoWidth,t.height=e.videoHeight;let r=t.getContext("2d"),o=e.videoWidth/e.videoHeight,s=this.overlayCanvasRef.nativeElement.width/this.overlayCanvasRef.nativeElement.height,i=0,a=0,c=e.videoWidth,u=e.videoHeight;o>s?(c=e.videoHeight*s,i=(e.videoWidth-c)/2):(u=e.videoWidth/s,a=(e.videoHeight-u)/2),r&&(r.drawImage(e,i,a,c,u,0,0,t.width,t.height),this.capturedImage.set(t.toDataURL("image/png")))}usePhoto(){alert("Foto confirmada \u2705")}static \u0275fac=function(t){return new(t||n)};static \u0275cmp=Ua({type:n,selectors:[["app-camera"]],viewQuery:function(t,r){if(t&1&&(Os(fle,5),Os(mle,5),Os(hle,5),Os(gle,5)),t&2){let o;Ms(o=$s())&&(r.videoRef=o.first),Ms(o=$s())&&(r.canvasRef=o.first),Ms(o=$s())&&(r.overlayCanvasRef=o.first),Ms(o=$s())&&(r.startBtnRef=o.first)}},decls:31,vars:5,consts:[["startBtn",""],["video",""],["canvas",""],["overlayCanvas",""],["id","startBtn",3,"click"],["id","video","autoplay","","playsinline",""],["id","canvas",2,"display","none"],["id","overlayCanvas"],["class","photo-preview",4,"ngIf"],["id","feedback"],[1,"toggle-panel"],[1,"toggle-item"],[1,"switch"],["type","checkbox",3,"change","checked"],[1,"slider"],[1,"toggle-label"],["class","detections-area",4,"ngIf"],[1,"orientation-warning"],[1,"orientation-content"],[1,"phone-icon"],[1,"photo-preview"],["alt","Captured photo",3,"src"],[1,"photo-actions"],[1,"retry",3,"click"],[1,"confirm",3,"click"],[1,"detections-area"],["id","proportionBox"],[3,"newValue","nearThreshold","farThreshold"],[1,"slider-group"],["type","range","min","0.81","max","1","step","0.01",1,"slider-near",3,"input","value"],["type","range","min","0.5","max","0.8","step","0.01",1,"slider-far",3,"input","value"]],template:function(t,r){if(t&1){let o=ef();kt(0,"button",4,0),mo("click",function(){return uo(o),lo(r.startCapture())}),nr(2,"Start capture"),Ht(),Mr(3,"video",5,1)(5,"canvas",6,2)(7,"canvas",7,3),Zd(9,xle,7,1,"div",8),kt(10,"div",9),nr(11),Ht(),kt(12,"div",10)(13,"div",11)(14,"label",12)(15,"input",13),mo("change",function(){return uo(o),lo(r.toggleDetections())}),Ht(),Mr(16,"span",14),Ht(),kt(17,"span",15),nr(18,"Show detections and proportions"),Ht()(),kt(19,"div",11)(20,"label",12)(21,"input",13),mo("change",function(){return uo(o),lo(r.toggleBoxes())}),Ht(),Mr(22,"span",14),Ht(),kt(23,"span",15),nr(24,"Show bounding boxes"),Ht()()(),Zd(25,yle,15,14,"div",16),kt(26,"div",17)(27,"div",18),Mr(28,"div",19),kt(29,"p"),nr(30,"Please turn your device to landscape orientation to continue."),Ht()()()}t&2&&(Ln(9),Or("ngIf",r.capturedImage()),Ln(2),nf(r.feedback()),Ln(4),Or("checked",r.showDetections()),Ln(6),Or("checked",r.showBoxes()),Ln(4),Or("ngIf",r.showDetections()))},dependencies:[Dg,uw,Sb,lw],styles:['[_nghost-%COMP%]{display:block;background:#000;height:100vh;width:100vw;overflow:hidden;position:relative}#video[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100vw;height:100vh;object-fit:cover}#overlayCanvas[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100vw;height:100vh;pointer-events:none}#startBtn[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:15px 30px;font-size:18px;z-index:1000;border-radius:10px;border:none;background:#32cd32;color:#fff;cursor:pointer}#feedback[_ngcontent-%COMP%]{position:fixed;bottom:0;left:0;width:100%;background:#000000b3;color:#fff;text-align:center;padding:12px 0;font-size:18px;font-weight:500;z-index:9999}#detections[_ngcontent-%COMP%]{position:absolute;top:20px;left:20px;padding:10px;background:#0009;color:#0f0;font-family:monospace;font-size:14px;border-radius:8px;max-width:50%;max-height:30%;overflow-y:auto;white-space:pre-wrap}#proportionBox[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:100%;padding:0;background:#0009;color:#0ff;font-family:monospace;font-size:14px;border-radius:8px}#proportionBox[_ngcontent-%COMP%]   canvas[_ngcontent-%COMP%]{display:block;margin-top:8px;background:#111;border:1px solid #0ff;border-radius:4px}.orientation-warning[_ngcontent-%COMP%]{display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000000e6;color:#fff;z-index:9999;display:flex;justify-content:center;align-items:center;text-align:center;padding:20px}@media only screen and (orientation: portrait){.orientation-warning[_ngcontent-%COMP%]{display:flex}}@media only screen and (orientation: landscape){.orientation-warning[_ngcontent-%COMP%]{display:none}}.orientation-content[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center}.phone-icon[_ngcontent-%COMP%]{width:60px;height:100px;border:4px solid white;border-radius:12px;position:relative;margin-bottom:20px;animation:_ngcontent-%COMP%_rotatePhone 2s infinite ease-in-out}.phone-icon[_ngcontent-%COMP%]:after{content:"";position:absolute;bottom:8px;left:50%;transform:translate(-50%);width:12px;height:12px;border:2px solid white;border-radius:50%}@keyframes _ngcontent-%COMP%_rotatePhone{0%{transform:rotate(0)}30%{transform:rotate(0)}50%{transform:rotate(90deg)}80%{transform:rotate(90deg)}to{transform:rotate(0)}}.orientation-warning[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:18px;font-weight:700;max-width:300px}.toggle-panel[_ngcontent-%COMP%]{position:absolute;top:15px;right:15px;display:flex;flex-direction:column;gap:10px;z-index:1000}.toggle-item[_ngcontent-%COMP%]{display:flex;align-items:center;gap:8px;color:#fff;font-family:sans-serif}.switch[_ngcontent-%COMP%]{position:relative;display:inline-block;width:50px;height:28px}.switch[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{opacity:0;width:0;height:0}.slider[_ngcontent-%COMP%]{position:absolute;cursor:pointer;inset:0;background-color:#aaa;transition:.3s;border-radius:28px}.slider[_ngcontent-%COMP%]:before{position:absolute;content:"";height:20px;width:20px;left:4px;bottom:4px;background-color:#fff;transition:.3s;border-radius:50%}input[_ngcontent-%COMP%]:checked + .slider[_ngcontent-%COMP%]{background-color:#4caf50}input[_ngcontent-%COMP%]:checked + .slider[_ngcontent-%COMP%]:before{transform:translate(22px)}.photo-preview[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;background:#000000d9;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:2000}.photo-preview[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{max-width:90%;max-height:60%;border-radius:12px;box-shadow:0 4px 12px #00000080;margin-bottom:20px}.photo-actions[_ngcontent-%COMP%]{display:flex;gap:20px}.photo-actions[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{padding:10px 20px;border:none;border-radius:8px;font-size:16px;font-weight:500;cursor:pointer}button.retry[_ngcontent-%COMP%]{background:#444;color:#fff}button.confirm[_ngcontent-%COMP%]{background:#2ecc71;color:#fff}.detections-area[_ngcontent-%COMP%]{position:absolute;width:30%;top:8;left:8;background:#0009;padding:10px;border-right:1px solid #444;border-bottom:1px solid #444;display:flex;flex-direction:column;align-items:flex-start;gap:12px;z-index:1000}.detections-area[_ngcontent-%COMP%]   app-chart[_ngcontent-%COMP%]{width:100%}.slider-group[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:8px;width:100%;color:#0ff;font-size:14px;font-family:monospace}.slider-group[_ngcontent-%COMP%]   input[type=range][_ngcontent-%COMP%]{width:100%}.slider-near[_ngcontent-%COMP%]{background:#e74c3c66}.slider-near[_ngcontent-%COMP%]::-webkit-slider-thumb{background:#e74c3c}.slider-near[_ngcontent-%COMP%]::-moz-range-thumb{background:#e74c3c}.slider-far[_ngcontent-%COMP%]{background:#f39c1266}.slider-far[_ngcontent-%COMP%]::-webkit-slider-thumb{background:#f39c12}.slider-far[_ngcontent-%COMP%]::-moz-range-thumb{background:#f39c12}']})};var Db=class n{title=Pn("guided-image-capture");static \u0275fac=function(t){return new(t||n)};static \u0275cmp=Ua({type:n,selectors:[["app-root"]],decls:1,vars:0,template:function(t,r){t&1&&Mr(0,"app-camera")},dependencies:[Nb],encapsulation:2})};bw(Db,l2).catch(n=>console.error(n));
