var Mj=Object.create;var Fd=Object.defineProperty,Oj=Object.defineProperties,$j=Object.getOwnPropertyDescriptor,Pj=Object.getOwnPropertyDescriptors,Lj=Object.getOwnPropertyNames,n1=Object.getOwnPropertySymbols,Bj=Object.getPrototypeOf,o1=Object.prototype.hasOwnProperty,Vj=Object.prototype.propertyIsEnumerable;var r1=(n,e,t)=>e in n?Fd(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Rt=(n,e)=>{for(var t in e||={})o1.call(e,t)&&r1(n,t,e[t]);if(n1)for(var t of n1(e))Vj.call(e,t)&&r1(n,t,e[t]);return n},Lt=(n,e)=>Oj(n,Pj(e));var D=(n,e)=>()=>(n&&(e=n(n=0)),e);var rr=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),Ue=(n,e)=>{for(var t in e)Fd(n,t,{get:e[t],enumerable:!0})},s1=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of Lj(e))!o1.call(n,o)&&o!==t&&Fd(n,o,{get:()=>e[o],enumerable:!(r=$j(e,o))||r.enumerable});return n};var Nh=(n,e,t)=>(t=n!=null?Mj(Bj(n)):{},s1(e||!n||!n.__esModule?Fd(t,"default",{value:n,enumerable:!0}):t,n)),i1=n=>s1(Fd({},"__esModule",{value:!0}),n);function Hn(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}var js,To,Yw=D(()=>{"use strict";js=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},To=class{refCount(e){return Hn("refCount")}incRef(e){return Hn("incRef")}timerAvailable(){return!0}time(e){return Hn("time")}read(e){return Hn("read")}readSync(e){return Hn("readSync")}readToGPU(e,t){return Hn("readToGPU")}numDataIds(){return Hn("numDataIds")}disposeData(e,t){return Hn("disposeData")}write(e,t,r){return Hn("write")}move(e,t,r,o,s){return Hn("move")}createTensorFromGPUData(e,t,r){return Hn("createTensorFromGPUData")}memory(){return Hn("memory")}floatPrecision(){return Hn("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Hn("dispose")}}});function jA(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Zg(n,e,t)}function v9(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,r=0;for(;t>0;)r=Math.random()*t|0,t--,Zg(n,t,r),Zg(e,t,r)}function dp(n,e,t){return Math.max(n,Math.min(e,t))}function b9(n){return n%2===0?n:n+1}function Zg(n,e,t){let r=n[e];n[e]=n[t],n[t]=r}function C9(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function w9(n,e){let t=Math.random();return e*t+(1-t)*n}function I9(n,e){let t=0;for(let r=0;r<n.length;r++){let o=Number(n[r])-Number(e[r]);t+=o*o}return t}function k(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function it(n,e,t=""){k(wn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function ar(n){k(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Ne(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function E9(n){return n.length===0}function Zw(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function wn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Jo(n){return n%1===0}function T9(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{let e=Math.exp(2*n);return(e-1)/(e+1)}}function S9(n){let e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function N9(n){let e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return jA(e),e}function Ja(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function D9(n,e=o=>0,t,r){return new Promise((o,s)=>{let i=0,a=()=>{if(n()){o();return}i++;let c=e(i);if(t!=null&&i>=t){s();return}r!=null?r(a,c):setTimeout(a,c)};a()})}function k9(n,e){let t=1,r=-1;for(let s=0;s<n.length;++s)if(n[s]>=0)t*=n[s];else if(n[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(n[s]<0)throw Error(`Shapes can not be < 0. Found ${n[s]} at dim ${s}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);let o=n.slice();return o[r]=e/t,o}function qs(n,e){let t=e.length;return n=n==null?e.map((r,o)=>o):[].concat(n),k(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),k(n.every(r=>Jo(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function Qw(n,e){let t=[],r=[],o=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||o?null:qs(e,n).sort(),i=0;for(let a=0;a<n.length;++a){if(s!=null){if(s[i]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(s[i]==null||s[i]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),s[i]<=a&&i++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function Jw(n,e){return Qg(n,e)}function Qg(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function eI(n,e){for(let t=0;t<n.length;t++){let r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function tI(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function _9(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function fp(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function nI(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Wr(n){return typeof n=="string"||n instanceof String}function qA(n){return typeof n=="boolean"}function KA(n){return typeof n=="number"}function Ks(n){return Array.isArray(n)?Ks(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":KA(n)?"float32":Wr(n)?"string":qA(n)?"bool":"float32"}function So(n){return!!(n&&n.constructor&&n.call&&n.apply)}function mp(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function No(n){let e=n.length;if(e<2)return[];let t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function XA(n,e,t,r=!1){let o=new Array;if(e.length===1){let s=e[0]*(r?2:1);for(let i=0;i<s;i++)o[i]=t[n+i]}else{let s=e[0],i=e.slice(1),a=i.reduce((c,l)=>c*l)*(r?2:1);for(let c=0;c<s;c++)o[c]=XA(n+c*a,i,t,r)}return o}function Qa(n,e,t=!1){if(n.length===0)return e[0];let r=n.reduce((o,s)=>o*s)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return XA(0,n,e,t)}function A9(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function Ff(n,e){let t=hp(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function hp(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function R9(n,e){let t=n.reduce((r,o)=>r*o,1);if(e==null||e==="float32")return Qa(n,new Float32Array(t));if(e==="int32")return Qa(n,new Int32Array(t));if(e==="bool")return Qa(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function dt(n){n.forEach(e=>{k(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function F9(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let o=0;o<n.length-1;++o)r+=t[o]*n[o];return r}function M9(n,e,t){if(e===0)return[];if(e===1)return[n];let r=new Array(e);for(let o=0;o<r.length-1;++o)r[o]=Math.floor(n/t[o]),n-=r[o]*t[o];return r[r.length-1]=n,r}function ec(n){return n&&n.then&&typeof n.then=="function"}var Bt=D(()=>{"use strict";});function $9(n){let e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(P9(e,r[0],r[1]),r.join("="))),e}function P9(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function L9(n,e){let t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function O(){return Jg}function ZA(n){Jg=n}var YA,gp,Jg,Yt=D(()=>{"use strict";Bt();YA="tfjsflags",gp=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=$9,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(O().getBool("IS_TEST")||O().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){let o=this.urlFlags[e];O().getBool("IS_TEST")||O().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(ec(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);YA in e&&e[YA].split(",").forEach(r=>{let[o,s]=r.split(":");this.urlFlags[o]=L9(o,s)})}};Jg=null});function oI(){if(rI==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");rI=n}return rI}function B9(){let n=oI();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Mf(n,e){let t=B9();if(t.has(n))return t.get(n);{let r=e();return t.set(n,r),t.get(n)}}var rI,ex=D(()=>{"use strict";});var tc,Xs,Ys,es,nc,xp,yp,rc,oc,Zs,Qs,Js,ei,ti,sc,Of,ic,$f,ac,cc,lc,ni,V9,uc,ts,ri,oi,pc,dc,fc,mc,hc,gc,xc,Pf,yc,vc,si,bc,Cc,wc,Ic,Ec,Tc,Sc,Nc,Dc,kc,tx,nx,vp,ii,_c,Ac,Lf,Rc,ai,Fc,Mc,ci,bp,Oc,$c,li,ui,Pc,Lc,Bc,pi,di,ns,Vc,Uc,fi,mi,hi,zc,gi,xi,Hc,Gc,yi,vi,bi,Ci,U9,z9,H9,Cp,Bf,G9,wp,wi,Wc,Vf,jc,Uf,qc,Kc,Ip,Ii,Xc,Yc,Zc,Ei,Ep,Ti,Qc,Jc,el,tl,nl,rl,ol,W9,sl,il,al,cl,ll,ul,pl,dl,Si,Ni,fl,ml,zf,hl,Hf,Di,gl,ki,_i,xl,yl,vl,bl,Ai,Cl,wl,Ri,Fi,Mi,Oi,$i,Tp,Il,El,Tl,Sl,Nl,Dl,kl,_l,Pi,Gf,Li,Al,Rl,Fl,Ml,Ol,$l,Bi,rs,Pl,Ll,os,Bl,Vl,Ul,j9,zl,Vi,Sp,Hl,Ui,zi,Hi,G=D(()=>{"use strict";tc="Abs",Xs="Acos",Ys="Acosh",es="Add",nc="AddN",xp="All",yp="Any",rc="ArgMax",oc="ArgMin",Zs="Asin",Qs="Asinh",Js="Atan",ei="Atanh",ti="Atan2",sc="AvgPool",Of="AvgPoolGrad",ic="AvgPool3D",$f="AvgPool3DGrad",ac="BatchMatMul",cc="BatchToSpaceND",lc="Bincount",ni="BitwiseAnd",V9="BroadcastTo",uc="BroadcastArgs",ts="Cast",ri="Ceil",oi="ClipByValue",pc="Complex",dc="ComplexAbs",fc="Concat",mc="Conv2D",hc="Conv2DBackpropFilter",gc="Conv2DBackpropInput",xc="Conv3D",Pf="Conv3DBackpropFilterV2",yc="Conv3DBackpropInputV2",vc="Cos",si="Cosh",bc="Cumprod",Cc="Cumsum",wc="CropAndResize",Ic="DenseBincount",Ec="DepthToSpace",Tc="DepthwiseConv2dNative",Sc="DepthwiseConv2dNativeBackpropFilter",Nc="DepthwiseConv2dNativeBackpropInput",Dc="Diag",kc="Dilation2D",tx="Dilation2DBackpropInput",nx="Dilation2DBackpropFilter",vp="Draw",ii="RealDiv",_c="Einsum",Ac="Elu",Lf="EluGrad",Rc="Erf",ai="Equal",Fc="Exp",Mc="ExpandDims",ci="Expm1",bp="FFT",Oc="Fill",$c="FlipLeftRight",li="Floor",ui="FloorDiv",Pc="FusedBatchNorm",Lc="GatherV2",Bc="GatherNd",pi="Greater",di="GreaterEqual",ns="Identity",Vc="IFFT",Uc="Imag",fi="IsFinite",mi="IsInf",hi="IsNan",zc="LeakyRelu",gi="Less",xi="LessEqual",Hc="LinSpace",Gc="Log",yi="Log1p",vi="LogicalAnd",bi="LogicalNot",Ci="LogicalOr",U9="LogicalXor",z9="LogSoftmax",H9="LowerBound",Cp="LRN",Bf="LRNGrad",G9="MatrixBandPart",wp="Max",wi="Maximum",Wc="MaxPool",Vf="MaxPoolGrad",jc="MaxPool3D",Uf="MaxPool3DGrad",qc="MaxPoolWithArgmax",Kc="Mean",Ip="Min",Ii="Minimum",Xc="MirrorPad",Yc="Mod",Zc="Multinomial",Ei="Multiply",Ep="Neg",Ti="NotEqual",Qc="NonMaxSuppressionV3",Jc="NonMaxSuppressionV4",el="NonMaxSuppressionV5",tl="OnesLike",nl="OneHot",rl="Pack",ol="PadV2",W9="Pool",sl="Pow",il="Prelu",al="Prod",cl="RaggedGather",ll="RaggedRange",ul="RaggedTensorToTensor",pl="Range",dl="Real",Si="Reciprocal",Ni="Relu",fl="Reshape",ml="ResizeNearestNeighbor",zf="ResizeNearestNeighborGrad",hl="ResizeBilinear",Hf="ResizeBilinearGrad",Di="Relu6",gl="Reverse",ki="Round",_i="Rsqrt",xl="ScatterNd",yl="TensorScatterUpdate",vl="SearchSorted",bl="Select",Ai="Selu",Cl="Slice",wl="Sin",Ri="Sinh",Fi="Sign",Mi="Sigmoid",Oi="Softplus",$i="Sqrt",Tp="Sum",Il="SpaceToBatchND",El="SplitV",Tl="Softmax",Sl="SparseFillEmptyRows",Nl="SparseReshape",Dl="SparseSegmentMean",kl="SparseSegmentSum",_l="SparseToDense",Pi="SquaredDifference",Gf="Square",Li="StaticRegexReplace",Al="StridedSlice",Rl="StringNGrams",Fl="StringSplit",Ml="StringToHashBucketFast",Ol="Sub",$l="Tan",Bi="Tanh",rs="Tile",Pl="TopK",Ll="Transform",os="Transpose",Bl="Unique",Vl="Unpack",Ul="UnsortedSegmentSum",j9="UpperBound",zl="ZerosLike",Vi="Step",Sp="FromPixels",Hl="RotateWithOffset",Ui="_FusedMatMul",zi="FusedConv2D",Hi="FusedDepthwiseConv2D"});function Do(...n){O().getBool("IS_TEST")||O().getBool("PROD")||console.warn(...n)}function q9(...n){O().getBool("IS_TEST")||O().getBool("PROD")||console.log(...n)}var rx=D(()=>{"use strict";Yt();});function Gl(n,e){let t=sI(n,e);return Np.get(t)}function ox(n){return Wf.get(n)}function jf(n){let e=Np.entries(),t=[];for(;;){let{done:r,value:o}=e.next();if(r)break;let[s,i]=o,[a]=s.split("_");a===n&&t.push(i)}return t}function Dp(n){let{kernelName:e,backendName:t}=n,r=sI(e,t);Np.has(r)&&Do(`The kernel '${e}' for backend '${t}' is already registered`),Np.set(r,n)}function K9(n){let{kernelName:e}=n;Wf.has(e)&&O().getBool("DEBUG")&&Do(`Overriding the gradient for '${e}'`),Wf.set(e,n)}function X9(n,e){let t=sI(n,e);if(!Np.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Np.delete(t)}function Y9(n){if(!Wf.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Wf.delete(n)}function Z9(n,e){jf(n).forEach(r=>{let o=Object.assign({},r,{backendName:e});Dp(o)})}function sI(n,e){return`${e}_${n}`}var Np,Wf,sx=D(()=>{"use strict";Yt();ex();rx();Np=Mf("kernelRegistry",()=>new Map),Wf=Mf("gradRegistry",()=>new Map)});function ix(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var iI=D(()=>{"use strict";});var lR=rr((rIe,cR)=>{"use strict";cR.exports=yt;var br=null;try{br=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function yt(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}yt.prototype.__isLong__;Object.defineProperty(yt.prototype,"__isLong__",{value:!0});function Wn(n){return(n&&n.__isLong__)===!0}yt.isLong=Wn;var JA={},eR={};function jl(n,e){var t,r,o;return e?(n>>>=0,(o=0<=n&&n<256)&&(r=eR[n],r)?r:(t=vt(n,(n|0)<0?-1:0,!0),o&&(eR[n]=t),t)):(n|=0,(o=-128<=n&&n<128)&&(r=JA[n],r)?r:(t=vt(n,n<0?-1:0,!1),o&&(JA[n]=t),t))}yt.fromInt=jl;function Cr(n,e){if(isNaN(n))return e?Wl:wr;if(e){if(n<0)return Wl;if(n>=oR)return aR}else{if(n<=-nR)return Gn;if(n+1>=nR)return iR}return n<0?Cr(-n,e).neg():vt(n%_p|0,n/_p|0,e)}yt.fromNumber=Cr;function vt(n,e,t){return new yt(n,e,t)}yt.fromBits=vt;var ax=Math.pow;function cI(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return wr;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return cI(n.substring(1),e,t).neg();for(var o=Cr(ax(t,8)),s=wr,i=0;i<n.length;i+=8){var a=Math.min(8,n.length-i),c=parseInt(n.substring(i,i+a),t);if(a<8){var l=Cr(ax(t,a));s=s.mul(l).add(Cr(c))}else s=s.mul(o),s=s.add(Cr(c))}return s.unsigned=e,s}yt.fromString=cI;function jr(n,e){return typeof n=="number"?Cr(n,e):typeof n=="string"?cI(n,e):vt(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}yt.fromValue=jr;var tR=65536,Q9=1<<24,_p=tR*tR,oR=_p*_p,nR=oR/2,rR=jl(Q9),wr=jl(0);yt.ZERO=wr;var Wl=jl(0,!0);yt.UZERO=Wl;var kp=jl(1);yt.ONE=kp;var sR=jl(1,!0);yt.UONE=sR;var aI=jl(-1);yt.NEG_ONE=aI;var iR=vt(-1,2147483647,!1);yt.MAX_VALUE=iR;var aR=vt(-1,-1,!0);yt.MAX_UNSIGNED_VALUE=aR;var Gn=vt(0,-2147483648,!1);yt.MIN_VALUE=Gn;var ie=yt.prototype;ie.toInt=function(){return this.unsigned?this.low>>>0:this.low};ie.toNumber=function(){return this.unsigned?(this.high>>>0)*_p+(this.low>>>0):this.high*_p+(this.low>>>0)};ie.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Gn)){var t=Cr(e),r=this.div(t),o=r.mul(t).sub(this);return r.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=Cr(ax(e,6),this.unsigned),i=this,a="";;){var c=i.div(s),l=i.sub(c.mul(s)).toInt()>>>0,u=l.toString(e);if(i=c,i.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};ie.getHighBits=function(){return this.high};ie.getHighBitsUnsigned=function(){return this.high>>>0};ie.getLowBits=function(){return this.low};ie.getLowBitsUnsigned=function(){return this.low>>>0};ie.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Gn)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};ie.isZero=function(){return this.high===0&&this.low===0};ie.eqz=ie.isZero;ie.isNegative=function(){return!this.unsigned&&this.high<0};ie.isPositive=function(){return this.unsigned||this.high>=0};ie.isOdd=function(){return(this.low&1)===1};ie.isEven=function(){return(this.low&1)===0};ie.equals=function(e){return Wn(e)||(e=jr(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};ie.eq=ie.equals;ie.notEquals=function(e){return!this.eq(e)};ie.neq=ie.notEquals;ie.ne=ie.notEquals;ie.lessThan=function(e){return this.comp(e)<0};ie.lt=ie.lessThan;ie.lessThanOrEqual=function(e){return this.comp(e)<=0};ie.lte=ie.lessThanOrEqual;ie.le=ie.lessThanOrEqual;ie.greaterThan=function(e){return this.comp(e)>0};ie.gt=ie.greaterThan;ie.greaterThanOrEqual=function(e){return this.comp(e)>=0};ie.gte=ie.greaterThanOrEqual;ie.ge=ie.greaterThanOrEqual;ie.compare=function(e){if(Wn(e)||(e=jr(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};ie.comp=ie.compare;ie.negate=function(){return!this.unsigned&&this.eq(Gn)?Gn:this.not().add(kp)};ie.neg=ie.negate;ie.add=function(e){Wn(e)||(e=jr(e));var t=this.high>>>16,r=this.high&65535,o=this.low>>>16,s=this.low&65535,i=e.high>>>16,a=e.high&65535,c=e.low>>>16,l=e.low&65535,u=0,p=0,d=0,f=0;return f+=s+l,d+=f>>>16,f&=65535,d+=o+c,p+=d>>>16,d&=65535,p+=r+a,u+=p>>>16,p&=65535,u+=t+i,u&=65535,vt(d<<16|f,u<<16|p,this.unsigned)};ie.subtract=function(e){return Wn(e)||(e=jr(e)),this.add(e.neg())};ie.sub=ie.subtract;ie.multiply=function(e){if(this.isZero())return wr;if(Wn(e)||(e=jr(e)),br){var t=br.mul(this.low,this.high,e.low,e.high);return vt(t,br.get_high(),this.unsigned)}if(e.isZero())return wr;if(this.eq(Gn))return e.isOdd()?Gn:wr;if(e.eq(Gn))return this.isOdd()?Gn:wr;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(rR)&&e.lt(rR))return Cr(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=e.high>>>16,c=e.high&65535,l=e.low>>>16,u=e.low&65535,p=0,d=0,f=0,m=0;return m+=i*u,f+=m>>>16,m&=65535,f+=s*u,d+=f>>>16,f&=65535,f+=i*l,d+=f>>>16,f&=65535,d+=o*u,p+=d>>>16,d&=65535,d+=s*l,p+=d>>>16,d&=65535,d+=i*c,p+=d>>>16,d&=65535,p+=r*u+o*l+s*c+i*a,p&=65535,vt(f<<16|m,p<<16|d,this.unsigned)};ie.mul=ie.multiply;ie.divide=function(e){if(Wn(e)||(e=jr(e)),e.isZero())throw Error("division by zero");if(br){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?br.div_u:br.div_s)(this.low,this.high,e.low,e.high);return vt(t,br.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Wl:wr;var r,o,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Wl;if(e.gt(this.shru(1)))return sR;s=Wl}else{if(this.eq(Gn)){if(e.eq(kp)||e.eq(aI))return Gn;if(e.eq(Gn))return kp;var i=this.shr(1);return r=i.div(e).shl(1),r.eq(wr)?e.isNegative()?kp:aI:(o=this.sub(e.mul(r)),s=r.add(o.div(e)),s)}else if(e.eq(Gn))return this.unsigned?Wl:wr;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=wr}for(o=this;o.gte(e);){r=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),c=a<=48?1:ax(2,a-48),l=Cr(r),u=l.mul(e);u.isNegative()||u.gt(o);)r-=c,l=Cr(r,this.unsigned),u=l.mul(e);l.isZero()&&(l=kp),s=s.add(l),o=o.sub(u)}return s};ie.div=ie.divide;ie.modulo=function(e){if(Wn(e)||(e=jr(e)),br){var t=(this.unsigned?br.rem_u:br.rem_s)(this.low,this.high,e.low,e.high);return vt(t,br.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};ie.mod=ie.modulo;ie.rem=ie.modulo;ie.not=function(){return vt(~this.low,~this.high,this.unsigned)};ie.and=function(e){return Wn(e)||(e=jr(e)),vt(this.low&e.low,this.high&e.high,this.unsigned)};ie.or=function(e){return Wn(e)||(e=jr(e)),vt(this.low|e.low,this.high|e.high,this.unsigned)};ie.xor=function(e){return Wn(e)||(e=jr(e)),vt(this.low^e.low,this.high^e.high,this.unsigned)};ie.shiftLeft=function(e){return Wn(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?vt(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):vt(0,this.low<<e-32,this.unsigned)};ie.shl=ie.shiftLeft;ie.shiftRight=function(e){return Wn(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?vt(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):vt(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};ie.shr=ie.shiftRight;ie.shiftRightUnsigned=function(e){if(Wn(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return vt(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?vt(t,0,this.unsigned):vt(t>>>e-32,0,this.unsigned)};ie.shru=ie.shiftRightUnsigned;ie.shr_u=ie.shiftRightUnsigned;ie.toSigned=function(){return this.unsigned?vt(this.low,this.high,!1):this};ie.toUnsigned=function(){return this.unsigned?this:vt(this.low,this.high,!0)};ie.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};ie.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};ie.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};yt.fromBytes=function(e,t,r){return r?yt.fromBytesLE(e,t):yt.fromBytesBE(e,t)};yt.fromBytesLE=function(e,t){return new yt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};yt.fromBytesBE=function(e,t){return new yt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}});function qf(n){return Kl.fromString(n,!0,16)}function lI(n){return n.xor(n.shru(47))}function dR(n,e,t){let r=n.slice(e,e+t);return Kl.fromBytes(Array.from(r),!0,!0)}function ft(n,e){return dR(n,e,8)}function uR(n,e){return dR(n,e,4)}function Zt(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Gi(n,e,t=qf("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let o=e.xor(r).mul(t);return o=o.xor(o.shru(47)),o=o.mul(t),o}function J9(n,e,t,r,o,s){o=o.add(n),s=Zt(s.add(o).add(r),21);let i=o;return o=o.add(e),o=o.add(t),s=s.add(Zt(o,44)),[o.add(r),s.add(i)]}function cx(n,e,t,r){return J9(ft(n,e),ft(n,e+8),ft(n,e+16),ft(n,e+24),t,r)}function e7(n,e=n.length){if(e>=8){let t=In.add(e*2),r=ft(n,0).add(In),o=ft(n,e-8),s=Zt(o,37).mul(t).add(r),i=Zt(r,25).add(o).mul(t);return Gi(s,i,t)}if(e>=4){let t=In.add(e*2),r=uR(n,0);return Gi(r.shl(3).add(e),uR(n,e-4),t)}if(e>0){let t=n[0],r=n[e>>1],o=n[e-1],s=t+(r<<8),i=e+(o<<2);return lI(In.mul(s).xor(pR.mul(i))).mul(In)}return In}function t7(n,e=n.length){let t=In.add(e*2),r=ft(n,0).mul(ql),o=ft(n,8),s=ft(n,e-8).mul(t),i=ft(n,e-16).mul(In);return Gi(Zt(r.add(o),43).add(Zt(s,30)).add(i),r.add(Zt(o.add(In),18)).add(s),t)}function n7(n,e=n.length){let t=In.add(e*2),r=ft(n,0).mul(In),o=ft(n,8),s=ft(n,e-8).mul(t),i=ft(n,e-16).mul(In),a=Zt(r.add(o),43).add(Zt(s,30)).add(i),c=Gi(a,r.add(Zt(o.add(In),18)).add(s),t),l=ft(n,16).mul(t),u=ft(n,24),p=a.add(ft(n,e-32)).mul(t),d=c.add(ft(n,e-24)).mul(t);return Gi(Zt(l.add(u),43).add(Zt(p,30)).add(d),l.add(Zt(u.add(r),18)).add(p),t)}function r7(n,e=n.length){let t=Kl.fromNumber(81,!0);if(e<=32)return e<=16?e7(n,e):t7(n,e);if(e<=64)return n7(n,e);let r=t,o=t.mul(ql).add(113),s=lI(o.mul(In).add(113)).mul(In),i=[Kl.UZERO,Kl.UZERO],a=[Kl.UZERO,Kl.UZERO];r=r.mul(In).add(ft(n,0));let c=0,l=(e-1>>6)*64,u=l+(e-1&63)-63;do r=Zt(r.add(o).add(i[0]).add(ft(n,c+8)),37).mul(ql),o=Zt(o.add(i[1]).add(ft(n,c+48)),42).mul(ql),r=r.xor(a[1]),o=o.add(i[0]).add(ft(n,c+40)),s=Zt(s.add(a[0]),33).mul(ql),i=cx(n,c,i[1].mul(ql),r.add(a[0])),a=cx(n,c+32,s.add(a[1]),o.add(ft(n,c+16))),[s,r]=[r,s],c+=64;while(c!==l);let p=ql.add(s.and(255).shl(1));return c=u,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Zt(r.add(o).add(i[0]).add(ft(n,c+8)),37).mul(p),o=Zt(o.add(i[1]).add(ft(n,c+48)),42).mul(p),r=r.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(ft(n,c+40))),s=Zt(s.add(a[0]),33).mul(p),i=cx(n,c,i[1].mul(p),r.add(a[0])),a=cx(n,c+32,s.add(a[1]),o.add(ft(n,c+16))),[s,r]=[r,s],Gi(Gi(i[0],a[0],p).add(lI(o).mul(pR)).add(s),Gi(i[1],a[1],p).add(r),p)}var uI,Kl,pR,ql,In,fR=D(()=>{"use strict";uI=Nh(lR());Kl=uI.default||uI;pR=qf("c3a5c85c97cb3127"),ql=qf("b492b66fbe98f273"),In=qf("9ae16a3b2f90404f")});var y={};Ue(y,{arraysEqual:()=>wn,arraysEqualWithNull:()=>Zw,assert:()=>k,assertNonNegativeIntegerDimensions:()=>dt,assertNonNull:()=>ar,assertShapesMatch:()=>it,bytesFromStringArray:()=>nI,bytesPerElement:()=>fp,checkConversionForErrors:()=>eI,clamp:()=>dp,computeStrides:()=>No,convertBackendValuesAndArrayBuffer:()=>A9,createScalarValue:()=>o7,createShuffledIndices:()=>N9,decodeString:()=>Rp,distSquared:()=>I9,encodeString:()=>Wi,fetch:()=>i7,fingerPrint64:()=>r7,flatten:()=>qr,getArrayFromDType:()=>Qg,getTypedArrayFromDType:()=>Jw,hasEncodingLoss:()=>_9,hexToLong:()=>qf,indexToLoc:()=>M9,inferDtype:()=>Ks,inferFromImplicitShape:()=>k9,isBoolean:()=>qA,isFunction:()=>So,isInt:()=>Jo,isNumber:()=>KA,isPromise:()=>ec,isScalarShape:()=>E9,isString:()=>Wr,isTypedArray:()=>Nt,isValidDtype:()=>tI,locToIndex:()=>F9,makeOnesTypedArray:()=>Ff,makeZerosNestedTypedArray:()=>R9,makeZerosTypedArray:()=>hp,nearestDivisor:()=>mp,nearestLargerEven:()=>b9,now:()=>Xl,parseAxisParam:()=>qs,randUniform:()=>w9,repeatedTry:()=>D9,rightPad:()=>Ja,shuffle:()=>jA,shuffleCombo:()=>v9,sizeFromShape:()=>Ne,sizeToSquarishShape:()=>S9,squeezeShape:()=>Qw,sum:()=>C9,swap:()=>Zg,tanh:()=>T9,toNestedArray:()=>Qa,toTypedArray:()=>Ap});function o7(n,e){return e==="string"?Wi(n):Ap([n],e)}function s7(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Ap(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=qr(n)),O().getBool("DEBUG")&&eI(n,e),s7(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){let t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Xl(){return O().platform.now()}function i7(n,e){return O().platform.fetch(n,e)}function Wi(n,e="utf-8"){return e=e||"utf-8",O().platform.encode(n,e)}function Rp(n,e="utf-8"){return e=e||"utf-8",O().platform.decode(n,e)}function Nt(n){return O().platform.isTypedArray!=null?O().platform.isTypedArray(n):ix(n)}function qr(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||ec(n)||n==null||Nt(n)&&t)e.push(n);else if(Array.isArray(n)||Nt(n))for(let r=0;r<n.length;++r)qr(n[r],e,t);else{let r=-1;for(let o of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(o)&&(r=Math.max(r,Number(o)));for(let o=0;o<=r;o++)qr(n[o],e,t)}return e}var q=D(()=>{"use strict";Yt();iI();Bt();Bt();fR();});function a7(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){let o=n[r];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${t}'`),!0}return!1}var lx,pI,mR=D(()=>{"use strict";Yt();q();lx=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new pI)}profileKernel(e,t,r){let o,s=()=>{o=r()},i,a=Xl();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();i=Promise.resolve({kernelMs:Xl()-a})}if(O().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let u=o[l];u.data().then(p=>{a7(p,u.dtype,e)})}return{kernelName:e,outputs:o,inputs:t,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:r,timeMs:o,inputs:s,extraInfo:i}=e;r.forEach(a=>{Promise.all([a.data(),o,i]).then(c=>{this.logger.logKernelProfile(t,a,c[0],c[1],s,c[2])})})}};pI=class{logKernelProfile(e,t,r,o,s,i){let a=typeof o=="number"?Ja(`${o}ms`,9):o.error,c=Ja(e,25),l=t.rank,u=t.size,p=Ja(t.shape.toString(),14),d="";for(let f in s){let m=s[f];if(m!=null){let h=m.shape||t.shape,g=h.length;d+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${c}	%c${a}	%c${l}D ${p}	%c${u}	%c${d}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}});function hR(n,e,t){let r={},o={};for(let c=0;c<e.length;c++)r[e[c].id]=!0;for(let c=0;c<n.length;c++){let l=n[c],u=l.inputs;for(let p in u){let d=u[p],f=!1;for(let m=0;m<e.length;m++)if(r[d.id]){l.outputs.forEach(h=>r[h.id]=!0),f=!0,o[l.id]=!0;break}if(f)break}}let s={};s[t.id]=!0;let i={};for(let c=n.length-1;c>=0;c--){let l=n[c],u=l.inputs;for(let p=0;p<l.outputs.length;p++)if(s[l.outputs[p].id]){for(let d in u)s[u[d].id]=!0,i[l.id]=!0;break}}let a=[];for(let c=0;c<n.length;c++){let l=n[c];if(o[l.id]&&i[l.id]){let u={};for(let d in l.inputs){let f=l.inputs[d];r[f.id]&&(u[d]=f)}let p=Object.assign({},l);p.inputs=u,p.outputs=l.outputs,a.push(p)}}return a}function gR(n,e,t,r){for(let o=e.length-1;o>=0;o--){let s=e[o],i=[];if(s.outputs.forEach(c=>{let l=n[c.id];l!=null?i.push(l):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let c in s.inputs){if(!(c in a))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(a)}.`);let l=t(()=>a[c]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${l.dtype}'`);let u=s.inputs[c];if(!wn(l.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${c}' has shape '${l.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=l;else{let p=n[u.id];n[u.id]=r(p,l),p.dispose()}}}}var xR=D(()=>{"use strict";q();});function vR(n,e,t,r){let o=No(e),s=c7(n,e,t,o),i=e.length,a=ux(n,e,t,o,s),c=["Tensor"];return r&&(c.push(`  dtype: ${t}`),c.push(`  rank: ${i}`),c.push(`  shape: [${e}]`),c.push("  values:")),c.push(a.map(l=>"    "+l).join(`
`)),c.join(`
`)}function c7(n,e,t,r){let o=Ne(e),s=r[r.length-1],i=new Array(s).fill(0),a=e.length,c=t==="complex64"?Yf(n):n;if(a>1)for(let l=0;l<o/s;l++){let u=l*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],Xf(c[u+p],0,t).length)}return i}function Xf(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(dI))} + ${parseFloat(n[1].toFixed(dI))}j`:Wr(n)?r=`'${n}'`:t==="bool"?r=bR(n):r=parseFloat(n.toFixed(dI)).toString(),Ja(r,e)}function bR(n){return n===0?"false":"true"}function ux(n,e,t,r,o,s=!0){let i=t==="complex64"?2:1,a=e[0],c=e.length;if(c===0){if(t==="complex64"){let h=Yf(n);return[Xf(h[0],0,t)]}return t==="bool"?[bR(n[0])]:[n[0].toString()]}if(c===1){if(a>yR){let g=Kf*i,x=Array.from(n.slice(0,g)),v=Array.from(n.slice((a-Kf)*i,a*i));return t==="complex64"&&(x=Yf(x),v=Yf(v)),["["+x.map((w,I)=>Xf(w,o[I],t)).join(", ")+", ..., "+v.map((w,I)=>Xf(w,o[a-Kf+I],t)).join(", ")+"]"]}return["["+(t==="complex64"?Yf(n):Array.from(n)).map((g,x)=>Xf(g,o[x],t)).join(", ")+"]"]}let l=e.slice(1),u=r.slice(1),p=r[0]*i,d=[];if(a>yR){for(let h=0;h<Kf;h++){let g=h*p,x=g+p;d.push(...ux(n.slice(g,x),l,t,u,o,!1))}d.push("...");for(let h=a-Kf;h<a;h++){let g=h*p,x=g+p;d.push(...ux(n.slice(g,x),l,t,u,o,h===a-1))}}else for(let h=0;h<a;h++){let g=h*p,x=g+p;d.push(...ux(n.slice(g,x),l,t,u,o,h===a-1))}let f=c===2?",":"";d[0]="["+(a>0?d[0]+f:"");for(let h=1;h<d.length-1;h++)d[h]=" "+d[h]+f;let m=`,
`;for(let h=2;h<c;h++)m+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":m),d}function Yf(n){let e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}var yR,Kf,dI,CR=D(()=>{"use strict";q();yR=20,Kf=3,dI=7});function wR(n){Kr=n}function IR(n){Fp=n}function ER(n){l7=n}function fI(){return Mf("Tensor",()=>Ze)}var He,Kr,Fp,l7,Ze,ko,cr=D(()=>{"use strict";ex();CR();q();q();He=class{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Ne(e),r!=null){let o=r.length;k(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Qg(t,this.size),this.strides=No(e)}set(e,...t){t.length===0&&(t=[0]),k(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let o of e){if(o<0||o>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let r=e[e.length-1];for(let o=0;o<e.length-1;++o)r+=this.strides[o]*e[o];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Kr().makeTensor(this.values,this.shape,this.dtype)}},Kr=null,Fp=null,l7=null;Ze=class{constructor(e,t,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ne(e),this.strides=No(e),this.dataId=r,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Fp.buffer(this.shape,this.dtype,e)}bufferSync(){return Fp.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Qa(this.shape,e,this.dtype==="complex64")}arraySync(){return Qa(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Kr().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(r=>Rp(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Kr().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Kr().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Rp(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Kr().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Kr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Fp.print(this,e)}clone(){return this.throwIfDisposed(),Fp.clone(this)}toString(e=!1){let t=this.dataSync();return vR(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Fp.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),Kr().makeVariable(this,e,t,r)}};Object.defineProperty(Ze,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});fI();ko=class extends Ze{constructor(e,t,r,o){super(e.shape,e.dtype,e.dataId,o),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!wn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Kr().disposeTensor(this),this.dataId=e.dataId,Kr().incRef(this,null)}dispose(){Kr().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(ko,Symbol.hasInstance,{value:n=>n instanceof Ze&&n.assign!=null&&n.assign instanceof Function})});function Dt(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return u7[n][e]}function ji(n){return Dt(n,"int32")}function px(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function dx(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}var mI,TR,SR,NR,DR,u7,Mp=D(()=>{"use strict";mI=(function(n){return n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6",n})(mI||{}),TR=(function(n){return n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",n})(TR||{}),SR=(function(n){return n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",n})(SR||{}),NR=(function(n){return n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",n})(NR||{}),DR=(function(n){return n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",n})(DR||{}),u7={float32:NR,int32:TR,bool:SR,complex64:DR}});var gI={};Ue(gI,{assertTypesMatch:()=>hI,getTensorsInContainer:()=>Zf,isTensorInList:()=>p7,makeTypesMatch:()=>Ee});function Ee(n,e){if(n.dtype===e.dtype)return[n,e];let t=Dt(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function hI(n,e){k(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function p7(n,e){return e.some(t=>t.id===n.id)}function Zf(n){let e=[];return kR(n,e,new Set),e}function kR(n,e,t){if(n==null)return;if(n instanceof Ze){e.push(n);return}if(!d7(n))return;let r=n;for(let o in r){let s=r[o];t.has(s)||(t.add(s),kR(s,e,t))}}function d7(n){return Array.isArray(n)||typeof n=="object"}var mt=D(()=>{"use strict";cr();Mp();q();});function xI(n){return n.kernelName!=null}function m7(n){let e=Ff(Ne(n),"float32");return N.makeTensor(e,n,"float32")}function yI(){let n=oI();if(n._tfengine==null){let e=new gp(n);n._tfengine=new f7(e)}return ZA(n._tfengine.ENV),wR(()=>n._tfengine),n._tfengine}function h7(n,e){let t={a:n,b:e};return N.runKernel("Add",t)}var fx,f7,N,B=D(()=>{"use strict";Yw();Yt();ex();G();sx();rx();mR();xR();cr();mt();q();q();fx=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},f7=(()=>{class n{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new fx}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let r=0;r<t.length;r++){let o=t[r];if(await this.initializeBackend(o).success){await this.setBackend(o);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:r}=this.initializeBackend(t);if(r)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,r,o=1){return t in this.registryFactory?(Do(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:r,priority:o},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:r,asyncInit:o}=this.initializeBackend(t);if(!(o?await r:r))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new lx(this.backendInstance),!0}setupRegisteredKernels(){jf(this.backendName).forEach(r=>{r.setupFunc!=null&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){jf(t).forEach(o=>{o.disposeFunc!=null&&o.disposeFunc(this.registry[t])})}initializeBackend(t){let r=this.registryFactory[t];if(r==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let o=r.factory();if(o&&!(o instanceof To)&&typeof o.then=="function"){let s=++this.pendingBackendInitId,i=o.then(a=>s<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Do(`Initialization of backend ${t} failed`),Do(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=o,{success:!0,asyncInit:!1}}catch(o){return Do(`Initialization of backend ${t} failed`),Do(o.stack||o.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,r)=>this.registryFactory[r].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let r=0;r<t.length;r++){let o=t[r],{success:s,asyncInit:i}=this.initializeBackend(o);if(i||s)return{name:o,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,r){let o=this.state.tensorInfo.get(r),s=o.backend,i=this.readSync(r),a=s.refCount(r);s.disposeData(r,!0),o.backend=t,t.move(r,i,o.shape,o.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,r){let o=null;if(r==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");r=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof r!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=t}let s;return this.scopedRun(()=>this.startScope(o),()=>this.endScope(s),()=>(s=r(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,r,o){t();try{let s=o();return r(),s}catch(s){throw r(),s}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(t){let r=N.runKernel(ns,{x:t}),o={x:t},s=a=>({x:()=>{let c="float32",l={x:a},u={dtype:c};return N.runKernel(ts,l,u)}}),i=[];return this.addTapeNode(this.state.activeScope.name,o,[r],s,i,{}),r}runKernel(t,r,o){if(this.backendName==null&&this.backend,!(Gl(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:r,attrs:o})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,r,o){let s=this.backend.numDataIds(),i=0;o.forEach(l=>{i+=l.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],c=s-r-i-a;if(c>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${c} data ids) after running '${t}'`)}runKernelFunc(t){let r,o=[],s=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let c;this.backendName==null&&this.backend;let l,u=xI(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(xI(t)){let{kernelName:h,inputs:g,attrs:x}=t;this.backendName==null&&this.backend;let v=Gl(h,this.backendName);k(v!=null,()=>`Cannot find registered kernel '${h}' for backend '${this.backendName}'`),c=()=>{let w=this.backend.numDataIds();l=v.kernelFunc({inputs:g,attrs:x,backend:this.backend});let I=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,w,I);let _=I.map(A=>A.rank!=null?A:this.makeTensorFromTensorInfo(A));if(s){let A=this.getTensorsForGradient(h,g,_);o=this.saveTensorsForBackwardMode(A)}return _}}else{let{forwardFunc:h}=t,g=x=>{s&&(o=x.map(v=>this.keep(this.clone(v))))};c=()=>{let x=this.backend.numDataIds();l=this.tidy(()=>h(this.backend,g));let v=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,x,v),v}}let{inputs:p,attrs:d}=t,f=xI(t)?null:t.backwardsFunc,m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?r=c():(m=this.profiler.profileKernel(u,p,()=>c()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),r=m.outputs)}),s&&this.addTapeNode(u,p,r,f,o,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(h=>p[h]!=null?p[h].shape:null),outputShapes:r.map(h=>h.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(l)?r:r[0]}saveTensorsForBackwardMode(t){return t.map(o=>this.keep(this.clone(o)))}getTensorsForGradient(t,r,o){let s=ox(t);if(s!=null){let i=s.inputsToSave||[],a=s.outputsToSave||[],c;s.saveAllInputs?(k(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),c=Object.keys(r).map(u=>r[u])):c=i.map(u=>r[u]);let l=o.filter((u,p)=>a[p]);return c.concat(l)}return[]}makeTensor(t,r,o,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");o=o||"float32",s=s||this.backend;let i=t;o==="string"&&Wr(t[0])&&(i=t.map(l=>Wi(l)));let a=s.write(i,r,o),c=new Ze(r,o,a,this.nextTensorId());if(this.trackTensor(c,s),o==="string"){let l=this.state.tensorInfo.get(a),u=nI(i);this.state.numBytes+=u-l.bytes,l.bytes=u}return c}makeTensorFromDataId(t,r,o,s){o=o||"float32";let i={dataId:t,shape:r,dtype:o};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(t,r){let{dataId:o,shape:s,dtype:i}=t,a=new Ze(s,i,o,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(t,r=!0,o,s){o=o||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));let i=new ko(t,r,o,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,r){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let o=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(o=t.size*fp(t.dtype)),this.state.numBytes+=o,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:r||this.backend,dtype:t.dtype,shape:t.shape,bytes:o})),t instanceof ko||this.track(t)}incRef(t,r){this.trackTensor(t,r),this.backend.incRef(t.dataId)}removeDataId(t,r){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===r&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let r=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let o=t.size*fp(t.dtype);this.state.numBytes-=o}r.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,r.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let r=this.state.registeredVariables[t];this.disposeVariable(r)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let r=this.state.numBytes,o=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-r,this.state.activeProfile.newTensors=this.state.numTensors-o;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,r,o,s,i,a){let c={id:this.state.nextTapeNodeId++,kernelName:t,inputs:r,outputs:o,saved:i},l=ox(t);l!=null&&(s=l.gradFunc),s!=null&&(c.gradient=u=>(u=u.map((p,d)=>{if(p==null){let f=o[d],m=hp(f.size,f.dtype);return this.makeTensor(m,f.shape,f.dtype)}return p}),s(u.length>1?u:u[0],i,a))),this.state.activeTape.push(c)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(r.name=t),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(t){let r=Zf(t),o=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){let a=this.state.activeScope.track[i];!a.kept&&!o.has(a.id)&&a.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(t,r,o,s=!1){if(k(r.length>0,()=>"gradients() received an empty list of xs."),o!=null&&o.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${o.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));k(i instanceof Ze,()=>"The result y returned by f() must be a tensor.");let a=hR(this.state.activeTape,r,i);if(!s&&a.length===0&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let c={};c[i.id]=o??m7(i.shape),gR(c,a,u=>this.tidy(u),h7);let l=r.map(u=>c[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let p of u.saved)p.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(t){return k(So(t),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{k(r.every(c=>c instanceof Ze),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let o,s={};r.forEach((c,l)=>{s[l]=c});let i=(c,l)=>(o=t(...r,l),k(o.value instanceof Ze,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),k(So(o.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o.value),a=(c,l)=>{let u=o.gradFunc(c,l),p=Array.isArray(u)?u:[u];k(p.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),k(p.every(f=>f instanceof Ze),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let d={};return p.forEach((f,m)=>{d[m]=()=>f}),d};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,r){return this.state.tensorInfo.get(t).backend.readToGPU(t,r)}async time(t){let r=Xl(),o=await this.backend.time(t);return o.wallMs=Xl()-r,o}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new fx;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();N=yI()});var ss={};Ue(ss,{isBrowser:()=>bI,isMobile:()=>y7,mockIsMobile:()=>x7});function g7(){return typeof navigator<"u"&&navigator!=null}function x7(n){vI=n}function y7(n){if(vI!==void 0)return vI;if(n||g7()){if(n||(n=navigator),n.product==="ReactNative")return!0;let e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){let t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function bI(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var vI,CI=D(()=>{"use strict";});var Rn,Op=D(()=>{"use strict";B();CI();Yt();Rn=O();Rn.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Rn.registerFlag("IS_BROWSER",()=>bI());Rn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Rn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Rn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Rn.registerFlag("PROD",()=>!1);Rn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Rn.getBool("DEBUG"));Rn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Rn.registerFlag("IS_TEST",()=>!1);Rn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Rn.getBool("DEBUG"));Rn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Rn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Rn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1)});function on(n,e){let t=n;if(Nt(n))return e==="string"?[]:[n.length];if(px(n)){let o=n.channels||"RGBA";return[n.height,n.width*o.length]}else if(dx(n))return[n.buffer.size/(e==null?4:fp(e))];if(!Array.isArray(n))return[];let r=[];for(;Array.isArray(t)||Nt(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&O().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&AR(n,r,[]),r}function AR(n,e,t){if(t=t||[],!Array.isArray(n)&&!Nt(n)){k(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}k(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),k(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);let r=e.slice(1);for(let o=0;o<n.length;++o)AR(n[o],r,t.concat(o))}function _R(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function C(n,e,t,r="numeric"){if(n instanceof fI())return _R(r,n.dtype,e,t),n;let o=Ks(n);if(o!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),_R(r,o,e,t),n==null||!Nt(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){let c=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${c}'`)}let s=on(n,o);!Nt(n)&&!Array.isArray(n)&&(n=[n]);let a=o!=="string"?Ap(n,o):qr(n,[],!0);return N.makeTensor(a,s,o)}function is(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,i)=>C(s,`${e}[${i}]`,t,r))}var $=D(()=>{"use strict";B();Yt();cr();Mp();q();Bt();});function E(n){let e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0],r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+mx;let o=(...s)=>{N.startScope(t);try{let i=r(...s);return ec(i)&&console.error("Cannot return a Promise inside of tidy."),N.endScope(i),i}catch(i){throw N.endScope(null),i}};return Object.defineProperty(o,"name",{value:t,configurable:!0}),o}var mx,M=D(()=>{"use strict";B();q();mx="__op"});function v7(n,e){let t=C(n,"real","complex"),r=C(e,"imag","complex");it(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);let o={real:t,imag:r};return N.runKernel(pc,o)}var En,qi=D(()=>{"use strict";B();G();$();q();M();En=E({complex_:v7})});function Tn(n,e,t,r){if(r==null)r=Ks(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(dx(n)||px(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return N.backend.createTensorFromGPUData(n,e||t,r)}if(!Nt(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){dt(e);let o=Ne(e),s=Ne(t);k(o===s,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<t.length;++i){let a=t[i],c=i===t.length-1?a!==Ne(e.slice(i)):!0;k(t[i]===e[i]||!c,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Nt(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?Ap(n,r):qr(n,[],!0),N.makeTensor(n,e,r)}var as=D(()=>{"use strict";B();Mp();q();});function fn(n,e,t){let r=on(n,t);return Tn(n,e,r,t)}var Qf=D(()=>{"use strict";$();as();});var cs,wI=D(()=>{"use strict";cs={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}});function b7(n,e){let t=0,r=n.length;for(;t<=r;){let o=Math.floor((r-t)/2)+t,s=e(n[o]);if(s===0)return o;s<0?r=o:t=o+1}return-1}var sn,Ki=D(()=>{"use strict";q();sn=class n{static join(e){return new n(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>Nt(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){let o=e[r];r!==e.length-1&&o.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=t+o.byteLength;this.shards.push({buffer:o,start:t,end:s}),t=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);let r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);let o=t-e,s=new ArrayBuffer(o),i=new Uint8Array(s),a=0;for(let c=r;c<this.shards.length;c++){let l=this.shards[c],p=e+a-l.start,d=a,m=Math.min(t,l.end)-l.start,h=new Uint8Array(l.buffer,p,m-p);if(i.set(h,d),a+=h.length,t<l.end)break}return s}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(o){return e<o.start?-1:e>=o.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=b7(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}});function C7(){O().set("PROD",!0)}function w7(){O().set("DEBUG",!0)}function I7(){O().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function RR(n){O().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function E7(){N.disposeVariables()}function lr(){return N}function T7(){return N.memory()}function S7(n){return N.profile(n)}function Ce(n,e){return N.tidy(n,e)}function Ct(n){Zf(n).forEach(t=>t.dispose())}function Sn(n){return N.keep(n)}function N7(n){return N.time(n)}function D7(n){return N.setBackend(n)}function k7(){return N.ready()}function II(){return N.backendName}function _7(n){N.removeBackend(n)}function A7(n){return N.findBackend(n)}function R7(n){return N.findBackendFactory(n)}function Jf(n,e,t=1){return N.registerBackend(n,e,t)}function EI(){return N.backend}function F7(n,e){O().setPlatform(n,e)}var jn=D(()=>{"use strict";B();Yt();cr();mt();ER(RR)});async function OR(n,e){let t=[],r=[],o=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<o.length;++i){let a=o[i],c=Array.isArray(n)?n[i].tensor:n[a];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${c.dtype}`);let l={name:a,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){let u=new Promise(async p=>{let d=await c.bytes(),f=d.reduce((g,x)=>g+x.length,0)+Xi*d.length,m=new Uint8Array(f),h=0;for(let g=0;g<d.length;g++){let x=d[g],v=new Uint8Array(new Uint32Array([x.length]).buffer);m.set(v,h),h+=Xi,m.set(x,h),h+=x.length}p(m)});r.push(u)}else r.push(c.data());e!=null&&(l.group=e),t.push(l)}let s=await Promise.all(r);return{data:$7(s),specs:t}}function hx(n,e){let t=new sn(n),r={},o=0;for(let s of e){let i=M7(s,(a,c)=>t.slice(o+a,o+c));r[s.name]=$R(s,t.slice(o,o+i)),o+=i}return r}function M7(n,e){let t=Ne(n.shape),r;if("quantization"in n){let o=n.quantization;r=cs[o.dtype]}else if(n.dtype==="string"){let o=0;for(let s=0;s<t;s++)o+=Xi+new Uint32Array(e(o,o+Xi))[0];return o}else r=cs[n.dtype];return t*r}async function O7(n,e){let t=Ne(n.shape),r;if("quantization"in n){let o=n.quantization;r=cs[o.dtype]}else if(n.dtype==="string"){let o=0;for(let s=0;s<t;s++)o+=Xi+new Uint32Array(await e(o,o+Xi))[0];return o}else r=cs[n.dtype];return t*r}function $R(n,e){let t=n.name,r=n.dtype,o=n.shape,s=Ne(o),i,a=0;if("quantization"in n){let c=n.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${n.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${n.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let l=cs[c.dtype],u=c.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){i=new Float32Array(u.length);for(let p=0;p<u.length;p++){let d=u[p];i[p]=d*c.scale+c.min}}else if(c.dtype==="float16")i=V7()(u);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(r==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let p=0;p<u.length;p++){let d=u[p];i[p]=Math.round(d*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);a+=s*l}else if(r==="string"){let c=Ne(n.shape);i=[];for(let l=0;l<c;l++){let u=new Uint32Array(e.slice(a,a+Xi))[0];a+=Xi;let p=new Uint8Array(e.slice(a,a+u));i.push(p),a+=u}}else{let c=cs[r];if(r==="float32")i=new Float32Array(e);else if(r==="int32")i=new Int32Array(e);else if(r==="bool")i=new Uint8Array(e);else if(r==="complex64"){i=new Float32Array(e);let l=new Float32Array(i.length/2),u=new Float32Array(i.length/2);for(let m=0;m<l.length;m++)l[m]=i[m*2],u[m]=i[m*2+1];let p=fn(l,o,"float32"),d=fn(u,o,"float32"),f=En(p,d);return p.dispose(),d.dispose(),f}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);a+=s*c}return fn(i,o,r)}async function FR(n,e,t){let r=new Uint8Array(e);for(;r.byteLength<t;){let{done:o,value:s}=await n.read();if(o&&s==null){let a=t-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}let i=new Uint8Array(r.length+s.byteLength);i.set(r,0),i.set(new Uint8Array(s),r.length),r=i}return r.buffer}async function gx(n,e){let t={},r=n.getReader(),o=new ArrayBuffer(0);for(let s of e){let i=await O7(s,async(l,u)=>(o=await FR(r,o,u),o.slice(l,u)));o=await FR(r,o,i);let a=o.slice(0,i);o=o.slice(i);let c=$R(s,a);if(t[s.name]=c,II()==="webgpu"){let l=EI();"uploadToGPU"in l&&Ne(c.shape)>=O().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&l.uploadToGPU(c.dataId)}}return t}function $7(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0,t=[];n.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(e),o=0;return t.forEach(s=>{r.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),r.buffer}function MR(n){return TI?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function PR(n){if(TI)return Buffer.from(n).toString("base64");let e=new Uint8Array(n),t="";for(let r=0,o=e.length;r<o;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function LR(n){if(TI){let r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function BR(n){return sn.join(n)}function SI(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);let t=n.split("/");return t[t.length-1]}function xx(n,e){let t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function NI(n,e,t){let r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}async function $p(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),NI(n,t,r)}function _o(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:MR(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:MR(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new sn(n.weightData).byteLength}}function em(n){let e=[];for(let t of n)e.push(...t.weights);return e}function P7(){let n=t=>{let r=t<<13,o=0;for(;(r&8388608)===0;)o-=8388608,r<<=1;return r&=-8388609,o+=947912704,r|o},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function L7(){let n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function B7(){let n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function V7(){let n=P7(),e=L7(),t=B7();return r=>{let o=new ArrayBuffer(4*r.length),s=new Uint32Array(o);for(let i=0;i<r.length;i++){let a=r[i],c=n[t[a>>10]+(a&1023)]+e[a>>10];s[i]=c}return new Float32Array(o)}}var Xi,TI,Yi=D(()=>{"use strict";qi();Qf();q();wI();Ki();jn();Yt();jn();Xi=4;TI=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u")});var Vt,VR,UR,zR,HR,Yl=D(()=>{"use strict";Vt=class n{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return n.instance==null&&(n.instance=new n),n.instance}static registerSaveRouter(e){n.getInstance().saveRouters.push(e)}static registerLoadRouter(e){n.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return n.getHandlers(e,"save")}static getLoadHandlers(e,t){return n.getHandlers(e,"load",t)}static getHandlers(e,t,r){let o=[];return(t==="load"?n.getInstance().loadRouters:n.getInstance().saveRouters).forEach(i=>{let a=i(e,r);a!==null&&o.push(a)}),o}},VR=n=>Vt.registerSaveRouter(n),UR=n=>Vt.registerLoadRouter(n),zR=n=>Vt.getSaveHandlers(n),HR=(n,e)=>Vt.getLoadHandlers(n,e)});function GR(){if(!O().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function _I(n){let e=n.result;e.createObjectStore(Zl,{keyPath:"modelPath"}),e.createObjectStore(Zi,{keyPath:"modelPath"})}function U7(n){return new Ql(n)}function z7(n){return n.startsWith(Ql.URL_SCHEME)?n.slice(Ql.URL_SCHEME.length):n}var DI,kI,Zl,Zi,Ql,WR,yx,AI=D(()=>{"use strict";Op();Yt();Yi();Yl();Ki();DI="tensorflowjs",kI=1,Zl="models_store",Zi="model_info_store";Ql=(()=>{class n{constructor(t){if(this.indexedDB=GR(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,r){return new Promise((o,s)=>{let i=this.indexedDB.open(DI,kI);i.onupgradeneeded=()=>_I(i),i.onsuccess=()=>{let a=i.result;if(r==null){let c=a.transaction(Zl,"readonly"),u=c.objectStore(Zl).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));o(u.result.modelArtifacts)},u.onerror=p=>(a.close(),s(u.error)),c.oncomplete=()=>a.close()}else{r.weightData=sn.join(r.weightData);let c=_o(r),l=a.transaction(Zi,"readwrite"),u=l.objectStore(Zi),p;try{p=u.put({modelPath:this.modelPath,modelArtifactsInfo:c})}catch(f){return s(f)}let d;p.onsuccess=()=>{d=a.transaction(Zl,"readwrite");let f=d.objectStore(Zl),m;try{m=f.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:c})}catch(h){return s(h)}m.onsuccess=()=>o({modelArtifactsInfo:c}),m.onerror=h=>{u=l.objectStore(Zi);let g=u.delete(this.modelPath);g.onsuccess=()=>(a.close(),s(m.error)),g.onerror=x=>(a.close(),s(m.error))}},p.onerror=f=>(a.close(),s(p.error)),l.oncomplete=()=>{d==null?a.close():d.oncomplete=()=>a.close()}}},i.onerror=a=>s(i.error)})}}return n.URL_SCHEME="indexeddb://",n})(),WR=n=>O().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ql.URL_SCHEME)?U7(n.slice(Ql.URL_SCHEME.length)):null;Vt.registerSaveRouter(WR);Vt.registerLoadRouter(WR);yx=class{constructor(){this.indexedDB=GR()}async listModels(){return new Promise((e,t)=>{let r=this.indexedDB.open(DI,kI);r.onupgradeneeded=()=>_I(r),r.onsuccess=()=>{let o=r.result,s=o.transaction(Zi,"readonly"),a=s.objectStore(Zi).getAll();a.onsuccess=()=>{let c={};for(let l of a.result)c[l.modelPath]=l.modelArtifactsInfo;e(c)},a.onerror=c=>(o.close(),t(a.error)),s.oncomplete=()=>o.close()},r.onerror=o=>t(r.error)})}async removeModel(e){return e=z7(e),new Promise((t,r)=>{let o=this.indexedDB.open(DI,kI);o.onupgradeneeded=()=>_I(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(Zi,"readwrite"),a=i.objectStore(Zi),c=a.get(e),l;c.onsuccess=()=>{if(c.result==null)return s.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let u=a.delete(e),p=()=>{l=s.transaction(Zl,"readwrite");let f=l.objectStore(Zl).delete(e);f.onsuccess=()=>t(c.result.modelArtifactsInfo),f.onerror=m=>r(c.error)};u.onsuccess=p,u.onerror=d=>(p(),s.close(),r(c.error))}},c.onerror=u=>(s.close(),r(c.error)),i.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>r(o.error)})}}});function qR(n){return{info:[Pp,n,jR].join(ls),topology:[Pp,n,H7].join(ls),weightSpecs:[Pp,n,G7].join(ls),weightData:[Pp,n,W7].join(ls),modelMetadata:[Pp,n,j7].join(ls)}}function KR(n){for(let e of Object.values(n))window.localStorage.removeItem(e)}function q7(n){let e=n.split(ls);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(ls)}function K7(n){return n.startsWith(Jl.URL_SCHEME)?n.slice(Jl.URL_SCHEME.length):n}function X7(n){return new Jl(n)}var ls,Pp,jR,H7,G7,W7,j7,Jl,XR,vx,RI=D(()=>{"use strict";Op();Yt();q();Yi();Ki();Yl();ls="/",Pp="tensorflowjs_models",jR="info",H7="model_topology",G7="weight_specs",W7="weight_data",j7="model_metadata";Jl=(()=>{class n{constructor(t){if(!O().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=qR(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let r=JSON.stringify(t.modelTopology),o=JSON.stringify(t.weightSpecs),s=_o(t),i=sn.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,r),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,PR(i));let a={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw KR(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let r={},o=JSON.parse(this.LS.getItem(this.keys.topology));if(o==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);r.modelTopology=o;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);r.weightSpecs=s;let i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){let c=JSON.parse(i);r.format=c.format,r.generatedBy=c.generatedBy,r.convertedBy=c.convertedBy,c.signature!=null&&(r.signature=c.signature),c.userDefinedMetadata!=null&&(r.userDefinedMetadata=c.userDefinedMetadata),c.modelInitializer!=null&&(r.modelInitializer=c.modelInitializer),c.initializerSignature!=null&&(r.initializerSignature=c.initializerSignature),c.trainingConfig!=null&&(r.trainingConfig=c.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return r.weightData=LR(a),r}}return n.URL_SCHEME="localstorage://",n})(),XR=n=>O().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Jl.URL_SCHEME)?X7(n.slice(Jl.URL_SCHEME.length)):null;Vt.registerSaveRouter(XR);Vt.registerLoadRouter(XR);vx=class{constructor(){k(O().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),k(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=Pp+ls,r=ls+jR;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(t)&&s.endsWith(r)){let i=q7(s);e[i]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=K7(e);let t=qR(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let r=JSON.parse(this.LS.getItem(t.info));return KR(t),r}}});function bx(n){if(n.indexOf(Lp)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Xr.getSchemes().join(",")}`);return{scheme:n.split(Lp)[0],path:n.split(Lp)[1]}}async function YR(n,e,t=!1){k(n!==e,()=>`Old path and new path are the same: '${n}'`);let r=Vt.getLoadHandlers(n);k(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),k(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);let o=r[0],s=Vt.getSaveHandlers(e);k(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),k(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);let i=s[0],a=bx(n).scheme,c=bx(n).path,l=a===bx(n).scheme,u=await o.load();t&&l&&await Xr.getManager(a).removeModel(c);let p=await i.save(u);return t&&!l&&await Xr.getManager(a).removeModel(c),p.modelArtifactsInfo}async function ZR(){let n=Xr.getSchemes(),e={};for(let t of n){let r=await Xr.getManager(t).listModels();for(let o in r){let s=t+Lp+o;e[s]=r[o]}}return e}async function QR(n){let e=bx(n);return Xr.getManager(e.scheme).removeModel(e.path)}async function JR(n,e){return YR(n,e,!1)}async function e2(n,e){return YR(n,e,!0)}var Lp,Xr,FI=D(()=>{"use strict";q();Yl();Lp="://",Xr=class n{constructor(){this.managers={}}static getInstance(){return n.instance==null&&(n.instance=new n),n.instance}static registerManager(e,t){k(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Lp)&&(e=e.slice(0,e.indexOf(Lp))),k(e.length>0,()=>"scheme must not be an empty string.");let r=n.getInstance();k(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){let t=n.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(n.getInstance().managers)}}});var MI,t2=D(()=>{"use strict";Op();Yt();AI();RI();FI();iI();MI=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!O().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();let o=this.functionRefs[r.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return ix(e)}};if(O().get("IS_BROWSER")){O().setPlatform("browser",new MI);try{Xr.registerManager(Jl.URL_SCHEME,new vx)}catch{}try{Xr.registerManager(Ql.URL_SCHEME,new yx)}catch{}}});var r2=rr((Bp,n2)=>{"use strict";var Y7=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("unable to locate global object")},eu=Y7();n2.exports=Bp=eu.fetch;eu.fetch&&(Bp.default=eu.fetch.bind(eu));Bp.Headers=eu.Headers;Bp.Request=eu.Request;Bp.Response=eu.Response});var o2=rr(()=>{"use strict"});var Z7,OI,$I,s2=D(()=>{"use strict";Yt();Z7={importFetch:()=>r2()},$I=class{constructor(){this.util=o2(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return O().global.fetch!=null?O().global.fetch(e,t):(OI==null&&(OI=Z7.importFetch()),OI(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};O().get("IS_NODE")&&!O().get("IS_BROWSER")&&O().setPlatform("node",new $I)});function le(n,e="float32",t){return e=e||"float32",dt(n),new He(n,e,t)}var us=D(()=>{"use strict";cr();q();});function Q7(n,e){let t=C(n,"x","cast");if(!tI(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:t},o={dtype:e};return N.runKernel(ts,r,o)}var De,an=D(()=>{"use strict";B();G();$();q();M();De=E({cast_:Q7})});function J7(n){let t={x:C(n,"x","clone","string_or_numeric")};return N.runKernel(ns,t)}var Fn,Vp=D(()=>{"use strict";B();G();$();M();Fn=E({clone_:J7})});function tm(n,e=!1){console.log(n.toString(e))}var PI=D(()=>{"use strict";});var eX,i2=D(()=>{"use strict";B();Op();t2();s2();us();an();Vp();PI();cr();yI();eX={buffer:le,cast:De,clone:Fn,print:tm};IR(eX)});function tX(n,e){let t=C(n,"a","add"),r=C(e,"b","add");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel("Add",o)}var de,Ot=D(()=>{"use strict";B();mt();$();M();de=E({add_:tX})});function nX(n,e){let t=C(n,"a","floorDiv"),r=C(e,"b","floorDiv");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel(ui,o)}var nm,LI=D(()=>{"use strict";B();G();mt();$();M();nm=E({floorDiv_:nX})});function rX(n,e){let t=C(n,"a","div"),r=C(e,"b","div");if([t,r]=Ee(t,r),t.dtype==="int32"&&r.dtype==="int32")return nm(t,r);let o={a:t,b:r},s={};return N.runKernel(ii,o,s)}var Pe,Mn=D(()=>{"use strict";B();G();mt();$();LI();M();Pe=E({div_:rX})});function oX(n,e){let t=C(n,"a","mul"),r=C(e,"b","mul");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel(Ei,o)}var ee,ht=D(()=>{"use strict";B();G();mt();$();M();ee=E({mul_:oX})});function sX(n){let e=C(n,"x","abs");if(e.dtype==="complex64"){let t={x:e};return N.runKernel(dc,t)}else{let t={x:e};return N.runKernel("Abs",t)}}var Ut,tu=D(()=>{"use strict";B();G();$();M();Ut=E({abs_:sX})});function iX(n){let t={x:C(n,"x","acos")};return N.runKernel(Xs,t)}var BI,a2=D(()=>{"use strict";B();G();$();M();BI=E({acos_:iX})});function aX(n){let t={x:C(n,"x","acosh")};return N.runKernel(Ys,t)}var VI,c2=D(()=>{"use strict";B();G();$();M();VI=E({acosh_:aX})});function cX(n){k(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),k(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);let e=n.map((o,s)=>C(o,`tensors${s}`,"addN")),t=e[0];e.forEach(o=>{if(o.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(o=>{if(!wn(o.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=e;return N.runKernel(nc,r)}var UI,l2=D(()=>{"use strict";B();G();$();q();M();UI=E({addN_:cX})});function lX(n,e=null,t=!1){let o={x:C(n,"x","all","bool")},s={axis:e,keepDims:t};return N.runKernel("All",o,s)}var zI,u2=D(()=>{"use strict";B();$();M();zI=E({all_:lX})});function uX(n,e=null,t=!1){let o={x:C(n,"x","any","bool")},s={axis:e,keepDims:t};return N.runKernel("Any",o,s)}var HI,p2=D(()=>{"use strict";B();$();M();HI=E({any_:uX})});function pX(n,e=0){let r={x:C(n,"x","argMax")},o={axis:e};return N.runKernel(rc,r,o)}var GI,d2=D(()=>{"use strict";B();G();$();M();GI=E({argMax_:pX})});function dX(n,e=0){let r={x:C(n,"x","argMin")},o={axis:e};return N.runKernel(oc,r,o)}var WI,f2=D(()=>{"use strict";B();G();$();M();WI=E({argMin_:dX})});function fX(n){let t={x:C(n,"x","asin")};return N.runKernel(Zs,t)}var jI,m2=D(()=>{"use strict";B();G();$();M();jI=E({asin_:fX})});function mX(n){let t={x:C(n,"x","asinh")};return N.runKernel(Qs,t)}var qI,h2=D(()=>{"use strict";B();G();$();M();qI=E({asinh_:mX})});function hX(n){let t={x:C(n,"x","atan")};return N.runKernel(Js,t)}var KI,g2=D(()=>{"use strict";B();G();$();M();KI=E({atan_:hX})});function gX(n,e){let t=C(n,"a","atan2"),r=C(e,"b","atan2");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel(ti,o)}var XI,x2=D(()=>{"use strict";B();G();mt();$();M();XI=E({atan2_:gX})});function xX(n){let t={x:C(n,"x","atanh")};return N.runKernel(ei,t)}var YI,y2=D(()=>{"use strict";B();G();$();M();YI=E({atanh_:xX})});function yX(n,e,t,r,o="NHWC",s){let i=n[3],a=[...e,i],c=b2(o);return ru(n,a,t,s,r,null,null,c)}function QI(n,e,t,r,o,s,i="channelsLast"){let[a,c]=rm(e),l;if(i==="channelsLast")l=[a,c,n[3],n[3]];else if(i==="channelsFirst")l=[a,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return ru(n,l,t,r,o,s,!1,i)}function vX(n,e,t,r,o,s,i="NDHWC"){let[a,c,l]=ZI(e),u,p;if(i==="NDHWC")p="channelsLast",u=[a,c,l,n[4],n[4]];else if(i==="NCDHW")p="channelsFirst",u=[a,c,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return v2(n,u,t,r,o,!1,p,s)}function ru(n,e,t,r,o,s,i=!1,a="channelsLast"){let[c,l,u,p]=[-1,-1,-1,-1];if(a==="channelsLast")[c,l,u,p]=n;else if(a==="channelsFirst")[c,p,l,u]=n;else throw new Error(`Unknown dataFormat ${a}`);let[d,f,,m]=e,[h,g]=rm(t),[x,v]=rm(r),w=Up(d,x),I=Up(f,v),{padInfo:_,outHeight:A,outWidth:R}=wX(o,l,u,h,g,w,I,s,a),F=i?m*p:m,P;return a==="channelsFirst"?P=[c,F,A,R]:a==="channelsLast"&&(P=[c,A,R,F]),{batchSize:c,dataFormat:a,inHeight:l,inWidth:u,inChannels:p,outHeight:A,outWidth:R,outChannels:F,padInfo:_,strideHeight:h,strideWidth:g,filterHeight:d,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:I,dilationHeight:x,dilationWidth:v,inShape:n,outShape:P,filterShape:e}}function v2(n,e,t,r,o,s=!1,i="channelsLast",a){let[c,l,u,p,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[c,l,u,p,d]=n;else if(i==="channelsFirst")[c,d,l,u,p]=n;else throw new Error(`Unknown dataFormat ${i}`);let[f,m,h,,g]=e,[x,v,w]=ZI(t),[I,_,A]=ZI(r),R=Up(f,I),F=Up(m,_),P=Up(h,A),{padInfo:L,outDepth:V,outHeight:z,outWidth:H}=IX(o,l,u,p,x,v,w,R,F,P,a),j=s?g*d:g,W;return i==="channelsFirst"?W=[c,j,V,z,H]:i==="channelsLast"&&(W=[c,V,z,H,j]),{batchSize:c,dataFormat:i,inDepth:l,inHeight:u,inWidth:p,inChannels:d,outDepth:V,outHeight:z,outWidth:H,outChannels:j,padInfo:L,strideDepth:x,strideHeight:v,strideWidth:w,filterDepth:f,filterHeight:m,filterWidth:h,effectiveFilterDepth:R,effectiveFilterHeight:F,effectiveFilterWidth:P,dilationDepth:I,dilationHeight:_,dilationWidth:A,inShape:n,outShape:W,filterShape:e}}function bX(n,e,t,r,o){r==null&&(r=JI(n,e,t));let s=n[0],i=n[1],a=om((s-e+2*r)/t+1,o),c=om((i-e+2*r)/t+1,o);return[a,c]}function CX(n,e,t,r,o,s){o==null&&(o=JI(n,e[0],r[0]));let i=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*o>=e[a]&&(i[a]=om((n[a]-e[a]+2*o)/r[a]+1,s));return i}function JI(n,e,t,r=1){let o=Up(e,r);return Math.floor((n[0]*(t-1)-t+o)/2)}function rm(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function ZI(n){return typeof n=="number"?[n,n,n]:n}function Up(n,e){return e<=1?n:n+(n-1)*(e-1)}function wX(n,e,t,r,o,s,i,a,c){let l,u,p;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};let f=bX([e,t],s,r,n,a);u=f[0],p=f[1]}else if(n==="same"){u=Math.ceil(e/r),p=Math.ceil(t/o);let d=Math.max(0,(u-1)*r+s-e),f=Math.max(0,(p-1)*o+i-t),m=Math.floor(d/2),h=d-m,g=Math.floor(f/2),x=f-g;l={top:m,bottom:h,left:g,right:x,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),p=Math.ceil((t-i+1)/o);else if(typeof n=="object"){let d=c==="channelsLast"?n[1][0]:n[2][0],f=c==="channelsLast"?n[1][1]:n[2][1],m=c==="channelsLast"?n[2][0]:n[3][0],h=c==="channelsLast"?n[2][1]:n[3][1];l={top:d,bottom:f,left:m,right:h,type:d===0&&f===0&&m===0&&h===0?"VALID":"EXPLICIT"},u=om((e-s+d+f)/r+1,a),p=om((t-i+m+h)/o+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outHeight:u,outWidth:p}}function IX(n,e,t,r,o,s,i,a,c,l,u){let p,d,f,m;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};let g=CX([e,t,r,1],[a,c,l],1,[o,s,i],n,u);d=g[0],f=g[1],m=g[2]}else if(n==="same"){d=Math.ceil(e/o),f=Math.ceil(t/s),m=Math.ceil(r/i);let h=(d-1)*o+a-e,g=(f-1)*s+c-t,x=(m-1)*i+l-r,v=Math.floor(h/2),w=h-v,I=Math.floor(g/2),_=g-I,A=Math.floor(x/2),R=x-A;p={top:I,bottom:_,left:A,right:R,front:v,back:w,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:d,outHeight:f,outWidth:m}}function om(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function nu(n){let[e,t,r]=rm(n);return e===1&&t===1&&r===1}function mn(n,e){return nu(n)||nu(e)}function Ao(n){return rm(n).every(e=>e>0)}function b2(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function _t(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")k(Jo(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(o=>{k(Jo(o),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${o}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}var On=D(()=>{"use strict";q();});function EX(n,e){let r={x:C(n,"x","reshape","string_or_numeric")},o={shape:e};return N.runKernel(fl,r,o)}var U,Se=D(()=>{"use strict";B();G();$();M();U=E({reshape_:EX})});function TX(n,e,t,r,o){let s=C(n,"x","avgPool","float32"),i=1;k(mn(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=s,c=!1;s.rank===3&&(c=!0,a=U(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),_t("avgPool",r,o);let l={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:o},p=N.runKernel(sc,l,u);return p=De(p,s.dtype),c?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var sm,eE=D(()=>{"use strict";B();G();$();q();an();On();M();Se();sm=E({avgPool_:TX})});function SX(n,e,t,r,o,s="NDHWC"){let i=C(n,"x","avgPool3d","float32"),a=i,c=!1;i.rank===4&&(c=!0,a=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),k(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),k(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),_t("avgPool3d",r,o);let l={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:o,dataFormat:s},p=N.runKernel(ic,l,u);return p=De(p,a.dtype),c?U(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var tE,C2=D(()=>{"use strict";B();G();$();q();an();On();M();Se();tE=E({avgPool3d_:SX})});function NX(n,e=0){k(n.length>=1,()=>"Pass at least one tensor to concat");let t=is(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return Fn(t[0]);let r=t,o={axis:e};return N.runKernel(fc,r,o)}var ot,Yr=D(()=>{"use strict";B();G();$();q();Vp();M();ot=E({concat_:NX})});function DX(n,e,t=!1,r=!1){let o=C(n,"a","matMul"),s=C(e,"b","matMul");[o,s]=Ee(o,s);let i={a:o,b:s},a={transposeA:t,transposeB:r};return N.runKernel(ac,i,a)}var ze,ps=D(()=>{"use strict";B();G();mt();$();M();ze=E({matMul_:DX})});function kX(n){let t={x:C(n,"x","sigmoid","float32")};return N.runKernel(Mi,t)}var Zr,im=D(()=>{"use strict";B();G();$();M();Zr=E({sigmoid_:kX})});function _X(n,e,t){let r=C(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let o={x:r},s={begin:e,size:t};return N.runKernel(Cl,o,s)}var Le,Ir=D(()=>{"use strict";B();G();$();M();Le=E({slice_:_X})});function AX(n){let t={x:C(n,"x","tanh","float32")};return N.runKernel(Bi,t)}var zp,nE=D(()=>{"use strict";B();G();$();M();zp=E({tanh_:AX})});function RX(n,e,t,r,o,s){let i=C(n,"forgetBias","basicLSTMCell"),a=C(e,"lstmKernel","basicLSTMCell"),c=C(t,"lstmBias","basicLSTMCell"),l=C(r,"data","basicLSTMCell"),u=C(o,"c","basicLSTMCell"),p=C(s,"h","basicLSTMCell"),d=ot([l,p],1),f=ze(d,a),m=de(f,c),h=m.shape[0],g=m.shape[1]/4,x=[h,g],v=Le(m,[0,0],x),w=Le(m,[0,g],x),I=Le(m,[0,g*2],x),_=Le(m,[0,g*3],x),A=de(ee(Zr(v),zp(w)),ee(u,Zr(de(i,I)))),R=ee(zp(A),Zr(_));return[A,R]}var rE,w2=D(()=>{"use strict";$();Ot();Yr();ps();ht();M();im();Ir();nE();rE=E({basicLSTMCell_:RX})});function FX(n,e,t){let r=C(n,"x","batchToSpaceND"),o=e.reduce((a,c)=>a*c);k(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),k(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),k(r.shape[0]%o===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`);let s={x:r},i={blockShape:e,crops:t};return N.runKernel(cc,s,i)}var am,oE=D(()=>{"use strict";B();G();$();q();M();am=E({batchToSpaceND_:FX})});function I2(n){let e;return n.rank===0||n.rank===1?e=U(n,[1,1,1,n.size]):n.rank===2?e=U(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}var E2=D(()=>{"use strict";Se()});function MX(n,e,t,r,o,s){s==null&&(s=.001);let i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),c=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let u;r!=null&&(u=C(r,"offset","batchNorm")),k(a.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:I2(i),scale:l,offset:u,mean:a,variance:c},f={varianceEpsilon:s},m=N.runKernel(Pc,d,f);return U(m,i.shape)}var ds,cm=D(()=>{"use strict";B();G();$();q();E2();M();Se();ds=E({batchNorm_:MX})});function OX(n,e,t,r,o,s){let i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),c=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let u;return r!=null&&(u=C(r,"offset","batchNorm")),k(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),k(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),k(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&k(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&k(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),ds(i,a,c,u,l,s)}var sE,T2=D(()=>{"use strict";$();q();cm();M();sE=E({batchNorm2d_:OX})});function $X(n,e,t,r,o,s){let i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),c=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let u;return r!=null&&(u=C(r,"offset","batchNorm")),k(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),k(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),k(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&k(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&k(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),ds(i,a,c,u,l,s)}var iE,S2=D(()=>{"use strict";$();q();cm();M();iE=E({batchNorm3d_:$X})});function PX(n,e,t,r,o,s){let i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),c=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let u;return r!=null&&(u=C(r,"offset","batchNorm")),k(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),k(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),k(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&k(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&k(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),ds(i,a,c,u,l,s)}var aE,N2=D(()=>{"use strict";$();q();cm();M();aE=E({batchNorm4d_:PX})});function LX(n,e,t){let r=C(n,"x","bincount"),o=C(e,"weights","bincount");k(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),k(t>=0,()=>`size must be non-negative, but got ${t}.`),k(o.size===r.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${o.shape}.`);let s={x:r,weights:o},i={size:t};return N.runKernel(lc,s,i)}var lm,cE=D(()=>{"use strict";B();G();$();q();M();lm=E({bincount_:LX})});function BX(n,e){let t=C(n,"x","bitwiseAnd"),r=C(e,"y","bitwiseAnd");if(!wn(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if(t.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);let o={a:t,b:r};return N.runKernel(ni,o)}var lE,D2=D(()=>{"use strict";B();G();$();Bt();M();lE=E({bitwiseAnd_:BX})});function VX(n,e){let t=C(n,"s0","broadcastArgs","int32"),r=C(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let o={s0:t,s1:r};return N.runKernel(uc,o)}var uE,k2=D(()=>{"use strict";B();G();$();M();uE=E({broadcastArgs_:VX})});function UX(n,e){let t=C(n,"broadcastTo","x"),r=t.shape;if(dt(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){let l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=U(t,l)}let o=t.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(o[l]===e[l])s[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(s.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return Fn(t);let a={x:t},c={reps:s};return N.runKernel(rs,a,c)}var fs,pE=D(()=>{"use strict";B();G();$();Bt();Vp();M();Se();fs=E({broadcastTo_:UX})});function zX(n){let t={x:C(n,"x","ceil","float32")};return N.runKernel(ri,t)}var dE,_2=D(()=>{"use strict";B();G();$();M();dE=E({ceil_:zX})});function Qr(n,e,t){dt(n),t=t||Ks(e);let r={shape:n,value:e,dtype:t};return N.runKernel(Oc,{},r)}var Hp=D(()=>{"use strict";B();G();q();Bt();});function HX(n,e,t){let r=C(n,"x","clipByValue");if(k(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Qr(r.shape,e,r.dtype);let o={x:r},s={clipValueMin:e,clipValueMax:t};return N.runKernel(oi,o,s)}var fE,A2=D(()=>{"use strict";B();G();$();q();Hp();M();fE=E({clipByValue_:HX})});function GX(n){return ot(n,0)}var mE,R2=D(()=>{"use strict";Yr();M();mE=E({concat1d_:GX})});function WX(n,e){return ot(n,e)}var hE,F2=D(()=>{"use strict";Yr();M();hE=E({concat2d_:WX})});function jX(n,e){return ot(n,e)}var gE,M2=D(()=>{"use strict";Yr();M();gE=E({concat3d_:jX})});function qX(n,e){return ot(n,e)}var xE,O2=D(()=>{"use strict";Yr();M();xE=E({concat4d_:qX})});function KX(n,e,t,r,o="NHWC",s=[1,1],i){let a=C(n,"x","conv2d","float32"),c=C(e,"filter","conv2d","float32"),l=a,u=!1;a.rank===3&&(u=!0,l=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),k(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),_t("conv2d",r,i);let p=o==="NHWC"?l.shape[3]:l.shape[1];k(p===c.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${c.shape[2]}.`),k(mn(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),k(Ao(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),k(Ao(t),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:l,filter:c},f={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},m=N.runKernel(mc,d,f);return u?U(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var ms,um=D(()=>{"use strict";B();G();$();q();On();M();Se();ms=E({conv2d_:KX})});function XX(n,e,t,r,o="NWC",s=1,i){let a=C(n,"x","conv1d"),c=C(e,"filter","conv1d"),l=a,u=!1;a.rank===2&&(u=!0,l=U(a,[1,a.shape[0],a.shape[1]])),k(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),k(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),_t("conv1d",r,i),k(l.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${c.shape[1]}.`),k(mn(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),k(Ao(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),k(Ao(t),()=>"Error in conv1D: Stride should be larger than 0."),k(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=U(c,[1,c.shape[0],c.shape[1],c.shape[2]]),d=U(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=ms(d,p,[1,t],r,"NHWC",[1,s],i);return u?U(g,[g.shape[2],g.shape[3]]):U(g,[g.shape[0],g.shape[2],g.shape[3]])}var yE,$2=D(()=>{"use strict";$();q();um();On();M();Se();yE=E({conv1d_:XX})});function YX(n,e,t,r,o,s="NHWC",i){k(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,c=e,l=!1;e.rank===3&&(l=!0,c=U(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),k(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),k(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),k(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);let u=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?c.shape[3]:c.shape[1];k(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),k(p===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${t.shape[3]}.`),_t("conv2dDerInput",o,i);let d={dy:c,filter:t},f={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},m=N.runKernel(gc,d,f);return l?U(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Cx,vE=D(()=>{"use strict";B();G();q();On();M();Se();Cx=E({conv2DBackpropInput_:YX})});function ZX(n,e,t,r,o,s){let i=C(n,"x","conv2dTranspose"),a=C(e,"filter","conv2dTranspose");return Cx(t,i,a,r,o,"NHWC",s)}var bE,P2=D(()=>{"use strict";$();vE();M();bE=E({conv2dTranspose_:ZX})});function QX(n,e,t,r,o="NDHWC",s=[1,1,1]){let i=C(n,"x","conv3d"),a=C(e,"filter","conv3d"),c=i,l=!1;i.rank===4&&(l=!0,c=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),k(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),k(c.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${a.shape[3]}.`),k(mn(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),k(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`),k(Ao(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),k(Ao(t),()=>"Error in conv3D: Strides should be larger than 0.");let u={x:c,filter:a},p={strides:t,pad:r,dataFormat:o,dilations:s},d=N.runKernel(xc,u,p);return l?U(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var CE,L2=D(()=>{"use strict";B();G();$();q();On();M();Se();CE=E({conv3d_:QX})});function JX(n,e,t,r,o){k(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let s=n,i=e,a=!1;e.rank===4&&(a=!0,i=U(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,n[0],n[1],n[2],n[3]]);let c=s[4],l=i.shape[4];k(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),k(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),k(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),k(c===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[3]}.`),k(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);let u={dy:i,filter:t},p={pad:o,strides:r,inputShape:s},d=N.runKernel(yc,u,p);return a?U(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var B2,V2=D(()=>{"use strict";B();G();q();M();Se();B2=E({conv3DBackpropInput_:JX})});function eY(n,e,t,r,o){let s=C(n,"x","conv3dTranspose"),i=C(e,"filter","conv3dTranspose");return B2(t,s,i,r,o)}var wE,U2=D(()=>{"use strict";$();V2();M();wE=E({conv3dTranspose_:eY})});function tY(n){let t={x:C(n,"x","cos","float32")};return N.runKernel("Cos",t)}var IE,z2=D(()=>{"use strict";B();$();M();IE=E({cos_:tY})});function nY(n){let t={x:C(n,"x","cosh","float32")};return N.runKernel(si,t)}var EE,H2=D(()=>{"use strict";B();G();$();M();EE=E({cosh_:nY})});function rY(n,e=0,t=!1,r=!1){let s={x:C(n,"x","cumprod")},i={axis:e,exclusive:t,reverse:r};return N.runKernel(bc,s,i)}var TE,G2=D(()=>{"use strict";B();G();$();M();TE=E({cumprod_:rY})});function oY(n,e=0,t=!1,r=!1){let s={x:C(n,"x","cumsum")},i={axis:e,exclusive:t,reverse:r};return N.runKernel(Cc,s,i)}var SE,W2=D(()=>{"use strict";B();G();$();M();SE=E({cumsum_:oY})});function sY(n,e,t,r=!1){let o=C(n,"x","denseBincount"),s=C(e,"weights","denseBincount");k(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),k(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),k(t>=0,()=>`size must be non-negative, but got ${t}.`),k(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:t,binaryOutput:r};return N.runKernel(Ic,i,a)}var NE,j2=D(()=>{"use strict";B();G();$();q();M();NE=E({denseBincount_:sY})});function iY(n,e,t="NHWC"){let r=C(n,"x","depthToSpace","float32"),o=t==="NHWC"?r.shape[1]:r.shape[2],s=t==="NHWC"?r.shape[2]:r.shape[3],i=t==="NHWC"?r.shape[3]:r.shape[1];k(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),k(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e}  for depthToSpace with input shape
    ${r.shape}`),k(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${r.shape}`),k(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`);let a={x:r},c={blockSize:e,dataFormat:t};return N.runKernel(Ec,a,c)}var DE,q2=D(()=>{"use strict";B();G();$();q();M();DE=E({depthToSpace_:iY})});function aY(n,e,t,r,o="NHWC",s=[1,1],i){let a=C(n,"x","depthwiseConv2d","float32"),c=C(e,"filter","depthwiseConv2d","float32"),l=a,u=!1;a.rank===3&&(u=!0,l=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),k(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);let p=o==="NHWC"?l.shape[3]:l.shape[1];k(p===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${c.shape[2]}.`),_t("depthwiseConv2d",r,i);let d={x:l,filter:c},f={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},m=N.runKernel(Tc,d,f);return u?U(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var ou,wx=D(()=>{"use strict";B();G();$();q();On();M();Se();ou=E({depthwiseConv2d_:aY})});function cY(n){let t={x:C(n,"x","diag")};return N.runKernel(Dc,t)}var kE,K2=D(()=>{"use strict";B();G();$();M();kE=E({diag_:cY})});function lY(n,e,t,r,o=[1,1],s="NHWC"){let i=C(n,"x","dilation2d"),a=C(e,"filter","dilation2d");k(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),k(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),k(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let c=i,l=!1;i.rank===3&&(c=U(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),k(c.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${a.shape[2]}`);let u={x:c,filter:a},p={strides:t,pad:r,dilations:o},d=N.runKernel(kc,u,p);return l?U(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var _E,X2=D(()=>{"use strict";B();G();$();q();M();Se();_E=E({dilation2d_:lY})});var Jr={};Ue(Jr,{assertAndGetBroadcastShape:()=>We,getBroadcastDims:()=>Y2,getReductionAxes:()=>Ix});function Y2(n,e){let t=n.length,r=[];for(let o=0;o<t;o++){let s=t-1-o,i=n[s]||1;(e[e.length-1-o]||1)>1&&i===1&&r.unshift(s)}return r}function Ix(n,e){let t=[];for(let r=0;r<e.length;r++){let o=n[n.length-r-1],s=e.length-r-1,i=e[s];(o==null||o===1&&i>1)&&t.unshift(s)}return t}function We(n,e){let t=Math.max(n.length,e.length),r=new Array(t);for(let o=0;o<t;o++){let s=n[n.length-o-1];s==null&&(s=1);let i=e[e.length-o-1];if(i==null&&(i=1),s===1)r[t-o-1]=i;else if(i===1)r[t-o-1]=s;else if(s!==i){let a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else r[t-o-1]=s}return r}var zt=D(()=>{"use strict";});function uY(n,e){let t=C(n,"a","equal","string_or_numeric"),r=C(e,"b","equal","string_or_numeric");[t,r]=Ee(t,r),We(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(ai,o)}var pm,AE=D(()=>{"use strict";B();G();mt();$();zt();M();pm=E({equal_:uY})});function pY(n,e,t){let r=C(e,"a","where"),o=C(t,"b","where"),s=C(n,"condition","where","bool"),i=We(We(s.shape,r.shape),o.shape),a=fs(s,i),c=fs(r,i),l=fs(o,i),u={condition:a,t:c,e:l};return N.runKernel(bl,u)}var qn,Gp=D(()=>{"use strict";B();G();$();pE();zt();M();qn=E({where_:pY})});function dY(n){let t={x:C(n,"x","zerosLike")};return N.runKernel(zl,t)}var Ft,hs=D(()=>{"use strict";B();G();$();M();Ft=E({zerosLike_:dY})});function fY(n,e){let t=C(n,"a","div"),r=C(e,"b","div");[t,r]=Ee(t,r);let o=Pe(t,r),s=Ft(o),i=pm(r,s);return qn(i,s,o)}var RE,Z2=D(()=>{"use strict";mt();$();Mn();AE();M();Gp();hs();RE=E({divNoNan_:fY})});function mY(n,e){let t=C(n,"t1","dot"),r=C(e,"t2","dot");k((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);let o=t.rank===1?t.size:t.shape[1],s=r.rank===1?r.size:r.shape[0];if(k(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),t.rank===1&&r.rank===1){let i=U(t,[1,-1]),a=U(r,[-1,1]),c=ze(i,a);return U(c,[])}else if(t.rank===1&&r.rank===2){let i=U(t,[1,-1]),a=U(r,[r.shape[0],r.shape[1]]),c=ze(i,a);return U(c,[c.size])}else if(t.rank===2&&r.rank===1){let i=U(r,[-1,1]),a=ze(t,i);return U(a,[a.size])}else{let i=U(r,[r.shape[0],r.shape[1]]);return ze(t,i)}}var FE,Q2=D(()=>{"use strict";$();q();ps();M();Se();FE=E({dot_:mY})});function hY(n,...e){let t=e.map((o,s)=>C(o,`tensors${s}`,"einsum")),r={equation:n};return N.runKernel(_c,t,r)}var gs,ME=D(()=>{"use strict";B();G();$();M();gs=E({einsum_:hY})});function gY(n){let t={x:C(n,"x","elu","float32")};return N.runKernel("Elu",t)}var dm,OE=D(()=>{"use strict";B();$();M();dm=E({elu_:gY})});function xY(n,e){let t=C(n,"x","ensureShape","string_or_numeric");if(!Zw(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}var $E,J2=D(()=>{"use strict";$();Bt();M();$E=E({ensureShape_:xY})});function yY(n){let e=C(n,"x","erf");k(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=De(e,"float32"));let t={x:e};return N.runKernel("Erf",t)}var PE,eF=D(()=>{"use strict";B();$();q();an();M();PE=E({erf_:yY})});function LE(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function tF(n,e,t){let r=n.length+e.length,o=[],s=0,i=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?o.push(n[s++]):o.push(e[i++]);return o}function vY(n,e){let t=[],r=n.length;for(let s=0;s<r;s++)e.indexOf(s)===-1&&t.push(n[s]);let o=e.map(s=>n[s]);return[t,o]}function xs(n,e){let t=e.map(r=>1);return tF(n,t,e)}function bY(n,e,t){k(LE(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function CY(n,e){if(LE(n,e))return null;let t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function wY(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function IY(n,e){let t=[];for(let r=e-n;r<e;++r)t.push(r);return t}var Wp=D(()=>{"use strict";q();});function TY(n,e=null,t=!1){let o={x:C(n,"x","max")},s={reductionIndices:e,keepDims:t};return N.runKernel("Max",o,s)}var eo,fm=D(()=>{"use strict";B();$();M();eo=E({max_:TY})});function SY(n,e=null,t=!1){let o={x:C(n,"x","min")},s={axis:e,keepDims:t};return N.runKernel("Min",o,s)}var jp,BE=D(()=>{"use strict";B();$();M();jp=E({min_:SY})});function NY(n,e){let t=C(n,"base","pow"),r=C(e,"exp","pow");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel("Pow",o)}var Fo,mm=D(()=>{"use strict";B();mt();$();M();Fo=E({pow_:NY})});function me(n,e){if((Nt(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Nt(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Tn(n,[],[],e)}var hn=D(()=>{"use strict";q();as();});function DY(n){let t={x:C(n,"x","sqrt","float32")};return N.runKernel($i,t)}var Nn,qp=D(()=>{"use strict";B();G();$();M();Nn=E({sqrt_:DY})});function kY(n){let e=C(n,"x","square"),t={};return N.runKernel("Square",{x:e},t)}var Ht,ys=D(()=>{"use strict";B();$();M();Ht=E({square_:kY})});function _Y(n,e=null,t=!1){let r=C(n,"x","sum");r.dtype==="bool"&&(r=De(r,"int32"));let o={x:r},s={axis:e,keepDims:t};return N.runKernel("Sum",o,s)}var je,to=D(()=>{"use strict";B();$();an();M();je=E({sum_:_Y})});function AY(n,e="euclidean",t=null,r=!1){n=C(n,"x","norm");let o=nF(n,e,t),s=o.shape;if(r){let i=qs(t,n.shape);s=xs(o.shape,i)}return U(o,s)}function nF(n,e,t=null){if(n.rank===0)return Ut(n);if(n.rank!==1&&t===null)return nF(U(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return je(Ut(n),t);if(e===1/0)return eo(Ut(n),t);if(e===-1/0)return jp(Ut(n),t);if(e==="euclidean"||e===2)return Nn(je(Fo(Ut(n),me(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return eo(je(Ut(n),t[0]),t[1]-1);if(e===1/0)return eo(je(Ut(n),t[1]),t[0]);if(e===-1/0)return jp(je(Ut(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Nn(je(Ht(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}var Qi,hm=D(()=>{"use strict";$();q();tu();Wp();fm();BE();M();mm();Se();hn();qp();ys();to();Qi=E({norm_:AY})});function RY(n,e=null,t=!1){return Qi(n,"euclidean",e,t)}var VE,rF=D(()=>{"use strict";hm();M();VE=E({euclideanNorm_:RY})});function FY(n){let t={x:C(n,"x","exp")};return N.runKernel("Exp",t)}var ur,Kp=D(()=>{"use strict";B();$();M();ur=E({exp_:FY})});function MY(n,e=0){let t=C(n,"x","expandDims","string_or_numeric");k(e<=t.rank,()=>"Axis must be <= rank of the tensor");let r={input:t},o={dim:e};return N.runKernel(Mc,r,o)}var Er,Ex=D(()=>{"use strict";B();G();$();q();M();Er=E({expandDims_:MY})});function OY(n){let t={x:C(n,"x","expm1")};return N.runKernel(ci,t)}var UE,oF=D(()=>{"use strict";B();G();$();M();UE=E({expm1_:OY})});function $Y(n,e){let t=C(n,"x","tile","string_or_numeric");k(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);let r={x:t},o={reps:e};return N.runKernel(rs,r,o)}var vs,Tx=D(()=>{"use strict";B();G();$();q();M();vs=E({tile_:$Y})});function PY(n,e,t,r="float32"){e==null&&(e=n);let o=le([n,e],r),s=n<=e?n:e;for(let a=0;a<s;++a)o.set(1,a,a);let i=U(o.toTensor(),[n,e]);if(t==null)return i;if(t.length===1)return vs(Er(i,0),[t[0],1,1]);if(t.length===2)return vs(Er(Er(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return vs(Er(Er(Er(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}var gm,zE=D(()=>{"use strict";us();Ex();M();Se();Tx();gm=E({eye_:PY})});function LY(n){let t={x:C(n,"x","floor","float32")};return N.runKernel(li,t)}var xm,HE=D(()=>{"use strict";B();G();$();M();xm=E({floor_:LY})});function BY(n,e,t=0,r=0){let o=C(n,"x","gather"),s=C(e,"indices","gather","int32"),i={x:o,indices:s},a={axis:t,batchDims:r};return N.runKernel(Lc,i,a)}var ym,GE=D(()=>{"use strict";B();G();$();M();ym=E({gather_:BY})});function VY(n,e){let t=C(n,"a","greater","string_or_numeric"),r=C(e,"b","greater","string_or_numeric");[t,r]=Ee(t,r),We(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(pi,o)}var Ji,Sx=D(()=>{"use strict";B();G();mt();$();zt();M();Ji=E({greater_:VY})});function UY(n,e){let t=C(n,"a","greaterEqual","string_or_numeric"),r=C(e,"b","greaterEqual","string_or_numeric");[t,r]=Ee(t,r),We(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(di,o)}var vm,WE=D(()=>{"use strict";B();G();mt();$();zt();M();vm=E({greaterEqual_:UY})});function zY(n){let t={input:C(n,"input","imag")};return N.runKernel(Uc,t)}var bs,bm=D(()=>{"use strict";B();G();$();M();bs=E({imag_:zY})});function HY(n){let t={x:C(n,"x","isFinite")};return N.runKernel(fi,t)}var jE,sF=D(()=>{"use strict";B();G();$();M();jE=E({isFinite_:HY})});function GY(n){let t={x:C(n,"x","isInf")};return N.runKernel(mi,t)}var qE,iF=D(()=>{"use strict";B();G();$();M();qE=E({isInf_:GY})});function WY(n){let t={x:C(n,"x","isNaN")};return N.runKernel(hi,t)}var KE,aF=D(()=>{"use strict";B();G();$();M();KE=E({isNaN_:WY})});function jY(n,e=.2){let r={x:C(n,"x","leakyRelu")},o={alpha:e};return N.runKernel(zc,r,o)}var Cm,XE=D(()=>{"use strict";B();G();$();M();Cm=E({leakyRelu_:jY})});function qY(n,e){let t=C(n,"a","less","string_or_numeric"),r=C(e,"b","less","string_or_numeric");[t,r]=Ee(t,r),We(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(gi,o)}var Xp,YE=D(()=>{"use strict";B();G();mt();$();zt();M();Xp=E({less_:qY})});function KY(n,e){let t=C(n,"a","lessEqual","string_or_numeric"),r=C(e,"b","lessEqual","string_or_numeric");[t,r]=Ee(t,r),We(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(xi,o)}var su,Nx=D(()=>{"use strict";B();G();mt();$();zt();M();su=E({lessEqual_:KY})});function ZE(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");let r={start:n,stop:e,num:t};return N.runKernel(Hc,{},r)}var cF=D(()=>{"use strict";B();G();});function XY(n,e=5,t=1,r=1,o=.5){let s=C(n,"x","localResponseNormalization");k(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),k(Jo(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=U(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let c={x:i},l={depthRadius:e,bias:t,alpha:r,beta:o},u=N.runKernel("LRN",c,l);return a?U(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var QE,lF=D(()=>{"use strict";B();$();q();M();Se();QE=E({localResponseNormalization_:XY})});function YY(n){let t={x:C(n,"x","log","float32")};return N.runKernel("Log",t)}var Mo,wm=D(()=>{"use strict";B();$();M();Mo=E({log_:YY})});function ZY(n){let t={x:C(n,"x","log1p")};return N.runKernel(yi,t)}var Im,JE=D(()=>{"use strict";B();G();$();M();Im=E({log1p_:ZY})});function uF(n){return k(So(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{let r=C(e,"x","tf.grad","string_or_numeric"),o=t!=null?C(t,"dy","tf.grad"):null;return N.tidy(()=>{let{value:s,grads:i}=N.gradients(()=>n(r),[r],o);return o!=null&&it(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),kx(i),i[0]})}}function pF(n){return k(So(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{k(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=is(e,"args","tf.grads","string_or_numeric"),o=t!=null?C(t,"dy","tf.grads"):null;return N.tidy(()=>{let{value:s,grads:i}=N.gradients(()=>n(...r),r,o);return o!=null&&it(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),kx(i),i})}}function dF(n){return k(So(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{k(e instanceof Ze,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),k(t==null||t instanceof Ze,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:o}=N.gradients(()=>n(e),[e],t);return kx(r),{grad:r[0],value:o}}}function fF(n){return k(So(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{k(Array.isArray(e)&&e.every(o=>o instanceof Ze),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),k(t==null||t instanceof Ze,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=N.gradients(()=>n(...e),e,t);return t!=null&&it(r.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),kx(r.grads),r}}function Dx(n,e){k(So(n),()=>"The f passed in variableGrads(f) must be a function"),k(e==null||Array.isArray(e)&&e.every(l=>l instanceof ko),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let t=e!=null;if(!t){e=[];for(let l in N.registeredVariables)e.push(N.registeredVariables[l])}let r=t?e.filter(l=>!l.trainable):null,o=e.length;e=e.filter(l=>l.trainable),k(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=N.gradients(n,e,null,s);k(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),k(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let c={};return e.forEach((l,u)=>{a[u]!=null&&(c[l.name]=a[u])}),r?.forEach(l=>c[l.name]=null),{value:i,grads:c}}function gn(n){return N.customGrad(n)}function kx(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}var Cs=D(()=>{"use strict";B();cr();$();q();});function QY(n){let t={x:C(n,"x","neg")};return N.runKernel("Neg",t)}var Qt,ws=D(()=>{"use strict";B();$();M();Qt=E({neg_:QY})});function JY(n){let t={x:C(n,"x","softplus")};return N.runKernel(Oi,t)}var Em,eT=D(()=>{"use strict";B();G();$();M();Em=E({softplus_:JY})});function eZ(n){let e=C(n,"x","logSigmoid");return gn(r=>({value:Qt(Em(Qt(r))),gradFunc:i=>ee(i,Zr(Qt(r)))}))(e)}var tT,mF=D(()=>{"use strict";Cs();$();ht();ws();M();im();eT();tT=E({logSigmoid_:eZ})});function tZ(n,e){let t=C(n,"a","sub"),r=C(e,"b","sub");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel("Sub",o)}var ge,Gt=D(()=>{"use strict";B();mt();$();M();ge=E({sub_:tZ})});function nZ(n,e=-1){let t=C(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return gn((o,s)=>{let a=eo(o,e,!0),c=ge(o,a),l=ge(De(c,"float32"),Mo(je(ur(c),e,!0)));return s([l]),{value:l,gradFunc:(p,d)=>{let[f]=d,m=!0,h=ur(f);return ge(p,ee(je(p,e,m),h))}}})(t)}var nT,hF=D(()=>{"use strict";Cs();$();an();Kp();wm();fm();ht();M();Gt();to();nT=E({logSoftmax_:nZ})});function rZ(n,e=null,t=!1){let r=C(n,"x","logSumExp"),o=qs(e,r.shape),s=eo(r,o,!0),i=ge(r,s),a=ur(i),c=je(a,o),l=Mo(c),u=de(U(s,l.shape),l);if(t){let p=xs(u.shape,o);return U(u,p)}return u}var Tm,rT=D(()=>{"use strict";$();q();Ot();Wp();Kp();wm();fm();M();Se();Gt();to();Tm=E({logSumExp_:rZ})});function oZ(n,e){let t=C(n,"a","logicalAnd","bool"),r=C(e,"b","logicalAnd","bool");We(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(vi,o)}var ea,_x=D(()=>{"use strict";B();G();$();zt();M();ea=E({logicalAnd_:oZ})});function sZ(n){let t={x:C(n,"x","logicalNot","bool")};return N.runKernel(bi,t)}var Sm,oT=D(()=>{"use strict";B();G();$();M();Sm=E({logicalNot_:sZ})});function iZ(n,e){let t=C(n,"a","logicalOr","bool"),r=C(e,"b","logicalOr","bool");We(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Ci,o)}var Nm,sT=D(()=>{"use strict";B();G();$();zt();M();Nm=E({logicalOr_:iZ})});function aZ(n,e){let t=C(n,"a","logicalXor","bool"),r=C(e,"b","logicalXor","bool");return We(t.shape,r.shape),ea(Nm(n,e),Sm(ea(n,e)))}var iT,gF=D(()=>{"use strict";$();zt();_x();oT();sT();M();iT=E({logicalXor_:aZ})});function cZ(n,e,t="left"){let r=C(n,"sortedSequence","searchSorted"),o=C(e,"values","searchSorted"),s=r.shape[r.shape.length-1],i=o.shape[o.shape.length-1],a=U(r,[-1,s]),c=U(o,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ne(c.shape)>=Ax)throw new Error(`values tensor size must less than ${Ax}`);if(a.shape[1]>=Ax)throw new Error(`trailing dim_size must less than ${Ax} for int32 output type, was ${a.shape[1]}`);let l={sortedSequence:a,values:c},u={side:t};return N.runKernel(vl,l,u)}var Ax,Yp,Rx=D(()=>{"use strict";B();G();$();Bt();M();Se();Ax=2147483648;Yp=E({searchSorted_:cZ})});function aT(n,e){return Yp(n,e,"left")}var xF=D(()=>{"use strict";Rx();});function lZ(n,e,t,r,o){let s=C(n,"x","maxPool"),i=1,a=s,c=!1;s.rank===3&&(c=!0,a=U(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),k(mn(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),_t("maxPool",r,o);let l={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:o},p=N.runKernel(Wc,l,u);return c?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Dm,cT=D(()=>{"use strict";B();G();$();q();On();M();Se();Dm=E({maxPool_:lZ})});function uZ(n,e=[1,1,1],t,r,o,s="NDHWC"){let i=C(n,"x","maxPool3d"),a=i,c=!1;i.rank===4&&(c=!0,a=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),k(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),_t("maxPool3d",r,o);let l={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:o,dataFormat:s},p=N.runKernel(jc,l,u);return c?U(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var lT,yF=D(()=>{"use strict";B();G();$();q();On();M();Se();lT=E({maxPool3d_:uZ})});function pZ(n,e,t,r,o=!1){let i={x:C(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:r,includeBatchInIndex:o},c=N.runKernel(qc,i,a);return{result:c[0],indexes:c[1]}}var uT,vF=D(()=>{"use strict";B();G();$();M();uT=E({maxPoolWithArgmax_:pZ})});function dZ(n,e){let t=C(n,"a","maximum"),r=C(e,"b","maximum");[t,r]=Ee(t,r),t.dtype==="bool"&&(t=De(t,"int32"),r=De(r,"int32")),We(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(wi,o)}var km,pT=D(()=>{"use strict";B();G();mt();$();zt();an();M();km=E({maximum_:dZ})});function fZ(n,e=null,t=!1){let o={x:C(n,"x","mean")},s={axis:e,keepDims:t};return N.runKernel(Kc,o,s)}var ta,Fx=D(()=>{"use strict";B();G();$();M();ta=E({mean_:fZ})});function pr(n,e="float32"){if(dt(n),e==="complex64"){let r=pr(n,"float32"),o=pr(n,"float32");return En(r,o)}let t=hp(Ne(n),e);return N.makeTensor(t,n,e)}var _m=D(()=>{"use strict";B();q();qi();});function no(n,e="float32"){if(dt(n),e==="complex64"){let r=no(n,"float32"),o=pr(n,"float32");return En(r,o)}let t=Ff(Ne(n),e);return N.makeTensor(t,n,e)}var Mx=D(()=>{"use strict";B();q();Bt();qi();_m();});function dT(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=C(n,"x","meshgrid",n instanceof Ze?n.dtype:"float32");if(e===void 0)return[r];let o=C(e,"y","meshgrid",e instanceof Ze?e.dtype:"float32"),s=Ne(r.shape),i=Ne(o.shape);return t==="xy"?(r=U(r,[1,-1]),o=U(o,[-1,1]),[ze(no([i,1],r.dtype),r),ze(o,no([1,s],o.dtype))]):(r=U(r,[-1,1]),o=U(o,[1,-1]),[ze(r,no([1,i],r.dtype)),ze(no([s,1],o.dtype),o)])}var bF=D(()=>{"use strict";ps();Mx();Se();cr();$();Bt();});function mZ(n,e){let t=C(n,"a","minimum"),r=C(e,"b","minimum");[t,r]=Ee(t,r),t.dtype==="bool"&&(t=De(t,"int32"),r=De(r,"int32")),We(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Ii,o)}var na,Ox=D(()=>{"use strict";B();G();mt();$();zt();an();M();na=E({minimum_:mZ})});function hZ(n,e,t){k(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);let r=C(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");k(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);let o=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)k(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),k(e[a][0]>=0&&e[a][0]<=r.shape[a]-o&&e[a][1]>=0&&e[a][1]<=r.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-o} or less than 0 for input of shape ${r.shape}`);let s={paddings:e,mode:t},i={x:r};return N.runKernel(Xc,i,s)}var fT,CF=D(()=>{"use strict";B();G();$();q();M();fT=E({mirrorPad_:hZ})});function gZ(n,e){let t=C(n,"a","mod"),r=C(e,"b","mod");[t,r]=Ee(t,r);let o={a:t,b:r};return N.runKernel("Mod",o)}var mT,wF=D(()=>{"use strict";B();mt();$();M();mT=E({mod_:gZ})});function xZ(n,e=null,t=!1){n=C(n,"x","moments");let r=qs(e,n.shape),o=ta(n,r,t),s=o.shape;t||(s=xs(o.shape,r));let i=Ht(ge(De(n,"float32"),U(o,s))),a=ta(i,r,t);return{mean:o,variance:a}}var hT,IF=D(()=>{"use strict";$();q();Wp();an();Fx();M();Se();ys();Gt();hT=E({moments_:xZ})});function yZ(n,e,t,r){let o=C(e,"data","multiRNNCell"),s=is(t,"c","multiRNNCell"),i=is(r,"h","multiRNNCell"),a=o,c=[];for(let p=0;p<n.length;p++){let d=n[p](a,s[p],i[p]);c.push(d[0]),c.push(d[1]),a=d[1]}let l=[],u=[];for(let p=0;p<c.length;p+=2)l.push(c[p]),u.push(c[p+1]);return[l,u]}var gT,EF=D(()=>{"use strict";$();M();gT=E({multiRNNCell_:yZ})});function vZ(n,e,t,r=!1){let o=C(n,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();let c={logits:i===1?U(o,[1,-1]):o},l={numSamples:e,seed:t,normalized:r},u=N.runKernel(Zc,c,l);return i===1?U(u,[u.size]):u}var xT,TF=D(()=>{"use strict";B();G();$();M();Se();xT=E({multinomial_:vZ})});function bZ(n,e){let t=C(n,"a","notEqual","string_or_numeric"),r=C(e,"b","notEqual","string_or_numeric");[t,r]=Ee(t,r),We(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Ti,o)}var Am,yT=D(()=>{"use strict";B();G();mt();$();zt();M();Am=E({notEqual_:bZ})});function CZ(n,e,t=1,r=0,o="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);let i={indices:C(n,"indices","oneHot","int32")},a={dtype:o,depth:e,onValue:t,offValue:r};return N.runKernel(nl,i,a)}var Zp,vT=D(()=>{"use strict";B();G();$();M();Zp=E({oneHot_:CZ})});function wZ(n){let t={x:C(n,"x","onesLike")};return N.runKernel(tl,t)}var bT,SF=D(()=>{"use strict";B();G();$();M();bT=E({onesLike_:wZ})});function IZ(n,e){let t=C(n,"v1","outerProduct"),r=C(e,"v2","outerProduct");k(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);let o=U(t,[-1,1]),s=U(r,[1,-1]);return ze(o,s)}var CT,NF=D(()=>{"use strict";$();q();ps();M();Se();CT=E({outerProduct_:IZ})});function EZ(n,e,t=0){let r=C(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:e,constantValue:t},s={x:r};return N.runKernel(ol,s,o)}var ro,Qp=D(()=>{"use strict";B();G();$();M();ro=E({pad_:EZ})});function TZ(n,e,t=0){return k(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),ro(n,[e],t)}var wT,DF=D(()=>{"use strict";q();M();Qp();wT=E({pad1d_:TZ})});function SZ(n,e,t=0){return k(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ro(n,e,t)}var IT,kF=D(()=>{"use strict";q();M();Qp();IT=E({pad2d_:SZ})});function NZ(n,e,t=0){return k(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ro(n,e,t)}var ET,_F=D(()=>{"use strict";q();M();Qp();ET=E({pad3d_:NZ})});function DZ(n,e,t=0){return k(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ro(n,e,t)}var TT,AF=D(()=>{"use strict";q();M();Qp();TT=E({pad4d_:DZ})});function kZ(n,e,t){let r=C(n,"x","spaceToBatchND");k(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),k(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),k(r.shape.reduce((i,a,c)=>c>0&&c<=e.length?i&&(a+t[c-1][0]+t[c-1][1])%e[c-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);let o={x:r},s={blockShape:e,paddings:t};return N.runKernel(Il,o,s)}var Rm,ST=D(()=>{"use strict";B();G();$();q();M();Rm=E({spaceToBatchND_:kZ})});function _Z(n,e,t,r,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),r===0&&(r="valid");let a=C(n,"x","maxPool"),c=a,l=!1;a.rank===3&&(l=!0,c=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(mn(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let u=QI(c.shape,e,s,o,r),p=[u.dilationHeight,u.dilationWidth],d;r==="same"?d=RZ([u.filterHeight,u.filterWidth],p):d=[[0,0],[0,0]];let f=p[0]===1&&p[1]===1,[m,h]=AZ([u.inHeight,u.inWidth],p,d),g=f?r:"valid",x=f?c:Rm(c,p,m),w=(t==="avg"?()=>sm(x,e,s,g,i):()=>Dm(x,e,s,g,i))(),I=f?w:am(w,p,h);return l?U(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function AZ(n,e,t){let r=t.map(u=>u[0]),o=t.map(u=>u[1]),s=n.concat(r,o),i=e.map((u,p)=>(u-s[p]%u)%u),a=o.map((u,p)=>u+i[p]),c=e.map((u,p)=>[r[p],a[p]]),l=e.map((u,p)=>[0,i[p]]);return[c,l]}function RZ(n,e){let r=n.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),o=r.map(i=>Math.floor(i/2)),s=r.map((i,a)=>i-o[a]);return r.map((i,a)=>[o[a],s[a]])}var NT,RF=D(()=>{"use strict";$();q();eE();oE();On();cT();M();Se();ST();NT=E({pool_:_Z})});function FZ(n,e){let t=C(n,"x","prelu"),r=C(e,"alpha","prelu"),o={x:t,alpha:r};return N.runKernel(il,o)}var Fm,DT=D(()=>{"use strict";B();G();$();M();Fm=E({prelu_:FZ})});function MZ(n,e=null,t=!1){let r=C(n,"x","prod");r.dtype==="bool"&&(r=De(r,"int32"));let o={x:r},s={axis:e,keepDims:t};return N.runKernel(al,o,s)}var kT,FF=D(()=>{"use strict";B();G();$();an();M();kT=E({prod_:MZ})});function OZ(n,e,t,r){let o=n.map((u,p)=>C(u,`tensors${p}`,"raggedGather","int32")),s=C(e,"paramsDenseValues","raggedGather"),i=C(t,"indices","raggedGather","int32"),a={paramsNestedSplits:o,paramsDenseValues:s,indices:i},c={outputRaggedRank:r},l=N.runKernel(cl,a,c);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}var _T,MF=D(()=>{"use strict";B();G();$();M();_T=E({raggedGather_:OZ})});function $Z(n,e,t){let r=C(n,"starts","raggedRange"),o=C(e,"limits","raggedRange",r.dtype),s=C(t,"deltas","raggedRange",r.dtype),i={starts:r,limits:o,deltas:s},a=N.runKernel(ll,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}var AT,OF=D(()=>{"use strict";B();G();$();M();AT=E({raggedRange_:$Z})});function PZ(n,e,t,r,o){let s=C(n,"shape","raggedTensorToTensor","int32"),i=C(e,"values","raggedTensorToTensor"),a=C(t,"defaultValue","raggedTensorToTensor",i.dtype),c=r.map((p,d)=>C(p,`tensors${d}`,"raggedTensorToTensor","int32")),l={shape:s,values:i,defaultValue:a,rowPartitionTensors:c},u={rowPartitionTypes:o};return N.runKernel(ul,l,u)}var RT,$F=D(()=>{"use strict";B();G();$();M();RT=E({raggedTensorToTensor_:PZ})});function LZ(n,e,t){dt(n);let r=Ne(n),o=null;if(t==null||t==="float32")o=new Float32Array(r);else if(t==="int32")o=new Int32Array(r);else if(t==="bool")o=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<r;s++)o[s]=e();return N.makeTensor(o,n,t)}var FT,PF=D(()=>{"use strict";B();q();Bt();M();FT=E({rand_:LZ})});var BF=rr((LF,MT)=>{"use strict";(function(n,e,t){function r(a){var c=this,l=i();c.next=function(){var u=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=u-(c.c=u|0)},c.c=1,c.s0=l(" "),c.s1=l(" "),c.s2=l(" "),c.s0-=l(a),c.s0<0&&(c.s0+=1),c.s1-=l(a),c.s1<0&&(c.s1+=1),c.s2-=l(a),c.s2<0&&(c.s2+=1),l=null}function o(a,c){return c.c=a.c,c.s0=a.s0,c.s1=a.s1,c.s2=a.s2,c}function s(a,c){var l=new r(a),u=c&&c.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,u&&(typeof u=="object"&&o(u,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,c=function(l){l=String(l);for(var u=0;u<l.length;u++){a+=l.charCodeAt(u);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(LF,typeof MT=="object"&&MT,typeof define=="function"&&define)});var UF=rr((VF,OT)=>{"use strict";(function(n,e,t){function r(i){var a=this,c="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var u=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^u^u>>>8},i===(i|0)?a.x=i:c+=i;for(var l=0;l<c.length+64;l++)a.x^=c.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var c=new r(i),l=a&&a.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,l&&(typeof l=="object"&&o(l,c),u.state=function(){return o(c,{})}),u}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(VF,typeof OT=="object"&&OT,typeof define=="function"&&define)});var HF=rr((zF,$T)=>{"use strict";(function(n,e,t){function r(i){var a=this,c="";a.next=function(){var u=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(u^u<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:c+=i;for(var l=0;l<c.length+64;l++)a.x^=c.charCodeAt(l)|0,l==c.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var c=new r(i),l=a&&a.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,l&&(typeof l=="object"&&o(l,c),u.state=function(){return o(c,{})}),u}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(zF,typeof $T=="object"&&$T,typeof define=="function"&&define)});var WF=rr((GF,PT)=>{"use strict";(function(n,e,t){function r(i){var a=this;a.next=function(){var l=a.x,u=a.i,p,d,f;return p=l[u],p^=p>>>7,d=p^p<<24,p=l[u+1&7],d^=p^p>>>10,p=l[u+3&7],d^=p^p>>>3,p=l[u+4&7],d^=p^p<<7,p=l[u+7&7],p=p^p<<13,d^=p^p<<9,l[u]=d,a.i=u+1&7,d};function c(l,u){var p,d,f=[];if(u===(u|0))d=f[0]=u;else for(u=""+u,p=0;p<u.length;++p)f[p&7]=f[p&7]<<15^u.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?d=f[7]=-1:d=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}c(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var c=new r(i),l=a&&a.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,l&&(l.x&&o(l,c),u.state=function(){return o(c,{})}),u}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(GF,typeof PT=="object"&&PT,typeof define=="function"&&define)});var qF=rr((jF,LT)=>{"use strict";(function(n,e,t){function r(i){var a=this;a.next=function(){var l=a.w,u=a.X,p=a.i,d,f;return a.w=l=l+1640531527|0,f=u[p+34&127],d=u[p=p+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,f=u[p]=f^d,a.i=p,f+(l^l>>>16)|0};function c(l,u){var p,d,f,m,h,g=[],x=128;for(u===(u|0)?(d=u,u=null):(u=u+"\0",d=0,x=Math.max(x,u.length)),f=0,m=-32;m<x;++m)u&&(d^=u.charCodeAt((m+32)%u.length)),m===0&&(h=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,m>=0&&(h=h+1640531527|0,p=g[m&127]^=d+h,f=p==0?f+1:0);for(f>=128&&(g[(u&&u.length||0)&127]=-1),f=127,m=512;m>0;--m)d=g[f+34&127],p=g[f=f+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,g[f]=d^p;l.w=h,l.X=g,l.i=f}c(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var c=new r(i),l=a&&a.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,l&&(l.X&&o(l,c),u.state=function(){return o(c,{})}),u}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})(jF,typeof LT=="object"&&LT,typeof define=="function"&&define)});var XF=rr((KF,BT)=>{"use strict";(function(n,e,t){function r(i){var a=this,c="";a.next=function(){var u=a.b,p=a.c,d=a.d,f=a.a;return u=u<<25^u>>>7^p,p=p-d|0,d=d<<24^d>>>8^f,f=f-u|0,a.b=u=u<<20^u>>>12^p,a.c=p=p-d|0,a.d=d<<16^p>>>16^f,a.a=f-u|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):c+=i;for(var l=0;l<c.length+20;l++)a.b^=c.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var c=new r(i),l=a&&a.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,l&&(typeof l=="object"&&o(l,c),u.state=function(){return o(c,{})}),u}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(KF,typeof BT=="object"&&BT,typeof define=="function"&&define)});var YF=rr(()=>{"use strict"});var QF=rr((ZF,$x)=>{"use strict";(function(n,e,t){var r=256,o=6,s=52,i="random",a=t.pow(r,o),c=t.pow(2,s),l=c*2,u=r-1,p;function d(w,I,_){var A=[];I=I==!0?{entropy:!0}:I||{};var R=g(h(I.entropy?[w,v(e)]:w??x(),3),A),F=new f(A),P=function(){for(var L=F.g(o),V=a,z=0;L<c;)L=(L+z)*r,V*=r,z=F.g(1);for(;L>=l;)L/=2,V/=2,z>>>=1;return(L+z)/V};return P.int32=function(){return F.g(4)|0},P.quick=function(){return F.g(4)/4294967296},P.double=P,g(v(F.S),e),(I.pass||_||function(L,V,z,H){return H&&(H.S&&m(H,F),L.state=function(){return m(F,{})}),z?(t[i]=L,V):L})(P,R,"global"in I?I.global:this==t,I.state)}function f(w){var I,_=w.length,A=this,R=0,F=A.i=A.j=0,P=A.S=[];for(_||(w=[_++]);R<r;)P[R]=R++;for(R=0;R<r;R++)P[R]=P[F=u&F+w[R%_]+(I=P[R])],P[F]=I;(A.g=function(L){for(var V,z=0,H=A.i,j=A.j,W=A.S;L--;)V=W[H=u&H+1],z=z*r+W[u&(W[H]=W[j=u&j+V])+(W[j]=V)];return A.i=H,A.j=j,z})(r)}function m(w,I){return I.i=w.i,I.j=w.j,I.S=w.S.slice(),I}function h(w,I){var _=[],A=typeof w,R;if(I&&A=="object")for(R in w)try{_.push(h(w[R],I-1))}catch{}return _.length?_:A=="string"?w:w+"\0"}function g(w,I){for(var _=w+"",A,R=0;R<_.length;)I[u&R]=u&(A^=I[u&R]*19)+_.charCodeAt(R++);return v(I)}function x(){try{var w;return p&&(w=p.randomBytes)?w=w(r):(w=new Uint8Array(r),(n.crypto||n.msCrypto).getRandomValues(w)),v(w)}catch{var I=n.navigator,_=I&&I.plugins;return[+new Date,n,_,n.screen,v(e)]}}function v(w){return String.fromCharCode.apply(0,w)}if(g(t.random(),e),typeof $x=="object"&&$x.exports){$x.exports=d;try{p=YF()}catch{}}else typeof define=="function"&&define.amd?define(function(){return d}):t["seed"+i]=d})(typeof self<"u"?self:ZF,[],Math)});var VT=rr((wPe,JF)=>{"use strict";var BZ=BF(),VZ=UF(),UZ=HF(),zZ=WF(),HZ=qF(),GZ=XF(),iu=QF();iu.alea=BZ;iu.xor128=VZ;iu.xorwow=UZ;iu.xorshift7=zZ;iu.xor4096=HZ;iu.tychei=GZ;JF.exports=iu});var GT={};Ue(GT,{TEST_EPSILON_FLOAT16:()=>eM,createVideoElement:()=>QZ,encodeStrings:()=>tM,expectArrayBuffersEqual:()=>ZZ,expectArraysClose:()=>jZ,expectArraysEqual:()=>KZ,expectNumbersClose:()=>XZ,expectPromiseToFail:()=>qZ,expectValuesInRange:()=>YZ,play:()=>JZ,testEpsilon:()=>zT});function jZ(n,e,t){return t==null&&(t=zT()),UT(n,e,(r,o)=>HT(r,o,t))}function zT(){return N.backend.floatPrecision()===32?WZ:eM}function UT(n,e,t){let r=!0;if((Nt(n)||Nt(e))&&(r=!1),Nt(n)&&Nt(e)&&(r=!0),r){let i=n.constructor.name,a=e.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(n)&&Array.isArray(e)){let i=on(n),a=on(e);if(!wn(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}let o=Nt(n)?n:qr(n),s=Nt(e)?e:qr(e);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let a=o[i],c=s[i];if(!t(a,c))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${c}.
Actual:   ${o}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function qZ(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function KZ(n,e){let t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return Wr(n)||Wr(n[0])||Wr(e)||Wr(e[0])?UT(n,t,(r,o)=>r==o):UT(n,e,(r,o)=>HT(r,o,0))}function XZ(n,e,t){if(t==null&&(t=zT()),!HT(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function HT(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function YZ(n,e,t){for(let r=0;r<n.length;r++)if(n[r]<e||n[r]>t)throw new Error(`Value out of range:${n[r]} low: ${e}, high: ${t}`)}function ZZ(n,e){let t=new Float32Array(n),r=new Float32Array(e);if(t.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${t.length}`);for(let o=0;o<r.length;o++)if(t[o]!==r[o])throw new Error(`Expected ArrayBuffer value at ${o} to be ${r[o]} but got ${t[o]} instead`)}function tM(n){for(let e=0;e<n.length;e++){let t=n[e];Array.isArray(t)?tM(t):n[e]=Wi(t)}return n}function QZ(n){let e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",r=>t(e)),e.load()})}async function JZ(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}var WZ,eM,nM=D(()=>{"use strict";B();$();q();WZ=.001,eM=.1});var Bx,au,Px,Lx,Mm=D(()=>{"use strict";Bx=Nh(VT());au=class{constructor(e,t,r,o,s){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=Bx.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let e,t,r=!1;for(;!r;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*o*a,t=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},Px=class{constructor(e,t,r,o){this.alpha=e,this.beta=1/t,this.dtype=r;let s=o||Math.random();this.randu=Bx.alea(s.toString()),this.randn=new au(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,e=o*o,t=1-.331*e*e,r=.5*e+this.d*(1-i+Math.log(i)),s=this.randu(),s<t||Math.log(s)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},Lx=class{constructor(e=0,t=1,r,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Bx.alea(o)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}});function eQ(n,e,t=1,r="float32",o){if(dt(n),t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new Px(e,t,r,o),i=le(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var WT,rM=D(()=>{"use strict";Bt();us();M();Mm();WT=E({randomGamma_:eQ})});function tQ(n,e=0,t=1,r,o){if(dt(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new au(e,t,r,!1,o),i=le(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Om,jT=D(()=>{"use strict";Bt();us();M();Mm();Om=E({randomNormal_:tQ})});function nQ(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Om(n,0,1,e,t)}var qT,oM=D(()=>{"use strict";M();jT();qT=E({randomStandardNormal_:nQ})});function rQ(n,e=0,t=1,r="float32",o){dt(n);let s=le(n,r),i=new Lx(e,t,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var cu,Vx=D(()=>{"use strict";Bt();us();M();Mm();cu=E({randomUniform_:rQ})});function oQ(n,e,t,r){return cu(n,e,t,"int32",r)}var KT,sM=D(()=>{"use strict";M();Vx();KT=E({randomUniformInt_:oQ})});function Is(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");let o={start:n,stop:e,step:t,dtype:r};return N.runKernel(pl,{},o)}var Ux=D(()=>{"use strict";B();G();});function sQ(n){let t={input:C(n,"input","real")};return N.runKernel(dl,t)}var Oo,$m=D(()=>{"use strict";B();G();$();M();Oo=E({real_:sQ})});function iQ(n){let t={x:C(n,"x","reciprocal")};return N.runKernel(Si,t)}var XT,iM=D(()=>{"use strict";B();G();$();M();XT=E({reciprocal_:iQ})});function aQ(n){let t={x:C(n,"x","relu")};return N.runKernel(Ni,t)}var Es,Pm=D(()=>{"use strict";B();G();$();M();Es=E({relu_:aQ})});function cQ(n){let t={x:C(n,"x","relu6")};return N.runKernel(Di,t)}var Lm,YT=D(()=>{"use strict";B();G();$();M();Lm=E({relu6_:cQ})});function lQ(n,e){let r={x:C(n,"x","reverse")},o={dims:e};return N.runKernel(gl,r,o)}var Kn,lu=D(()=>{"use strict";B();G();$();M();Kn=E({reverse_:lQ})});function uQ(n){let e=C(n,"x","reverse");return k(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Kn(e,0)}var ZT,aM=D(()=>{"use strict";$();q();M();lu();ZT=E({reverse1d_:uQ})});function pQ(n,e){let t=C(n,"x","reverse");return k(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Kn(t,e)}var QT,cM=D(()=>{"use strict";$();q();M();lu();QT=E({reverse2d_:pQ})});function dQ(n,e){let t=C(n,"x","reverse");return k(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Kn(t,e)}var JT,lM=D(()=>{"use strict";$();q();M();lu();JT=E({reverse3d_:dQ})});function fQ(n,e){let t=C(n,"x","reverse");return k(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Kn(t,e)}var eS,uM=D(()=>{"use strict";$();q();M();lu();eS=E({reverse4d_:fQ})});function mQ(n){let t={x:C(n,"x","round")};return N.runKernel(ki,t)}var Bm,tS=D(()=>{"use strict";B();G();$();M();Bm=E({round_:mQ})});function hQ(n){let t={x:C(n,"x","rsqrt","float32")};return N.runKernel(_i,t)}var nS,pM=D(()=>{"use strict";B();G();$();M();nS=E({rsqrt_:hQ})});function gQ(n){let t={x:C(n,"x","selu")};return N.runKernel(Ai,t)}var rS,dM=D(()=>{"use strict";B();G();$();M();rS=E({selu_:gQ})});function xQ(n,e,t,r,o,s=[1,1],i="NHWC"){let a=C(n,"x","separableConv2d"),c=C(e,"depthwiseFilter","separableConv2d"),l=C(t,"pointwiseFilter","separableConv2d"),u=a,p=!1;if(a.rank===3&&(p=!0,u=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");k(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),k(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),k(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),k(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),k(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let d=c.shape[2],f=c.shape[3];k(l.shape[2]===d*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*f}, but got ${l.shape[2]}.`);let m=ou(u,c,r,o,i,s),g=ms(m,l,1,"valid",i);return p?U(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var oS,fM=D(()=>{"use strict";$();q();um();wx();M();Se();oS=E({separableConv2d_:xQ})});async function yQ(n,e){let t=C(n,"x","setdiff1d"),r=C(e,"y","setdiff1d");k(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),k(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),k(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let o=await t.data(),s=await r.data(),i=new Set(s),a=0;for(let u=0;u<o.length;u++)i.has(o[u])||a++;let c=new He([a],t.dtype),l=new He([a],"int32");for(let u=0,p=0;u<o.length;u++)i.has(o[u])||(c.values[p]=o[u],l.values[p]=u,p++);return[c.toTensor(),l.toTensor()]}var sS,mM=D(()=>{"use strict";cr();$();q();sS=yQ});function vQ(n){let t={x:C(n,"x","sign")};return N.runKernel(Fi,t)}var iS,hM=D(()=>{"use strict";B();G();$();M();iS=E({sign_:vQ})});function bQ(n){let t={x:C(n,"x","sin","float32")};return N.runKernel("Sin",t)}var aS,gM=D(()=>{"use strict";B();$();M();aS=E({sin_:bQ})});function CQ(n){let t={x:C(n,"x","sinh")};return N.runKernel(Ri,t)}var cS,xM=D(()=>{"use strict";B();G();$();M();cS=E({sinh_:CQ})});function wQ(n,e,t){let r=C(n,"x","slice1d");return k(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Le(r,[e],[t])}var lS,yM=D(()=>{"use strict";$();q();M();Ir();lS=E({slice1d_:wQ})});function IQ(n,e,t){let r=C(n,"x","slice2d");return k(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Le(r,e,t)}var uS,vM=D(()=>{"use strict";$();q();M();Ir();uS=E({slice2d_:IQ})});function EQ(n,e,t){let r=C(n,"x","slice3d");return k(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Le(r,e,t)}var pS,bM=D(()=>{"use strict";$();q();M();Ir();pS=E({slice3d_:EQ})});function TQ(n,e,t){let r=C(n,"x","slice4d");return k(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Le(r,e,t)}var dS,CM=D(()=>{"use strict";$();q();M();Ir();dS=E({slice4d_:TQ})});function SQ(n,e=-1){let t=C(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);let r={logits:t},o={dim:e};return N.runKernel(Tl,r,o)}var fS,wM=D(()=>{"use strict";B();G();$();M();fS=E({softmax_:SQ})});function NQ(n){k(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);let e={input:n};return N.runKernel("FFT",e)}var uu,zx=D(()=>{"use strict";B();q();M();uu=E({fft_:NQ})});function DQ(n){k(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);let e={input:n};return N.runKernel(Vc,e)}var ra,Hx=D(()=>{"use strict";B();G();q();M();ra=E({ifft_:DQ})});function kQ(n){let e=n.shape[n.shape.length-1],t=n.size/e,r;if(e<=2){let o=U(n,[t,e]);r=ra(o)}else{let o=[t,2*(e-1)],s=U(Oo(n),[t,e]),i=U(bs(n),[t,e]),a=Kn(Le(s,[0,1],[t,e-2]),1),c=ee(Kn(Le(i,[0,1],[t,e-2]),1),me(-1)),l=ot([s,a],1),u=ot([i,c],1),p=U(En(l,u),[o[0],o[1]]);r=ra(p)}if(r=Oo(r),n.rank===3&&n.shape[0]!==0){let o=r,s=n.shape[0];r=U(r,[s,r.shape[0]/s,r.shape[1]]),o.dispose()}return r}var Vm,mS=D(()=>{"use strict";qi();Yr();bm();ht();M();$m();Se();lu();hn();Ir();Hx();Vm=E({irfft_:kQ})});function _Q(n,e,t=0){let o={x:C(n,"x","split")},s={numOrSizeSplits:e,axis:t};return N.runKernel(El,o,s)}var $o,Um=D(()=>{"use strict";B();G();$();M();$o=E({split_:_Q})});function AQ(n,e){k(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1],r=n.size/t,o;if(e!=null&&e<t){let m=n.shape.map(g=>0),h=n.shape.map(g=>g);h[n.shape.length-1]=e,o=Le(n,m,h),t=e}else if(e!=null&&e>t){let m=n.shape.map(h=>h);m[n.shape.length-1]=e-t,o=ot([n,pr(m)],n.shape.length-1),t=e}else o=n;let s=Ft(o),i=U(En(o,s),[r,t]),a=uu(i),c=Math.floor(t/2)+1,l=Oo(a),u=bs(a),p=$o(l,[c,t-c],l.shape.length-1),d=$o(u,[c,t-c],u.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=c,U(En(p[0],d[0]),f)}var pu,Gx=D(()=>{"use strict";q();qi();Yr();bm();M();$m();Se();Ir();Um();_m();hs();zx();pu=E({rfft_:AQ})});function RQ(n,e){let t=C(n,"a","squaredDifference"),r=C(e,"b","squaredDifference");[t,r]=Ee(t,r),We(t.shape,r.shape);let o={a:t,b:r},s={};return N.runKernel(Pi,o,s)}var zm,hS=D(()=>{"use strict";B();G();mt();$();zt();M();zm=E({squaredDifference_:RQ})});function FQ(n,e){let t=C(n,"x","squeeze","string_or_numeric");return U(t,Qw(t.shape,e).newShape)}var du,Wx=D(()=>{"use strict";$();q();M();Se();du=E({squeeze_:FQ})});function MQ(n,e=0){let t=is(n,"tensors","stack","string_or_numeric");k(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&k(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");let r=t,o={axis:e};return N.runKernel(rl,r,o)}var xn,Hm=D(()=>{"use strict";B();G();$();q();M();xn=E({stack_:MQ})});function OQ(n,e=0){let r={x:C(n,"x","step")},o={alpha:e};return N.runKernel(Vi,r,o)}var Gm,gS=D(()=>{"use strict";B();G();$();M();Gm=E({step_:OQ})});function $Q(n,e,t,r,o=0,s=0,i=0,a=0,c=0){let u={x:C(n,"x","stridedSlice","string_or_numeric")},p={begin:e,end:t,strides:r,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:c};return N.runKernel(Al,u,p)}var xS,IM=D(()=>{"use strict";B();G();$();M();xS=E({stridedSlice_:$Q})});function PQ(n){let t={x:C(n,"x","tan","float32")};return N.runKernel("Tan",t)}var yS,EM=D(()=>{"use strict";B();$();M();yS=E({tan_:PQ})});function Wt(n,e){ar(n);let t=on(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Tn(n,null,t,e)}var oa=D(()=>{"use strict";$();q();as();});function Ts(n,e,t){if(ar(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=on(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Tn(n,e,r,t)}var jx=D(()=>{"use strict";$();q();as();});function Wm(n,e,t){if(ar(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=on(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Tn(n,e,r,t)}var vS=D(()=>{"use strict";$();q();as();});function bS(n,e,t){if(ar(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=on(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Tn(n,e,r,t)}var TM=D(()=>{"use strict";$();q();as();});function CS(n,e,t){if(ar(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=on(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Tn(n,e,r,t)}var SM=D(()=>{"use strict";$();q();as();});function wS(n,e,t){if(ar(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=on(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,Tn(n,e,r,t)}var NM=D(()=>{"use strict";$();q();as();});var jm={};Ue(jm,{calculateShapes:()=>DM,validateInput:()=>Jp,validateUpdateShape:()=>IS});function IS(n,e,t){let r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${o}.`;if(t.rank<o)throw new Error(s+` update.rank < ${o}. `);if(n.length<r+(t.rank-o))throw new Error(s+` Output shape length < ${r+(t.rank-o)}`);if(t.rank!==o+n.length-r)throw new Error(s+` update.rank != ${o+n.length-r}`);for(let i=0;i<o;++i)if(t.shape[i]!==e.shape[i])throw new Error(s+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-o;++i)if(t.shape[i+o]!==n[i+r])throw new Error(s+` updates.shape[${i+o}] (${t.shape[i+o]}) != shape[${i+o}] (${n[i+o]})`)}function Jp(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}IS(t,e,n)}function DM(n,e,t){let r=e.shape.length,o=r>1?e.shape[r-1]:1,s=t.length,i=1;for(let p=o;p<s;++p)i*=t[p];let a=o<1?1:o,c=Ne(e.shape)/a,l=[...No(t.slice(0,o)),1],u=Ne(t);return{sliceRank:o,numUpdates:c,sliceSize:i,strides:l,outputSize:u}}var qm=D(()=>{"use strict";q()});function LQ(n,e,t){let r=C(n,"tensor","tensorScatterupdate"),o=C(e,"indices","tensorScatterupdate","int32"),s=C(t,"updates","tensorScatterupdate");if(Jp(s,o,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:o,updates:s},a={};return N.runKernel(yl,i,a)}var ES,kM=D(()=>{"use strict";B();G();$();M();qm();ES=E({tensorScatterUpdate_:LQ})});function BQ(n,e=1,t=!0){let r=C(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);let s={x:r},i={k:e,sorted:t},[a,c]=N.runKernel(Pl,s,i);return{values:a,indices:c}}var TS,_M=D(()=>{"use strict";B();G();$();M();TS=E({topk_:BQ})});function VQ(n,e=0,t=1,r,o){if(dt(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new au(e,t,r,!0,o),i=le(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var SS,AM=D(()=>{"use strict";Bt();us();M();Mm();SS=E({truncatedNormal_:VQ})});function UQ(n,e=0){let t=C(n,"x","unique","string_or_numeric");k(t.rank>0,()=>"The input tensor must be at least 1D");let r={x:t},o={axis:e},[s,i]=N.runKernel(Bl,r,o);return{values:s,indices:i}}var NS,RM=D(()=>{"use strict";B();G();$();q();M();NS=E({unique_:UQ})});function zQ(n,e,t){let r=C(n,"x","unsortedSegmentSum"),o=C(e,"segmentIds","unsortedSegmentSum","int32");k(Jo(t),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:o},i={numSegments:t};return N.runKernel(Ul,s,i)}var DS,FM=D(()=>{"use strict";B();G();$();q();M();DS=E({unsortedSegmentSum_:zQ})});function HQ(n,e=0){let t=C(n,"x","unstack","string_or_numeric");k(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);let r={value:t},o={axis:e};return N.runKernel(Vl,r,o)}var Xn,qx=D(()=>{"use strict";B();G();$();q();M();Xn=E({unstack_:HQ})});function kS(n,e){return Yp(n,e,"right")}var MM=D(()=>{"use strict";Rx();});function _S(n,e=!0,t,r){return N.makeVariable(n,e,t,r)}var OM=D(()=>{"use strict";B();});function Kx(n,e){let t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);let r=le(n,"int32"),o=le([t.length,n.length],"int32");for(let s=0;s<t.length;s++){let i=r.indexToLoc(t[s]),a=s*n.length;o.values.set(i,a)}return o.toTensor()}var AS=D(()=>{"use strict";us();});async function GQ(n){let e=C(n,"condition","whereAsync","bool"),t=await e.data(),r=Kx(e.shape,t);return n!==e&&e.dispose(),r}var Km,RS=D(()=>{"use strict";AS();$();Km=GQ});async function WQ(n,e,t){let r=C(n,"tensor","boolMask"),o=C(e,"mask","boolMask","bool"),s=t??0,i=o.rank,a=r.shape;k(i>0,()=>"mask cannot be scalar"),it(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let h=s;h<s+i;h++)c*=a[h];let l=a.slice(0,s).concat([c],a.slice(s+i)),u=U(r,l),p=U(o,[-1]),d=await Km(p),f=du(d,[1]),m=ym(u,f,s);return n!==r&&r.dispose(),e!==o&&o.dispose(),f.dispose(),u.dispose(),p.dispose(),d.dispose(),m}var $M,PM=D(()=>{"use strict";$();q();GE();Se();Wx();RS();$M=WQ});function jQ(n,e,t){let r=C(n,"x","transpose");if(e==null&&(e=r.shape.map((i,a)=>a).reverse()),k(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(i=>{k(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();let o={x:r},s={perm:e};return r.dtype==="complex64"?Ce(()=>{let i=Oo(r),a=bs(r);return i=N.runKernel(os,{x:i},s),a=N.runKernel(os,{x:a},s),t&&(a=Qt(a)),En(i,a)}):N.runKernel(os,o,s)}var fu,Xx=D(()=>{"use strict";B();jn();G();$();q();qi();bm();ws();M();$m();fu=E({transpose_:jQ})});function qQ(n,e,t,r,o=!0){let s=C(n,"v","movingAverage"),i=C(e,"x","movingAverage"),a=C(t,"decay","movingAverage");hI(s,i),k(wn(s.shape,i.shape),()=>"Shape mismatch in v and x");let c=me(1),l=ge(c,a),u=ee(ge(i,s),l);if(o){k(r!=null,()=>"When using zeroDebias: true, step is required.");let p=C(r,"step","movingAverage");u=Pe(u,ge(c,Fo(a,p)))}return de(s,u)}var LM,BM=D(()=>{"use strict";mt();$();q();Ot();Mn();ht();M();mm();hn();Gt();LM=E({movingAverage_:qQ})});function KQ(n,e,t){dt(t);let r=C(n,"indices","scatterND","int32"),o=C(e,"updates","scatterND");Jp(o,r,t);let s={indices:r,updates:o},i={shape:t};return N.runKernel(xl,s,i)}var VM,UM=D(()=>{"use strict";B();G();$();Bt();M();qm();VM=E({scatterND_:KQ})});function zM(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);let o=n.rank>0?n.shape[0]:1,s=n.rank>1?n.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);let i=e.size;if(!(e.rank===0||e.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}var HM=D(()=>{"use strict"});function YQ(n,e,t,r=0){dt(t);let o=C(n,"sparseIndices","sparseToDense","int32"),s=C(e,"sparseValues","sparseToDense","string_or_numeric"),i=C(r,"defaultValue","sparseToDense",s.dtype);zM(o,s,t,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},c={outputShape:t};return N.runKernel(_l,a,c)}var GM,WM=D(()=>{"use strict";B();G();HM();$();Bt();M();GM=E({sparseToDense_:YQ})});function ZQ(n,e){let t=C(e,"indices","gatherND","int32"),o={params:C(n,"x","gatherND","string_or_numeric"),indices:t};return N.runKernel(Bc,o)}var jM,qM=D(()=>{"use strict";B();G();$();M();jM=E({gatherND_:ZQ})});function KM(n,e){if(e==null)return n.shape.slice();if(wn(n.shape,e))return e;if(n.shape.length===e.length){let t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}var XM=D(()=>{"use strict";q();});function QQ(n,e,t,r){let o=C(n,"x","dropout");if(k(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),k(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Ze?o.clone():o;let s=KM(o,t),i=1-e,a=Pe(xm(de(cu(s,0,1,"float32",r),i)),i);return ee(o,a)}var YM,ZM=D(()=>{"use strict";cr();$();q();Ot();Mn();XM();HE();ht();M();Vx();YM=E({dropout_:QQ})});function Yx(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function ed(n,e,t){let r=1-n%2,o=new Float32Array(n);for(let s=0;s<n;++s){let i=2*Math.PI*s/(n+r-1);o[s]=e-t*Math.cos(i)}return Wt(o,"float32")}var Xm=D(()=>{"use strict";oa();});async function JQ(n,e,t=1){let r=C(n,"predictions","inTopK"),o=C(e,"targets","inTopK");k(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),k(r.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${o.rank}`),it(r.shape.slice(0,r.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];k(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);let i=await r.data(),a=await o.data(),[c,l]=[i.length/s,s],u=Jw("bool",c);for(let p=0;p<c;p++){let d=p*l,f=i.subarray(d,d+l),m=[];for(let h=0;h<f.length;h++)m.push({value:f[h],index:h});m.sort((h,g)=>g.value-h.value),u[p]=0;for(let h=0;h<t;h++)if(m[h].index===a[p]){u[p]=1;break}}return n!==r&&r.dispose(),e!==o&&o.dispose(),fn(u,o.shape,"bool")}var QM,JM=D(()=>{"use strict";$();q();Qf();QM=JQ});function eJ(n,e,t,r,o,s="NHWC",i){let a=n;n.rank===3&&(a=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=U(e,[1,e.shape[0],e.shape[1],e.shape[2]])),k(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),k(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),k(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);let l=s==="NHWC"?a.shape[3]:a.shape[1],u=s==="NHWC"?c.shape[3]:c.shape[1];k(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),k(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),_t("conv2dDerFilter",o,i);let p={x:a,dy:c},d={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:t};return N.runKernel(hc,p,d)}var eO,tO=D(()=>{"use strict";B();G();q();On();M();Se();eO=E({conv2DBackpropFilter_:eJ})});function mu(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return ee(n,Gm(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function hu(n,e){let t=e,r=Ix(n.shape,e.shape);return r.length>0&&(t=je(t,r)),U(t,n.shape)}function gu(n,e,t,r){if(e==="linear")return n;if(e==="relu")return Es(n);if(e==="elu")return dm(n);if(e==="relu6")return Lm(n);if(e==="prelu")return Fm(n,t);if(e==="leakyrelu")return Cm(n,r);if(e==="sigmoid")return Zr(n);throw new Error(`Unknown fused activation ${e}.`)}var xu,td=D(()=>{"use strict";zt();OE();XE();ht();DT();Pm();YT();Se();im();gS();to();xu=(n,e)=>!(n>0)||e==="linear"});function tJ({x:n,filter:e,strides:t,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:u}){if(c=c||"linear",xu(N.state.gradientDepth,c)===!1){k(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let A=ms(n,e,t,r,o,s,i);return a!=null&&(A=de(A,a)),gu(A,c,l,u)}let p=C(n,"x","conv2d","float32"),d=C(e,"filter","conv2d","float32"),f=p,m=!1;p.rank===3&&(m=!0,f=U(p,[1,p.shape[0],p.shape[1],p.shape[2]])),k(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),k(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),_t("fused conv2d",r,i);let h=o==="NHWC"?f.shape[3]:f.shape[1];k(d.shape[2]===h,()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${d.shape[2]}.`),k(mn(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let g=ru(f.shape,d.shape,t,s,r,i),x;a!=null&&(x=C(a,"bias","fused conv2d"),[x]=Ee(x,p),o==="NHWC"?We(g.outShape,x.shape):(k(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),k(x.shape.length===0||x.shape[0]===g.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let v;if(l!=null){let A=l.shape;if(k(A.length<=1||A.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${A.length}.`),A.length===1)k(A[0]===1||A[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the number of output channels (${g.outChannels}).`);else if(A.length===3)try{We(A,g.outShape)}catch{let F=`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(F)}v=C(l,"prelu weights","fused conv2d")}let w=(A,R)=>{k(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[F,P,L,V]=R,z=mu(A,L,c);k(nu(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let H=Cx(P.shape,z,F,t,r),j=eO(P,z,F.shape,t,r),W=[H,j];if(V!=null){let Y=hu(V,z);W.push(Y)}return W},I={x:f,filter:d,bias:x,preluActivationWeights:v},_={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:c,leakyreluAlpha:u};return a==null?gn((R,F,P)=>{let L=N.runKernel(zi,I,_);return P([F,R,L]),m&&(L=U(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:w}})(f,d):gn((R,F,P,L)=>{let V=N.runKernel(zi,I,_);return L([F,R,V,P]),m&&(V=U(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:w}})(f,d,x)}var nO,rO=D(()=>{"use strict";B();Cs();G();mt();$();q();Ot();zt();um();tO();vE();On();td();M();Se();nO=E({fusedConv2d_:tJ})});function nJ(n,e,t,r,o,s=[1,1],i){let a=n;n.rank===3&&(a=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=U(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={x:a,dy:c},u={strides:r,pad:o,dimRoundingMode:i,dilations:s,filterShape:t};return N.runKernel(Sc,l,u)}var oO,sO=D(()=>{"use strict";B();G();M();Se();oO=E({depthwiseConv2dNativeBackpropFilter_:nJ})});function rJ(n,e,t,r,o,s=[1,1],i){let a=e,c=!1;e.rank===3&&(c=!0,a=U(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={dy:a,filter:t},u={strides:r,pad:o,dimRoundingMode:i,dilations:s,inputShape:n},p=N.runKernel(Nc,l,u);return c?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var iO,aO=D(()=>{"use strict";B();G();M();Se();iO=E({depthwiseConv2dNativeBackpropInput_:rJ})});function oJ({x:n,filter:e,strides:t,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:u}){if(xu(N.state.gradientDepth,c)===!1){let _=ou(n,e,t,r,o,s,i);return a!=null&&(_=de(_,a)),gu(_,c,l,u)}let p=C(n,"x","depthwiseConv2d","float32"),d=C(e,"filter","depthwiseConv2d","float32"),f=p,m=!1;p.rank===3&&(m=!0,f=U(p,[1,p.shape[0],p.shape[1],p.shape[2]])),k(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),k(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),k(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),s==null&&(s=[1,1]),k(mn(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),_t("fused depthwiseConv2d",r,i);let h=ru(f.shape,d.shape,t,s,r,i,!0),g;a!=null&&(g=C(a,"bias","fused conv2d"),[g]=Ee(g,p),We(h.outShape,g.shape));let x;l!=null&&(x=C(l,"prelu weights","fused depthwiseConv2d"));let v=(_,A)=>{k(nu(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[R,F,P,L]=A,V=mu(_,P,c),z=iO(F.shape,V,R,t,r,s,i),H=oO(F,V,R.shape,t,r,s,i);if(L!=null){let j=hu(g,V);return[z,H,j]}return[z,H]},w={x:f,filter:d,bias:g,preluActivationWeights:x},I={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:c,leakyreluAlpha:u};return a==null?gn((A,R,F)=>{let P=N.runKernel(Hi,w,I);return F([R,A,P]),m&&(P=U(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:v}})(f,d):gn((A,R,F,P)=>{let L=N.runKernel(Hi,w,I);return P([R,A,L,F]),m&&(L=U(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:v}})(f,d,g)}var cO,lO=D(()=>{"use strict";B();Cs();G();mt();$();q();Ot();zt();On();wx();sO();aO();td();M();Se();cO=E({fusedDepthwiseConv2d_:oJ})});function sJ({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(xu(N.state.gradientDepth,s)===!1){let V=ze(n,e,t,r);return o!=null&&(V=de(V,o)),gu(V,s,i,a)}let c=C(n,"a","fused matMul"),l=C(e,"b","fused matMul");[c,l]=Ee(c,l);let u=t?c.shape[c.rank-2]:c.shape[c.rank-1],p=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=t?c.shape[c.rank-1]:c.shape[c.rank-2],f=r?l.shape[l.rank-2]:l.shape[l.rank-1],m=c.shape.slice(0,-2),h=l.shape.slice(0,-2),g=Ne(m),x=Ne(h);k(u===p,()=>`Error in fused matMul: inner shapes (${u}) and (${p}) of Tensors with shapes ${c.shape} and ${l.shape} and transposeA=${t} and transposeB=${r} must match.`);let w=We(c.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,f]),I=t?U(c,[g,u,d]):U(c,[g,d,u]),_=r?U(l,[x,f,p]):U(l,[x,p,f]),A;o!=null&&(A=C(o,"bias","fused matMul"),[A]=Ee(A,c),We(w,A.shape));let R;i!=null&&(R=C(i,"prelu weights","fused matMul"));let F=(V,z)=>{let[H,j,W,Y]=z,Z=mu(U(V,W.shape),W,s),K,Q;if(!t&&!r?(K=ze(Z,j,!1,!0),Q=ze(H,Z,!0,!1)):!t&&r?(K=ze(Z,j,!1,!1),Q=ze(Z,H,!0,!1)):t&&!r?(K=ze(j,Z,!1,!0),Q=ze(H,Z,!1,!1)):(K=ze(j,Z,!0,!0),Q=ze(Z,H,!0,!0)),o!=null){let te=hu(Y,Z);return[K,Q,te]}else return[K,Q]},P={a:I,b:_,bias:A,preluActivationWeights:R},L={transposeA:t,transposeB:r,activation:s,leakyreluAlpha:a};return o==null?gn((z,H,j)=>{let W=N.runKernel(Ui,P,L);return j([z,H,W]),{value:U(W,w),gradFunc:F}})(I,_):gn((z,H,j,W)=>{let Y=N.runKernel(Ui,P,L);return W([z,H,Y,j]),{value:U(Y,w),gradFunc:F}})(I,_,A)}var uO,pO=D(()=>{"use strict";B();Cs();G();mt();$();q();Ot();zt();td();ps();M();Se();uO=E({fusedMatMul_:sJ})});var Zx={};Ue(Zx,{conv2d:()=>nO,depthwiseConv2d:()=>cO,matMul:()=>uO});var dO=D(()=>{"use strict";rO();lO();pO();});function iJ(n){return ed(n,.54,.46)}var fO,mO=D(()=>{"use strict";M();Xm();fO=E({hammingWindow_:iJ})});function aJ(n){return ed(n,.5,.5)}var Qx,FS=D(()=>{"use strict";M();Xm();Qx=E({hannWindow_:aJ})});function cJ(n,e,t,r=!1,o=0){let s=0,i=[];for(;s+e<=n.size;)i.push(Le(n,s,e)),s+=t;if(r)for(;s<n.size;){let a=s+e-n.size,c=ot([Le(n,s,e-a),Qr([a],o)]);i.push(c),s+=t}return i.length===0?Ts([],[0,e]):U(ot(i),[i.length,e])}var Jx,MS=D(()=>{"use strict";Yr();Hp();M();Se();Ir();jx();Jx=E({frame_:cJ})});function lJ(n,e,t,r,o=Qx){r==null&&(r=Yx(e));let s=Jx(n,e,t),i=ee(s,o(e));return pu(i,r)}var hO,gO=D(()=>{"use strict";ht();M();Xm();Gx();MS();FS();hO=E({stft_:lJ})});function uJ(n,e,t,r,o="bilinear",s=0){let i=C(n,"image","cropAndResize"),a=C(e,"boxes","cropAndResize","float32"),c=C(t,"boxInd","cropAndResize","int32"),l=a.shape[0];k(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),k(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),k(c.rank===1&&c.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),k(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),k(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),k(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let u={image:i,boxes:a,boxInd:c},p={method:o,extrapolationValue:s,cropSize:r};return N.runKernel(wc,u,p)}var xO,yO=D(()=>{"use strict";B();G();$();q();M();xO=E({cropAndResize_:uJ})});function pJ(n){let e=C(n,"image","flipLeftRight","float32");k(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);let t={image:e};return N.runKernel($c,t,{})}var vO,bO=D(()=>{"use strict";B();G();$();q();M();vO=E({flipLeftRight_:pJ})});function dJ(n){let e=C(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];k(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),k(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let o=new Array(e.rank);return o.fill(1,0,t),o[t]=3,vs(e,o)}var CO,wO=D(()=>{"use strict";$();q();M();Tx();CO=E({grayscaleToRGB_:dJ})});function fJ(n){let e=C(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];k(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),k(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let o=e.dtype,s=De(e,"float32"),i=Wt([.2989,.587,.114]),a;switch(e.rank){case 2:a=gs("ij,j->i",s,i);break;case 3:a=gs("ijk,k->ij",s,i);break;case 4:a=gs("ijkl,l->ijk",s,i);break;case 5:a=gs("ijklm,m->ijkl",s,i);break;case 6:a=gs("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return a=Er(a,-1),De(a,o)}var IO,EO=D(()=>{"use strict";$();q();an();ME();Ex();M();oa();IO=E({rgbToGrayscale_:fJ})});function mJ(n,e,t=0,r=.5){let o=C(n,"image","rotateWithOffset","float32");k(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:e,fillValue:t,center:r};return N.runKernel(Hl,s,i)}var TO,SO=D(()=>{"use strict";B();G();$();q();M();TO=E({rotateWithOffset_:mJ})});function Tr(n,e,t,r,o,s){r==null&&(r=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=n.shape[0];return t=Math.min(t,i),k(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),k(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),k(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),k(e.rank===1,()=>"scores must be a 1D tensor"),k(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),k(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:o,softNmsSigma:s}}var yu=D(()=>{"use strict";q();});function hJ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY){let s=C(n,"boxes","nonMaxSuppression","float32"),i=C(e,"scores","nonMaxSuppression","float32"),a=Tr(s,i,t,r,o);t=a.maxOutputSize,r=a.iouThreshold,o=a.scoreThreshold;let c={maxOutputSize:t,iouThreshold:r,scoreThreshold:o};return N.runKernel(Qc,{boxes:s,scores:i},c)}var NO,DO=D(()=>{"use strict";B();G();$();yu();M();NO=E({nonMaxSuppression_:hJ})});function kO(n,e,t){let r=gJ(n,e,t),o=r<0?-(r+1):r;n.splice(o,0,e)}function gJ(n,e,t){return yJ(n,e,t||xJ)}function xJ(n,e){return n>e?1:n<e?-1:0}function yJ(n,e,t){let r=0,o=n.length,s=0,i=!1;for(;r<o;){s=r+(o-r>>>1);let a=t(e,n[s]);a>0?r=s+1:(o=s,i=!a)}return i?r:-r-1}var _O=D(()=>{"use strict";});function ey(n,e,t,r,o){return OS(n,e,t,r,o,0)}function ty(n,e,t,r,o,s){return OS(n,e,t,r,o,0,!1,s,!0)}function ny(n,e,t,r,o,s){return OS(n,e,t,r,o,s,!0)}function OS(n,e,t,r,o,s,i=!1,a=!1,c=!1){let l=[];for(let g=0;g<e.length;g++)e[g]>o&&l.push({score:e[g],boxIndex:g,suppressBeginIndex:0});l.sort(AO);let u=s>0?-.5/s:0,p=[],d=[];for(;p.length<t&&l.length>0;){let g=l.pop(),{score:x,boxIndex:v,suppressBeginIndex:w}=g;if(x<o)break;let I=!1;for(let _=p.length-1;_>=w;--_){let A=vJ(n,v,p[_]);if(A>=r){I=!0;break}if(g.score=g.score*bJ(r,u,A),g.score<=o)break}g.suppressBeginIndex=p.length,I||(g.score===x?(p.push(v),d.push(g.score)):g.score>o&&kO(l,g,AO))}let f=p.length,m=t-f;a&&m>0&&(p.push(...new Array(m).fill(0)),d.push(...new Array(m).fill(0)));let h={selectedIndices:p};return i&&(h.selectedScores=d),c&&(h.validOutputs=f),h}function vJ(n,e,t){let r=n.subarray(e*4,e*4+4),o=n.subarray(t*4,t*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),l=Math.min(o[0],o[2]),u=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),d=Math.max(o[1],o[3]),f=(a-s)*(c-i),m=(p-l)*(d-u);if(f<=0||m<=0)return 0;let h=Math.max(s,l),g=Math.max(i,u),x=Math.min(a,p),v=Math.min(c,d),w=Math.max(x-h,0)*Math.max(v-g,0);return w/(f+m-w)}function bJ(n,e,t){let r=Math.exp(e*t*t);return t<=n?r:0}function AO(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}var Ym=D(()=>{"use strict";_O();});async function CJ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY){let s=C(n,"boxes","nonMaxSuppressionAsync"),i=C(e,"scores","nonMaxSuppressionAsync"),a=Tr(s,i,t,r,o);t=a.maxOutputSize,r=a.iouThreshold,o=a.scoreThreshold;let c=await Promise.all([s.data(),i.data()]),l=c[0],u=c[1],{selectedIndices:p}=ey(l,u,t,r,o);return s!==n&&s.dispose(),i!==e&&i.dispose(),Wt(p,"int32")}var RO,FO=D(()=>{"use strict";Ym();$();yu();oa();RO=CJ});function wJ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(n,"boxes","nonMaxSuppression"),a=C(e,"scores","nonMaxSuppression"),c=Tr(i,a,t,r,o,s);t=c.maxOutputSize,r=c.iouThreshold,o=c.scoreThreshold,s=c.softNmsSigma;let l={boxes:i,scores:a},u={maxOutputSize:t,iouThreshold:r,scoreThreshold:o,softNmsSigma:s},p=N.runKernel(el,l,u);return{selectedIndices:p[0],selectedScores:p[1]}}var MO,OO=D(()=>{"use strict";B();G();$();yu();M();MO=E({nonMaxSuppressionWithScore_:wJ})});async function IJ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(n,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),c=Tr(i,a,t,r,o,s);t=c.maxOutputSize,r=c.iouThreshold,o=c.scoreThreshold,s=c.softNmsSigma;let l=await Promise.all([i.data(),a.data()]),u=l[0],p=l[1],{selectedIndices:d,selectedScores:f}=ny(u,p,t,r,o,s);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:Wt(d,"int32"),selectedScores:Wt(f)}}var $O,PO=D(()=>{"use strict";Ym();$();yu();oa();$O=IJ});function EJ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(n,"boxes","nonMaxSuppression"),a=C(e,"scores","nonMaxSuppression"),c=Tr(i,a,t,r,o,null),l=c.maxOutputSize,u=c.iouThreshold,p=c.scoreThreshold,d={boxes:i,scores:a},f={maxOutputSize:l,iouThreshold:u,scoreThreshold:p,padToMaxOutputSize:s},m=N.runKernel(Jc,d,f);return{selectedIndices:m[0],validOutputs:m[1]}}var LO,BO=D(()=>{"use strict";B();G();$();yu();M();LO=E({nonMaxSuppressionPadded_:EJ})});async function TJ(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(n,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),c=Tr(i,a,t,r,o,null),l=c.maxOutputSize,u=c.iouThreshold,p=c.scoreThreshold,[d,f]=await Promise.all([i.data(),a.data()]),{selectedIndices:m,validOutputs:h}=ty(d,f,l,u,p,s);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:Wt(m,"int32"),validOutputs:me(h,"int32")}}var VO,UO=D(()=>{"use strict";Ym();$();yu();hn();oa();VO=TJ});function SJ(n,e,t=!1,r=!1){let o=C(n,"images","resizeBilinear");k(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),k(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),k(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=U(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,a={images:s},c={alignCorners:t,halfPixelCenters:r,size:e},l=N.runKernel(hl,a,c);return i?U(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var zO,HO=D(()=>{"use strict";B();G();$();q();M();Se();zO=E({resizeBilinear_:SJ})});function NJ(n,e,t=!1,r=!1){let o=C(n,"images","resizeNearestNeighbor");k(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),k(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),k(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),k(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=U(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,a={images:s},c={alignCorners:t,halfPixelCenters:r,size:e},l=N.runKernel(ml,a,c);return i?U(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var GO,WO=D(()=>{"use strict";B();G();$();q();M();Se();GO=E({resizeNearestNeighbor_:NJ})});function DJ(n,e="binary",t=!1,r=.5){let o=C(n,"image","threshold"),s=.2989,i=.587,a=.114,c=o.shape[0]*o.shape[1],l=ee(Wt([r]),255),u,p,d,f;if(k(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),k(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),k(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),k(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),o.shape[2]===3){[u,p,d]=$o(o,[1,1,1],-1);let g=ee(u,s),x=ee(p,i),v=ee(d,a);f=de(de(g,x),v)}else f=n;if(e==="otsu"){let g=lm(De(Bm(f),"int32"),fn([]),256);l=kJ(g,c)}let m=t?su(f,l):Ji(f,l);return De(ee(m,255),"int32")}function kJ(n,e){let t=Wt([-1]),r=Wt([0]),o=Wt([0]),s,i,a,c,l,u;for(let p=0;p<n.size-1;p++){s=Le(n,0,p+1),i=Le(n,p+1),l=Pe(je(s),e),u=Pe(je(i),e);let d=je(ee(s,Is(0,s.size)));a=Pe(d,je(s));let f=Qr(i.shape,s.size),m=de(Is(0,i.size),f),h=ee(i,m);c=Pe(je(h),je(i));let g=ge(a,c),x=ge(a,c),v=ee(l,u);o=ee(ee(v,g),x);let w=Ji(o,r);r=qn(w,o,r),t=qn(w,Wt([p]),t)}return t}var jO,qO=D(()=>{"use strict";oa();M();an();Um();cE();Nx();Sx();to();Ot();ht();Mn();Gt();tS();Gp();Hp();Ir();Ux();Qf();q();$();jO=E({threshold_:DJ})});function _J(n,e,t="nearest",r="constant",o=0,s){let i=C(n,"image","transform","float32"),a=C(e,"transforms","transform","float32");k(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),k(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),k(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let c={image:i,transforms:a},l={interpolation:t,fillMode:r,fillValue:o,outputShape:s};return N.runKernel(Ll,c,l)}var KO,XO=D(()=>{"use strict";B();G();$();q();M();KO=E({transform_:_J})});function AJ(n,e,t){let r=C(n,"a","bandPart");k(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let o=r.shape,[s,i]=r.shape.slice(-2),a,c;typeof e=="number"?(k(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),k(e<=s,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`),a=C(e<0?s:e,"numLower","bandPart")):(k(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=qn(Xp(e,0),s,na(e,s))),typeof t=="number"?(k(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),k(t<=i,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`),c=C(t<0?i:t,"numUpper","bandPart")):(k(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),c=qn(Xp(t,0),i,na(t,i)));let l=U(Is(0,s,1,"int32"),[-1,1]),u=Is(0,i,1,"int32"),p=ge(l,u),d=ea(su(p,a),vm(p,Qt(c))),f=pr([s,i],r.dtype);return U(xn(Xn(U(r,[-1,s,i])).map(m=>qn(d,m,f))),o)}var YO,ZO=D(()=>{"use strict";$();q();WE();YE();Nx();_x();Ox();ws();M();Ux();Se();Hm();Gt();qx();Gp();_m();YO=E({bandPart_:AJ})});function RJ(n){let e;if(Array.isArray(n)){e=!1,k(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=n[0].shape[0];for(let s=1;s<n.length;++s)k(n[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[s].shape[0]} vs. ${o})`)}else e=!0,n=$o(n,n.shape[0],0).map(o=>du(o,[0]));k(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);let t=[],r=n;for(let o=0;o<n.length;++o)t.push(N.tidy(()=>{let s=r[o];if(o>0)for(let i=0;i<o;++i){let a=ee(je(ee(t[i],s)),t[i]);s=ge(s,a)}return Pe(s,Qi(s,"euclidean"))}));return e?xn(t,0):t}var QO,JO=D(()=>{"use strict";B();q();Mn();ht();hm();M();Um();Wx();Hm();Gt();to();QO=E({gramSchmidt_:RJ})});function FJ(n,e=!1){if(k(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return e$(n,e);{let t=n.shape.slice(0,n.shape.length-2).reduce((c,l)=>c*l),r=Xn(U(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),o=[],s=[];r.forEach(c=>{let[l,u]=e$(c,e);o.push(l),s.push(u)});let i=U(xn(o,0),n.shape),a=U(xn(s,0),n.shape);return[i,a]}}function e$(n,e=!1){return N.tidy(()=>{k(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);let t=n.shape[0],r=n.shape[1],o=gm(t),s=Fn(n),i=Ts([[1]],[1,1]),a=Fn(i),c=t>=r?r:t;for(let l=0;l<c;++l){let u=s,p=a,d=o;[a,s,o]=N.tidy(()=>{let f=Le(s,[l,l],[t-l,1]),m=Qi(f),h=Le(s,[l,l],[1,1]),g=qn(Ji(h,0),Ts([[-1]]),Ts([[1]])),x=ge(h,ee(g,m)),v=Pe(f,x);v.shape[0]===1?a=Fn(i):a=ot([i,Le(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);let w=Qt(Pe(ze(g,x),m)),I=Le(s,[l,0],[t-l,r]),_=ee(w,a),A=fu(a);if(l===0)s=ge(I,ze(_,ze(A,I)));else{let P=ge(I,ze(_,ze(A,I)));s=ot([Le(s,[0,0],[l,r]),P],0)}let R=fu(_),F=Le(o,[0,l],[t,o.shape[1]-l]);if(l===0)o=ge(F,ze(ze(F,a),R));else{let P=ge(F,ze(ze(F,a),R));o=ot([Le(o,[0,0],[t,l]),P],1)}return[a,s,o]}),Ct([u,p,d])}return!e&&t>r&&(o=Le(o,[0,0],[t,r]),s=Le(s,[0,0],[r,r])),[o,s]})}var t$,n$=D(()=>{"use strict";B();jn();q();Vp();Yr();Mn();zE();Sx();ps();ht();ws();hm();M();Se();Ir();Hm();Gt();jx();Xx();qx();Gp();t$=E({qr_:FJ})});var wt,oo=D(()=>{"use strict";wt=(function(n){return n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",n})(wt||{})});function MJ(n,e,t=wt.SUM_BY_NONZERO_WEIGHTS){let r=C(n,"losses","computeWeightedLoss"),o=null;e!=null&&(o=C(e,"weights","computeWeightedLoss"));let s=o==null?r:ee(r,o);if(t===wt.NONE)return s;if(t===wt.SUM)return je(s);if(t===wt.MEAN){if(o==null)return ta(s);{let i=r.size/o.size,a=Pe(je(s),je(o));return i>1?Pe(a,me(i)):a}}if(t===wt.SUM_BY_NONZERO_WEIGHTS){if(o==null)return Pe(je(s),me(r.size));{let i=ee(o,no(r.shape)),a=De(je(Am(i,me(0))),"float32");return Pe(je(s),a)}}throw Error(`Unknown reduction: ${t}`)}var cn,Po=D(()=>{"use strict";$();an();Mn();oo();Fx();ht();yT();Mx();M();hn();to();cn=E({computeWeightedLoss_:MJ})});function OJ(n,e,t,r=wt.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"labels","absoluteDifference"),s=C(e,"predictions","absoluteDifference"),i=null;t!=null&&(i=C(t,"weights","absoluteDifference")),it(o.shape,s.shape,"Error in absoluteDifference: ");let a=Ut(ge(o,s));return cn(a,i,r)}var r$,o$=D(()=>{"use strict";$();q();tu();oo();M();Gt();Po();r$=E({absoluteDifference_:OJ})});function $J(n,e,t,r,o=wt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"labels","cosineDistance"),i=C(e,"predictions","cosineDistance"),a=null;r!=null&&(a=C(r,"weights","cosineDistance")),it(s.shape,i.shape,"Error in cosineDistance: ");let c=me(1),l=ge(c,je(ee(s,i),t,!0));return cn(l,a,o)}var s$,i$=D(()=>{"use strict";$();q();oo();ht();M();hn();Gt();to();Po();s$=E({cosineDistance_:$J})});function PJ(n,e,t,r=wt.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"labels","hingeLoss"),s=C(e,"predictions","hingeLoss"),i=null;t!=null&&(i=C(t,"weights","hingeLoss")),it(o.shape,s.shape,"Error in hingeLoss: ");let a=me(1);o=ge(ee(me(2),o),a);let c=Es(ge(a,ee(o,s)));return cn(c,i,r)}var a$,c$=D(()=>{"use strict";$();q();oo();ht();M();Pm();hn();Gt();Po();a$=E({hingeLoss_:PJ})});function LJ(n,e,t,r=1,o=wt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"labels","huberLoss"),i=C(e,"predictions","huberLoss"),a=null;t!=null&&(a=C(t,"weights","huberLoss")),it(s.shape,i.shape,"Error in huberLoss: ");let c=me(r),l=Ut(ge(i,s)),u=na(l,c),p=ge(l,u),d=de(ee(me(.5),Ht(u)),ee(c,p));return cn(d,a,o)}var l$,u$=D(()=>{"use strict";$();q();tu();Ot();oo();Ox();ht();M();hn();ys();Gt();Po();l$=E({huberLoss_:LJ})});function BJ(n,e,t,r=1e-7,o=wt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"labels","logLoss"),i=C(e,"predictions","logLoss"),a=null;t!=null&&(a=C(t,"weights","logLoss")),it(s.shape,i.shape,"Error in logLoss: ");let c=me(1),l=me(r),u=Qt(ee(s,Mo(de(i,l)))),p=ee(ge(c,s),Mo(de(ge(c,i),l))),d=ge(u,p);return cn(d,a,o)}var p$,d$=D(()=>{"use strict";$();q();Ot();wm();oo();ht();ws();M();hn();Gt();Po();p$=E({logLoss_:BJ})});function VJ(n,e,t,r=wt.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"labels","meanSquaredError"),s=C(e,"predictions","meanSquaredError"),i=null;t!=null&&(i=C(t,"weights","meanSquaredError")),it(o.shape,s.shape,"Error in meanSquaredError: ");let a=zm(o,s);return cn(a,i,r)}var f$,m$=D(()=>{"use strict";$();q();oo();M();hS();Po();f$=E({meanSquaredError_:VJ})});function UJ(n,e){let t=C(n,"labels","sigmoidCrossEntropyWithLogits"),r=C(e,"logits","sigmoidCrossEntropyWithLogits");it(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=Es(r),s=ee(r,t),i=Im(ur(Qt(Ut(r))));return de(ge(o,s),i)}function zJ(n,e,t,r=0,o=wt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"multiClassLabels","sigmoidCrossEntropy"),i=C(e,"logits","sigmoidCrossEntropy"),a=null;if(t!=null&&(a=C(t,"weights","sigmoidCrossEntropy")),it(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let l=me(r),u=me(1),p=me(.5);s=de(ee(s,ge(u,l)),ee(p,l))}let c=UJ(s,i);return cn(c,a,o)}var h$,g$=D(()=>{"use strict";$();q();tu();Ot();Kp();JE();oo();ht();ws();M();Pm();hn();Gt();Po();h$=E({sigmoidCrossEntropy_:zJ})});function HJ(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return gn((o,s,i)=>{let c=Tm(s,[t],!0),l=ge(De(s,"float32"),c);i([o,l]);let u=Qt(ee(l,o));return{value:je(u,[t]),gradFunc:(f,m)=>{let[h,g]=m,x=xs(f.shape,[t]);return[ee(U(f,x),ge(De(h,"float32"),ur(g))),ee(U(f,x),ge(ur(g),De(h,"float32")))]}}})(n,e)}function GJ(n,e,t,r=0,o=wt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"onehotLabels","softmaxCrossEntropy"),i=C(e,"logits","softmaxCrossEntropy"),a=null;if(t!=null&&(a=C(t,"weights","softmaxCrossEntropy")),it(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let l=me(r),u=me(1),p=me(s.shape[1]);s=de(ee(s,ge(u,l)),Pe(l,p))}let c=HJ(s,i);return cn(c,a,o)}var x$,y$=D(()=>{"use strict";Cs();$();q();Ot();Wp();an();Mn();Kp();rT();oo();ht();ws();M();Se();hn();Gt();to();Po();x$=E({softmaxCrossEntropy_:GJ})});function WJ(n,e,t,r){let o=C(n,"indices","sparseFillEmptyRows","int32"),s=C(e,"values","sparseFillEmptyRows"),i=C(t,"denseShape","sparseFillEmptyRows","int32"),a=C(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let c={indices:o,values:s,denseShape:i,defaultValue:a},l=N.runKernel(Sl,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var v$,b$=D(()=>{"use strict";B();G();$();M();v$=E({sparseFillEmptyRows_:WJ})});function jJ(n,e,t){let r=C(n,"inputIndices","sparseReshape","int32"),o=C(e,"inputShape","sparseReshape","int32"),s=C(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:o,newShape:s},a=N.runKernel(Nl,i);return{outputIndices:a[0],outputShape:a[1]}}var C$,w$=D(()=>{"use strict";B();G();$();M();C$=E({sparseReshape_:jJ})});function qJ(n,e,t){let r=C(n,"data","sparseSegmentMean"),o=C(e,"indices","sparseSegmentMean","int32"),s=C(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return N.runKernel(Dl,i)}var I$,E$=D(()=>{"use strict";B();G();$();M();I$=E({sparseSegmentMean_:qJ})});function KJ(n,e,t){let r=C(n,"data","sparseSegmentSum"),o=C(e,"indices","sparseSegmentSum","int32"),s=C(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return N.runKernel(kl,i)}var T$,S$=D(()=>{"use strict";B();G();$();M();T$=E({sparseSegmentSum_:KJ})});function XJ(n,e,t,r,o,s,i,a){let c=C(n,"data","stringNGrams","string");if(c.dtype!=="string")throw new Error("Data must be of datatype string");if(c.shape.length!==1)throw new Error(`Data must be a vector, saw: ${c.shape}`);let l=C(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let u={separator:t,nGramWidths:r,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:c,dataSplits:l},d=N.runKernel(Rl,p,u);return{nGrams:d[0],nGramsSplits:d[1]}}var N$,D$=D(()=>{"use strict";B();G();$();M();N$=E({stringNGrams_:XJ})});function YJ(n,e,t=!0){let r=C(n,"input","stringSplit","string"),o=C(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:t},i={input:r,delimiter:o},a=N.runKernel(Fl,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var k$,_$=D(()=>{"use strict";B();G();$();M();k$=E({stringSplit_:YJ})});function ZJ(n,e){let t=C(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");let o={input:t};return N.runKernel(Ml,o,r)}var A$,R$=D(()=>{"use strict";B();G();$();M();A$=E({stringToHashBucketFast_:ZJ})});function QJ(n,e,t,r=!0){let o=C(n,"input","staticRegexReplace","string"),s={pattern:e,rewrite:t,replaceGlobal:r};return N.runKernel(Li,{x:o},s)}var F$,M$=D(()=>{"use strict";B();G();$();M();F$=E({staticRegexReplace_:QJ})});var O$,$$,P$,L$,B$,V$,U$,Zm=D(()=>{"use strict";tu();a2();c2();Ot();l2();u2();p2();d2();f2();m2();h2();g2();x2();y2();eE();C2();w2();oE();cm();T2();S2();N2();cE();D2();k2();pE();us();an();_2();A2();Vp();qi();Yr();R2();F2();M2();O2();$2();um();P2();L2();U2();z2();H2();G2();W2();j2();q2();wx();K2();X2();Mn();Z2();Q2();ME();OE();J2();AE();eF();rF();Kp();Ex();oF();zE();Hp();HE();LI();GE();Sx();WE();bm();sF();iF();aF();XE();YE();Nx();cF();lF();wm();JE();mF();hF();rT();_x();oT();sT();gF();xF();ps();fm();cT();yF();vF();pT();Fx();bF();BE();Ox();CF();wF();IF();ht();EF();TF();ws();yT();vT();Mx();SF();NF();Qp();DF();kF();_F();AF();RF();mm();DT();PI();FF();MF();OF();$F();PF();rM();jT();oM();Vx();sM();Ux();$m();iM();Pm();YT();Se();lu();aM();cM();lM();uM();tS();pM();hn();dM();fM();mM();im();hM();gM();xM();Ir();yM();vM();bM();CM();wM();eT();ST();zx();Hx();mS();Gx();Um();qp();ys();hS();Wx();Hm();gS();IM();Gt();to();EM();nE();Qf();oa();jx();vS();TM();SM();NM();kM();Tx();_M();AM();RM();FM();qx();MM();OM();Gp();RS();_m();hs();PM();Xx();hm();BM();UM();Rx();WM();qM();ZM();Xm();JM();M();Gx();zx();Hx();mS();dO();mO();FS();MS();gO();yO();bO();wO();EO();SO();DO();FO();OO();PO();BO();UO();HO();WO();qO();XO();ZO();JO();n$();o$();Po();i$();c$();u$();d$();m$();g$();y$();b$();w$();E$();S$();D$();_$();R$();M$();O$={fft:uu,ifft:ra,rfft:pu,irfft:Vm},$$={hammingWindow:fO,hannWindow:Qx,frame:Jx,stft:hO},P$={flipLeftRight:vO,grayscaleToRGB:CO,resizeNearestNeighbor:GO,resizeBilinear:zO,rgbToGrayscale:IO,rotateWithOffset:TO,cropAndResize:xO,nonMaxSuppression:NO,nonMaxSuppressionAsync:RO,nonMaxSuppressionWithScore:MO,nonMaxSuppressionWithScoreAsync:$O,nonMaxSuppressionPadded:LO,nonMaxSuppressionPaddedAsync:VO,threshold:jO,transform:KO},L$={bandPart:YO,gramSchmidt:QO,qr:t$},B$={absoluteDifference:r$,computeWeightedLoss:cn,cosineDistance:s$,hingeLoss:a$,huberLoss:l$,logLoss:p$,meanSquaredError:f$,sigmoidCrossEntropy:h$,softmaxCrossEntropy:x$},V$={sparseFillEmptyRows:v$,sparseReshape:C$,sparseSegmentMean:I$,sparseSegmentSum:T$},U$={stringNGrams:N$,stringSplit:k$,stringToHashBucketFast:A$,staticRegexReplace:F$}});var LS={};Ue(LS,{Serializable:()=>Qm,SerializationMap:()=>ry,getRegisteredName:()=>eee,registerClass:()=>PS});function PS(n,e,t){k(n.className!=null,()=>"Class being registered does not have the static className property defined."),k(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),k(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);let r=t,o=e+">"+r;return ry.register(n),JJ.set(o,n),$S.set(n,o),n}function eee(n){return $S.has(n)?$S.get(n):n.className}var JJ,$S,Qm,ry,oy=D(()=>{"use strict";q();JJ=new Map,$S=new Map,Qm=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},ry=class n{constructor(){this.classNameMap={}}static getMap(){return n.instance==null&&(n.instance=new n),n.instance}static register(e){n.getMap().classNameMap[e.className]=[e,e.fromConfig]}}});var yn,sa=D(()=>{"use strict";jn();Cs();Zm();oy();yn=class extends Qm{minimize(e,t=!1,r){let{value:o,grads:s}=this.computeGradients(e,r);if(r!=null){let i=r.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return Ct(s),t?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Dx(e,t)}dispose(){this.iterations_!=null&&Ct(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:me(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(yn,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null})});var ia,sy=D(()=>{"use strict";B();jn();Ot();Mn();ht();Zm();ys();hs();sa();ia=class extends yn{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{let s=N.registeredVariables[r],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accum_grad`,variable:Ce(()=>Ft(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${r}/accum_var`,variable:Ce(()=>Ft(s).variable(i))});let a=Array.isArray(e)?e[o].tensor:e[r];if(a==null)return;let c=this.accumulatedGrads[o].variable,l=this.accumulatedUpdates[o].variable;Ce(()=>{let u=de(ee(c,this.rho),ee(Ht(a),1-this.rho)),p=ee(Pe(Nn(de(l,this.epsilon)),Nn(de(c,this.epsilon))),a),d=de(ee(l,this.rho),ee(Ht(p),1-this.rho));c.assign(u),l.assign(d);let f=de(ee(p,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ct(this.accumulatedGrads.map(e=>e.variable)),Ct(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}});var aa,iy=D(()=>{"use strict";B();jn();Ot();Mn();Hp();ht();qp();ys();sa();aa=class extends yn{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{let s=N.registeredVariables[r];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accumulator`,variable:Ce(()=>Qr(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(e)?e[o].tensor:e[r];if(i==null)return;let a=this.accumulatedGrads[o].variable;Ce(()=>{let c=de(a,Ht(i));a.assign(c);let l=de(ee(Pe(i,Nn(de(c,N.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ct(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}});var ca,ay=D(()=>{"use strict";B();jn();Ot();Mn();ht();mm();hn();qp();ys();Gt();hs();sa();ca=class extends yn{static get className(){return"Adam"}constructor(e,t,r,o=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ce(()=>{this.accBeta1=me(t).variable(),this.accBeta2=me(r).variable()}),o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Ce(()=>{let r=ge(1,this.accBeta1),o=ge(1,this.accBeta2);t.forEach((s,i)=>{let a=N.registeredVariables[s],c=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:Ce(()=>Ft(a).variable(c))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:Ce(()=>Ft(a).variable(c))});let l=Array.isArray(e)?e[i].tensor:e[s];if(l==null)return;let u=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,d=de(ee(u,this.beta1),ee(l,1-this.beta1)),f=de(ee(p,this.beta2),ee(Ht(l),1-this.beta2)),m=Pe(d,r),h=Pe(f,o);u.assign(d),p.assign(f);let g=de(ee(Pe(m,de(Nn(h),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(ee(this.accBeta1,this.beta1)),this.accBeta2.assign(ee(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ct(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ct(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Ce(()=>{this.accBeta1.assign(Fo(this.beta1,this.iterations_+1)),this.accBeta2.assign(Fo(this.beta2,this.iterations_+1))});let t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}});var la,cy=D(()=>{"use strict";B();jn();tu();Ot();Mn();pT();ht();hn();Gt();hs();sa();la=class extends yn{static get className(){return"Adamax"}constructor(e,t,r,o=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ce(()=>{this.iteration=me(0).variable(),this.accBeta1=me(t).variable()}),o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Ce(()=>{let r=ge(1,this.accBeta1),o=Pe(-this.learningRate,de(ee(this.iteration,this.decay),1));t.forEach((s,i)=>{let a=N.registeredVariables[s],c=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:Ft(a).variable(c)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:Ft(a).variable(c)});let l=Array.isArray(e)?e[i].tensor:e[s];if(l==null)return;let u=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,d=de(ee(u,this.beta1),ee(l,1-this.beta1)),f=ee(p,this.beta2),m=Ut(l),h=km(f,m);u.assign(d),p.assign(h);let g=de(ee(Pe(o,r),Pe(d,de(h,this.epsilon))),a);a.assign(g)}),this.iteration.assign(de(this.iteration,1)),this.accBeta1.assign(ee(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ct(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ct(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}});var Lo,Jm=D(()=>{"use strict";B();jn();Ot();ht();hn();sa();Lo=class extends yn{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{let s=Array.isArray(e)?e[o].tensor:e[r];if(s==null)return;let i=N.registeredVariables[r];Ce(()=>{let a=de(ee(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Sn(me(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}});var ua,ly=D(()=>{"use strict";B();jn();Ot();ht();hn();hs();Jm();ua=class extends Lo{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=me(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{let s=N.registeredVariables[r];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${r}/momentum`,variable:Ce(()=>Ft(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(e)?e[o].tensor:e[r];a!=null&&Ce(()=>{let c,l=de(ee(this.m,i),a);this.useNesterov?c=de(ee(this.c,de(a,ee(l,this.m))),s):c=de(ee(this.c,l),s),i.assign(l),s.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ct(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}});var pa,uy=D(()=>{"use strict";B();jn();Ot();Mn();ht();qp();ys();Gt();hs();sa();pa=class extends yn{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,o=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=N.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{let s=N.registeredVariables[r],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${r}/rms`,variable:Ce(()=>Ft(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${r}/momentum`,variable:Ce(()=>Ft(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${r}/mg`,variable:Ce(()=>Ft(s).variable(i))});let a=Array.isArray(e)?e[o].tensor:e[r];if(a==null)return;let c=this.accumulatedMeanSquares[o].variable,l=this.accumulatedMoments[o].variable;Ce(()=>{let u=de(ee(c,this.decay),ee(Ht(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,d=de(ee(p,this.decay),ee(a,1-this.decay)),f=Pe(ee(a,this.learningRate),Nn(ge(u,de(Ht(d),this.epsilon)))),m=de(ee(l,this.momentum),f);c.assign(u),p.assign(d),l.assign(m);let h=ge(s,m);s.assign(h)}else{let p=de(ee(c,this.decay),ee(Ht(a),1-this.decay)),d=de(ee(l,this.momentum),Pe(ee(a,this.learningRate),Nn(de(p,this.epsilon))));c.assign(p),l.assign(d);let f=ge(s,d);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ct(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ct(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ct(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}});function z$(){for(let n of tee)PS(n)}var tee,H$=D(()=>{"use strict";sy();iy();ay();cy();ly();uy();Jm();oy();tee=[ia,aa,ca,la,ua,pa,Lo]});function G$(n){return new Promise(e=>setTimeout(e)).then(n)}function iee(n="model"){return new BS(n)}function W$(n){return new VS(n)}var nee,ree,oee,BS,VS,see,j$=D(()=>{"use strict";Op();Yt();Yi();Yl();Ki();nee="model",ree=".json",oee=".weights.bin";BS=(()=>{class n{constructor(t){if(!O().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(n.URL_SCHEME)&&(t=t.slice(n.URL_SCHEME.length)),(t==null||t.length===0)&&(t=nee),this.modelJsonFileName=t+ree,this.weightDataFileName=t+oee}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let r=sn.join(t.weightData),o=window.URL.createObjectURL(new Blob([r],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],i=xx(t,s),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),c=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(c.download=this.modelJsonFileName,c.href=a,await G$(()=>c.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=o,await G$(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:_o(t)}}}}return n.URL_SCHEME="downloads://",n})(),VS=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let r=new FileReader;r.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}let c=$p(s,l=>this.loadWeights(l));e(c)},r.onerror=o=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){let t=[],r=[];for(let i of e)t.push(...i.weights),r.push(...i.paths);let o=this.checkManifestAndWeightFiles(e),s=r.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[t,i])}loadWeightsFile(e,t){return new Promise((r,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;r(a)},s.onerror=i=>o(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],r=this.weightsFiles.map(s=>SI(s.name)),o={};for(let s of e)s.paths.forEach(i=>{let a=SI(i);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},see=n=>O().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(BS.URL_SCHEME)?iee(n.slice(BS.URL_SCHEME.length)):null;Vt.registerSaveRouter(see)});function US(n,e,t,r){i(n),t=t??0,r=r??1,a(t,r);let o=0,s=c=>(c.then(l=>{let u=t+ ++o/n.length*(r-t);return e(u),l}),c);function i(c){k(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function a(c,l){k(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),k(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),k(l>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${l}`)}return Promise.all(n.map(s))}var q$=D(()=>{"use strict";q();});async function zS(n,e){e==null&&(e={});let t=e.fetchFunc==null?O().platform.fetch:e.fetchFunc,r=n.map(p=>t(p,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(r):await US(r,e.onProgress,0,.5)).map(p=>p.arrayBuffer());return e.onProgress==null?await Promise.all(a):await US(a,e.onProgress,.5,1)}function K$(n,e){var t;let r=e.fetchFunc==null?O().platform.fetch:e.fetchFunc,o=0,s;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async i=>{for(var a;o<n.length;){s||(s=(await r(n[o],e.requestInit,{isBinary:!0})).body.getReader());let{done:c,value:l}=await s.read();if(c){o++,s=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,o/n.length);continue}i.enqueue(l);return}i.close()}})}async function X$(n,e="",t,r){return HS(i=>zS(i,{requestInit:r}))(n,e,t)}function HS(n){return async(e,t="",r)=>{let o=e.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((f,m)=>{let h=0;f.weights.forEach(g=>{let x="quantization"in g?g.quantization.dtype:g.dtype,v=cs[x]*Ne(g.shape),w=()=>{o[m]=!0,s[m]==null&&(s[m]=[]),s[m].push({manifestEntry:g,groupOffset:h,sizeBytes:v})};r!=null?r.forEach((I,_)=>{I===g.name&&(w(),i[_]=!0)}):w(),a.push(g.name),h+=v})}),!i.every(f=>f)){let f=r.filter((m,h)=>!i[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let c=o.reduce((f,m,h)=>(m&&f.push(h),f),[]),l=[];c.forEach(f=>{e[f].paths.forEach(m=>{let h=t+(t.endsWith("/")?"":"/")+m;l.push(h)})});let u=await n(l),p={},d=0;return c.forEach(f=>{let m=e[f].paths.length,h=new sn(u.slice(d,d+m));s[f].forEach(x=>{let v=h.slice(x.groupOffset,x.groupOffset+x.sizeBytes),w=hx(v,[x.manifestEntry]);for(let I in w)p[I]=w[I]}),d+=m}),p}}var GS=D(()=>{"use strict";Yt();q();Ki();Yi();q$();wI();});function lee(n){let e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),o=t>e?n.substring(t):"";return[r+"/",o]}function py(n){return n.match(Y$.URL_SCHEME_REGEX)!=null}function dy(n,e){return new Y$(n,e)}function Q$(n,e){return dy(n,e)}var aee,cee,Y$,Z$,J$=D(()=>{"use strict";Yt();q();Yi();Ki();Yl();GS();aee="application/octet-stream",cee="application/json",Y$=(()=>{class n{constructor(t,r){if(this.DEFAULT_METHOD="POST",r==null&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,r.fetchFunc!=null?(k(typeof r.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=O().platform.fetch,k(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&k(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,r.requestInit!=null&&r.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let r=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);r.body=new FormData;let o=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],s=xx(t,o);if(r.body.append("model.json",new Blob([JSON.stringify(s)],{type:cee}),"model.json"),t.weightData!=null){let a=sn.join(t.weightData);r.body.append("model.weights.bin",new Blob([a],{type:aee}),"model.weights.bin")}let i=await this.fetch(this.path,r);if(i.ok)return{modelArtifactsInfo:_o(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let r;try{r=await t.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let o=r.modelTopology,s=r.weightsManifest;if(o==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return r}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let t=await this.loadModelJSON();return $p(t,r=>this.loadWeights(r))}async loadStream(){let t=await this.loadModelJSON(),r=await this.getWeightUrls(t.weightsManifest),o=em(t.weightsManifest),s=()=>K$(r,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:o,getWeightStream:s})}async getWeightUrls(t){let r=Array.isArray(this.path)?this.path[1]:this.path,[o,s]=lee(r),i=this.weightPathPrefix||o,a=[],c=[];for(let l of t)for(let u of l.paths)this.weightUrlConverter!=null?c.push(this.weightUrlConverter(u)):a.push(i+u+s);return this.weightUrlConverter&&a.push(...await Promise.all(c)),a}async loadWeights(t){let r=await this.getWeightUrls(t),o=em(t),s=await zS(r,this.loadOptions);return[o,s]}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();Z$=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>py(r)):t=py(n),t)return dy(n,e)}return null};Vt.registerSaveRouter(Z$);Vt.registerLoadRouter(Z$)});function eP(n,e,t,r){let o=arguments;return new WS(jS(...o))}function jS(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new eh(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new eh({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new eh({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function tP(n){return new fy(n)}function nP(n){return new fy(n)}var eh,fy,WS,rP=D(()=>{"use strict";eh=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},fy=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},WS=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}});var Bo={};Ue(Bo,{CompositeArrayBuffer:()=>sn,browserFiles:()=>W$,browserHTTPRequest:()=>Q$,concatenateArrayBuffers:()=>BR,copyModel:()=>JR,decodeWeights:()=>hx,decodeWeightsStream:()=>gx,encodeWeights:()=>OR,fromMemory:()=>eP,fromMemorySync:()=>jS,getLoadHandlers:()=>HR,getModelArtifactsForJSON:()=>$p,getModelArtifactsForJSONSync:()=>NI,getModelArtifactsInfoForJSON:()=>_o,getSaveHandlers:()=>zR,getWeightSpecs:()=>em,http:()=>dy,isHTTPScheme:()=>py,listModels:()=>ZR,loadWeights:()=>X$,moveModel:()=>e2,registerLoadRouter:()=>UR,registerSaveRouter:()=>VR,removeModel:()=>QR,weightsLoaderFactory:()=>HS,withSaveHandler:()=>tP,withSaveHandlerSync:()=>nP});var oP=D(()=>{"use strict";AI();RI();j$();J$();Yi();rP();Yl();GS();Ki();FI();});function uee(n,e,t){let r=C(n,"labels","confusionMatrix"),o=C(e,"predictions","confusionMatrix");k(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),k(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),k(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),k(r.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),k(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);let s=Zp(De(r,"int32"),t),i=Zp(De(o,"int32"),t),a=fu(s),c=ze(a,i);return De(c,"int32")}var sP,iP=D(()=>{"use strict";$();q();an();ps();vT();M();Xx();sP=E({confusionMatrix_:uee})});var qS={};Ue(qS,{confusionMatrix:()=>sP});var aP=D(()=>{"use strict";iP();});var KS={};Ue(KS,{draw:()=>yee,fromPixels:()=>vee,fromPixelsAsync:()=>hee,toPixels:()=>xee});function lP(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,o=!1,s=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)s=!0;else if(n.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Gl(Sp,N.backendName)!=null){let m={pixels:n},h={numChannels:e};return N.runKernel(Sp,m,h)}let[l,u]=o?[n.videoWidth,n.videoHeight]:[n.width,n.height],p;if(i)p=n.getContext("2d").getImageData(0,0,l,u).data;else if(r||t)p=n.data;else if(s||o||a){if(vu==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")vu=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else vu=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});vu.canvas.width=l,vu.canvas.height=u,vu.drawImage(n,0,0,l,u),p=vu.getImageData(0,0,l,u).data}let d;if(e===4)d=new Int32Array(p);else{let m=l*u;d=new Int32Array(m*e);for(let h=0;h<m;h++)for(let g=0;g<e;++g)d[h*e+g]=p[h*4+g]}return Wm(d,[u,l,e],"int32")}function pee(n){return n!=null&&n.data instanceof Uint8Array}function dee(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function fee(n){return n!=null&&n.width!==0&&n.height!==0}function mee(n){return dee()&&!(n instanceof ImageBitmap)&&fee(n)&&!pee(n)}async function hee(n,e=3){let t=null;if(O().getBool("WRAP_TO_IMAGEBITMAP")&&mee(n)){let r;try{r=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===n.width&&r.height===n.height?t=r:t=n}else t=n;return lP(t,e)}function uP(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);let e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function gee(n){let e=n?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function xee(n,e){let t=C(n,"img","toPixels");if(!(n instanceof Ze)){let l=t;t=De(l,"int32"),l.dispose()}uP(t);let[r,o]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2],i=await t.data(),a=t.dtype==="float32"?255:1,c=new Uint8ClampedArray(o*r*4);for(let l=0;l<r*o;++l){let u=[0,0,0,255];for(let d=0;d<s;d++){let f=i[l*s+d];if(t.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(t.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(u[0]=f*a,u[1]=f*a,u[2]=f*a):u[d]=f*a}let p=l*4;c[p+0]=Math.round(u[0]),c[p+1]=Math.round(u[1]),c[p+2]=Math.round(u[2]),c[p+3]=Math.round(u[3])}if(e!=null){cP||Gl(vp,N.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),cP=!0),e.width=o,e.height=r;let l=e.getContext("2d"),u=new ImageData(c,o,r);l.putImageData(u,0,0)}return t!==n&&t.dispose(),c}function yee(n,e,t){let r=C(n,"img","draw");if(!(n instanceof Ze)){let i=r;r=De(i,"int32"),i.dispose()}uP(r),gee(t?.imageOptions);let o={image:r},s={canvas:e,options:t};N.runKernel(vp,o,s)}var vu,cP,vee,pP=D(()=>{"use strict";B();Yt();G();sx();cr();$();an();M();vS();cP=!1;vee=E({fromPixels_:lP})});var XS={};Ue(XS,{prepareAndValidate:()=>dP});function dP(n,e){let t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(Ne(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);let o=e.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=n.shape,c=o.slice();c.pop();let l=1;for(let p=s;p<t;++p)l*=a[p],c.push(a[p]);let u=[...No(n.shape).map(p=>p/l),1].slice(0,s);return[c,i,l,u]}var YS=D(()=>{"use strict";q()});var $t={};Ue($t,{assertParamsValid:()=>Cee,computeFlatOffset:()=>See,computeOutShape:()=>Iee,getNormalizedAxes:()=>Eee,isSliceContinous:()=>Tee,maskToAxes:()=>wee,parseSliceParams:()=>Nee,sliceInfo:()=>Dee,startForAxis:()=>bP,startIndicesWithElidedDims:()=>xP,stopForAxis:()=>CP,stopIndicesWithElidedDims:()=>yP,stridesForAxis:()=>vP,stridesWithElidedDims:()=>mP});function Cee(n,e,t){let r=n.shape.length;k(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),k(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let o=0;o<r;++o)k(e[o]+t[o]<=n.shape[o],()=>`Error in slice${r}D: begin[${o}] + size[${o}] (${e[o]+t[o]}) would overflow input.shape[${o}] (${n.shape[o]})`)}function wee(n){let e=[],t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function Iee(n,e,t){let r=[];for(let o=0;o<n.length;o++)r[o]=Math.ceil((e[o]-n[o])/t[o]);return r}function mP(n,e,t,r){let o=[...n];for(let s=o.length;s<r.length;s++)o.push(1);for(let s=0;s<t;s++)s===0?o[e]=1:(o.splice(e,0,1),o.pop());return o}function hP(n,e,t){return t<=n?t:t-(e-1)}function gP(n,e){let t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function Eee(n,e,t,r,o,s,i,a,c){let l=n.length,u=new Array(l),p=new Array(l),d=new Array(l);if(e.length&&t>0){let f=e[0],m=t+1;u=xP(i,f,m,r,n),p=yP(a,f,m,o,n),d=mP(s,f,m,n)}else for(let f=0;f<l;f++)u[f]=bP(i,r,s,n,f,c),p[f]=CP(a,o,s,n,f,c),d[f]=vP(s,f,c);return{begin:u,end:p,strides:d}}function xP(n,e,t,r,o){let s=[...o],i=gP(t,e);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let c=hP(e,t,a),l=r[c];n&1<<c&&(l=0),s[a]=l}return s}function yP(n,e,t,r,o){let s=[...o],i=gP(t,e);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let c=hP(e,t,a),l=r[c];n&1<<c&&(l=Number.MAX_SAFE_INTEGER),s[a]=l}for(let a=0;a<s.length;a++){let c=o[a];s[a]<0&&(s[a]+=c),s[a]=dp(0,s[a],o[a])}return s}function vP(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function bP(n,e,t,r,o,s){let i=e[o],a=t[o]||1;(n&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let c=r[o];return i<0&&(i+=c),i=dp(0,i,c-1),i}function CP(n,e,t,r,o,s){let i=e[o],a=t[o]||1;(n&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let c=r[o];return i<0&&(i+=c),a>0?i=dp(0,i,c):i=dp(-1,i,c-1),i}function Tee(n,e,t){let r=t.length;for(let o=0;o<t.length;o++)if(t[o]>1){r=o;break}for(let o=r+1;o<t.length;o++)if(e[o]>0||t[o]!==n[o])return!1;return!0}function See(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function Nee(n,e,t){let r,o=n.shape.length;typeof e=="number"?r=[e,...new Array(o-1).fill(0)]:e.length<o?r=e.concat(new Array(o-e.length).fill(0)):r=e.slice(),r.forEach(i=>{k(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(o).fill(-1):typeof t=="number"?s=[t,...new Array(o-1).fill(-1)]:t.length<o?s=t.concat(new Array(o-t.length).fill(-1)):s=t,s=s.map((i,a)=>i>=0?i:(k(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,s]}function Dee(n,e,t,r,o,s,i,a,c){let l;if(r==null?(l=new Array(e.length),l.fill(1)):l=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1,p={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:c};for(let w=0;w<p.dims;w++)u&&(1<<w&a)!==0&&p.numAddAxisAfterEllipsis++,1<<w&i&&(u=!0);u||(p.ellipsisMask|=1<<p.dims,p.dims++);let d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};kee(p,d);let f=!0,m=!0,h=!0,g=[],x=[];for(let w=0;w<n.length;++w){if(d.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);let I=!!(d.shrinkAxisMask&1<<w),_=n[w];if(_===-1){g.push(I?1:-1);continue}let A=[d.beginMask&1<<w,d.endMask&1<<w],R=[d.strides[w]>0?0:-1,d.strides[w]>0?_:_-1];if(I&&d.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&d.strides[w]===1;let F=!!(d.beginMask&1<<w&&d.endMask&1<<w);if(d.beginValid&&d.endValid){if(I){let z=d.begin[w]<0?_+d.begin[w]:d.begin[w];if(d.begin[w]=z,d.end[w]=d.begin[w]+1,z<0||z>=_)throw Error(`slice index ${d.begin[w]} of dimension ${w} out of bounds.`)}else d.begin[w]=fP(d.begin[w],0,d.strides[w],_,A,R),d.end[w]=fP(d.end[w],1,d.strides[w],_,A,R);let V=d.strides[w]===1&&d.begin[w]===0&&d.end[w]===_;f=f&&V,m=m&&(w===0&&d.strides[w]===1||V)}else f=f&&d.strides[w]===1&&F,m=m&&(w===0&&d.strides[w]===1||F);let P,L=!1;if(d.beginValid&&d.endValid?(P=d.end[w]-d.begin[w],L=!0):I?(P=1,L=!0):F&&_>=0&&(d.strides[w]<0?P=-_:P=_,L=!0),L){let V;P===0||P<0!=d.strides[w]<0?V=0:V=Math.trunc(P/d.strides[w])+(P%d.strides[w]!==0?1:0),g.push(V)}else g.push(-1)}for(let w=0;w<d.finalShapeGatherIndices.length;++w){let I=d.finalShapeGatherIndices[w];I>=0?x.push(g[I]):I===ZS&&x.push(1)}return{finalShapeSparse:x.filter((w,I)=>d.finalShapeGatherIndices[I]!==ZS),finalShape:x,isIdentity:f,sliceDim0:m,isSimpleSlice:h,begin:d.begin,end:d.end,strides:d.strides}}function kee(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){let o=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<o;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(ZS),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(bee),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function fP(n,e,t,r,o,s){if(o[e])return t>0?s[e]:s[e+1&1];{let i=n<0?r+n:n;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var ZS,bee,QS=D(()=>{"use strict";q();ZS=-2,bee=-1});var wP,IP=D(()=>{"use strict";wP="4.22.0"});var nd,JS=D(()=>{"use strict";sy();iy();ay();cy();ly();uy();Jm();nd=class{static sgd(e){return new Lo(e)}static momentum(e,t,r=!1){return new ua(e,t,r)}static rmsprop(e,t=.9,r=0,o=null,s=!1){return new pa(e,t,r,o,s)}static adam(e=.001,t=.9,r=.999,o=null){return new ca(e,t,r,o)}static adadelta(e=.001,t=.95,r=null){return new ia(e,t,r)}static adamax(e=.002,t=.9,r=.999,o=null,s=0){return new la(e,t,r,o,s)}static adagrad(e,t=.1){return new aa(e,t)}}});var _ee,EP=D(()=>{"use strict";JS();_ee=nd});function my(){return new Promise(n=>Aee(()=>n()))}var Aee,TP=D(()=>{"use strict";Aee=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n()});function Ree(n,e){let t=n[0].length;n.forEach((o,s)=>{k(o.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),k(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);let r=n[0];n.forEach((o,s)=>{for(let i=0;i<t;i++)k(i===e||o[i]===r[i],()=>`Error in concat${t}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function Fee(n,e){let t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}var SP=D(()=>{"use strict";q();});var NP=D(()=>{"use strict";});function Mee(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let o=1;o<t.length;++o){let s=t[o],i=r[r.length-t.length+o],a=r[i];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${o+n}] = ${s} but shape[${o+n}] = ${a}`)}else r[i]=s}return r}function Oee(n){let e={FIRST_DIM_SIZE:Ss.FIRST_DIM_SIZE,VALUE_ROWIDS:Ss.VALUE_ROWIDS,ROW_LENGTHS:Ss.ROW_LENGTHS,ROW_SPLITS:Ss.ROW_SPLITS,ROW_LIMITS:Ss.ROW_LIMITS,ROW_STARTS:Ss.ROW_STARTS},t=[];for(let r of n)if(r in e)t.push(e[r]);else break;return t}function $ee(n){return n.length===0?0:n[0]===Ss.FIRST_DIM_SIZE?n.length-1:n.length}function Pee(n,e){if(n==null||e==null)return;let t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let o=0;o<Math.min(t,r-1);++o){let s=n[o],i=e[o+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${o-n.length}] = ${s} but ragged tensor input.flatValues.shape[${o-n.length}] = ${i}`)}}var Ss,DP=D(()=>{"use strict";Ss=(function(n){return n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",n})(Ss||{})});function Lee(n){return n<=hy?n:mp(n,Math.floor(Math.sqrt(n)))}var hy,eN=D(()=>{"use strict";q();hy=30});function Bee(n,e,t){let r=t*(typeof n=="number"?n:n[0]),o=e*(typeof n=="number"?n:n[1]);return[r,o]}var kP=D(()=>{"use strict";});function Vee(n,e,t,r=!0){let o=[];if(r)o=o.concat(e.slice(0)),o.push(n[0]/t),o=o.concat(n.slice(1));else{o=o.concat(n[0]);let s=e.length;for(let i=0;i<s;++i)o=o.concat([n[i+1]/e[i],e[i]]);o=o.concat(n.slice(s+1))}return o}function Uee(n,e,t=!0){let r=[];if(t){r.push(e);for(let o=e+1;o<n;++o)o<=2*e?(r.push(o),r.push(o-(e+1))):r.push(o)}else{let o=[],s=[];for(let i=1;i<n;++i)i>=e*2+1||i%2===1?s.push(i):o.push(i);r.push(...o),r.push(0),r.push(...s)}return r}function zee(n,e,t,r=!0){let o=[];r?o.push(n[0]/t):o.push(n[0]*t);for(let s=1;s<n.length;++s)s<=e.length?r?o.push(e[s-1]*n[s]):o.push(n[s]/e[s-1]):o.push(n[s]);return o}function Hee(n,e){let t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function Gee(n,e,t){let r=n.slice(0,1);for(let o=0;o<t;++o)r.push(n[o+1]-e[o][0]-e[o][1]);return r}var _P=D(()=>{"use strict";});var Wee,jee,AP=D(()=>{"use strict";Wee=1.7580993408473768,jee=1.0507009873554805});var qee,Kee,Xee,Yee,Zee,Qee,RP=D(()=>{"use strict";qee=.3275911,Kee=.254829592,Xee=-.284496736,Yee=1.421413741,Zee=-1.453152027,Qee=1.061405429});function Jee(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);let t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function ete(n){let e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function tte(n){let e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let o=0;o<n.length;o+=4)t[Math.floor(o/4)]=n[o],r[Math.floor(o/4)]=n[o+1];return{real:t,imag:r}}function nte(n){let e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let o=2;o<n.length;o+=4)t[Math.floor(o/4)]=n[o],r[Math.floor(o/4)]=n[o+1];return{real:t,imag:r}}function rte(n,e){let t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function ote(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function ste(n,e){let t=new Float32Array(n/2),r=new Float32Array(n/2);for(let o=0;o<Math.ceil(n/2);o++){let s=(e?2:-2)*Math.PI*(o/n);t[o]=Math.cos(s),r[o]=Math.sin(s)}return{real:t,imag:r}}function ite(n,e,t){let r=(t?2:-2)*Math.PI*(n/e),o=Math.cos(r),s=Math.sin(r);return{real:o,imag:s}}var FP=D(()=>{"use strict";});function cte(n,e){n=n.replace(/\s/g,"");let t=(n.length-n.replace(ate,"").length)/tN.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${tN}").`);let[r,o]=n.split(tN);k(r.indexOf(OP)===-1,()=>`The ellipsis notation ("${OP}") is not supported yet.`);let s=r.split(MP),i=s.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let d=0;d<o.length;++d){let f=o[d];if(!s.some(m=>m.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let d=0;d<r.length;++d){let f=r[d];a.indexOf(f)===-1&&f!==MP&&a.push(f)}let c=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);c[d]=[];for(let f=0;f<s[d].length;++f)c[d].push(a.indexOf(s[d][f]))}let l=a.length,u=o.length,p=[];for(let d=u;d<l;++d)p.push(d);return{allDims:a,summedDims:p,idDims:c}}function lte(n,e){let t=new Array(n);t.fill(-1);for(let o=0;o<e.length;++o)t[e[o]]=o;let r=[];for(let o=0;o<n;++o)t[o]===-1&&r.push(o);return t=t.filter(o=>o!==-1),{permutationIndices:t,expandDims:r}}function ute(n,e,t){let r=new Array(n);for(let o=0;o<t.length;++o){let s=t[o].shape;for(let i=0;i<e[o].length;++i)r[e[o][i]]===void 0?r[e[o][i]]=s[i]:k(r[e[o][i]]===s[i],()=>`Expected dimension ${r[e[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function pte(n,e){let t=n,r=[],o=0;n.length===0&&t.push(-1),o=n.length+1;for(let i=0;i<o;++i)r.push([]);let s=[];for(let i=0;i<t.length;++i){let a=t[i],c=fte(e,a);for(let l of c)s.indexOf(l)===-1&&(r[i].push(l),s.push(l))}return{path:t,steps:r}}function dte(n){return n.every((e,t)=>e===t)}function fte(n,e){let t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}var tN,ate,MP,OP,$P=D(()=>{"use strict";Bt();tN="->",ate=/->/g,MP=",",OP="..."});function mte(n,e,t=0){let r=[];if(typeof e=="number")k(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{let o=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);k(o<=1,()=>"There should be only one negative value in split array.");let s=e.indexOf(-1);if(s!==-1){let i=e.reduce((a,c)=>c>0?a+c:a);e[s]=n.shape[t]-i}k(n.shape[t]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}var PP=D(()=>{"use strict";q()});function hte(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function gte(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function xte(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}var LP=D(()=>{"use strict";});function yte(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function vte(n,e){return`size ${n} must be non-negative, not ${e}`}function bte(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Cte(n,e){let t=Ne(n),r=Ne(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function wte(n,e){let t=Ne(n),r=Ne(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}var BP=D(()=>{"use strict";q();});function Ite(){return"segment ids must be >= 0"}function Ete(){return"segment ids are not increasing"}function Tte(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Ste(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}var VP=D(()=>{"use strict";});var nN={};Ue(nN,{collectGatherOpShapeInfo:()=>kte,computeOutShape:()=>Dte,segOpComputeOptimalWindowSize:()=>Nte});function Nte(n,e){let t=!1,r;for(n<=hy?(r=n,t=!0):r=mp(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=mp(n,r+1);return r}function Dte(n,e,t){let r=[],o=n.length;for(let s=0;s<o;s++)s!==e?r.push(n[s]):r.push(t);return r}function kte(n,e,t,r){let o=e.shape.length,s=n.shape.length;if(r!==0&&(r<-o||r>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${r}`);if(r<0&&(r+=o),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let p=0;p<r;++p)if(n.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);let i=n.shape[t],a=[],c=1,l=1,u=1;for(let p=0;p<r;++p)a.push(n.shape[p]),c*=n.shape[p];for(let p=r;p<t;p++)a.push(n.shape[p]),l*=n.shape[p];for(let p=r;p<o;p++)a.push(e.shape[p]);for(let p=t+1;p<s;p++)a.push(n.shape[p]),u*=n.shape[p];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:i,outputShape:a}}var UP=D(()=>{"use strict";q();eN();});var S={};Ue(S,{ERF_A1:()=>Kee,ERF_A2:()=>Xee,ERF_A3:()=>Yee,ERF_A4:()=>Zee,ERF_A5:()=>Qee,ERF_P:()=>qee,PARALLELIZE_THRESHOLD:()=>hy,RowPartitionType:()=>Ss,SELU_SCALE:()=>jee,SELU_SCALEALPHA:()=>Wee,applyActivation:()=>gu,assertAndGetBroadcastShape:()=>We,assertAxesAreInnerMostDims:()=>bY,assertParamsConsistent:()=>Ree,assignToTypedArray:()=>ote,axesAreInnerMostDims:()=>LE,calculateShapes:()=>DM,checkEinsumDimSizes:()=>ute,checkPadOnDimRoundingMode:()=>_t,combineLocations:()=>tF,combineRaggedTensorToTensorShapes:()=>Mee,complexWithEvenIndex:()=>tte,complexWithOddIndex:()=>nte,computeConv2DInfo:()=>ru,computeConv3DInfo:()=>v2,computeDefaultPad:()=>JI,computeDilation2DInfo:()=>yX,computeOptimalWindowSize:()=>Lee,computeOutAndReduceShapes:()=>vY,computeOutShape:()=>Fee,computePool2DInfo:()=>QI,computePool3DInfo:()=>vX,convertConv2DDataFormat:()=>b2,decodeEinsumEquation:()=>cte,eitherStridesOrDilationsAreOne:()=>mn,expandShapeToKeepDim:()=>xs,exponent:()=>ite,exponents:()=>ste,fromStringArrayToUint8:()=>Ate,fromUint8ToStringArray:()=>_te,getAxesPermutation:()=>CY,getBroadcastDims:()=>Y2,getComplexWithIndex:()=>rte,getEinsumComputePath:()=>pte,getEinsumPermutation:()=>lte,getFusedBiasGradient:()=>hu,getFusedDyActivation:()=>mu,getImageCenter:()=>Bee,getInnerMostAxes:()=>IY,getPermuted:()=>Uee,getRaggedRank:()=>$ee,getReductionAxes:()=>Ix,getReshaped:()=>Vee,getReshapedPermuted:()=>zee,getRowPartitionTypesHelper:()=>Oee,getSliceBeginCoords:()=>Hee,getSliceSize:()=>Gee,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>hte,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>gte,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>xte,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>bte,getSparseReshapeInputOutputMismatchErrorMessage:()=>wte,getSparseReshapeInputOutputMultipleErrorMessage:()=>Cte,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>yte,getSparseReshapeNegativeOutputDimErrorMessage:()=>vte,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Ste,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Ite,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Ete,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Tte,getUndoAxesPermutation:()=>wY,isIdentityPermutation:()=>dte,log:()=>q9,mergeRealAndImagArrays:()=>Jee,prepareAndValidate:()=>dP,prepareSplitSize:()=>mte,segment_util:()=>nN,shouldFuse:()=>xu,slice_util:()=>$t,splitRealAndImagArrays:()=>ete,stridesOrDilationsArePositive:()=>Ao,tupleValuesAreOne:()=>nu,upcastType:()=>Dt,validateDefaultValueShape:()=>Pee,validateInput:()=>Jp,validateUpdateShape:()=>IS,warn:()=>Do});function _te(n){try{return n.map(e=>Rp(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Ate(n){return n.map(e=>Wi(e))}var zP=D(()=>{"use strict";q();Wp();zt();SP();On();td();NP();DP();eN();QS();Mp();kP();_P();YS();qm();AP();td();RP();rx();FP();$P();PP();LP();BP();VP();UP();});var Jt={};Ue(Jt,{nonMaxSuppressionV3Impl:()=>ey,nonMaxSuppressionV4Impl:()=>ty,nonMaxSuppressionV5Impl:()=>ny,whereImpl:()=>Kx});var HP=D(()=>{"use strict";Ym();AS();});var GP=D(()=>{"use strict";oP();aP();zt();pP();YS();qm();QS();oy();mt();nM();q();IP();sy();iy();ay();cy();ly();sa();JS();uy();Jm();cr();Mp();Zm();oo();EP();jn();sx();Cs();Yt();TP();zP();CI();HP();Yw();G();});var gy={};Ue(gy,{Abs:()=>tc,Acos:()=>Xs,Acosh:()=>Ys,AdadeltaOptimizer:()=>ia,AdagradOptimizer:()=>aa,AdamOptimizer:()=>ca,AdamaxOptimizer:()=>la,Add:()=>es,AddN:()=>nc,All:()=>xp,Any:()=>yp,ArgMax:()=>rc,ArgMin:()=>oc,Asin:()=>Zs,Asinh:()=>Qs,Atan:()=>Js,Atan2:()=>ti,Atanh:()=>ei,AvgPool:()=>sc,AvgPool3D:()=>ic,AvgPool3DGrad:()=>$f,AvgPoolGrad:()=>Of,BatchMatMul:()=>ac,BatchToSpaceND:()=>cc,Bincount:()=>lc,BitwiseAnd:()=>ni,BroadcastArgs:()=>uc,BroadcastTo:()=>V9,Cast:()=>ts,Ceil:()=>ri,ClipByValue:()=>oi,Complex:()=>pc,ComplexAbs:()=>dc,Concat:()=>fc,Conv2D:()=>mc,Conv2DBackpropFilter:()=>hc,Conv2DBackpropInput:()=>gc,Conv3D:()=>xc,Conv3DBackpropFilterV2:()=>Pf,Conv3DBackpropInputV2:()=>yc,Cos:()=>vc,Cosh:()=>si,CropAndResize:()=>wc,Cumprod:()=>bc,Cumsum:()=>Cc,DataStorage:()=>js,DenseBincount:()=>Ic,DepthToSpace:()=>Ec,DepthwiseConv2dNative:()=>Tc,DepthwiseConv2dNativeBackpropFilter:()=>Sc,DepthwiseConv2dNativeBackpropInput:()=>Nc,Diag:()=>Dc,Dilation2D:()=>kc,Dilation2DBackpropFilter:()=>nx,Dilation2DBackpropInput:()=>tx,Draw:()=>vp,ENV:()=>Jg,Einsum:()=>_c,Elu:()=>Ac,EluGrad:()=>Lf,Environment:()=>gp,Equal:()=>ai,Erf:()=>Rc,Exp:()=>Fc,ExpandDims:()=>Mc,Expm1:()=>ci,FFT:()=>bp,Fill:()=>Oc,FlipLeftRight:()=>$c,Floor:()=>li,FloorDiv:()=>ui,FromPixels:()=>Sp,FusedBatchNorm:()=>Pc,FusedConv2D:()=>zi,FusedDepthwiseConv2D:()=>Hi,GatherNd:()=>Bc,GatherV2:()=>Lc,Greater:()=>pi,GreaterEqual:()=>di,IFFT:()=>Vc,Identity:()=>ns,Imag:()=>Uc,IsFinite:()=>fi,IsInf:()=>mi,IsNan:()=>hi,KernelBackend:()=>To,LRN:()=>Cp,LRNGrad:()=>Bf,LeakyRelu:()=>zc,Less:()=>gi,LessEqual:()=>xi,LinSpace:()=>Hc,Log:()=>Gc,Log1p:()=>yi,LogSoftmax:()=>z9,LogicalAnd:()=>vi,LogicalNot:()=>bi,LogicalOr:()=>Ci,LogicalXor:()=>U9,LowerBound:()=>H9,MatrixBandPart:()=>G9,Max:()=>wp,MaxPool:()=>Wc,MaxPool3D:()=>jc,MaxPool3DGrad:()=>Uf,MaxPoolGrad:()=>Vf,MaxPoolWithArgmax:()=>qc,Maximum:()=>wi,Mean:()=>Kc,Min:()=>Ip,Minimum:()=>Ii,MirrorPad:()=>Xc,Mod:()=>Yc,MomentumOptimizer:()=>ua,Multinomial:()=>Zc,Multiply:()=>Ei,Neg:()=>Ep,NonMaxSuppressionV3:()=>Qc,NonMaxSuppressionV4:()=>Jc,NonMaxSuppressionV5:()=>el,NotEqual:()=>Ti,OP_SCOPE_SUFFIX:()=>mx,OneHot:()=>nl,OnesLike:()=>tl,Optimizer:()=>yn,OptimizerConstructors:()=>nd,Pack:()=>rl,PadV2:()=>ol,Pool:()=>W9,Pow:()=>sl,Prelu:()=>il,Prod:()=>al,RMSPropOptimizer:()=>pa,RaggedGather:()=>cl,RaggedRange:()=>ll,RaggedTensorToTensor:()=>ul,Range:()=>pl,Rank:()=>mI,Real:()=>dl,RealDiv:()=>ii,Reciprocal:()=>Si,Reduction:()=>wt,Relu:()=>Ni,Relu6:()=>Di,Reshape:()=>fl,ResizeBilinear:()=>hl,ResizeBilinearGrad:()=>Hf,ResizeNearestNeighbor:()=>ml,ResizeNearestNeighborGrad:()=>zf,Reverse:()=>gl,RotateWithOffset:()=>Hl,Round:()=>ki,Rsqrt:()=>_i,SGDOptimizer:()=>Lo,ScatterNd:()=>xl,SearchSorted:()=>vl,Select:()=>bl,Selu:()=>Ai,Sigmoid:()=>Mi,Sign:()=>Fi,Sin:()=>wl,Sinh:()=>Ri,Slice:()=>Cl,Softmax:()=>Tl,Softplus:()=>Oi,SpaceToBatchND:()=>Il,SparseFillEmptyRows:()=>Sl,SparseReshape:()=>Nl,SparseSegmentMean:()=>Dl,SparseSegmentSum:()=>kl,SparseToDense:()=>_l,SplitV:()=>El,Sqrt:()=>$i,Square:()=>Gf,SquaredDifference:()=>Pi,StaticRegexReplace:()=>Li,Step:()=>Vi,StridedSlice:()=>Al,StringNGrams:()=>Rl,StringSplit:()=>Fl,StringToHashBucketFast:()=>Ml,Sub:()=>Ol,Sum:()=>Tp,Tan:()=>$l,Tanh:()=>Bi,Tensor:()=>Ze,TensorBuffer:()=>He,TensorScatterUpdate:()=>yl,Tile:()=>rs,TopK:()=>Pl,Transform:()=>Ll,Transpose:()=>os,Unique:()=>Bl,Unpack:()=>Vl,UnsortedSegmentSum:()=>Ul,UpperBound:()=>j9,Variable:()=>ko,ZerosLike:()=>zl,_FusedMatMul:()=>Ui,abs:()=>Ut,acos:()=>BI,acosh:()=>VI,add:()=>de,addN:()=>UI,all:()=>zI,any:()=>HI,argMax:()=>GI,argMin:()=>WI,asin:()=>jI,asinh:()=>qI,atan:()=>KI,atan2:()=>XI,atanh:()=>YI,avgPool:()=>sm,avgPool3d:()=>tE,backend:()=>EI,backend_util:()=>S,basicLSTMCell:()=>rE,batchNorm:()=>ds,batchNorm2d:()=>sE,batchNorm3d:()=>iE,batchNorm4d:()=>aE,batchToSpaceND:()=>am,bincount:()=>lm,bitwiseAnd:()=>lE,booleanMaskAsync:()=>$M,broadcastArgs:()=>uE,broadcastTo:()=>fs,broadcast_util:()=>Jr,browser:()=>KS,buffer:()=>le,cast:()=>De,ceil:()=>dE,clipByValue:()=>fE,clone:()=>Fn,complex:()=>En,concat:()=>ot,concat1d:()=>mE,concat2d:()=>hE,concat3d:()=>gE,concat4d:()=>xE,conv1d:()=>yE,conv2d:()=>ms,conv2dTranspose:()=>bE,conv3d:()=>CE,conv3dTranspose:()=>wE,copyRegisteredKernels:()=>Z9,cos:()=>IE,cosh:()=>EE,cosineWindow:()=>ed,cumprod:()=>TE,cumsum:()=>SE,customGrad:()=>gn,denseBincount:()=>NE,deprecationWarn:()=>RR,depthToSpace:()=>DE,depthwiseConv2d:()=>ou,device_util:()=>ss,diag:()=>kE,dilation2d:()=>_E,disableDeprecationWarnings:()=>I7,dispose:()=>Ct,disposeVariables:()=>E7,div:()=>Pe,divNoNan:()=>RE,dot:()=>FE,dropout:()=>YM,einsum:()=>gs,elu:()=>dm,enableDebugMode:()=>w7,enableProdMode:()=>C7,enclosingPowerOfTwo:()=>Yx,engine:()=>lr,ensureShape:()=>$E,env:()=>O,equal:()=>pm,erf:()=>PE,euclideanNorm:()=>VE,exp:()=>ur,expandDims:()=>Er,expm1:()=>UE,eye:()=>gm,fft:()=>uu,fill:()=>Qr,findBackend:()=>A7,findBackendFactory:()=>R7,floor:()=>xm,floorDiv:()=>nm,fused:()=>Zx,gather:()=>ym,gatherND:()=>jM,gather_util:()=>XS,getBackend:()=>II,getGradient:()=>ox,getKernel:()=>Gl,getKernelsForBackend:()=>jf,grad:()=>uF,grads:()=>pF,greater:()=>Ji,greaterEqual:()=>vm,ifft:()=>ra,imag:()=>bs,image:()=>P$,inTopKAsync:()=>QM,io:()=>Bo,irfft:()=>Vm,isFinite:()=>jE,isInf:()=>qE,isNaN:()=>KE,keep:()=>Sn,kernel_impls:()=>Jt,leakyRelu:()=>Cm,less:()=>Xp,lessEqual:()=>su,linalg:()=>L$,linspace:()=>ZE,localResponseNormalization:()=>QE,log:()=>Mo,log1p:()=>Im,logSigmoid:()=>tT,logSoftmax:()=>nT,logSumExp:()=>Tm,logicalAnd:()=>ea,logicalNot:()=>Sm,logicalOr:()=>Nm,logicalXor:()=>iT,losses:()=>B$,lowerBound:()=>aT,matMul:()=>ze,math:()=>qS,max:()=>eo,maxPool:()=>Dm,maxPool3d:()=>lT,maxPoolWithArgmax:()=>uT,maximum:()=>km,mean:()=>ta,memory:()=>T7,meshgrid:()=>dT,min:()=>jp,minimum:()=>na,mirrorPad:()=>fT,mod:()=>mT,moments:()=>hT,movingAverage:()=>LM,mul:()=>ee,multiRNNCell:()=>gT,multinomial:()=>xT,neg:()=>Qt,nextFrame:()=>my,norm:()=>Qi,notEqual:()=>Am,oneHot:()=>Zp,ones:()=>no,onesLike:()=>bT,op:()=>E,outerProduct:()=>CT,pad:()=>ro,pad1d:()=>wT,pad2d:()=>IT,pad3d:()=>ET,pad4d:()=>TT,pool:()=>NT,pow:()=>Fo,prelu:()=>Fm,print:()=>tm,prod:()=>kT,profile:()=>S7,raggedGather:()=>_T,raggedRange:()=>AT,raggedTensorToTensor:()=>RT,rand:()=>FT,randomGamma:()=>WT,randomNormal:()=>Om,randomStandardNormal:()=>qT,randomUniform:()=>cu,randomUniformInt:()=>KT,range:()=>Is,ready:()=>k7,real:()=>Oo,reciprocal:()=>XT,registerBackend:()=>Jf,registerGradient:()=>K9,registerKernel:()=>Dp,relu:()=>Es,relu6:()=>Lm,removeBackend:()=>_7,reshape:()=>U,reverse:()=>Kn,reverse1d:()=>ZT,reverse2d:()=>QT,reverse3d:()=>JT,reverse4d:()=>eS,rfft:()=>pu,round:()=>Bm,rsqrt:()=>nS,scalar:()=>me,scatterND:()=>VM,scatter_util:()=>jm,searchSorted:()=>Yp,selu:()=>rS,separableConv2d:()=>oS,serialization:()=>LS,setBackend:()=>D7,setPlatform:()=>F7,setdiff1dAsync:()=>sS,sigmoid:()=>Zr,sign:()=>iS,signal:()=>$$,sin:()=>aS,sinh:()=>cS,slice:()=>Le,slice1d:()=>lS,slice2d:()=>uS,slice3d:()=>pS,slice4d:()=>dS,slice_util:()=>$t,softmax:()=>fS,softplus:()=>Em,spaceToBatchND:()=>Rm,sparse:()=>V$,sparseToDense:()=>GM,spectral:()=>O$,split:()=>$o,sqrt:()=>Nn,square:()=>Ht,squaredDifference:()=>zm,squeeze:()=>du,stack:()=>xn,step:()=>Gm,stridedSlice:()=>xS,string:()=>U$,sub:()=>ge,sum:()=>je,sumOutType:()=>ji,tan:()=>yS,tanh:()=>zp,tensor:()=>fn,tensor1d:()=>Wt,tensor2d:()=>Ts,tensor3d:()=>Wm,tensor4d:()=>bS,tensor5d:()=>CS,tensor6d:()=>wS,tensorScatterUpdate:()=>ES,tensor_util:()=>gI,test_util:()=>GT,tidy:()=>Ce,tile:()=>vs,time:()=>N7,topk:()=>TS,train:()=>_ee,transpose:()=>fu,truncatedNormal:()=>SS,unique:()=>NS,unregisterGradient:()=>Y9,unregisterKernel:()=>X9,unsortedSegmentSum:()=>DS,unstack:()=>Xn,upcastType:()=>Dt,upperBound:()=>kS,util:()=>y,valueAndGrad:()=>dF,valueAndGrads:()=>fF,variable:()=>_S,variableGrads:()=>Dx,version_core:()=>wP,where:()=>qn,whereAsync:()=>Km,zeros:()=>pr,zerosLike:()=>Ft});var T=D(()=>{"use strict";i2();H$();GP();z$()});var hue,jG=D(()=>{"use strict";T();hue=O();hue.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})});var er,qG,KG=D(()=>{"use strict";er=(function(n){return n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",n})(er||{});(function(n){let e;(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(qG||(qG={}))});function XG(n,e){let t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};DD[n]=t}function Nb(n){return DD[n]}function YG(n){delete DD[n]}var DD,Db=D(()=>{"use strict";DD={}});function b(n,e,t,r,o){let s=e.inputParams[n];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,c=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd,l=a<0?e.inputNames.length+a:a;if(s.type==="tensor")return At(e.inputNames[l],t,r,o);if(s.type==="tensors"){let d=e.inputs.slice(a,c);return e.inputNames.slice(a,c).filter((m,h)=>{var g;return((g=d[h])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(m=>At(m,t,r,o))}let u=At(e.inputNames[l],t,r,o),p=u.dataSync();return s.type==="number"?p[0]:y.toNestedArray(u.shape,p)}let i=e.attrParams[n];return i&&i.value}function At(n,e,t,r){let[o,s]=Dn(n,t);if(r!=null){let a=r.getHashTableHandleByName(o);if(a!=null)return a}let i=t.currentContextIds.find(a=>!!e[kb(o,a)]);return i!==void 0?e[kb(o,i)][s]:void 0}function kD(n,e,t){return e[kb(n,t.currentContextId)]}function lo(n,e){let[t,r,o]=Dn(n,e);return[kb(t,e&&e.currentContextId),r,o]}function kb(n,e){return e?`${n}-${e}`:n}function Dn(n,e){if(n==="")return["",0,void 0];let t=e!=null&&e.parseNodeNameCache!=null;if(t){let s=e.parseNodeNameCache.get(n);if(s!=null)return s}let r=n.split(":"),o;if(r.length===1)o=[n,0,void 0];else{let s=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);o=[s,a,i]}return t&&e.parseNodeNameCache.set(n,o),o}function wh(n,e,t){let r=b("pad",n,e,t);if(r==="explicit"){r=b("explicitPaddings",n,e,t);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=r[s*2],o[s][1]=r[s*2+1];return o}return r}function uo(n){return n.kept?n:Fn(n)}var Tt=D(()=>{"use strict";T();});var _D={};Ue(_D,{json:()=>xue});var xue,ZG=D(()=>{"use strict";xue=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var AD={};Ue(AD,{json:()=>yue});var yue,QG=D(()=>{"use strict";yue=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var RD={};Ue(RD,{json:()=>vue});var vue,JG=D(()=>{"use strict";vue=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]});var FD={};Ue(FD,{json:()=>bue});var bue,eW=D(()=>{"use strict";bue=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]});var MD={};Ue(MD,{json:()=>Cue});var Cue,tW=D(()=>{"use strict";Cue=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});var OD={};Ue(OD,{json:()=>wue});var wue,nW=D(()=>{"use strict";wue=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var $D={};Ue($D,{json:()=>Iue});var Iue,rW=D(()=>{"use strict";Iue=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]});var PD={};Ue(PD,{json:()=>Eue});var Eue,oW=D(()=>{"use strict";Eue=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]});var LD={};Ue(LD,{json:()=>Tue});var Tue,sW=D(()=>{"use strict";Tue=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]});var BD={};Ue(BD,{json:()=>Sue});var Sue,iW=D(()=>{"use strict";Sue=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]});var VD={};Ue(VD,{json:()=>Nue});var Nue,aW=D(()=>{"use strict";Nue=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}]});var UD={};Ue(UD,{json:()=>Due});var Due,cW=D(()=>{"use strict";Due=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}]});var zD={};Ue(zD,{json:()=>kue});var kue,lW=D(()=>{"use strict";kue=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}]});var HD={};Ue(HD,{json:()=>_ue});var _ue,uW=D(()=>{"use strict";_ue=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});var GD={};Ue(GD,{json:()=>Aue});var Aue,pW=D(()=>{"use strict";Aue=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]});var WD={};Ue(WD,{json:()=>Rue});var Rue,dW=D(()=>{"use strict";Rue=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]});var jD={};Ue(jD,{json:()=>Fue});var Fue,fW=D(()=>{"use strict";Fue=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});var qD={};Ue(qD,{json:()=>Mue});var Mue,mW=D(()=>{"use strict";Mue=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]});var KD={};Ue(KD,{json:()=>Oue});var Oue,hW=D(()=>{"use strict";Oue=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]});function $ue(n){let e=O().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function xW(n,e){let t=Array.isArray(n)?String.fromCharCode.apply(null,n):$ue(n);return e?t:t.toLowerCase()}function _b(n,e,t,r=!1){let o=n[e];return o!=null?xW(o.s,r):t}function Ab(n,e,t){let r=n[e];return r?r.b:t}function Rb(n,e,t){let r=n[e]||{},o=r.i!=null?r.i:r.f!=null?r.f:t;return typeof o=="number"?o:parseInt(o,10)}function XD(n){switch(typeof n=="string"&&(n=er[n]),n){case er.DT_FLOAT:case er.DT_HALF:return"float32";case er.DT_INT32:case er.DT_INT64:case er.DT_INT8:case er.DT_UINT8:return"int32";case er.DT_BOOL:return"bool";case er.DT_DOUBLE:return"float32";case er.DT_STRING:return"string";case er.DT_COMPLEX64:case er.DT_COMPLEX128:return"complex64";default:return null}}function gW(n,e,t){let r=n[e];return r&&r.func?r.func.name:t}function Fb(n,e,t){let r=n[e];return r&&r.type?XD(r.type):t}function Mb(n,e,t){let r=n[e];return r&&r.list&&r.list.type?r.list.type.map(o=>XD(o)):t}function yW(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Ob(n,e,t){let r=n[e];return r&&r.shape?yW(r.shape):t}function $b(n,e,t){let r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):t}function Pb(n,e,t,r=!1){let o=n[e];return o&&o.list&&o.list.s?o.list.s.map(s=>xW(s,r)):t}function Lb(n,e,t){let r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(o=>yW(o)):t}function Bb(n,e,t){let r=n[e];return r&&r.list&&r.list.b?r.list.b:t}var Ih,YD=D(()=>{"use strict";T();KG();Db();Tt();ZG();QG();JG();eW();tW();nW();rW();oW();sW();iW();aW();cW();lW();uW();pW();dW();fW();mW();hW();Ih=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[_D,AD,RD,FD,MD,OD,$D,PD,LD,BD,VD,UD,zD,HD,GD,WD,jD,qD,KD],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,o)=>(r[o.tfOpName]=o,r),{})}transformGraph(e,t={}){let r=e.node,o=[],s=[],i=[],a=r.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&i.push(h[g.name]),h),{}),c=[],l=[],u={},p={};t!=null&&(u=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let d=Object.keys(a);d.forEach(h=>{let g=a[h];g.inputNames.forEach((x,v)=>{let[w,,I]=lo(x),_=a[w];if(_.outputs!=null){let A=_.outputs.indexOf(I);if(A!==-1){let R=`${w}:${A}`;g.inputNames[v]=R}}g.inputs.push(_),_.children.push(g)})}),Object.keys(p).length===0?d.forEach(h=>{let g=a[h];g.children.length===0&&l.push(g)}):Object.keys(p).forEach(h=>{let[g]=lo(h),x=a[g];x!=null&&(x.signatureKey=p[h],l.push(x))}),Object.keys(u).length>0?Object.keys(u).forEach(h=>{let[g]=lo(h),x=a[g];x&&(x.signatureKey=u[h],c.push(x))}):c=o;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let m={nodes:a,inputs:c,outputs:l,weights:s,placeholders:o,signature:t,functions:f};return i.length>0&&(m.initNodes=i),m}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){let t=Nb(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=_b(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=_b(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=Pb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Pb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=Rb(e.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=Rb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=$b(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=$b(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=Ab(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Ab(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=Bb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Bb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=Ob(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Ob(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=Lb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Lb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=Fb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Fb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=Mb(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Mb(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=gW(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=gW(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return o[s.name]={value:a,type:i},o},{})),r}mapFunction(e){let t=e.nodeDef,r=[],o=[],s={};t!=null&&(s=t.reduce((p,d)=>(p[d.name]=this.mapNode(d),d.op==="Const"&&o.push(p[d.name]),p),{}));let i=[],a=[];e.signature.inputArg.forEach(p=>{let[d]=lo(p.name),f={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:XD(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,i.push(f),s[d]=f}),Object.keys(s).forEach(p=>{let d=s[p];d.inputNames.forEach((f,m)=>{let[h,,g]=lo(f),x=s[h];if(x.outputs!=null){let v=x.outputs.indexOf(g);if(v!==-1){let w=`${h}:${v}`;d.inputNames[m]=w}}d.inputs.push(x),x.children.push(d)})});let l=e.ret;e.signature.outputArg.forEach(p=>{let[d,f]=lo(l[p.name]),m=s[d];m!=null&&(m.defaultOutput=f,a.push(m))});let u=this.mapArgsToSignature(e);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:r,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}});var Vb,vW=D(()=>{"use strict";Tt();YD();Vb=class{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(o=>this.getInput(o)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(e){return At(e,this.tensorMap,this.context)}getAttr(e,t){let r=this.node.rawAttrs[e];if(r.tensor!=null)return At(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return Rb(this.node.rawAttrs,e,t);if(r.s!=null)return _b(this.node.rawAttrs,e,t);if(r.b!=null)return Ab(this.node.rawAttrs,e,t);if(r.shape!=null)return Ob(this.node.rawAttrs,e,t);if(r.type!=null)return Fb(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return $b(this.node.rawAttrs,e,t);if(r.list.s!=null)return Pb(this.node.rawAttrs,e,t);if(r.list.shape!=null)return Lb(this.node.rawAttrs,e,t);if(r.list.b!=null)return Bb(this.node.rawAttrs,e,t);if(r.list.type!=null)return Mb(this.node.rawAttrs,e,t)}return t}}});var Ge={};Ue(Ge,{OP_SCOPE_SUFFIX:()=>mx,abs:()=>Ut,acos:()=>BI,acosh:()=>VI,add:()=>de,addN:()=>UI,all:()=>zI,any:()=>HI,argMax:()=>GI,argMin:()=>WI,asin:()=>jI,asinh:()=>qI,atan:()=>KI,atan2:()=>XI,atanh:()=>YI,avgPool:()=>sm,avgPool3d:()=>tE,basicLSTMCell:()=>rE,batchNorm:()=>ds,batchNorm2d:()=>sE,batchNorm3d:()=>iE,batchNorm4d:()=>aE,batchToSpaceND:()=>am,bincount:()=>lm,bitwiseAnd:()=>lE,booleanMaskAsync:()=>$M,broadcastArgs:()=>uE,broadcastTo:()=>fs,buffer:()=>le,cast:()=>De,ceil:()=>dE,clipByValue:()=>fE,clone:()=>Fn,complex:()=>En,concat:()=>ot,concat1d:()=>mE,concat2d:()=>hE,concat3d:()=>gE,concat4d:()=>xE,conv1d:()=>yE,conv2d:()=>ms,conv2dTranspose:()=>bE,conv3d:()=>CE,conv3dTranspose:()=>wE,cos:()=>IE,cosh:()=>EE,cosineWindow:()=>ed,cumprod:()=>TE,cumsum:()=>SE,denseBincount:()=>NE,depthToSpace:()=>DE,depthwiseConv2d:()=>ou,diag:()=>kE,dilation2d:()=>_E,div:()=>Pe,divNoNan:()=>RE,dot:()=>FE,dropout:()=>YM,einsum:()=>gs,elu:()=>dm,enclosingPowerOfTwo:()=>Yx,ensureShape:()=>$E,equal:()=>pm,erf:()=>PE,euclideanNorm:()=>VE,exp:()=>ur,expandDims:()=>Er,expm1:()=>UE,eye:()=>gm,fft:()=>uu,fill:()=>Qr,floor:()=>xm,floorDiv:()=>nm,fused:()=>Zx,gather:()=>ym,gatherND:()=>jM,greater:()=>Ji,greaterEqual:()=>vm,ifft:()=>ra,imag:()=>bs,image:()=>P$,inTopKAsync:()=>QM,irfft:()=>Vm,isFinite:()=>jE,isInf:()=>qE,isNaN:()=>KE,leakyRelu:()=>Cm,less:()=>Xp,lessEqual:()=>su,linalg:()=>L$,linspace:()=>ZE,localResponseNormalization:()=>QE,log:()=>Mo,log1p:()=>Im,logSigmoid:()=>tT,logSoftmax:()=>nT,logSumExp:()=>Tm,logicalAnd:()=>ea,logicalNot:()=>Sm,logicalOr:()=>Nm,logicalXor:()=>iT,losses:()=>B$,lowerBound:()=>aT,matMul:()=>ze,max:()=>eo,maxPool:()=>Dm,maxPool3d:()=>lT,maxPoolWithArgmax:()=>uT,maximum:()=>km,mean:()=>ta,meshgrid:()=>dT,min:()=>jp,minimum:()=>na,mirrorPad:()=>fT,mod:()=>mT,moments:()=>hT,movingAverage:()=>LM,mul:()=>ee,multiRNNCell:()=>gT,multinomial:()=>xT,neg:()=>Qt,norm:()=>Qi,notEqual:()=>Am,oneHot:()=>Zp,ones:()=>no,onesLike:()=>bT,op:()=>E,outerProduct:()=>CT,pad:()=>ro,pad1d:()=>wT,pad2d:()=>IT,pad3d:()=>ET,pad4d:()=>TT,pool:()=>NT,pow:()=>Fo,prelu:()=>Fm,print:()=>tm,prod:()=>kT,raggedGather:()=>_T,raggedRange:()=>AT,raggedTensorToTensor:()=>RT,rand:()=>FT,randomGamma:()=>WT,randomNormal:()=>Om,randomStandardNormal:()=>qT,randomUniform:()=>cu,randomUniformInt:()=>KT,range:()=>Is,real:()=>Oo,reciprocal:()=>XT,relu:()=>Es,relu6:()=>Lm,reshape:()=>U,reverse:()=>Kn,reverse1d:()=>ZT,reverse2d:()=>QT,reverse3d:()=>JT,reverse4d:()=>eS,rfft:()=>pu,round:()=>Bm,rsqrt:()=>nS,scalar:()=>me,scatterND:()=>VM,searchSorted:()=>Yp,selu:()=>rS,separableConv2d:()=>oS,setdiff1dAsync:()=>sS,sigmoid:()=>Zr,sign:()=>iS,signal:()=>$$,sin:()=>aS,sinh:()=>cS,slice:()=>Le,slice1d:()=>lS,slice2d:()=>uS,slice3d:()=>pS,slice4d:()=>dS,softmax:()=>fS,softplus:()=>Em,spaceToBatchND:()=>Rm,sparse:()=>V$,sparseToDense:()=>GM,spectral:()=>O$,split:()=>$o,sqrt:()=>Nn,square:()=>Ht,squaredDifference:()=>zm,squeeze:()=>du,stack:()=>xn,step:()=>Gm,stridedSlice:()=>xS,string:()=>U$,sub:()=>ge,sum:()=>je,tan:()=>yS,tanh:()=>zp,tensor:()=>fn,tensor1d:()=>Wt,tensor2d:()=>Ts,tensor3d:()=>Wm,tensor4d:()=>bS,tensor5d:()=>CS,tensor6d:()=>wS,tensorScatterUpdate:()=>ES,tile:()=>vs,topk:()=>TS,transpose:()=>fu,truncatedNormal:()=>SS,unique:()=>NS,unsortedSegmentSum:()=>DS,unstack:()=>Xn,upperBound:()=>kS,variable:()=>_S,where:()=>qn,whereAsync:()=>Km,zeros:()=>pr,zerosLike:()=>Ft});var qt=D(()=>{"use strict";Zm();});var bW,CW=D(()=>{"use strict";qt();Tt();bW=(n,e,t,r=Ge)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(b("a",n,e,t),b("b",n,e,t))];case"AddN":return[r.addN(b("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(b("a",n,e,t),b("b",n,e,t))];case"Mul":return[r.mul(b("a",n,e,t),b("b",n,e,t))];case"RealDiv":case"Div":return[r.div(b("a",n,e,t),b("b",n,e,t))];case"DivNoNan":return[r.divNoNan(b("a",n,e,t),b("b",n,e,t))];case"FloorDiv":return[r.floorDiv(b("a",n,e,t),b("b",n,e,t))];case"Sub":return[r.sub(b("a",n,e,t),b("b",n,e,t))];case"Minimum":return[r.minimum(b("a",n,e,t),b("b",n,e,t))];case"Maximum":return[r.maximum(b("a",n,e,t),b("b",n,e,t))];case"Pow":return[r.pow(b("a",n,e,t),b("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(b("a",n,e,t),b("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var wW,IW=D(()=>{"use strict";qt();Tt();wW=(n,e,t,r=Ge)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(b("x",n,e,t))];case"Acos":return[r.acos(b("x",n,e,t))];case"Acosh":return[r.acosh(b("x",n,e,t))];case"Asin":return[r.asin(b("x",n,e,t))];case"Asinh":return[r.asinh(b("x",n,e,t))];case"Atan":return[r.atan(b("x",n,e,t))];case"Atan2":return[r.atan2(b("x",n,e,t),b("y",n,e,t))];case"Atanh":return[r.atanh(b("x",n,e,t))];case"Ceil":return[r.ceil(b("x",n,e,t))];case"Complex":return[r.complex(b("real",n,e,t),b("imag",n,e,t))];case"Cos":return[r.cos(b("x",n,e,t))];case"Cosh":return[r.cosh(b("x",n,e,t))];case"Elu":return[r.elu(b("x",n,e,t))];case"Erf":return[r.erf(b("x",n,e,t))];case"Exp":return[r.exp(b("x",n,e,t))];case"Expm1":return[r.expm1(b("x",n,e,t))];case"Floor":return[r.floor(b("x",n,e,t))];case"Log":return[r.log(b("x",n,e,t))];case"Log1p":return[r.log1p(b("x",n,e,t))];case"Imag":return[r.imag(b("x",n,e,t))];case"Neg":return[r.neg(b("x",n,e,t))];case"Reciprocal":return[r.reciprocal(b("x",n,e,t))];case"Real":return[r.real(b("x",n,e,t))];case"Relu":return[r.relu(b("x",n,e,t))];case"Round":return[r.round(b("x",n,e,t))];case"Selu":return[r.selu(b("x",n,e,t))];case"Sigmoid":return[r.sigmoid(b("x",n,e,t))];case"Sin":return[r.sin(b("x",n,e,t))];case"Sign":return[r.sign(b("x",n,e,t))];case"Sinh":return[r.sinh(b("x",n,e,t))];case"Softplus":return[r.softplus(b("x",n,e,t))];case"Sqrt":return[r.sqrt(b("x",n,e,t))];case"Square":return[r.square(b("x",n,e,t))];case"Tanh":return[r.tanh(b("x",n,e,t))];case"Tan":return[r.tan(b("x",n,e,t))];case"ClipByValue":return[r.clipByValue(b("x",n,e,t),b("clipValueMin",n,e,t),b("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(b("x",n,e,t))];case"Rsqrt":return[r.rsqrt(At(n.inputNames[0],e,t))];case"LeakyRelu":return[r.leakyRelu(b("x",n,e,t),b("alpha",n,e,t))];case"Prelu":return[r.prelu(b("x",n,e,t),b("alpha",n,e,t))];case"IsNan":return[r.isNaN(At(n.inputNames[0],e,t))];case"IsInf":return[r.isInf(At(n.inputNames[0],e,t))];case"IsFinite":return[r.isFinite(At(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});function tr(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){y.assert(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){let o=n[r],s=e[r];y.assert(o<0||s<0||o===s,()=>t+` Shapes ${n} and ${e} must match`)}}}function EW(n){return!(typeof n=="number"||n.some(e=>e<0))}function Dd(n,e,t){let r=Ub(n,t),o=!EW(r);if(o&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(o&&e.forEach(s=>{r=Ub(s.shape,r)}),!EW(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Ub(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);let t=[];for(let r=0;r<n.length;++r){let o=n[r],s=e[r];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=o>=0?o:s}return t}var ZD=D(()=>{"use strict";T();});var zb,TW=D(()=>{"use strict";T();ZD();zb=class{constructor(e,t,r,o,s,i,a){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=me(0),Sn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),tr(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,Sn(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,o)=>this.write(r,t[o]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let o=0;o<this.size();o++)e.push(o)}if(e.length===0)return fn([],[0].concat(this.elementShape));let r=this.readMany(e);return tr(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),xn(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return fn([],[0].concat(this.elementShape));let t=[];for(let o=0;o<this.size();o++)t.push(o);let r=this.readMany(t);return tr(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),ot(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Xn(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0,o=e.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=r===0?0:t.size/r,i=[];Ce(()=>{t=U(t,[1,r,s]);for(let c=0;c<e.length;++c){let u=[0,c===0?0:o[c-1],0],p=[1,e[c],s];i[c]=U(Le(t,u,p),this.elementShape)}return i});let a=[];for(let c=0;c<e.length;c++)a[c]=c;this.writeMany(a,i)}}});function SW(n,e,t){let r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);let o=n.shape.slice(1);tr(o,e,"TensorList shape mismatch: ");let s=Xn(n);return new kd(s,e,r)}function NW(n,e,t,r){return new kd([],n,e,r)}function DW(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);let o=Math.max(...e);if(r!=null&&r!==-1&&o>=r)throw new Error(`Max index must be < array size (${o}  vs. ${r})`);let s=new kd([],t,n.dtype,r),i=Xn(n,0);return e.forEach((a,c)=>{s.setItem(a,i[c])}),s}function kW(n,e,t){let r=0,o=e.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);let s=n.shape.slice(1),i=Ub(s,t),a=r===0?0:n.size/r,c=Ce(()=>{let u=[];n=U(n,[1,r,a]);for(let p=0;p<e.length;++p){let f=[0,p===0?0:o[p-1],0],m=[1,e[p],a];u[p]=U(Le(n,f,m),i)}return n.dispose(),u}),l=new kd([],t,n.dtype,e.length);for(let u=0;u<c.length;u++)l.setItem(u,c[u]);return l}var kd,_W=D(()=>{"use strict";T();ZD();kd=class n{get id(){return this.idTensor.id}constructor(e,t,r,o=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e?.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);tr(t,s.shape,"TensorList shape mismatch: "),Sn(s)}),this.idTensor=me(0),this.maxNumElements=o,Sn(this.idTensor)}copy(){return new n([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);tr(e,this.elementShape,"TensorList shape mismatch: ");let o=Dd(this.elementShape,this.tensors,e);return Ce(()=>{let s=this.tensors.map(i=>U(i,o));return xn(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=Dd(this.elementShape,this.tensors,e),o=this.tensors.pop();return o.kept=!1,tr(o.shape,e,"TensorList shape mismatch: "),U(o,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(tr(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Sn(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new n([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);tr(this.tensors[e].shape,t,"TensorList shape mismatch: ");let o=Dd(this.elementShape,this.tensors,t);return U(this.tensors[e],o)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);tr(this.elementShape,t.shape,"TensorList shape mismatch: "),Sn(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);tr(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());let o=Dd(this.elementShape,this.tensors,r);return e.length===0?fn([],[0].concat(o)):Ce(()=>{let s=e.map(i=>U(this.tensors[i],o));return xn(s,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);tr(this.elementShape,t,"TensorList shape mismatch: ");let r=Dd(this.elementShape,this.tensors,t);return this.size()===0?fn([],[0].concat(r)):Ce(()=>{let o=this.tensors.map(s=>U(s,r));return ot(o,0)})}}});var AW,RW=D(()=>{"use strict";T();TW();_W();Tt();AW=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{let r=b("thenBranch",n,e,t),o=b("elseBranch",n,e,t),s=b("cond",n,e,t),i=b("args",n,e,t);return(await s.data())[0]?t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[o].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{let r=b("body",n,e,t),o=b("cond",n,e,t),s=b("args",n,e,t),i=await t.functionMap[o].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),a=s.map(u=>u.id),c=await i[0].data();i.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let l=s;for(;c[0];){let u=l;l=await t.functionMap[r].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);let p=l.map(f=>f.id);u.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let d=await t.functionMap[o].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);c=await d[0].data(),d.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{let r=b("pred",n,e,t);return[uo(r)]}case"Switch":{let r=b("pred",n,e,t),o=b("data",n,e,t);return o.kept||(o=uo(o)),(await r.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let r=n.inputNames.find(o=>At(o,e,t)!==void 0);if(r){let o=At(r,e,t);return[uo(o)]}return}case"Enter":{let r=b("frameName",n,e,t),o=b("tensor",n,e,t);return t.enterFrame(r),[uo(o)]}case"Exit":{let r=b("tensor",n,e,t);return t.exitFrame(),[uo(r)]}case"NextIteration":{let r=b("tensor",n,e,t);return t.nextIteration(),[uo(r)]}case"TensorArrayV3":{let r=b("size",n,e,t),o=b("dtype",n,e,t),s=b("elementShape",n,e,t),i=b("dynamicSize",n,e,t),a=b("clearAfterRead",n,e,t),c=b("identicalElementShapes",n,e,t),l=b("name",n,e,t),u=new zb(l,o,r,s,c,i,a);return t.addTensorArray(u),[u.idTensor,me(1)]}case"TensorArrayWriteV3":{let r=b("tensorArrayId",n,e,t),o=b("index",n,e,t),s=b("tensor",n,e,t),i=t.getTensorArray(r.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let r=b("tensorArrayId",n,e,t),o=b("index",n,e,t);return[t.getTensorArray(r.id).read(o)]}case"TensorArrayGatherV3":{let r=b("tensorArrayId",n,e,t),o=b("indices",n,e,t),s=b("dtype",n,e,t);return[t.getTensorArray(r.id).gather(o,s)]}case"TensorArrayScatterV3":{let r=b("tensorArrayId",n,e,t),o=b("indices",n,e,t),s=b("tensor",n,e,t),i=t.getTensorArray(r.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=b("tensorArrayId",n,e,t),o=t.getTensorArray(r.id),s=b("dtype",n,e,t);return[o.concat(s)]}case"TensorArraySplitV3":{let r=b("tensorArrayId",n,e,t),o=b("tensor",n,e,t),s=b("lengths",n,e,t),i=t.getTensorArray(r.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let r=b("tensorArrayId",n,e,t),o=t.getTensorArray(r.id);return[me(o.size(),"int32")]}case"TensorArrayCloseV3":{let r=b("tensorArrayId",n,e,t),o=t.getTensorArray(r.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let r=b("tensorListId",n,e,t),o=b("index",n,e,t),s=b("tensor",n,e,t),i=t.getTensorList(r.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let r=b("tensorListId",n,e,t),o=b("index",n,e,t),s=b("elementShape",n,e,t),i=b("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=b("indices",n,e,t),o=b("tensor",n,e,t),s=b("elementShape",n,e,t),i=b("numElements",n,e,t),a=DW(o,r,s,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=b("elementShape",n,e,t),o=b("elementDType",n,e,t),s;n.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=b(s,n,e,t),a=n.op==="TensorListReserve"?-1:i,c=NW(r,o,i,a);return t.addTensorList(c),[c.idTensor]}case"TensorListGather":{let r=b("tensorListId",n,e,t),o=b("indices",n,e,t),s=b("elementShape",n,e,t),i=b("elementDType",n,e,t);return[t.getTensorList(r.id).gather(o,i,s)]}case"TensorListStack":{let r=b("tensorListId",n,e,t),o=b("elementShape",n,e,t),s=b("elementDType",n,e,t),i=b("numElements",n,e,t);return[t.getTensorList(r.id).stack(o,s,i)]}case"TensorListFromTensor":{let r=b("tensor",n,e,t),o=b("elementShape",n,e,t),s=b("elementDType",n,e,t),i=SW(r,o,s);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=b("tensorListId",n,e,t),o=t.getTensorList(r.id),s=b("dtype",n,e,t),i=b("elementShape",n,e,t);return[o.concat(s,i)]}case"TensorListPushBack":{let r=b("tensorListId",n,e,t),o=b("tensor",n,e,t),s=t.getTensorList(r.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let r=b("tensorListId",n,e,t),o=b("elementShape",n,e,t),s=b("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(o,s)]}case"TensorListSplit":{let r=b("tensor",n,e,t),o=b("elementShape",n,e,t),s=b("lengths",n,e,t),i=kW(r,s,o);return t.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=b("tensorListId",n,e,t),o=t.getTensorList(r.id);return[me(o.size(),"int32")]}case"TensorListResize":{let r=b("tensorListId",n,e,t),o=b("size",n,e,t),i=t.getTensorList(r.id).resize(o);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});function FW(n,e,t){let[r,o]=b("fusedOps",n,e,t),s=r==="biasadd",i=!s,a=o==="prelu",c=r==="fusedbatchnorm",l=b("numArgs",n,e,t);if(s){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=b("strides",n,e,t),p=wh(n,e,t),d=b("dataFormat",n,e,t).toUpperCase(),f=b("dilations",n,e,t),[m,h]=b("args",n,e,t);i&&(h=m,m=void 0);let g=b("leakyreluAlpha",n,e,t);return{stride:u,pad:p,dataFormat:d,dilations:f,biasArg:m,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var MW,OW=D(()=>{"use strict";qt();Tt();MW=(n,e,t,r=Ge)=>{switch(n.op){case"Conv1D":{let o=b("stride",n,e,t),s=b("pad",n,e,t),i=b("dataFormat",n,e,t).toUpperCase(),a=b("dilation",n,e,t);return[r.conv1d(b("x",n,e,t),b("filter",n,e,t),o,s,i,a)]}case"Conv2D":{let o=b("strides",n,e,t),s=wh(n,e,t),i=b("dataFormat",n,e,t).toUpperCase(),a=b("dilations",n,e,t);return[r.conv2d(b("x",n,e,t),b("filter",n,e,t),[o[1],o[2]],s,i,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:p}=FW(n,e,t);return[r.fused.conv2d({x:b("x",n,e,t),filter:b("filter",n,e,t),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:p}=FW(n,e,t);return[r.fused.depthwiseConv2d({x:b("x",n,e,t),filter:b("filter",n,e,t),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=b("outputShape",n,e,t),s=b("strides",n,e,t),i=wh(n,e,t);return[r.conv2dTranspose(b("x",n,e,t),b("filter",n,e,t),o,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=b("strides",n,e,t),s=wh(n,e,t),i=b("dilations",n,e,t),a=b("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(b("input",n,e,t),b("filter",n,e,t),[o[1],o[2]],s,a,[i[1],i[2]])]}case"Conv3D":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("dataFormat",n,e,t).toUpperCase(),a=b("dilations",n,e,t);return[r.conv3d(b("x",n,e,t),b("filter",n,e,t),[o[1],o[2],o[3]],s,i,[a[1],a[2],a[3]])]}case"AvgPool":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.avgPool(b("x",n,e,t),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.maxPool(b("x",n,e,t),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("kernelSize",n,e,t),a=b("includeBatchInIndex",n,e,t),{result:c,indexes:l}=r.maxPoolWithArgmax(b("x",n,e,t),[i[1],i[2]],[o[1],o[2]],s,a);return[c,l]}case"AvgPool3D":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.avgPool3d(b("x",n,e,t),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("kernelSize",n,e,t);return[r.maxPool3d(b("x",n,e,t),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=b("strides",n,e,t),s=b("pad",n,e,t),i=b("dilations",n,e,t),a=o[1],c=o[2],l=i[1],u=i[2];return[r.dilation2d(b("x",n,e,t),b("filter",n,e,t),[a,c],s,[l,u],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var $W,PW=D(()=>{"use strict";qt();Tt();$W=(n,e,t,r=Ge)=>{switch(n.op){case"Fill":{let o=b("shape",n,e,t),s=b("dtype",n,e,t),i=b("value",n,e,t);return[r.fill(o,i,s)]}case"LinSpace":{let o=b("start",n,e,t),s=b("stop",n,e,t),i=b("num",n,e,t);return[r.linspace(o,s,i)]}case"Multinomial":{let o=b("logits",n,e,t),s=b("numSamples",n,e,t),i=b("seed",n,e,t);return[r.multinomial(o,s,i)]}case"OneHot":{let o=b("indices",n,e,t),s=b("depth",n,e,t),i=b("onValue",n,e,t),a=b("offValue",n,e,t),c=b("dtype",n,e,t);return[r.oneHot(o,s,i,a,c)]}case"Ones":return[r.ones(b("shape",n,e,t),b("dtype",n,e,t))];case"OnesLike":return[r.onesLike(b("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(b("shape",n,e,t),b("dtype",n,e,t),b("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(b("shape",n,e,t),b("minval",n,e,t),b("maxval",n,e,t),b("dtype",n,e,t))];case"RandomUniformInt":return[r.randomUniformInt(b("shape",n,e,t),b("minval",n,e,t),b("maxval",n,e,t),b("seed",n,e,t))];case"Range":{let o=b("start",n,e,t),s=b("stop",n,e,t),i=b("step",n,e,t);return[r.range(o,s,i,b("dtype",n,e,t))]}case"TruncatedNormal":{let o=b("shape",n,e,t),s=b("mean",n,e,t),i=b("stdDev",n,e,t),a=b("seed",n,e,t);return[r.truncatedNormal(o,s,i,b("dtype",n,e,t),a)]}case"Zeros":return[r.zeros(b("shape",n,e,t),b("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});function QD(n,e,t){let r=b("boxes",n,e,t),o=b("scores",n,e,t),s=b("maxOutputSize",n,e,t),i=b("iouThreshold",n,e,t),a=b("scoreThreshold",n,e,t),c=b("softNmsSigma",n,e,t);return{boxes:r,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:c}}var LW,BW=D(()=>{"use strict";qt();Tt();LW=async(n,e,t,r,o=Ge)=>{switch(n.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:l,softNmsSigma:u}=QD(n,e,t),p=await o.image.nonMaxSuppressionWithScoreAsync(s,i,a,c,l,u);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:l}=QD(n,e,t),u=b("padToMaxOutputSize",n,e,t),p=await o.image.nonMaxSuppressionPaddedAsync(s,i,a,c,l,u);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:l}=QD(n,e,t);return[await o.image.nonMaxSuppressionAsync(s,i,a,c,l)]}case"Where":{let s=o.cast(b("condition",n,e,t),"bool"),i=[await o.whereAsync(s)];return s.dispose(),i}case"ListDiff":return o.setdiff1dAsync(b("x",n,e,t),b("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var VW,UW=D(()=>{"use strict";qt();Tt();VW=(n,e,t,r=Ge)=>{switch(n.op){case"LowerBound":{let o=b("sortedSequence",n,e,t),s=b("values",n,e,t);return[r.lowerBound(o,s)]}case"TopKV2":{let o=b("x",n,e,t),s=b("k",n,e,t),i=b("sorted",n,e,t),a=r.topk(o,s,i);return[a.values,a.indices]}case"UpperBound":{let o=b("sortedSequence",n,e,t),s=b("values",n,e,t);return[r.upperBound(o,s)]}case"Unique":{let o=b("x",n,e,t),s=r.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=b("x",n,e,t),s=b("axis",n,e,t),i=r.unique(o,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var zW,HW=D(()=>{"use strict";qt();Tt();zW=(n,e,t,r=Ge)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":let o=b("default",n,e,t);return[At(n.name,e,t)||o];case"Placeholder":return[At(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=b("x",n,e,t);return[uo(u)]}case"IdentityN":return b("x",n,e,t).map(u=>uo(u));case"Snapshot":let s=b("x",n,e,t);return[uo(s)];case"Shape":return[r.tensor1d(b("x",n,e,t).shape,"int32")];case"ShapeN":return b("x",n,e,t).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(b("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(b("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=b("x",n,e,t),a=b("data",n,e,t),c=b("message",n,e,t),l=b("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(c);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var Hb,GW=D(()=>{"use strict";T();qt();Hb=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=me(0),this.tensorMap=new Map,Sn(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return me(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let r=await e.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),Ce(()=>{let o=Xn(t),s=r.length,i=o.length;y.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let c=r[a],l=o[a];Sn(l),this.tensorMap.set(c,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let r=await e.data();return Ce(()=>{let o=[];for(let s=0;s<r.length;s++){let i=r[s],a=this.findWithDefault(i,t);o.push(a)}return xn(o)})}findWithDefault(e,t){let r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}});var WW,jW=D(()=>{"use strict";GW();Tt();WW=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{let o=r.getHashTableHandleByName(n.name);if(o!=null)return[o];{let s=b("keyDType",n,e,t),i=b("valueDType",n,e,t),a=new Hb(s,i);return r.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let o=b("tableHandle",n,e,t,r),s=b("keys",n,e,t),i=b("values",n,e,t);return[await r.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=b("tableHandle",n,e,t,r),s=b("keys",n,e,t),i=b("defaultValue",n,e,t);return[await r.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=b("tableHandle",n,e,t,r);return[r.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var qW,KW=D(()=>{"use strict";qt();Tt();qW=(n,e,t,r=Ge)=>{switch(n.op){case"ResizeBilinear":{let o=b("images",n,e,t),s=b("size",n,e,t),i=b("alignCorners",n,e,t),a=b("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(o,[s[0],s[1]],i,a)]}case"ResizeNearestNeighbor":{let o=b("images",n,e,t),s=b("size",n,e,t),i=b("alignCorners",n,e,t),a=b("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(o,[s[0],s[1]],i,a)]}case"CropAndResize":{let o=b("image",n,e,t),s=b("boxes",n,e,t),i=b("boxInd",n,e,t),a=b("cropSize",n,e,t),c=b("method",n,e,t),l=b("extrapolationValue",n,e,t);return[r.image.cropAndResize(o,s,i,a,c,l)]}case"ImageProjectiveTransformV3":{let o=b("images",n,e,t),s=b("transforms",n,e,t),i=b("outputShape",n,e,t),a=b("fillValue",n,e,t),c=b("interpolation",n,e,t),l=b("fillMode",n,e,t);return[r.image.transform(o,s,c.toLowerCase(),l.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var XW,YW=D(()=>{"use strict";qt();Tt();XW=(n,e,t,r=Ge)=>{switch(n.op){case"Equal":return[r.equal(b("a",n,e,t),b("b",n,e,t))];case"NotEqual":return[r.notEqual(b("a",n,e,t),b("b",n,e,t))];case"Greater":return[r.greater(b("a",n,e,t),b("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(b("a",n,e,t),b("b",n,e,t))];case"Less":return[r.less(b("a",n,e,t),b("b",n,e,t))];case"LessEqual":return[r.lessEqual(b("a",n,e,t),b("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(b("a",n,e,t),b("b",n,e,t))];case"LogicalNot":return[r.logicalNot(b("a",n,e,t))];case"LogicalOr":return[r.logicalOr(b("a",n,e,t),b("b",n,e,t))];case"Select":case"SelectV2":return[r.where(b("condition",n,e,t),b("a",n,e,t),b("b",n,e,t))];case"BitwiseAnd":return[r.bitwiseAnd(b("a",n,e,t),b("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var ZW,QW=D(()=>{"use strict";qt();Tt();ZW=(n,e,t,r=Ge)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(b("a",n,e,t),b("b",n,e,t),b("transposeA",n,e,t),b("transposeB",n,e,t))];case"Einsum":return[r.einsum(b("equation",n,e,t),...b("tensors",n,e,t))];case"Transpose":return[r.transpose(b("x",n,e,t),b("perm",n,e,t))];case"_FusedMatMul":let[o,s]=b("fusedOps",n,e,t),i=o==="biasadd",a=s==="prelu",c=b("numArgs",n,e,t),l=b("leakyreluAlpha",n,e,t);if(i){if(a&&c!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&c!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,p]=b("args",n,e,t);return[r.fused.matMul({a:b("a",n,e,t),b:b("b",n,e,t),transposeA:b("transposeA",n,e,t),transposeB:b("transposeB",n,e,t),bias:u,activation:s,preluActivationWeights:p,leakyreluAlpha:l})];case"MatrixBandPart":return[r.linalg.bandPart(b("a",n,e,t),b("numLower",n,e,t),b("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var JW,ej=D(()=>{"use strict";qt();Tt();JW=(n,e,t,r=Ge)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(b("x",n,e,t),b("axis",n,e,t),b("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(b("x",n,e,t),b("mean",n,e,t),b("variance",n,e,t),b("offset",n,e,t),b("scale",n,e,t),b("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(b("x",n,e,t),b("mean",n,e,t),b("variance",n,e,t),b("offset",n,e,t),b("scale",n,e,t),b("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(b("x",n,e,t),b("radius",n,e,t),b("bias",n,e,t),b("alpha",n,e,t),b("beta",n,e,t))];case"Softmax":return[r.softmax(b("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var tj,nj=D(()=>{"use strict";qt();Tt();tj=(n,e,t,r=Ge)=>{switch(n.op){case"RaggedGather":{let{outputNestedSplits:o,outputDenseValues:s}=r.raggedGather(b("paramsNestedSplits",n,e,t),b("paramsDenseValues",n,e,t),b("indices",n,e,t),b("outputRaggedRank",n,e,t));return o.concat(s)}case"RaggedRange":{let{rtNestedSplits:o,rtDenseValues:s}=r.raggedRange(b("starts",n,e,t),b("limits",n,e,t),b("splits",n,e,t));return[o,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(b("shape",n,e,t),b("values",n,e,t),b("defaultValue",n,e,t),b("rowPartitionTensors",n,e,t),b("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var rj,oj=D(()=>{"use strict";qt();Tt();rj=(n,e,t,r=Ge)=>{switch(n.op){case"Max":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.max(b("x",n,e,t),a,c)]}case"Mean":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.mean(b("x",n,e,t),a,c)]}case"Min":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.min(b("x",n,e,t),a,c)]}case"Sum":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.sum(b("x",n,e,t),a,c)]}case"All":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.all(b("x",n,e,t),a,c)]}case"Any":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.any(b("x",n,e,t),a,c)]}case"ArgMax":{let a=b("axis",n,e,t);return[r.argMax(b("x",n,e,t),a)]}case"ArgMin":{let a=b("axis",n,e,t);return[r.argMin(b("x",n,e,t),a)]}case"Prod":{let a=b("axis",n,e,t),c=b("keepDims",n,e,t);return[r.prod(b("x",n,e,t),a,c)]}case"Cumprod":{let a=b("axis",n,e,t),c=b("exclusive",n,e,t),l=b("reverse",n,e,t);return[r.cumprod(b("x",n,e,t),a,c,l)]}case"Cumsum":{let a=b("axis",n,e,t),c=b("exclusive",n,e,t),l=b("reverse",n,e,t);return[r.cumsum(b("x",n,e,t),a,c,l)]}case"Bincount":let o=b("x",n,e,t),s=b("weights",n,e,t),i=b("size",n,e,t);return[r.bincount(o,s,i)];case"DenseBincount":{let a=b("x",n,e,t),c=b("weights",n,e,t),l=b("size",n,e,t),u=b("binaryOutput",n,e,t);return[r.denseBincount(a,c,l,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var sj,ij=D(()=>{"use strict";T();qt();Tt();sj=(n,e,t,r=Ge)=>{switch(n.op){case"ConcatV2":case"Concat":{let o=b("n",n,e,t),s=b("axis",n,e,t),i=b("tensors",n,e,t);return i=i.slice(0,o),[r.concat(i,s)]}case"Gather":{let o=b("x",n,e,t),s=b("indices",n,e,t);return[r.gather(o,r.cast(s,"int32"),0)]}case"GatherV2":{let o=b("axis",n,e,t),s=b("batchDims",n,e,t),i=b("x",n,e,t),a=b("indices",n,e,t);return[r.gather(i,r.cast(a,"int32"),o,s)]}case"Reverse":{let o=b("dims",n,e,t),s=[];for(let a=0;a<o.length;a++)o[a]&&s.push(a);let i=b("x",n,e,t);return[r.reverse(i,s)]}case"ReverseV2":{let o=b("axis",n,e,t),s=b("x",n,e,t);return[r.reverse(s,o)]}case"Slice":{let o=b("begin",n,e,t),s=b("size",n,e,t);return[r.slice(b("x",n,e,t),o,s)]}case"StridedSlice":{let o=b("begin",n,e,t),s=b("end",n,e,t),i=b("strides",n,e,t),a=b("beginMask",n,e,t),c=b("endMask",n,e,t),l=b("ellipsisMask",n,e,t),u=b("newAxisMask",n,e,t),p=b("shrinkAxisMask",n,e,t),d=b("x",n,e,t);return[r.stridedSlice(d,o,s,i,a,c,l,u,p)]}case"Pack":return Ce(()=>{let o=b("axis",n,e,t),s=b("tensors",n,e,t),i=s[0].shape,a=r.squeeze(s[0]).shape,c=s.map(l=>{let u=y.arraysEqual(l.shape,i);if(!u&&!y.arraysEqual(r.squeeze(l).shape,a))throw new Error("the input tensors shape does not match");return u?l:r.reshape(l,i)});return[r.stack(c,o)]});case"Unpack":{let o=b("axis",n,e,t),s=b("tensor",n,e,t);return r.unstack(s,o)}case"Tile":{let o=b("reps",n,e,t);return[r.tile(b("x",n,e,t),o)]}case"Split":case"SplitV":{let o=b("axis",n,e,t),s=b("numOrSizeSplits",n,e,t),i=b("x",n,e,t);return r.split(i,s,o)}case"ScatterNd":{let o=b("indices",n,e,t),s=b("values",n,e,t),i=b("shape",n,e,t);return[r.scatterND(o,s,i)]}case"GatherNd":{let o=b("x",n,e,t),s=b("indices",n,e,t);return[r.gatherND(o,s)]}case"SparseToDense":{let o=b("sparseIndices",n,e,t),s=b("outputShape",n,e,t),i=b("sparseValues",n,e,t),a=b("defaultValue",n,e,t);return[r.sparseToDense(o,i,s,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{let o=b("indices",n,e,t),s=b("values",n,e,t),i=b("tensor",n,e,t);return[r.tensorScatterUpdate(i,o,s)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var aj,cj=D(()=>{"use strict";qt();Tt();aj=(n,e,t,r=Ge)=>{switch(n.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(b("indices",n,e,t),b("values",n,e,t),b("denseShape",n,e,t),b("defaultValue",n,e,t));return[o,s,i,a]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=r.sparse.sparseReshape(b("inputIndices",n,e,t),b("inputShape",n,e,t),b("newShape",n,e,t));return[o,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(b("data",n,e,t),b("indices",n,e,t),b("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(b("data",n,e,t),b("indices",n,e,t),b("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var lj,uj=D(()=>{"use strict";qt();Tt();lj=(n,e,t,r=Ge)=>{switch(n.op){case"FFT":return[r.fft(b("x",n,e,t))];case"IFFT":return[r.ifft(b("x",n,e,t))];case"RFFT":return[r.rfft(b("x",n,e,t))];case"IRFFT":return[r.irfft(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var pj,dj=D(()=>{"use strict";qt();Tt();pj=(n,e,t,r=Ge)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(b("input",n,e,t),b("pattern",n,e,t),b("rewrite",n,e,t),b("replaceGlobal",n,e,t))];case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=r.string.stringNGrams(b("data",n,e,t),b("dataSplits",n,e,t),b("separator",n,e,t),b("nGramWidths",n,e,t),b("leftPad",n,e,t),b("rightPad",n,e,t),b("padWidth",n,e,t),b("preserveShortSequences",n,e,t));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:i}=r.string.stringSplit(b("input",n,e,t),b("delimiter",n,e,t),b("skipEmpty",n,e,t));return[o,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(b("input",n,e,t),b("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});var fj,mj=D(()=>{"use strict";qt();Tt();fj=(n,e,t,r=Ge)=>{switch(n.op){case"Cast":return[r.cast(b("x",n,e,t),b("dtype",n,e,t))];case"ExpandDims":{let o=b("axis",n,e,t);return[r.expandDims(b("x",n,e,t),o)]}case"Squeeze":{let o=b("axis",n,e,t);return[r.squeeze(b("x",n,e,t),o)]}case"Reshape":return[r.reshape(b("x",n,e,t),b("shape",n,e,t))];case"EnsureShape":return[r.ensureShape(b("x",n,e,t),b("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(b("x",n,e,t),b("padding",n,e,t),b("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(b("x",n,e,t),b("padding",n,e,t),b("constantValue",n,e,t))];case"SpaceToBatchND":{let o=b("blockShape",n,e,t),s=b("paddings",n,e,t);return[r.spaceToBatchND(b("x",n,e,t),o,s)]}case"BatchToSpaceND":{let o=b("blockShape",n,e,t),s=b("crops",n,e,t);return[r.batchToSpaceND(b("x",n,e,t),o,s)]}case"DepthToSpace":{let o=b("blockSize",n,e,t),s=b("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(b("x",n,e,t),o,s)]}case"BroadcastTo":return[r.broadcastTo(b("x",n,e,t),b("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(b("s0",n,e,t),b("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}}});function JD(n,e,t,r,o=Ce){let s=((i,a,c)=>{switch(i.category){case"arithmetic":return o(()=>bW(i,a,c));case"basic_math":return o(()=>wW(i,a,c));case"control":return AW(i,a,c);case"convolution":return o(()=>MW(i,a,c));case"creation":return o(()=>$W(i,a,c));case"dynamic":return LW(i,a,c);case"evaluation":return o(()=>VW(i,a,c));case"image":return o(()=>qW(i,a,c));case"graph":return o(()=>zW(i,a,c));case"logical":return o(()=>XW(i,a,c));case"matrices":return o(()=>ZW(i,a,c));case"normalization":return o(()=>JW(i,a,c));case"ragged":return o(()=>tj(i,a,c));case"reduction":return o(()=>rj(i,a,c));case"slice_join":return o(()=>sj(i,a,c));case"sparse":return o(()=>aj(i,a,c));case"spectral":return o(()=>lj(i,a,c));case"string":return o(()=>pj(i,a,c));case"transformation":return o(()=>fj(i,a,c));case"hash_table":return WW(i,a,c,r);case"custom":let l=Nb(i.op);if(l&&l.customExecutor)return l.customExecutor(new Vb(i,a,c));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return y.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var hj=D(()=>{"use strict";T();vW();Db();CW();IW();RW();OW();PW();BW();UW();HW();jW();KW();YW();QW();ej();nj();oj();ij();cj();uj();dj();mj();});var Eh,gj=D(()=>{"use strict";Eh=class{constructor(e={},t={},r={},o={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=o,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}});function e1(n,e,t,r){let o=new Set,s=[],i=null,a=null,c=new Set,l=new Set(Object.keys(n).map(d=>Dn(d)[0]));r=r||[];let u=new Set(r.map(d=>Dn(d.name)[0])),p=[...e];for(;p.length>0;){let d=p.pop();if((ya(d)||cpe(d)||lpe(d))&&i==null&&(i=d,a=i.children.map(f=>f.name).filter(f=>o.has(f))),o.add(d.name),t[d.name]==null&&!l.has(d.name)&&!u.has(d.name)){if(d.inputs.length===0){s.push(d.name);continue}d.inputs.forEach(f=>{c.has(f.name)||(c.add(f.name),p.push(f))})}}return{inputs:n,outputs:e,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function xj(n,e){let{usedNodes:t,inputs:r}=e,o=Object.keys(r).map(g=>Dn(g)[0]).map(g=>n.nodes[g]),s=n.initNodes||[],i=g=>t.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(x=>[x.name,x])).values()]}let c=a([...o,...n.weights,...s]).filter(i),l=a([...c,...Object.values(n.nodes)]).filter(i),u=new Map(l.map(g=>[g.name,g])),p={};for(let g of l){p[g.name]=p[g.name]||0;for(let x of g.children)i(x)||(p[x.name]=Number.POSITIVE_INFINITY),p[x.name]=(p[x.name]||0)+1}let d=Object.entries(p).filter(([,g])=>g===0).map(([g])=>g),f=[...d];for(;d.length>0;){let g=d.pop(),x=u.get(g);for(let v of x.children.filter(i))--p[v.name]===0&&(f.push(v.name),d.push(v.name))}let m=f.map(g=>u.get(g)),h=rpe(m,c);return ope(h,c),h}function rpe(n,e){let t=new Map(n.map(i=>[i.name,i])),r=e.map(i=>i.name),o=new Set(r);for(;r.length>0;){let i=r.pop(),a=t.get(i);for(let c of a.children)!t.has(c.name)||o.has(c.name)||(o.add(c.name),r.push(c.name))}return n.filter(i=>o.has(i.name))}function ope(n,e){let t=new Map(n.map((a,c)=>[a.name,c])),r=new Set(e.map(a=>a.name)),o=a=>r.has(typeof a=="string"?a:a.name),s=new Set(n.map(a=>a.name)),i=a=>s.has(typeof a=="string"?a:a.name);for(let a of n){for(let c of a.children.filter(i)){if(!t.has(c.name))throw new _d(`Child ${c.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(c.name))throw new _d(`Node ${a.name} is scheduled to run after its child ${c.name}.`)}if(!o(a))for(let c of a.inputs){if(!t.has(c.name))throw new _d(`Input ${c.name} of node ${a.name} is unreachable.`);if(t.get(c.name)>t.get(a.name))throw new _d(`Node ${a.name} is scheduled to run before its input ${c.name}.`)}}}function yj(n){let e=new Map(n.map((a,c)=>[a.name,c])),t=Number.MAX_SAFE_INTEGER,r=n.map((a,c)=>ya(a)?t:c),o=a=>{let c=r[e.get(a.name)];return c??-1},s=n.map((a,c)=>a.children.map(o).reduce((l,u)=>Math.max(l,u),r[c])),i=new Map;for(let a=0;a<n.length;++a){let c=s[a];if(c===t)continue;let l=n[a],u=n[c];i.has(u.name)||i.set(u.name,[]),i.get(u.name).push(l)}return i}function ya(n){return spe.has(n.op)}function cpe(n){return ipe.has(n.op)}function lpe(n){return ape.has(n.op)}var _d,spe,ipe,ape,vj=D(()=>{"use strict";Tt();_d=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};spe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),ipe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),ape=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"])});var Th,bj=D(()=>{"use strict";T();Tt();hj();gj();vj();Th=class n{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(r=>e[r].map(o=>o.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new n(e.functions[r],this)})}getCompilationKey(e,t){let r=e.map(s=>s.name).sort(),o=t.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+o.join(this.SEPARATOR)}compile(e,t){let r=e1(e,t,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let l=t.map(p=>p.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}let a=xj(this.graph,r),c=yj(a);return{orderedNodes:a,nodeLiveUntilMap:c}}cloneAndKeepTensor(e){if(e==null)return null;let t=e.clone();return Sn(t),t}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let o=r.map(d=>this.graph.nodes[Dn(d)[0]]),s=t.map(d=>Dn(d)[0]),i=new Set(s),a=s.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);let c=this.getCompilationKey(o,a),l=this.compiledMap.get(c);l==null&&(l=this.compile(e,a),this.compiledMap.set(c,l));try{this.keepIntermediateTensors=O().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let u={},p={};return Ce(()=>{let d=new Eh(this.weightMap,u,p,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(x=>{let[v,w]=Dn(x,d),I=[];I[w]=e[x],f[v]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[v]=this.cloneTensorList(I))});let m=this.getFrozenTensorIds(f),{orderedNodes:h,nodeLiveUntilMap:g}=l;for(let x of h){if(f[x.name])continue;let v=JD(x,f,d,this._resourceManager);if(y.isPromise(v))throw new Error(`The execution of the op '${x.op}' returned a promise. Please use model.executeAsync() instead.`);f[x.name]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[x.name]=this.cloneTensorList(v)),this.checkTensorForDisposalWithNodeLiveUntilInfo(x,f,d,m,i,g.get(x.name))}return this.parent==null&&d.dispose(m),t.map(x=>At(x,f,d))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(o=>o.id)));return new Set(t)}checkTensorForDisposal(e,t,r,o,s,i,a){if(!(ya(t)||i.has(e))){for(let c of r[e])c!=null&&(a[c.id]=(a[c.id]||0)+t.children.length);for(let c of t.inputs){if(ya(c))continue;let l=kD(c.name,r,o);if(l!=null)for(let u of l){if(!u||u.kept||s.has(u.id))continue;let p=a[u.id];p===1?(u.dispose(),delete a[u.id]):p!=null&&a[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,o,s,i){function a(c){return ya(c)||s.has(c.name)}if(!(ya(e)||i==null))for(let c of i){if(a(c))continue;let l=kD(c.name,t,r);for(let u of l)!u||u.kept||o.has(u.id)||u.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,o={},s={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=O().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let i=new Eh(this.weightMap,o,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let a=await this.executeWithControlFlow(e,i,t,r),c=t.map(d=>At(d,a,i)),l=c.map(d=>d.id),u=Object.keys(e).map(d=>e[d].id),p=new Set([...l,...u,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(f=>{f&&!f.isDisposed&&!p.has(f.id)&&f.dispose()})}),this.parent==null&&i.dispose(p),c}async executeFunctionAsync(e,t,r){let o=e.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,o){let s=Object.keys(e),i=s.map(I=>this.graph.nodes[Dn(I)[0]]),a=r.map(I=>Dn(I)[0]),c=new Set(a),l=a.map(I=>this.graph.nodes[I]);l.length===0&&(l=this._outputs);let{usedNodes:u,missingInputs:p,dynamicNode:d,syncInputs:f}=e1(e,l,this.weightMap,this._initNodes),m=[...i,...this.graph.weights,...this._initNodes||[]].map(I=>({node:I,contexts:t.currentContext})),h=Object.assign({},this.weightMap);Object.keys(e).forEach(I=>{let[_,A]=Dn(I),R=[];R[A]=e[I],h[_]=R});let g={},x=this.getFrozenTensorIds(h),v={};for(;m.length>0;){let I=this.processStack(i,m,t,h,v,x,c,g,u);await Promise.all(I)}d==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let w=l.filter(I=>!ya(I)&&!At(I.name,h,t)).map(I=>I.name);if(w.length>0){let I="";throw d!=null&&(I=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${I}`)}return h}processStack(e,t,r,o,s,i,a,c,l){let u=[];for(;t.length>0;){let p=t.pop();r.currentContext=p.contexts;let d="";if(p.node.op==="Enter"&&b("isConstant",p.node,o,r)&&([d]=lo(p.node.name,r)),o[p.node.name]==null){let f=JD(p.node,o,r,this._resourceManager);d||([d]=lo(p.node.name,r));let m=r.currentContext;y.isPromise(f)?u.push(f.then(h=>(o[d]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(h)),r.currentContext=m,this.checkTensorForDisposal(d,p.node,o,r,i,a,c),this.processChildNodes(p.node,t,r,o,s,l),h))):(o[d]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(f)),this.checkTensorForDisposal(d,p.node,o,r,i,a,c),this.processChildNodes(p.node,t,r,o,s,l))}else this.processChildNodes(p.node,t,r,o,s,l)}return u}processChildNodes(e,t,r,o,s,i){e.children.forEach(a=>{let[c]=lo(a.name,r);s[c]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!At(l,o,r))&&(s[c]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(l=>!!At(l,o,r))&&(s[c]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let r=e[t],[o]=Dn(t),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((c,l)=>i[l]===-1||i[l]===c);y.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&y.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;let o={};for(let s in e){let i=(r=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||r===void 0?void 0:r[s];i!=null?o[i.name]=e[s]:o[s]=e[s]}return o}checkInputs(e){let t=Object.keys(e).filter(r=>{let[o]=Dn(r);return this.graph.nodes[o]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var r,o;let s=(o=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||o===void 0?void 0:o[t];return s!=null?s.name:t},{})}checkOutputs(e){e.forEach(t=>{let[r]=Dn(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}});var Gb,Cj=D(()=>{"use strict";Gb=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}});async function wj(n,e={},t=Bo){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=dpe(n));let r=new Ad(n,e,t);return await r.load(),r}function Ij(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){let[r,o]=n;if(!r)throw new Error("modelJSON must be the first element of the array");if(!o||!(o instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let s=Bo.getWeightSpecs(r.weightsManifest),i=Bo.getModelArtifactsForJSONSync(r,s,o);e=Bo.fromMemorySync(i)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=Bo.fromMemorySync(n);else throw new Error("Unknown model format");let t=new Ad(e);return t.load(),t}function dpe(n){return n.endsWith("/")||(n=n+"/"),`${n}${ppe}${upe}`}var upe,ppe,Ad,Ej=D(()=>{"use strict";T();YD();bj();Cj();Yi();upe="?tfjs-format=file",ppe="model.json",Ad=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=Bo){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new Gb}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return y.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await gx(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let r=this.artifacts.modelTopology,o=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(o=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=o,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Th(Ih.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=Ih.Instance.transformGraph(e.modelInitializer);this.initializer=new Th(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Ze?[e]:e,r={};return t.forEach((o,s)=>r[this.structuredOutputKeys[s]]=o),r}return e}predict(e,t){let r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){let r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof Ze)&&!Array.isArray(e)){let s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(let i in s){let a=s[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];let r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let o=0;return this.inputNodes.reduce((s,i)=>{var a,c,l;let u=(l=(c=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||c===void 0?void 0:c[i])===null||l===void 0?void 0:l.resourceId;return u!=null?s[i]=this.resourceIdToCapturedInput[u]:s[i]=e[o++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,r=Object.keys(t);for(let o=0;o<r.length;o++){let s=r[o],i=t[s];this.resourceIdToCapturedInput[i.resourceId]=e[o]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ct(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}});var Tj,Sj=D(()=>{"use strict";Tj="4.22.0"});var Nj={};Ue(Nj,{GraphModel:()=>Ad,deregisterOp:()=>YG,loadGraphModel:()=>wj,loadGraphModelSync:()=>Ij,registerOp:()=>XG,version_converter:()=>Tj});var Dj=D(()=>{"use strict";jG();Ej();Db();Sj();});var _j=rr((Wb,kj)=>{"use strict";(function(n,e){typeof Wb=="object"&&typeof kj<"u"?e(Wb,(Dj(),i1(Nj)),(T(),i1(gy))):typeof define=="function"&&define.amd?define(["exports","@tensorflow/tfjs-converter","@tensorflow/tfjs-core"],e):e((n=n||self).cocoSsd=n.cocoSsd||{},n.tf,n.tf)})(Wb,function(n,e,t){"use strict";let r={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class o{constructor(i,a){this.modelPath=a||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(i)}/model.json`}getPrefix(i){return i==="lite_mobilenet_v2"?`ssd${i}`:`ssd_${i}`}async load(){this.model=await e.loadGraphModel(this.modelPath);let i=t.zeros([1,300,300,3],"int32"),a=await this.model.executeAsync(i);await Promise.all(a.map(c=>c.data())),a.map(c=>c.dispose()),i.dispose()}async infer(i,a,c){let l=t.tidy(()=>(i instanceof t.Tensor||(i=t.browser.fromPixels(i)),t.expandDims(i))),u=l.shape[1],p=l.shape[2],d=await this.model.executeAsync(l),f=d[0].dataSync(),m=d[1].dataSync();l.dispose(),t.dispose(d);let[h,g]=this.calculateMaxScores(f,d[0].shape[1],d[0].shape[2]),x=t.getBackend();t.getBackend()==="webgl"&&t.setBackend("cpu");let v=t.tidy(()=>{let I=t.tensor2d(m,[d[1].shape[1],d[1].shape[3]]);return t.image.nonMaxSuppression(I,h,a,c,c)}),w=v.dataSync();return v.dispose(),x!==t.getBackend()&&t.setBackend(x),this.buildDetectedObjects(p,u,m,h,w,g)}buildDetectedObjects(i,a,c,l,u,p){let d=u.length,f=[];for(let m=0;m<d;m++){let h=[];for(let I=0;I<4;I++)h[I]=c[4*u[m]+I];let g=h[0]*a,x=h[1]*i,v=h[2]*a,w=h[3]*i;h[0]=x,h[1]=g,h[2]=w-x,h[3]=v-g,f.push({bbox:h,class:r[p[u[m]]+1].displayName,score:l[u[m]]})}return f}calculateMaxScores(i,a,c){let l=[],u=[];for(let p=0;p<a;p++){let d=Number.MIN_VALUE,f=-1;for(let m=0;m<c;m++)i[p*c+m]>d&&(d=i[p*c+m],f=m);l[p]=d,u[p]=f}return[l,u]}async detect(i,a=20,c=.5){return this.infer(i,a,c)}dispose(){this.model!=null&&this.model.dispose()}}n.ObjectDetection=o,n.load=async function(s={}){if(t==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");let i=s.base||"lite_mobilenet_v2",a=s.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(i)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${i}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);let c=new o(i,a);return await c.load(),c},n.version="2.2.3",Object.defineProperty(n,"__esModule",{value:!0})})});var Zb;function Dh(){return Zb}function po(n){let e=Zb;return Zb=n,e}var a1=Symbol("NotFound");function Fu(n){return n===a1||n?.name==="\u0275NotFound"}function Qb(n,e){return Object.is(n,e)}var bn=null,kh=!1,Jb=1,Uj=null,Vn=Symbol("SIGNAL");function Me(n){let e=bn;return bn=n,e}function Ah(){return bn}var Mu={version:0,lastCleanEpoch:0,dirty:!1,producers:void 0,producersTail:void 0,consumers:void 0,consumersTail:void 0,recomputing:!1,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,kind:"unknown",producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function Md(n){if(kh)throw new Error("");if(bn===null)return;bn.consumerOnSignalRead(n);let e=bn.producersTail;if(e!==void 0&&e.producer===n)return;let t,r=bn.recomputing;if(r&&(t=e!==void 0?e.nextProducer:bn.producers,t!==void 0&&t.producer===n)){bn.producersTail=t,t.lastReadVersion=n.version;return}let o=n.consumersTail;if(o!==void 0&&o.consumer===bn&&(!r||Hj(o,bn)))return;let s=Pu(bn),i={producer:n,consumer:bn,nextProducer:t,prevConsumer:o,lastReadVersion:n.version,nextConsumer:void 0};bn.producersTail=i,e!==void 0?e.nextProducer=i:bn.producers=i,s&&l1(n,i)}function c1(){Jb++}function e0(n){if(!(Pu(n)&&!n.dirty)&&!(!n.dirty&&n.lastCleanEpoch===Jb)){if(!n.producerMustRecompute(n)&&!$u(n)){_h(n);return}n.producerRecomputeValue(n),_h(n)}}function t0(n){if(n.consumers===void 0)return;let e=kh;kh=!0;try{for(let t=n.consumers;t!==void 0;t=t.nextConsumer){let r=t.consumer;r.dirty||zj(r)}}finally{kh=e}}function n0(){return bn?.consumerAllowSignalWrites!==!1}function zj(n){n.dirty=!0,t0(n),n.consumerMarkedDirty?.(n)}function _h(n){n.dirty=!1,n.lastCleanEpoch=Jb}function Ou(n){return n&&(n.producersTail=void 0,n.recomputing=!0),Me(n)}function Od(n,e){if(Me(e),!n)return;n.recomputing=!1;let t=n.producersTail,r=t!==void 0?t.nextProducer:n.producers;if(r!==void 0){if(Pu(n))do r=r0(r);while(r!==void 0);t!==void 0?t.nextProducer=void 0:n.producers=void 0}}function $u(n){for(let e=n.producers;e!==void 0;e=e.nextProducer){let t=e.producer,r=e.lastReadVersion;if(r!==t.version||(e0(t),r!==t.version))return!0}return!1}function ba(n){if(Pu(n)){let e=n.producers;for(;e!==void 0;)e=r0(e)}n.producers=void 0,n.producersTail=void 0,n.consumers=void 0,n.consumersTail=void 0}function l1(n,e){let t=n.consumersTail,r=Pu(n);if(t!==void 0?(e.nextConsumer=t.nextConsumer,t.nextConsumer=e):(e.nextConsumer=void 0,n.consumers=e),e.prevConsumer=t,n.consumersTail=e,!r)for(let o=n.producers;o!==void 0;o=o.nextProducer)l1(o.producer,o)}function r0(n){let e=n.producer,t=n.nextProducer,r=n.nextConsumer,o=n.prevConsumer;if(n.nextConsumer=void 0,n.prevConsumer=void 0,r!==void 0?r.prevConsumer=o:e.consumersTail=o,o!==void 0)o.nextConsumer=r;else if(e.consumers=r,!Pu(e)){let s=e.producers;for(;s!==void 0;)s=r0(s)}return t}function Pu(n){return n.consumerIsAlwaysLive||n.consumers!==void 0}function o0(n){Uj?.(n)}function Hj(n,e){let t=e.producersTail;if(t!==void 0){let r=e.producers;do{if(r===n)return!0;if(r===t)break;r=r.nextProducer}while(r!==void 0)}return!1}function Gj(){throw new Error}var u1=Gj;function p1(n){u1(n)}function s0(n){u1=n}var Wj=null;function i0(n,e){let t=Object.create(Rh);t.value=n,e!==void 0&&(t.equal=e);let r=()=>d1(t);return r[Vn]=t,o0(t),[r,i=>Lu(t,i),i=>a0(t,i)]}function d1(n){return Md(n),n.value}function Lu(n,e){n0()||p1(n),n.equal(n.value,e)||(n.value=e,jj(n))}function a0(n,e){n0()||p1(n),Lu(n,e(n.value))}var Rh=Lt(Rt({},Mu),{equal:Qb,value:void 0,kind:"signal"});function jj(n){n.version++,c1(),t0(n),Wj?.(n)}function Un(n){return typeof n=="function"}function Fh(n){let t=n(r=>{Error.call(r),r.stack=new Error().stack});return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}var Mh=Fh(n=>function(t){n(this),this.message=t?`${t.length} errors occurred during unsubscription:
${t.map((r,o)=>`${o+1}) ${r.toString()}`).join(`
  `)}`:"",this.name="UnsubscriptionError",this.errors=t});function $d(n,e){if(n){let t=n.indexOf(e);0<=t&&n.splice(t,1)}}var kn=class n{constructor(e){this.initialTeardown=e,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let e;if(!this.closed){this.closed=!0;let{_parentage:t}=this;if(t)if(this._parentage=null,Array.isArray(t))for(let s of t)s.remove(this);else t.remove(this);let{initialTeardown:r}=this;if(Un(r))try{r()}catch(s){e=s instanceof Mh?s.errors:[s]}let{_finalizers:o}=this;if(o){this._finalizers=null;for(let s of o)try{f1(s)}catch(i){e=e??[],i instanceof Mh?e=[...e,...i.errors]:e.push(i)}}if(e)throw new Mh(e)}}add(e){var t;if(e&&e!==this)if(this.closed)f1(e);else{if(e instanceof n){if(e.closed||e._hasParent(this))return;e._addParent(this)}(this._finalizers=(t=this._finalizers)!==null&&t!==void 0?t:[]).push(e)}}_hasParent(e){let{_parentage:t}=this;return t===e||Array.isArray(t)&&t.includes(e)}_addParent(e){let{_parentage:t}=this;this._parentage=Array.isArray(t)?(t.push(e),t):t?[t,e]:e}_removeParent(e){let{_parentage:t}=this;t===e?this._parentage=null:Array.isArray(t)&&$d(t,e)}remove(e){let{_finalizers:t}=this;t&&$d(t,e),e instanceof n&&e._removeParent(this)}};kn.EMPTY=(()=>{let n=new kn;return n.closed=!0,n})();var c0=kn.EMPTY;function Oh(n){return n instanceof kn||n&&"closed"in n&&Un(n.remove)&&Un(n.add)&&Un(n.unsubscribe)}function f1(n){Un(n)?n():n.unsubscribe()}var Rr={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1};var Bu={setTimeout(n,e,...t){let{delegate:r}=Bu;return r?.setTimeout?r.setTimeout(n,e,...t):setTimeout(n,e,...t)},clearTimeout(n){let{delegate:e}=Bu;return(e?.clearTimeout||clearTimeout)(n)},delegate:void 0};function m1(n){Bu.setTimeout(()=>{let{onUnhandledError:e}=Rr;if(e)e(n);else throw n})}function l0(){}var h1=u0("C",void 0,void 0);function g1(n){return u0("E",void 0,n)}function x1(n){return u0("N",n,void 0)}function u0(n,e,t){return{kind:n,value:e,error:t}}var Ca=null;function Vu(n){if(Rr.useDeprecatedSynchronousErrorHandling){let e=!Ca;if(e&&(Ca={errorThrown:!1,error:null}),n(),e){let{errorThrown:t,error:r}=Ca;if(Ca=null,t)throw r}}else n()}function y1(n){Rr.useDeprecatedSynchronousErrorHandling&&Ca&&(Ca.errorThrown=!0,Ca.error=n)}var wa=class extends kn{constructor(e){super(),this.isStopped=!1,e?(this.destination=e,Oh(e)&&e.add(this)):this.destination=Xj}static create(e,t,r){return new Uu(e,t,r)}next(e){this.isStopped?d0(x1(e),this):this._next(e)}error(e){this.isStopped?d0(g1(e),this):(this.isStopped=!0,this._error(e))}complete(){this.isStopped?d0(h1,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(e){this.destination.next(e)}_error(e){try{this.destination.error(e)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}},qj=Function.prototype.bind;function p0(n,e){return qj.call(n,e)}var f0=class{constructor(e){this.partialObserver=e}next(e){let{partialObserver:t}=this;if(t.next)try{t.next(e)}catch(r){$h(r)}}error(e){let{partialObserver:t}=this;if(t.error)try{t.error(e)}catch(r){$h(r)}else $h(e)}complete(){let{partialObserver:e}=this;if(e.complete)try{e.complete()}catch(t){$h(t)}}},Uu=class extends wa{constructor(e,t,r){super();let o;if(Un(e)||!e)o={next:e??void 0,error:t??void 0,complete:r??void 0};else{let s;this&&Rr.useDeprecatedNextContext?(s=Object.create(e),s.unsubscribe=()=>this.unsubscribe(),o={next:e.next&&p0(e.next,s),error:e.error&&p0(e.error,s),complete:e.complete&&p0(e.complete,s)}):o=e}this.destination=new f0(o)}};function $h(n){Rr.useDeprecatedSynchronousErrorHandling?y1(n):m1(n)}function Kj(n){throw n}function d0(n,e){let{onStoppedNotification:t}=Rr;t&&Bu.setTimeout(()=>t(n,e))}var Xj={closed:!0,next:l0,error:Kj,complete:l0};var v1=typeof Symbol=="function"&&Symbol.observable||"@@observable";function b1(n){return n}function C1(n){return n.length===0?b1:n.length===1?n[0]:function(t){return n.reduce((r,o)=>o(r),t)}}var zu=(()=>{class n{constructor(t){t&&(this._subscribe=t)}lift(t){let r=new n;return r.source=this,r.operator=t,r}subscribe(t,r,o){let s=Zj(t)?t:new Uu(t,r,o);return Vu(()=>{let{operator:i,source:a}=this;s.add(i?i.call(s,a):a?this._subscribe(s):this._trySubscribe(s))}),s}_trySubscribe(t){try{return this._subscribe(t)}catch(r){t.error(r)}}forEach(t,r){return r=w1(r),new r((o,s)=>{let i=new Uu({next:a=>{try{t(a)}catch(c){s(c),i.unsubscribe()}},error:s,complete:o});this.subscribe(i)})}_subscribe(t){var r;return(r=this.source)===null||r===void 0?void 0:r.subscribe(t)}[v1](){return this}pipe(...t){return C1(t)(this)}toPromise(t){return t=w1(t),new t((r,o)=>{let s;this.subscribe(i=>s=i,i=>o(i),()=>r(s))})}}return n.create=e=>new n(e),n})();function w1(n){var e;return(e=n??Rr.Promise)!==null&&e!==void 0?e:Promise}function Yj(n){return n&&Un(n.next)&&Un(n.error)&&Un(n.complete)}function Zj(n){return n&&n instanceof wa||Yj(n)&&Oh(n)}function Qj(n){return Un(n?.lift)}function I1(n){return e=>{if(Qj(e))return e.lift(function(t){try{return n(t,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function E1(n,e,t,r,o){return new m0(n,e,t,r,o)}var m0=class extends wa{constructor(e,t,r,o,s,i){super(e),this.onFinalize=s,this.shouldUnsubscribe=i,this._next=t?function(a){try{t(a)}catch(c){e.error(c)}}:super._next,this._error=o?function(a){try{o(a)}catch(c){e.error(c)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){e.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var e;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){let{closed:t}=this;super.unsubscribe(),!t&&((e=this.onFinalize)===null||e===void 0||e.call(this))}}};var T1=Fh(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});var $s=(()=>{class n extends zu{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(t){let r=new Ph(this,this);return r.operator=t,r}_throwIfClosed(){if(this.closed)throw new T1}next(t){Vu(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(let r of this.currentObservers)r.next(t)}})}error(t){Vu(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=t;let{observers:r}=this;for(;r.length;)r.shift().error(t)}})}complete(){Vu(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;let{observers:t}=this;for(;t.length;)t.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var t;return((t=this.observers)===null||t===void 0?void 0:t.length)>0}_trySubscribe(t){return this._throwIfClosed(),super._trySubscribe(t)}_subscribe(t){return this._throwIfClosed(),this._checkFinalizedStatuses(t),this._innerSubscribe(t)}_innerSubscribe(t){let{hasError:r,isStopped:o,observers:s}=this;return r||o?c0:(this.currentObservers=null,s.push(t),new kn(()=>{this.currentObservers=null,$d(s,t)}))}_checkFinalizedStatuses(t){let{hasError:r,thrownError:o,isStopped:s}=this;r?t.error(o):s&&t.complete()}asObservable(){let t=new zu;return t.source=this,t}}return n.create=(e,t)=>new Ph(e,t),n})(),Ph=class extends $s{constructor(e,t){super(),this.destination=e,this.source=t}next(e){var t,r;(r=(t=this.destination)===null||t===void 0?void 0:t.next)===null||r===void 0||r.call(t,e)}error(e){var t,r;(r=(t=this.destination)===null||t===void 0?void 0:t.error)===null||r===void 0||r.call(t,e)}complete(){var e,t;(t=(e=this.destination)===null||e===void 0?void 0:e.complete)===null||t===void 0||t.call(e)}_subscribe(e){var t,r;return(r=(t=this.source)===null||t===void 0?void 0:t.subscribe(e))!==null&&r!==void 0?r:c0}};var Pd=class extends $s{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){let t=super._subscribe(e);return!t.closed&&e.next(this._value),t}getValue(){let{hasError:e,thrownError:t,_value:r}=this;if(e)throw t;return this._throwIfClosed(),r}next(e){super.next(this._value=e)}};function h0(n,e){return I1((t,r)=>{let o=0;t.subscribe(E1(r,s=>{r.next(n.call(e,s,o++))}))})}var S1=Lt(Rt({},Mu),{consumerIsAlwaysLive:!0,consumerAllowSignalWrites:!0,dirty:!0,hasRun:!1,kind:"effect"});function N1(n){if(n.dirty=!1,n.hasRun&&!$u(n))return;n.hasRun=!0;let e=Ou(n);try{n.cleanup(),n.fn()}finally{Od(n,e)}}var Hh="https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss",Te=class extends Error{code;constructor(e,t){super(Gu(e,t)),this.code=e}};function Jj(n){return`NG0${Math.abs(n)}`}function Gu(n,e){return`${Jj(n)}${e?": "+e:""}`}var Na=globalThis;function st(n){for(let e in n)if(n[e]===st)return e;throw Error("")}function Ps(n){if(typeof n=="string")return n;if(Array.isArray(n))return`[${n.map(Ps).join(", ")}]`;if(n==null)return""+n;let e=n.overriddenName||n.name;if(e)return`${e}`;let t=n.toString();if(t==null)return""+t;let r=t.indexOf(`
`);return r>=0?t.slice(0,r):t}function N0(n,e){return n?e?`${n} ${e}`:n:e||""}var e6=st({__forward_ref__:st});function Gh(n){return n.__forward_ref__=Gh,n.toString=function(){return Ps(this())},n}function or(n){return A1(n)?n():n}function A1(n){return typeof n=="function"&&n.hasOwnProperty(e6)&&n.__forward_ref__===Gh}function R1(n,e){n==null&&D0(e,n,null,"!=")}function D0(n,e,t,r){throw new Error(`ASSERTION ERROR: ${n}`+(r==null?"":` [Expected=> ${t} ${r} ${e} <=Actual]`))}function ut(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function zd(n){return{providers:n.providers||[],imports:n.imports||[]}}function Wh(n){return t6(n,jh)}function t6(n,e){return n.hasOwnProperty(e)&&n[e]||null}function n6(n){let e=n?.[jh]??null;return e||null}function x0(n){return n&&n.hasOwnProperty(Bh)?n[Bh]:null}var jh=st({\u0275prov:st}),Bh=st({\u0275inj:st}),qe=class{_desc;ngMetadataName="InjectionToken";\u0275prov;constructor(e,t){this._desc=e,this.\u0275prov=void 0,typeof t=="number"?this.__NG_ELEMENT_ID__=t:t!==void 0&&(this.\u0275prov=ut({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}};function k0(n){return n&&!!n.\u0275providers}var _0=st({\u0275cmp:st}),A0=st({\u0275dir:st}),R0=st({\u0275pipe:st});var y0=st({\u0275fac:st}),Da=st({__NG_ELEMENT_ID__:st}),k1=st({__NG_ENV_ID__:st});function Hd(n){return typeof n=="string"?n:n==null?"":String(n)}function Vh(n){return typeof n=="function"?n.name||n.toString():typeof n=="object"&&n!=null&&typeof n.type=="function"?n.type.name||n.type.toString():Hd(n)}var F0=st({ngErrorCode:st}),F1=st({ngErrorMessage:st}),Bd=st({ngTokenPath:st});function M0(n,e){return M1("",-200,e)}function qh(n,e){throw new Te(-201,!1)}function r6(n,e){n[Bd]??=[];let t=n[Bd],r;typeof e=="object"&&"multi"in e&&e?.multi===!0?(R1(e.provide,"Token with multi: true should have a provide property"),r=Vh(e.provide)):r=Vh(e),t[0]!==r&&n[Bd].unshift(r)}function o6(n,e){let t=n[Bd],r=n[F0],o=n[F1]||n.message;return n.message=i6(o,r,t,e),n}function M1(n,e,t){let r=new Te(e,n);return r[F0]=e,r[F1]=n,t&&(r[Bd]=t),r}function s6(n){return n[F0]}function i6(n,e,t=[],r=null){let o="";t&&t.length>1&&(o=` Path: ${t.join(" -> ")}.`);let s=r?` Source: ${r}.`:"";return Gu(e,`${n}${s}${o}`)}var v0;function O1(){return v0}function _n(n){let e=v0;return v0=n,e}function O0(n,e,t){let r=Wh(n);if(r&&r.providedIn=="root")return r.value===void 0?r.value=r.factory():r.value;if(t&8)return null;if(e!==void 0)return e;qh(n,"Injector")}var a6={},Ia=a6,c6="__NG_DI_FLAG__",b0=class{injector;constructor(e){this.injector=e}retrieve(e,t){let r=Ea(t)||0;try{return this.injector.get(e,r&8?null:Ia,r)}catch(o){if(Fu(o))return o;throw o}}};function l6(n,e=0){let t=Dh();if(t===void 0)throw new Te(-203,!1);if(t===null)return O0(n,void 0,e);{let r=u6(e),o=t.retrieve(n,r);if(Fu(o)){if(r.optional)return null;throw o}return o}}function Qe(n,e=0){return(O1()||l6)(or(n),e)}function Ae(n,e){return Qe(n,Ea(e))}function Ea(n){return typeof n>"u"||typeof n=="number"?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function u6(n){return{optional:!!(n&8),host:!!(n&1),self:!!(n&2),skipSelf:!!(n&4)}}function C0(n){let e=[];for(let t=0;t<n.length;t++){let r=or(n[t]);if(Array.isArray(r)){if(r.length===0)throw new Te(900,!1);let o,s=0;for(let i=0;i<r.length;i++){let a=r[i],c=p6(a);typeof c=="number"?c===-1?o=a.token:s|=c:o=a}e.push(Qe(o,s))}else e.push(Qe(r))}return e}function p6(n){return n[c6]}function Ta(n,e){let t=n.hasOwnProperty(y0);return t?n[y0]:null}function $1(n,e,t){if(n.length!==e.length)return!1;for(let r=0;r<n.length;r++){let o=n[r],s=e[r];if(t&&(o=t(o),s=t(s)),s!==o)return!1}return!0}function P1(n){return n.flat(Number.POSITIVE_INFINITY)}function Kh(n,e){n.forEach(t=>Array.isArray(t)?Kh(t,e):e(t))}function $0(n,e,t){e>=n.length?n.push(t):n.splice(e,0,t)}function Gd(n,e){return e>=n.length-1?n.pop():n.splice(e,1)[0]}function L1(n,e,t,r){let o=n.length;if(o==e)n.push(t,r);else if(o===1)n.push(r,n[0]),n[0]=t;else{for(o--,n.push(n[o-1],n[o]);o>e;){let s=o-2;n[o]=n[s],o--}n[e]=t,n[e+1]=r}}function B1(n,e,t){let r=Wu(n,e);return r>=0?n[r|1]=t:(r=~r,L1(n,r,e,t)),r}function Xh(n,e){let t=Wu(n,e);if(t>=0)return n[t|1]}function Wu(n,e){return d6(n,e,1)}function d6(n,e,t){let r=0,o=n.length>>t;for(;o!==r;){let s=r+(o-r>>1),i=n[s<<t];if(e===i)return s<<t;i>e?o=s:r=s+1}return~(o<<t)}var ka={},fr=[],Bs=new qe(""),P0=new qe("",-1),L0=new qe(""),Vd=class{get(e,t=Ia){if(t===Ia){let o=M1("",-201);throw o.name="\u0275NotFound",o}return t}};function _a(n){return n[_0]||null}function B0(n){return n[A0]||null}function V1(n){return n[R0]||null}function ju(n){return{\u0275providers:n}}function U1(n){return ju([{provide:Bs,multi:!0,useValue:n}])}function z1(...n){return{\u0275providers:V0(!0,n),\u0275fromNgModule:!0}}function V0(n,...e){let t=[],r=new Set,o,s=i=>{t.push(i)};return Kh(e,i=>{let a=i;Uh(a,s,[],r)&&(o||=[],o.push(a))}),o!==void 0&&H1(o,s),t}function H1(n,e){for(let t=0;t<n.length;t++){let{ngModule:r,providers:o}=n[t];U0(o,s=>{e(s,r)})}}function Uh(n,e,t,r){if(n=or(n),!n)return!1;let o=null,s=x0(n),i=!s&&_a(n);if(!s&&!i){let c=n.ngModule;if(s=x0(c),s)o=c;else return!1}else{if(i&&!i.standalone)return!1;o=n}let a=r.has(o);if(i){if(a)return!1;if(r.add(o),i.dependencies){let c=typeof i.dependencies=="function"?i.dependencies():i.dependencies;for(let l of c)Uh(l,e,t,r)}}else if(s){if(s.imports!=null&&!a){r.add(o);let l;try{Kh(s.imports,u=>{Uh(u,e,t,r)&&(l||=[],l.push(u))})}finally{}l!==void 0&&H1(l,e)}if(!a){let l=Ta(o)||(()=>new o);e({provide:o,useFactory:l,deps:fr},o),e({provide:L0,useValue:o,multi:!0},o),e({provide:Bs,useValue:()=>Qe(o),multi:!0},o)}let c=s.providers;if(c!=null&&!a){let l=n;U0(c,u=>{e(u,l)})}}else return!1;return o!==n&&n.providers!==void 0}function U0(n,e){for(let t of n)k0(t)&&(t=t.\u0275providers),Array.isArray(t)?U0(t,e):e(t)}var f6=st({provide:String,useValue:st});function G1(n){return n!==null&&typeof n=="object"&&f6 in n}function m6(n){return!!(n&&n.useExisting)}function h6(n){return!!(n&&n.useFactory)}function zh(n){return typeof n=="function"}var Wd=new qe(""),Lh={},_1={},g0;function jd(){return g0===void 0&&(g0=new Vd),g0}var mr=class{},Sa=class extends mr{parent;source;scopes;records=new Map;_ngOnDestroyHooks=new Set;_onDestroyHooks=[];get destroyed(){return this._destroyed}_destroyed=!1;injectorDefTypes;constructor(e,t,r,o){super(),this.parent=t,this.source=r,this.scopes=o,I0(e,i=>this.processProvider(i)),this.records.set(P0,Hu(void 0,this)),o.has("environment")&&this.records.set(mr,Hu(void 0,this));let s=this.records.get(Wd);s!=null&&typeof s.value=="string"&&this.scopes.add(s.value),this.injectorDefTypes=new Set(this.get(L0,fr,{self:!0}))}retrieve(e,t){let r=Ea(t)||0;try{return this.get(e,Ia,r)}catch(o){if(Fu(o))return o;throw o}}destroy(){Ld(this),this._destroyed=!0;let e=Me(null);try{for(let r of this._ngOnDestroyHooks)r.ngOnDestroy();let t=this._onDestroyHooks;this._onDestroyHooks=[];for(let r of t)r()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),Me(e)}}onDestroy(e){return Ld(this),this._onDestroyHooks.push(e),()=>this.removeOnDestroy(e)}runInContext(e){Ld(this);let t=po(this),r=_n(void 0),o;try{return e()}finally{po(t),_n(r)}}get(e,t=Ia,r){if(Ld(this),e.hasOwnProperty(k1))return e[k1](this);let o=Ea(r),s,i=po(this),a=_n(void 0);try{if(!(o&4)){let l=this.records.get(e);if(l===void 0){let u=b6(e)&&Wh(e);u&&this.injectableDefInScope(u)?l=Hu(w0(e),Lh):l=null,this.records.set(e,l)}if(l!=null)return this.hydrate(e,l,o)}let c=o&2?jd():this.parent;return t=o&8&&t===Ia?null:t,c.get(e,t)}catch(c){let l=s6(c);throw l===-200||l===-201?new Te(l,null):c}finally{_n(a),po(i)}}resolveInjectorInitializers(){let e=Me(null),t=po(this),r=_n(void 0),o;try{let s=this.get(Bs,fr,{self:!0});for(let i of s)i()}finally{po(t),_n(r),Me(e)}}toString(){let e=[],t=this.records;for(let r of t.keys())e.push(Ps(r));return`R3Injector[${e.join(", ")}]`}processProvider(e){e=or(e);let t=zh(e)?e:or(e&&e.provide),r=x6(e);if(!zh(e)&&e.multi===!0){let o=this.records.get(t);o||(o=Hu(void 0,Lh,!0),o.factory=()=>C0(o.multi),this.records.set(t,o)),t=e,o.multi.push(e)}this.records.set(t,r)}hydrate(e,t,r){let o=Me(null);try{if(t.value===_1)throw M0(Ps(e));return t.value===Lh&&(t.value=_1,t.value=t.factory(void 0,r)),typeof t.value=="object"&&t.value&&v6(t.value)&&this._ngOnDestroyHooks.add(t.value),t.value}finally{Me(o)}}injectableDefInScope(e){if(!e.providedIn)return!1;let t=or(e.providedIn);return typeof t=="string"?t==="any"||this.scopes.has(t):this.injectorDefTypes.has(t)}removeOnDestroy(e){let t=this._onDestroyHooks.indexOf(e);t!==-1&&this._onDestroyHooks.splice(t,1)}};function w0(n){let e=Wh(n),t=e!==null?e.factory:Ta(n);if(t!==null)return t;if(n instanceof qe)throw new Te(204,!1);if(n instanceof Function)return g6(n);throw new Te(204,!1)}function g6(n){if(n.length>0)throw new Te(204,!1);let t=n6(n);return t!==null?()=>t.factory(n):()=>new n}function x6(n){if(G1(n))return Hu(void 0,n.useValue);{let e=W1(n);return Hu(e,Lh)}}function W1(n,e,t){let r;if(zh(n)){let o=or(n);return Ta(o)||w0(o)}else if(G1(n))r=()=>or(n.useValue);else if(h6(n))r=()=>n.useFactory(...C0(n.deps||[]));else if(m6(n))r=(o,s)=>Qe(or(n.useExisting),s!==void 0&&s&8?8:void 0);else{let o=or(n&&(n.useClass||n.provide));if(y6(n))r=()=>new o(...C0(n.deps));else return Ta(o)||w0(o)}return r}function Ld(n){if(n.destroyed)throw new Te(205,!1)}function Hu(n,e,t=!1){return{factory:n,value:e,multi:t?[]:void 0}}function y6(n){return!!n.deps}function v6(n){return n!==null&&typeof n=="object"&&typeof n.ngOnDestroy=="function"}function b6(n){return typeof n=="function"||typeof n=="object"&&n.ngMetadataName==="InjectionToken"}function I0(n,e){for(let t of n)Array.isArray(t)?I0(t,e):t&&k0(t)?I0(t.\u0275providers,e):e(t)}function Yh(n,e){let t;n instanceof Sa?(Ld(n),t=n):t=new b0(n);let r,o=po(t),s=_n(void 0);try{return e()}finally{po(o),_n(s)}}function j1(){return O1()!==void 0||Dh()!=null}var Mr=0,we=1,Ie=2,nn=3,hr=4,gr=5,qd=6,qu=7,pn=8,Aa=9,mo=10,Kt=11,Ku=12,z0=13,Ra=14,Or=15,Vs=16,Fa=17,ho=18,Kd=19,H0=20,qo=21,Zh=22,Xo=23,sr=24,Qh=25,Xt=26,q1=1;var Us=7,Xd=8,Ma=9,Cn=10;function Yo(n){return Array.isArray(n)&&typeof n[q1]=="object"}function $r(n){return Array.isArray(n)&&n[q1]===!0}function G0(n){return(n.flags&4)!==0}function Oa(n){return n.componentOffset>-1}function Yd(n){return(n.flags&1)===1}function $a(n){return!!n.template}function Xu(n){return(n[Ie]&512)!==0}function Pa(n){return(n[Ie]&256)===256}var W0="svg",K1="math";function xr(n){for(;Array.isArray(n);)n=n[Mr];return n}function j0(n,e){return xr(e[n])}function Pr(n,e){return xr(e[n.index])}function Zd(n,e){return n.data[e]}function X1(n,e){return n[e]}function q0(n,e,t,r){t>=n.data.length&&(n.data[t]=null,n.blueprint[t]=null),e[t]=r}function go(n,e){let t=e[n];return Yo(t)?t:t[Mr]}function Y1(n){return(n[Ie]&4)===4}function Jh(n){return(n[Ie]&128)===128}function Z1(n){return $r(n[nn])}function xo(n,e){return e==null?null:n[e]}function K0(n){n[Fa]=0}function X0(n){n[Ie]&1024||(n[Ie]|=1024,Jh(n)&&La(n))}function Q1(n,e){for(;n>0;)e=e[Ra],n--;return e}function Qd(n){return!!(n[Ie]&9216||n[sr]?.dirty)}function eg(n){n[mo].changeDetectionScheduler?.notify(8),n[Ie]&64&&(n[Ie]|=1024),Qd(n)&&La(n)}function La(n){n[mo].changeDetectionScheduler?.notify(0);let e=Ls(n);for(;e!==null&&!(e[Ie]&8192||(e[Ie]|=8192,!Jh(e)));)e=Ls(e)}function Y0(n,e){if(Pa(n))throw new Te(911,!1);n[qo]===null&&(n[qo]=[]),n[qo].push(e)}function J1(n,e){if(n[qo]===null)return;let t=n[qo].indexOf(e);t!==-1&&n[qo].splice(t,1)}function Ls(n){let e=n[nn];return $r(e)?e[nn]:e}function Z0(n){return n[qu]??=[]}function Q0(n){return n.cleanup??=[]}function ek(n,e,t,r){let o=Z0(e);o.push(t),n.firstCreatePass&&Q0(n).push(r,o.length-1)}var Be={lFrame:mk(null),bindingsEnabled:!0,skipHydrationRootTNode:null},Jd=(function(n){return n[n.Off=0]="Off",n[n.Exhaustive=1]="Exhaustive",n[n.OnlyDirtyViews=2]="OnlyDirtyViews",n})(Jd||{}),C6=0,E0=!1;function tk(){return Be.lFrame.elementDepthCount}function nk(){Be.lFrame.elementDepthCount++}function J0(){Be.lFrame.elementDepthCount--}function eC(){return Be.bindingsEnabled}function rk(){return Be.skipHydrationRootTNode!==null}function tC(n){return Be.skipHydrationRootTNode===n}function nC(){Be.skipHydrationRootTNode=null}function Je(){return Be.lFrame.lView}function zn(){return Be.lFrame.tView}function Lr(n){return Be.lFrame.contextLView=n,n[pn]}function Br(n){return Be.lFrame.contextLView=null,n}function yr(){let n=rC();for(;n!==null&&n.type===64;)n=n.parent;return n}function rC(){return Be.lFrame.currentTNode}function ok(){let n=Be.lFrame,e=n.currentTNode;return n.isParent?e:e.parent}function Yu(n,e){let t=Be.lFrame;t.currentTNode=n,t.isParent=e}function oC(){return Be.lFrame.isParent}function sk(){Be.lFrame.isParent=!1}function sC(n){D0("Must never be called in production mode"),C6=n}function iC(){return E0}function Zu(n){let e=E0;return E0=n,e}function ik(){let n=Be.lFrame,e=n.bindingRootIndex;return e===-1&&(e=n.bindingRootIndex=n.tView.bindingStartIndex),e}function ak(n){return Be.lFrame.bindingIndex=n}function ef(){return Be.lFrame.bindingIndex++}function ck(n){let e=Be.lFrame,t=e.bindingIndex;return e.bindingIndex=e.bindingIndex+n,t}function lk(){return Be.lFrame.inI18n}function uk(n,e){let t=Be.lFrame;t.bindingIndex=t.bindingRootIndex=n,tg(e)}function pk(){return Be.lFrame.currentDirectiveIndex}function tg(n){Be.lFrame.currentDirectiveIndex=n}function dk(n){let e=Be.lFrame.currentDirectiveIndex;return e===-1?null:n[e]}function aC(){return Be.lFrame.currentQueryIndex}function ng(n){Be.lFrame.currentQueryIndex=n}function w6(n){let e=n[we];return e.type===2?e.declTNode:e.type===1?n[gr]:null}function cC(n,e,t){if(t&4){let o=e,s=n;for(;o=o.parent,o===null&&!(t&1);)if(o=w6(s),o===null||(s=s[Ra],o.type&10))break;if(o===null)return!1;e=o,n=s}let r=Be.lFrame=fk();return r.currentTNode=e,r.lView=n,!0}function rg(n){let e=fk(),t=n[we];Be.lFrame=e,e.currentTNode=t.firstChild,e.lView=n,e.tView=t,e.contextLView=n,e.bindingIndex=t.bindingStartIndex,e.inI18n=!1}function fk(){let n=Be.lFrame,e=n===null?null:n.child;return e===null?mk(n):e}function mk(n){let e={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return n!==null&&(n.child=e),e}function hk(){let n=Be.lFrame;return Be.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}var lC=hk;function og(){let n=hk();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function gk(n){return(Be.lFrame.contextLView=Q1(n,Be.lFrame.contextLView))[pn]}function Ba(){return Be.lFrame.selectedIndex}function zs(n){Be.lFrame.selectedIndex=n}function uC(){let n=Be.lFrame;return Zd(n.tView,n.selectedIndex)}function tf(){Be.lFrame.currentNamespace=W0}function nf(){I6()}function I6(){Be.lFrame.currentNamespace=null}function xk(){return Be.lFrame.currentNamespace}var yk=!0;function sg(){return yk}function ig(n){yk=n}var E6={elements:void 0};function ag(){return E6}function T0(n,e=null,t=null,r){let o=vk(n,e,t,r);return o.resolveInjectorInitializers(),o}function vk(n,e=null,t=null,r,o=new Set){let s=[t||fr,z1(n)];return r=r||(typeof n=="object"?void 0:Ps(n)),new Sa(s,e||jd(),r||null,o)}var Ko=class n{static THROW_IF_NOT_FOUND=Ia;static NULL=new Vd;static create(e,t){if(Array.isArray(e))return T0({name:""},t,e,"");{let r=e.name??"";return T0({name:r},e.parent,e.providers,r)}}static \u0275prov=ut({token:n,providedIn:"any",factory:()=>Qe(P0)});static __NG_ELEMENT_ID__=-1},vr=new qe(""),Va=(()=>{class n{static __NG_ELEMENT_ID__=T6;static __NG_ENV_ID__=t=>t}return n})(),Ud=class extends Va{_lView;constructor(e){super(),this._lView=e}get destroyed(){return Pa(this._lView)}onDestroy(e){let t=this._lView;return Y0(t,e),()=>J1(t,e)}};function T6(){return new Ud(Je())}var Fr=class{_console=console;handleError(e){this._console.error("ERROR",e)}},yo=new qe("",{providedIn:"root",factory:()=>{let n=Ae(mr),e;return t=>{n.destroyed&&!e?setTimeout(()=>{throw t}):(e??=n.get(Fr),e.handleError(t))}}}),bk={provide:Bs,useValue:()=>void Ae(Fr),multi:!0},S6=new qe("",{providedIn:"root",factory:()=>{let n=Ae(vr).defaultView;if(!n)return;let e=Ae(yo),t=s=>{e(s.reason),s.preventDefault()},r=s=>{s.error?e(s.error):e(new Error(s.message,{cause:s})),s.preventDefault()},o=()=>{n.addEventListener("unhandledrejection",t),n.addEventListener("error",r)};typeof Zone<"u"?Zone.root.run(o):o(),Ae(Va).onDestroy(()=>{n.removeEventListener("error",r),n.removeEventListener("unhandledrejection",t)})}});function pC(){return ju([U1(()=>void Ae(S6))])}function rt(n,e){let[t,r,o]=i0(n,e?.equal),s=t,i=s[Vn];return s.set=r,s.update=o,s.asReadonly=dC.bind(s),s}function dC(){let n=this[Vn];if(n.readonlyFn===void 0){let e=()=>this();e[Vn]=n,n.readonlyFn=e}return n.readonlyFn}var fo=class{},rf=new qe("",{providedIn:"root",factory:()=>!1});var fC=new qe(""),cg=new qe("");var of=(()=>{class n{view;node;constructor(t,r){this.view=t,this.node=r}static __NG_ELEMENT_ID__=N6}return n})();function N6(){return new of(Je(),yr())}var Ua=(()=>{class n{taskId=0;pendingTasks=new Set;destroyed=!1;pendingTask=new Pd(!1);get hasPendingTasks(){return this.destroyed?!1:this.pendingTask.value}get hasPendingTasksObservable(){return this.destroyed?new zu(t=>{t.next(!1),t.complete()}):this.pendingTask}add(){!this.hasPendingTasks&&!this.destroyed&&this.pendingTask.next(!0);let t=this.taskId++;return this.pendingTasks.add(t),t}has(t){return this.pendingTasks.has(t)}remove(t){this.pendingTasks.delete(t),this.pendingTasks.size===0&&this.hasPendingTasks&&this.pendingTask.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this.hasPendingTasks&&this.pendingTask.next(!1),this.destroyed=!0,this.pendingTask.unsubscribe()}static \u0275prov=ut({token:n,providedIn:"root",factory:()=>new n})}return n})();function za(...n){}var sf=(()=>{class n{static \u0275prov=ut({token:n,providedIn:"root",factory:()=>new S0})}return n})(),S0=class{dirtyEffectCount=0;queues=new Map;add(e){this.enqueue(e),this.schedule(e)}schedule(e){e.dirty&&this.dirtyEffectCount++}remove(e){let t=e.zone,r=this.queues.get(t);r.has(e)&&(r.delete(e),e.dirty&&this.dirtyEffectCount--)}enqueue(e){let t=e.zone;this.queues.has(t)||this.queues.set(t,new Set);let r=this.queues.get(t);r.has(e)||r.add(e)}flush(){for(;this.dirtyEffectCount>0;){let e=!1;for(let[t,r]of this.queues)t===null?e||=this.flushQueue(r):e||=t.run(()=>this.flushQueue(r));e||(this.dirtyEffectCount=0)}}flushQueue(e){let t=!1;for(let r of e)r.dirty&&(this.dirtyEffectCount--,t=!0,r.run());return t}};function Ng(n){return{toString:n}.toString()}function $6(n){return typeof n=="function"}var mg=class{previousValue;currentValue;firstChange;constructor(e,t,r){this.previousValue=e,this.currentValue=t,this.firstChange=r}isFirstChange(){return this.firstChange}};function Yk(n,e,t,r){e!==null?e.applyValueToInputSignal(e,r):n[t]=r}function P6(n){return n.type.prototype.ngOnChanges&&(n.setInput=B6),L6}function L6(){let n=Qk(this),e=n?.current;if(e){let t=n.previous;if(t===ka)n.previous=e;else for(let r in e)t[r]=e[r];n.current=null,this.ngOnChanges(e)}}function B6(n,e,t,r,o){let s=this.declaredInputs[r],i=Qk(n)||V6(n,{previous:ka,current:null}),a=i.current||(i.current={}),c=i.previous,l=c[s];a[s]=new mg(l&&l.currentValue,t,c===ka),Yk(n,e,o,t)}var Zk="__ngSimpleChanges__";function Qk(n){return n[Zk]||null}function V6(n,e){return n[Zk]=e}var Ck=[];var pt=function(n,e=null,t){for(let r=0;r<Ck.length;r++){let o=Ck[r];o(n,e,t)}};function U6(n,e,t){let{ngOnChanges:r,ngOnInit:o,ngDoCheck:s}=e.type.prototype;if(r){let i=P6(e);(t.preOrderHooks??=[]).push(n,i),(t.preOrderCheckHooks??=[]).push(n,i)}o&&(t.preOrderHooks??=[]).push(0-n,o),s&&((t.preOrderHooks??=[]).push(n,s),(t.preOrderCheckHooks??=[]).push(n,s))}function Jk(n,e){for(let t=e.directiveStart,r=e.directiveEnd;t<r;t++){let s=n.data[t].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:c,ngAfterViewChecked:l,ngOnDestroy:u}=s;i&&(n.contentHooks??=[]).push(-t,i),a&&((n.contentHooks??=[]).push(t,a),(n.contentCheckHooks??=[]).push(t,a)),c&&(n.viewHooks??=[]).push(-t,c),l&&((n.viewHooks??=[]).push(t,l),(n.viewCheckHooks??=[]).push(t,l)),u!=null&&(n.destroyHooks??=[]).push(t,u)}}function ug(n,e,t){e_(n,e,3,t)}function pg(n,e,t,r){(n[Ie]&3)===t&&e_(n,e,t,r)}function mC(n,e){let t=n[Ie];(t&3)===e&&(t&=16383,t+=1,n[Ie]=t)}function e_(n,e,t,r){let o=r!==void 0?n[Fa]&65535:0,s=r??-1,i=e.length-1,a=0;for(let c=o;c<i;c++)if(typeof e[c+1]=="number"){if(a=e[c],r!=null&&a>=r)break}else e[c]<0&&(n[Fa]+=65536),(a<s||s==-1)&&(z6(n,t,e,c),n[Fa]=(n[Fa]&4294901760)+c+2),c++}function wk(n,e){pt(4,n,e);let t=Me(null);try{e.call(n)}finally{Me(t),pt(5,n,e)}}function z6(n,e,t,r){let o=t[r]<0,s=t[r+1],i=o?-t[r]:t[r],a=n[i];o?n[Ie]>>14<n[Fa]>>16&&(n[Ie]&3)===e&&(n[Ie]+=16384,wk(a,s)):wk(a,s)}var Ju=-1,lf=class{factory;name;injectImpl;resolving=!1;canSeeViewProviders;multi;componentProviders;index;providerFactory;constructor(e,t,r,o){this.factory=e,this.name=o,this.canSeeViewProviders=t,this.injectImpl=r}};function H6(n){return(n.flags&8)!==0}function G6(n){return(n.flags&16)!==0}function W6(n,e,t){let r=0;for(;r<t.length;){let o=t[r];if(typeof o=="number"){if(o!==0)break;r++;let s=t[r++],i=t[r++],a=t[r++];n.setAttribute(e,i,a,s)}else{let s=o,i=t[++r];q6(s)?n.setProperty(e,s,i):n.setAttribute(e,s,i),r++}}return r}function j6(n){return n===3||n===4||n===6}function q6(n){return n.charCodeAt(0)===64}function Dg(n,e){if(!(e===null||e.length===0))if(n===null||n.length===0)n=e.slice();else{let t=-1;for(let r=0;r<e.length;r++){let o=e[r];typeof o=="number"?t=o:t===0||(t===-1||t===2?Ik(n,t,o,null,e[++r]):Ik(n,t,o,null,null))}}return n}function Ik(n,e,t,r,o){let s=0,i=n.length;if(e===-1)i=-1;else for(;s<n.length;){let a=n[s++];if(typeof a=="number"){if(a===e){i=-1;break}else if(a>e){i=s-1;break}}}for(;s<n.length;){let a=n[s];if(typeof a=="number")break;if(a===t){o!==null&&(n[s+1]=o);return}s++,o!==null&&s++}i!==-1&&(n.splice(i,0,e),s=i+1),n.splice(s++,0,t),o!==null&&n.splice(s++,0,o)}function t_(n){return n!==Ju}function hg(n){return n&32767}function K6(n){return n>>16}function gg(n,e){let t=K6(n),r=e;for(;t>0;)r=r[Ra],t--;return r}var wC=!0;function xg(n){let e=wC;return wC=n,e}var X6=256,n_=X6-1,r_=5,Y6=0,vo={};function Z6(n,e,t){let r;typeof t=="string"?r=t.charCodeAt(0)||0:t.hasOwnProperty(Da)&&(r=t[Da]),r==null&&(r=t[Da]=Y6++);let o=r&n_,s=1<<o;e.data[n+(o>>r_)]|=s}function o_(n,e){let t=s_(n,e);if(t!==-1)return t;let r=e[we];r.firstCreatePass&&(n.injectorIndex=e.length,hC(r.data,n),hC(e,null),hC(r.blueprint,null));let o=GC(n,e),s=n.injectorIndex;if(t_(o)){let i=hg(o),a=gg(o,e),c=a[we].data;for(let l=0;l<8;l++)e[s+l]=a[i+l]|c[i+l]}return e[s+8]=o,s}function hC(n,e){n.push(0,0,0,0,0,0,0,0,e)}function s_(n,e){return n.injectorIndex===-1||n.parent&&n.parent.injectorIndex===n.injectorIndex||e[n.injectorIndex+8]===null?-1:n.injectorIndex}function GC(n,e){if(n.parent&&n.parent.injectorIndex!==-1)return n.parent.injectorIndex;let t=0,r=null,o=e;for(;o!==null;){if(r=u_(o),r===null)return Ju;if(t++,o=o[Ra],r.injectorIndex!==-1)return r.injectorIndex|t<<16}return Ju}function Q6(n,e,t){Z6(n,e,t)}function i_(n,e,t){if(t&8||n!==void 0)return n;qh(e,"NodeInjector")}function a_(n,e,t,r){if(t&8&&r===void 0&&(r=null),(t&3)===0){let o=n[Aa],s=_n(void 0);try{return o?o.get(e,r,t&8):O0(e,r,t&8)}finally{_n(s)}}return i_(r,e,t)}function c_(n,e,t,r=0,o){if(n!==null){if(e[Ie]&2048&&!(r&2)){let i=n8(n,e,t,r,vo);if(i!==vo)return i}let s=l_(n,e,t,r,vo);if(s!==vo)return s}return a_(e,t,r,o)}function l_(n,e,t,r,o){let s=e8(t);if(typeof s=="function"){if(!cC(e,n,r))return r&1?i_(o,t,r):a_(e,t,r,o);try{let i;if(i=s(r),i==null&&!(r&8))qh(t);else return i}finally{lC()}}else if(typeof s=="number"){let i=null,a=s_(n,e),c=Ju,l=r&1?e[Or][gr]:null;for((a===-1||r&4)&&(c=a===-1?GC(n,e):e[a+8],c===Ju||!Tk(r,!1)?a=-1:(i=e[we],a=hg(c),e=gg(c,e)));a!==-1;){let u=e[we];if(Ek(s,a,u.data)){let p=J6(a,e,t,i,r,l);if(p!==vo)return p}c=e[a+8],c!==Ju&&Tk(r,e[we].data[a+8]===l)&&Ek(s,a,e)?(i=u,a=hg(c),e=gg(c,e)):a=-1}}return o}function J6(n,e,t,r,o,s){let i=e[we],a=i.data[n+8],c=r==null?Oa(a)&&wC:r!=i&&(a.type&3)!==0,l=o&1&&s===a,u=dg(a,i,t,c,l);return u!==null?yg(e,i,u,a,o):vo}function dg(n,e,t,r,o){let s=n.providerIndexes,i=e.data,a=s&1048575,c=n.directiveStart,l=n.directiveEnd,u=s>>20,p=r?a:a+u,d=o?a+u:l;for(let f=p;f<d;f++){let m=i[f];if(f<c&&t===m||f>=c&&m.type===t)return f}if(o){let f=i[c];if(f&&$a(f)&&f.type===t)return c}return null}function yg(n,e,t,r,o){let s=n[t],i=e.data;if(s instanceof lf){let a=s;if(a.resolving){let f=Vh(i[t]);throw M0(f)}let c=xg(a.canSeeViewProviders);a.resolving=!0;let l=i[t].type||i[t],u,p=a.injectImpl?_n(a.injectImpl):null,d=cC(n,r,0);try{s=n[t]=a.factory(void 0,o,i,n,r),e.firstCreatePass&&t>=r.directiveStart&&U6(t,i[t],e)}finally{p!==null&&_n(p),xg(c),a.resolving=!1,lC()}}return s}function e8(n){if(typeof n=="string")return n.charCodeAt(0)||0;let e=n.hasOwnProperty(Da)?n[Da]:void 0;return typeof e=="number"?e>=0?e&n_:t8:e}function Ek(n,e,t){let r=1<<n;return!!(t[e+(n>>r_)]&r)}function Tk(n,e){return!(n&2)&&!(n&1&&e)}var Ga=class{_tNode;_lView;constructor(e,t){this._tNode=e,this._lView=t}get(e,t,r){return c_(this._tNode,this._lView,e,Ea(r),t)}};function t8(){return new Ga(yr(),Je())}function n8(n,e,t,r,o){let s=n,i=e;for(;s!==null&&i!==null&&i[Ie]&2048&&!Xu(i);){let a=l_(s,i,t,r|2,vo);if(a!==vo)return a;let c=s.parent;if(!c){let l=i[H0];if(l){let u=l.get(t,vo,r);if(u!==vo)return u}c=u_(i),i=i[Ra]}s=c}return o}function u_(n){let e=n[we],t=e.type;return t===2?e.declTNode:t===1?n[gr]:null}function r8(){return rp(yr(),Je())}function rp(n,e){return new op(Pr(n,e))}var op=(()=>{class n{nativeElement;constructor(t){this.nativeElement=t}static __NG_ELEMENT_ID__=r8}return n})();function o8(n){return n instanceof op?n.nativeElement:n}function s8(){return this._results[Symbol.iterator]()}var vg=class{_emitDistinctChangesOnly;dirty=!0;_onDirty=void 0;_results=[];_changesDetected=!1;_changes=void 0;length=0;first=void 0;last=void 0;get changes(){return this._changes??=new $s}constructor(e=!1){this._emitDistinctChangesOnly=e}get(e){return this._results[e]}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,t){return this._results.reduce(e,t)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e,t){this.dirty=!1;let r=P1(e);(this._changesDetected=!$1(this._results,r,t))&&(this._results=r,this.length=r.length,this.last=r[this.length-1],this.first=r[0])}notifyOnChanges(){this._changes!==void 0&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.next(this)}onDirty(e){this._onDirty=e}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){this._changes!==void 0&&(this._changes.complete(),this._changes.unsubscribe())}[Symbol.iterator]=s8};function p_(n){return(n.flags&128)===128}var WC=(function(n){return n[n.OnPush=0]="OnPush",n[n.Default=1]="Default",n})(WC||{}),d_=new Map,i8=0;function a8(){return i8++}function c8(n){d_.set(n[Kd],n)}function IC(n){d_.delete(n[Kd])}var Sk="__ngContext__";function ep(n,e){Yo(e)?(n[Sk]=e[Kd],c8(e)):n[Sk]=e}function f_(n){return h_(n[Ku])}function m_(n){return h_(n[hr])}function h_(n){for(;n!==null&&!$r(n);)n=n[hr];return n}var EC;function jC(n){EC=n}function g_(){if(EC!==void 0)return EC;if(typeof document<"u")return document;throw new Te(210,!1)}var kg=new qe("",{providedIn:"root",factory:()=>l8}),l8="ng",_g=new qe(""),sp=new qe("",{providedIn:"platform",factory:()=>"unknown"});var Ag=new qe("",{providedIn:"root",factory:()=>g_().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});var u8="h",p8="b";var x_=!1,y_=new qe("",{providedIn:"root",factory:()=>x_});var d8=(n,e,t,r)=>{};function f8(n,e,t,r){d8(n,e,t,r)}function qC(n){return(n.flags&32)===32}var m8=()=>null;function v_(n,e,t=!1){return m8(n,e,t)}function b_(n,e){let t=n.contentQueries;if(t!==null){let r=Me(null);try{for(let o=0;o<t.length;o+=2){let s=t[o],i=t[o+1];if(i!==-1){let a=n.data[i];ng(s),a.contentQueries(2,e[i],i)}}}finally{Me(r)}}}function TC(n,e,t){ng(0);let r=Me(null);try{e(n,t)}finally{Me(r)}}function C_(n,e,t){if(G0(e)){let r=Me(null);try{let o=e.directiveStart,s=e.directiveEnd;for(let i=o;i<s;i++){let a=n.data[i];if(a.contentQueries){let c=t[i];a.contentQueries(1,c,i)}}}finally{Me(r)}}}var Qo=(function(n){return n[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",n})(Qo||{});var bg=class{changingThisBreaksApplicationSecurity;constructor(e){this.changingThisBreaksApplicationSecurity=e}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Hh})`}};function KC(n){return n instanceof bg?n.changingThisBreaksApplicationSecurity:n}function w_(n,e){let t=I_(n);if(t!=null&&t!==e){if(t==="ResourceURL"&&e==="URL")return!0;throw new Error(`Required a safe ${e}, got a ${t} (see ${Hh})`)}return t===e}function I_(n){return n instanceof bg&&n.getTypeName()||null}var h8=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;function E_(n){return n=String(n),n.match(h8)?n:"unsafe:"+n}var XC=(function(n){return n[n.NONE=0]="NONE",n[n.HTML=1]="HTML",n[n.STYLE=2]="STYLE",n[n.SCRIPT=3]="SCRIPT",n[n.URL=4]="URL",n[n.RESOURCE_URL=5]="RESOURCE_URL",n})(XC||{});function YC(n){let e=g8();return e?e.sanitize(XC.URL,n)||"":w_(n,"URL")?KC(n):E_(Hd(n))}function g8(){let n=Je();return n&&n[mo].sanitizer}function x8(n,e,t){let r=n.length;for(;;){let o=n.indexOf(e,t);if(o===-1)return o;if(o===0||n.charCodeAt(o-1)<=32){let s=e.length;if(o+s===r||n.charCodeAt(o+s)<=32)return o}t=o+1}}var T_="ng-template";function y8(n,e,t,r){let o=0;if(r){for(;o<e.length&&typeof e[o]=="string";o+=2)if(e[o]==="class"&&x8(e[o+1].toLowerCase(),t,0)!==-1)return!0}else if(ZC(n))return!1;if(o=e.indexOf(1,o),o>-1){let s;for(;++o<e.length&&typeof(s=e[o])=="string";)if(s.toLowerCase()===t)return!0}return!1}function ZC(n){return n.type===4&&n.value!==T_}function v8(n,e,t){let r=n.type===4&&!t?T_:n.value;return e===r}function b8(n,e,t){let r=4,o=n.attrs,s=o!==null?I8(o):0,i=!1;for(let a=0;a<e.length;a++){let c=e[a];if(typeof c=="number"){if(!i&&!Vr(r)&&!Vr(c))return!1;if(i&&Vr(c))continue;i=!1,r=c|r&1;continue}if(!i)if(r&4){if(r=2|r&1,c!==""&&!v8(n,c,t)||c===""&&e.length===1){if(Vr(r))return!1;i=!0}}else if(r&8){if(o===null||!y8(n,o,c,t)){if(Vr(r))return!1;i=!0}}else{let l=e[++a],u=C8(c,o,ZC(n),t);if(u===-1){if(Vr(r))return!1;i=!0;continue}if(l!==""){let p;if(u>s?p="":p=o[u+1].toLowerCase(),r&2&&l!==p){if(Vr(r))return!1;i=!0}}}}return Vr(r)||i}function Vr(n){return(n&1)===0}function C8(n,e,t,r){if(e===null)return-1;let o=0;if(r||!t){let s=!1;for(;o<e.length;){let i=e[o];if(i===n)return o;if(i===3||i===6)s=!0;else if(i===1||i===2){let a=e[++o];for(;typeof a=="string";)a=e[++o];continue}else{if(i===4)break;if(i===0){o+=4;continue}}o+=s?1:2}return-1}else return E8(e,n)}function w8(n,e,t=!1){for(let r=0;r<e.length;r++)if(b8(n,e[r],t))return!0;return!1}function I8(n){for(let e=0;e<n.length;e++){let t=n[e];if(j6(t))return e}return n.length}function E8(n,e){let t=n.indexOf(4);if(t>-1)for(t++;t<n.length;){let r=n[t];if(typeof r=="number")return-1;if(r===e)return t;t++}return-1}function Nk(n,e){return n?":not("+e.trim()+")":e}function T8(n){let e=n[0],t=1,r=2,o="",s=!1;for(;t<n.length;){let i=n[t];if(typeof i=="string")if(r&2){let a=n[++t];o+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else r&8?o+="."+i:r&4&&(o+=" "+i);else o!==""&&!Vr(i)&&(e+=Nk(s,o),o=""),r=i,s=s||!Vr(r);t++}return o!==""&&(e+=Nk(s,o)),e}function S8(n){return n.map(T8).join(",")}function N8(n){let e=[],t=[],r=1,o=2;for(;r<n.length;){let s=n[r];if(typeof s=="string")o===2?s!==""&&e.push(s,n[++r]):o===8&&t.push(s);else{if(!Vr(o))break;o=s}r++}return t.length&&e.push(1,...t),e}var Co={};function D8(n,e){return n.createText(e)}function k8(n,e,t){n.setValue(e,t)}function S_(n,e,t){return n.createElement(e,t)}function Cg(n,e,t,r,o){n.insertBefore(e,t,r,o)}function N_(n,e,t){n.appendChild(e,t)}function Dk(n,e,t,r,o){r!==null?Cg(n,e,t,r,o):N_(n,e,t)}function _8(n,e,t){n.removeChild(null,e,t)}function A8(n,e,t){n.setAttribute(e,"style",t)}function R8(n,e,t){t===""?n.removeAttribute(e,"class"):n.setAttribute(e,"class",t)}function D_(n,e,t){let{mergedAttrs:r,classes:o,styles:s}=t;r!==null&&W6(n,e,r),o!==null&&R8(n,e,o),s!==null&&A8(n,e,s)}function QC(n,e,t,r,o,s,i,a,c,l,u){let p=Xt+r,d=p+o,f=F8(p,d),m=typeof l=="function"?l():l;return f[we]={type:n,blueprint:f,template:t,queries:null,viewQuery:a,declTNode:e,data:f.slice().fill(null,p),bindingStartIndex:p,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:typeof s=="function"?s():s,pipeRegistry:typeof i=="function"?i():i,firstChild:null,schemas:c,consts:m,incompleteFirstPass:!1,ssrId:u}}function F8(n,e){let t=[];for(let r=0;r<e;r++)t.push(r<n?null:Co);return t}function M8(n){let e=n.tView;return e===null||e.incompleteFirstPass?n.tView=QC(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts,n.id):e}function JC(n,e,t,r,o,s,i,a,c,l,u){let p=e.blueprint.slice();return p[Mr]=o,p[Ie]=r|4|128|8|64|1024,(l!==null||n&&n[Ie]&2048)&&(p[Ie]|=2048),K0(p),p[nn]=p[Ra]=n,p[pn]=t,p[mo]=i||n&&n[mo],p[Kt]=a||n&&n[Kt],p[Aa]=c||n&&n[Aa]||null,p[gr]=s,p[Kd]=a8(),p[qd]=u,p[H0]=l,p[Or]=e.type==2?n[Or]:p,p}function O8(n,e,t){let r=Pr(e,n),o=M8(t),s=n[mo].rendererFactory,i=ew(n,JC(n,o,null,k_(t),r,e,null,s.createRenderer(r,t),null,null,null));return n[e.index]=i}function k_(n){let e=16;return n.signals?e=4096:n.onPush&&(e=64),e}function __(n,e,t,r){if(t===0)return-1;let o=e.length;for(let s=0;s<t;s++)e.push(r),n.blueprint.push(r),n.data.push(null);return o}function ew(n,e){return n[Ku]?n[z0][hr]=e:n[Ku]=e,n[z0]=e,e}function Xe(n=1){A_(zn(),Je(),Ba()+n,!1)}function A_(n,e,t,r){if(!r)if((e[Ie]&3)===3){let s=n.preOrderCheckHooks;s!==null&&ug(e,s,t)}else{let s=n.preOrderHooks;s!==null&&pg(e,s,0,t)}zs(t)}var Rg=(function(n){return n[n.None=0]="None",n[n.SignalBased=1]="SignalBased",n[n.HasDecoratorInputTransform=2]="HasDecoratorInputTransform",n})(Rg||{});function SC(n,e,t,r){let o=Me(null);try{let[s,i,a]=n.inputs[t],c=null;(i&Rg.SignalBased)!==0&&(c=e[s][Vn]),c!==null&&c.transformFn!==void 0?r=c.transformFn(r):a!==null&&(r=a.call(e,r)),n.setInput!==null?n.setInput(e,c,r,t,s):Yk(e,c,s,r)}finally{Me(o)}}var bo=(function(n){return n[n.Important=1]="Important",n[n.DashCase=2]="DashCase",n})(bo||{}),$8;function tw(n,e){return $8(n,e)}function Qu(n,e,t,r,o){if(r!=null){let s,i=!1;$r(r)?s=r:Yo(r)&&(i=!0,r=r[Mr]);let a=xr(r);n===0&&t!==null?o==null?N_(e,t,a):Cg(e,t,a,o||null,!0):n===1&&t!==null?Cg(e,t,a,o||null,!0):n===2?_8(e,a,i):n===3&&e.destroyNode(a),s!=null&&K8(e,n,s,t,o)}}function P8(n,e){R_(n,e),e[Mr]=null,e[gr]=null}function L8(n,e,t,r,o,s){r[Mr]=o,r[gr]=e,Fg(n,r,t,1,o,s)}function R_(n,e){e[mo].changeDetectionScheduler?.notify(9),Fg(n,e,e[Kt],2,null,null)}function B8(n){let e=n[Ku];if(!e)return gC(n[we],n);for(;e;){let t=null;if(Yo(e))t=e[Ku];else{let r=e[Cn];r&&(t=r)}if(!t){for(;e&&!e[hr]&&e!==n;)Yo(e)&&gC(e[we],e),e=e[nn];e===null&&(e=n),Yo(e)&&gC(e[we],e),t=e&&e[hr]}e=t}}function nw(n,e){let t=n[Ma],r=t.indexOf(e);t.splice(r,1)}function rw(n,e){if(Pa(e))return;let t=e[Kt];t.destroyNode&&Fg(n,e,t,3,null,null),B8(e)}function gC(n,e){if(Pa(e))return;let t=Me(null);try{e[Ie]&=-129,e[Ie]|=256,e[sr]&&ba(e[sr]),U8(n,e),V8(n,e),e[we].type===1&&e[Kt].destroy();let r=e[Vs];if(r!==null&&$r(e[nn])){r!==e[nn]&&nw(r,e);let o=e[ho];o!==null&&o.detachView(n)}IC(e)}finally{Me(t)}}function V8(n,e){let t=n.cleanup,r=e[qu];if(t!==null)for(let i=0;i<t.length-1;i+=2)if(typeof t[i]=="string"){let a=t[i+3];a>=0?r[a]():r[-a].unsubscribe(),i+=2}else{let a=r[t[i+1]];t[i].call(a)}r!==null&&(e[qu]=null);let o=e[qo];if(o!==null){e[qo]=null;for(let i=0;i<o.length;i++){let a=o[i];a()}}let s=e[Xo];if(s!==null){e[Xo]=null;for(let i of s)i.destroy()}}function U8(n,e){let t;if(n!=null&&(t=n.destroyHooks)!=null)for(let r=0;r<t.length;r+=2){let o=e[t[r]];if(!(o instanceof lf)){let s=t[r+1];if(Array.isArray(s))for(let i=0;i<s.length;i+=2){let a=o[s[i]],c=s[i+1];pt(4,a,c);try{c.call(a)}finally{pt(5,a,c)}}else{pt(4,o,s);try{s.call(o)}finally{pt(5,o,s)}}}}}function z8(n,e,t){return H8(n,e.parent,t)}function H8(n,e,t){let r=e;for(;r!==null&&r.type&168;)e=r,r=e.parent;if(r===null)return t[Mr];if(Oa(r)){let{encapsulation:o}=n.data[r.directiveStart+r.componentOffset];if(o===Qo.None||o===Qo.Emulated)return null}return Pr(r,t)}function G8(n,e,t){return j8(n,e,t)}function W8(n,e,t){return n.type&40?Pr(n,t):null}var j8=W8,kk;function ow(n,e,t,r){let o=z8(n,r,e),s=e[Kt],i=r.parent||e[gr],a=G8(i,r,e);if(o!=null)if(Array.isArray(t))for(let c=0;c<t.length;c++)Dk(s,o,t[c],a,!1);else Dk(s,o,t,a,!1);kk!==void 0&&kk(s,r,e,t,o)}function af(n,e){if(e!==null){let t=e.type;if(t&3)return Pr(e,n);if(t&4)return NC(-1,n[e.index]);if(t&8){let r=e.child;if(r!==null)return af(n,r);{let o=n[e.index];return $r(o)?NC(-1,o):xr(o)}}else{if(t&128)return af(n,e.next);if(t&32)return tw(e,n)()||xr(n[e.index]);{let r=F_(n,e);if(r!==null){if(Array.isArray(r))return r[0];let o=Ls(n[Or]);return af(o,r)}else return af(n,e.next)}}}return null}function F_(n,e){if(e!==null){let r=n[Or][gr],o=e.projection;return r.projection[o]}return null}function NC(n,e){let t=Cn+n+1;if(t<e.length){let r=e[t],o=r[we].firstChild;if(o!==null)return af(r,o)}return e[Us]}function sw(n,e,t,r,o,s,i){for(;t!=null;){if(t.type===128){t=t.next;continue}let a=r[t.index],c=t.type;if(i&&e===0&&(a&&ep(xr(a),r),t.flags|=2),!qC(t))if(c&8)sw(n,e,t.child,r,o,s,!1),Qu(e,n,o,a,s);else if(c&32){let l=tw(t,r),u;for(;u=l();)Qu(e,n,o,u,s);Qu(e,n,o,a,s)}else c&16?q8(n,e,r,t,o,s):Qu(e,n,o,a,s);t=i?t.projectionNext:t.next}}function Fg(n,e,t,r,o,s){sw(t,r,n.firstChild,e,o,s,!1)}function q8(n,e,t,r,o,s){let i=t[Or],c=i[gr].projection[r.projection];if(Array.isArray(c))for(let l=0;l<c.length;l++){let u=c[l];Qu(e,n,o,u,s)}else{let l=c,u=i[nn];p_(r)&&(l.flags|=128),sw(n,e,l,u,o,s,!0)}}function K8(n,e,t,r,o){let s=t[Us],i=xr(t);s!==i&&Qu(e,n,r,s,o);for(let a=Cn;a<t.length;a++){let c=t[a];Fg(c[we],c,n,e,r,s)}}function X8(n,e,t,r,o){if(e)o?n.addClass(t,r):n.removeClass(t,r);else{let s=r.indexOf("-")===-1?void 0:bo.DashCase;o==null?n.removeStyle(t,r,s):(typeof o=="string"&&o.endsWith("!important")&&(o=o.slice(0,-10),s|=bo.Important),n.setStyle(t,r,o,s))}}function M_(n,e,t,r,o){let s=Ba(),i=r&2;try{zs(-1),i&&e.length>Xt&&A_(n,e,Xt,!1),pt(i?2:0,o,t),t(r,o)}finally{zs(s),pt(i?3:1,o,t)}}function iw(n,e,t){r5(n,e,t),(t.flags&64)===64&&o5(n,e,t)}function Mg(n,e,t=Pr){let r=e.localNames;if(r!==null){let o=e.index+1;for(let s=0;s<r.length;s+=2){let i=r[s+1],a=i===-1?t(e,n):n[i];n[o++]=a}}}function Y8(n,e,t,r){let s=r.get(y_,x_)||t===Qo.ShadowDom,i=n.selectRootElement(e,s);return Z8(i),i}function Z8(n){Q8(n)}var Q8=()=>null;function J8(n){return n==="class"?"className":n==="for"?"htmlFor":n==="formaction"?"formAction":n==="innerHtml"?"innerHTML":n==="readonly"?"readOnly":n==="tabindex"?"tabIndex":n}function e5(n,e,t,r,o,s){let i=e[we];if(aw(n,i,e,t,r)){Oa(n)&&n5(e,n.index);return}n.type&3&&(t=J8(t)),t5(n,e,t,r,o,s)}function t5(n,e,t,r,o,s){if(n.type&3){let i=Pr(n,e);r=s!=null?s(r,n.value||"",t):r,o.setProperty(i,t,r)}else n.type&12}function n5(n,e){let t=go(e,n);t[Ie]&16||(t[Ie]|=64)}function r5(n,e,t){let r=t.directiveStart,o=t.directiveEnd;Oa(t)&&O8(e,t,n.data[r+t.componentOffset]),n.firstCreatePass||o_(t,e);let s=t.initialInputs;for(let i=r;i<o;i++){let a=n.data[i],c=yg(e,n,i,t);if(ep(c,e),s!==null&&c5(e,i-r,c,a,t,s),$a(a)){let l=go(t.index,e);l[pn]=yg(e,n,i,t)}}}function o5(n,e,t){let r=t.directiveStart,o=t.directiveEnd,s=t.index,i=pk();try{zs(s);for(let a=r;a<o;a++){let c=n.data[a],l=e[a];tg(a),(c.hostBindings!==null||c.hostVars!==0||c.hostAttrs!==null)&&s5(c,l)}}finally{zs(-1),tg(i)}}function s5(n,e){n.hostBindings!==null&&n.hostBindings(1,e)}function O_(n,e){let t=n.directiveRegistry,r=null;if(t)for(let o=0;o<t.length;o++){let s=t[o];w8(e,s.selectors,!1)&&(r??=[],$a(s)?r.unshift(s):r.push(s))}return r}function i5(n,e,t,r,o,s){let i=Pr(n,e);a5(e[Kt],i,s,n.value,t,r,o)}function a5(n,e,t,r,o,s,i){if(s==null)n.removeAttribute(e,o,t);else{let a=i==null?Hd(s):i(s,r||"",o);n.setAttribute(e,o,a,t)}}function c5(n,e,t,r,o,s){let i=s[e];if(i!==null)for(let a=0;a<i.length;a+=2){let c=i[a],l=i[a+1];SC(r,t,c,l)}}function $_(n,e,t,r,o){let s=Xt+t,i=e[we],a=o(i,e,n,r,t);e[s]=a,Yu(n,!0);let c=n.type===2;return c?(D_(e[Kt],a,n),(tk()===0||Yd(n))&&ep(a,e),nk()):ep(a,e),sg()&&(!c||!qC(n))&&ow(i,e,a,n),n}function P_(n){let e=n;return oC()?sk():(e=e.parent,Yu(e,!1)),e}function l5(n,e){let t=n[Aa];if(!t)return;let r;try{r=t.get(yo,null)}catch{r=null}r?.(e)}function aw(n,e,t,r,o){let s=n.inputs?.[r],i=n.hostDirectiveInputs?.[r],a=!1;if(i)for(let c=0;c<i.length;c+=2){let l=i[c],u=i[c+1],p=e.data[l];SC(p,t[l],u,o),a=!0}if(s)for(let c of s){let l=t[c],u=e.data[c];SC(u,l,r,o),a=!0}return a}function u5(n,e){let t=go(e,n),r=t[we];p5(r,t);let o=t[Mr];o!==null&&t[qd]===null&&(t[qd]=v_(o,t[Aa])),pt(18),cw(r,t,t[pn]),pt(19,t[pn])}function p5(n,e){for(let t=e.length;t<n.blueprint.length;t++)e.push(n.blueprint[t])}function cw(n,e,t){rg(e);try{let r=n.viewQuery;r!==null&&TC(1,r,t);let o=n.template;o!==null&&M_(n,e,o,1,t),n.firstCreatePass&&(n.firstCreatePass=!1),e[ho]?.finishViewCreation(n),n.staticContentQueries&&b_(n,e),n.staticViewQueries&&TC(2,n.viewQuery,t);let s=n.components;s!==null&&d5(e,s)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{e[Ie]&=-5,og()}}function d5(n,e){for(let t=0;t<e.length;t++)u5(n,e[t])}function L_(n,e,t,r){let o=Me(null);try{let s=e.tView,a=n[Ie]&4096?4096:16,c=JC(n,s,t,a,null,e,null,null,r?.injector??null,r?.embeddedViewInjector??null,r?.dehydratedView??null),l=n[e.index];c[Vs]=l;let u=n[ho];return u!==null&&(c[ho]=u.createEmbeddedView(s)),cw(s,c,t),c}finally{Me(o)}}function DC(n,e){return!e||e.firstChild===null||p_(n)}var _k=!1,f5=new qe("");function uf(n,e,t,r,o=!1){for(;t!==null;){if(t.type===128){t=o?t.projectionNext:t.next;continue}let s=e[t.index];s!==null&&r.push(xr(s)),$r(s)&&B_(s,r);let i=t.type;if(i&8)uf(n,e,t.child,r);else if(i&32){let a=tw(t,e),c;for(;c=a();)r.push(c)}else if(i&16){let a=F_(e,t);if(Array.isArray(a))r.push(...a);else{let c=Ls(e[Or]);uf(c[we],c,a,r,!0)}}t=o?t.projectionNext:t.next}return r}function B_(n,e){for(let t=Cn;t<n.length;t++){let r=n[t],o=r[we].firstChild;o!==null&&uf(r[we],r,o,e)}n[Us]!==n[Mr]&&e.push(n[Us])}function V_(n){if(n[Qh]!==null){for(let e of n[Qh])e.impl.addSequence(e);n[Qh].length=0}}var U_=[];function m5(n){return n[sr]??h5(n)}function h5(n){let e=U_.pop()??Object.create(x5);return e.lView=n,e}function g5(n){n.lView[sr]!==n&&(n.lView=null,U_.push(n))}var x5=Lt(Rt({},Mu),{consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:n=>{La(n.lView)},consumerOnSignalRead(){this.lView[sr]=this}});function y5(n){let e=n[sr]??Object.create(v5);return e.lView=n,e}var v5=Lt(Rt({},Mu),{consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:n=>{let e=Ls(n.lView);for(;e&&!z_(e[we]);)e=Ls(e);e&&X0(e)},consumerOnSignalRead(){this.lView[sr]=this}});function z_(n){return n.type!==2}function H_(n){if(n[Xo]===null)return;let e=!0;for(;e;){let t=!1;for(let r of n[Xo])r.dirty&&(t=!0,r.zone===null||Zone.current===r.zone?r.run():r.zone.run(()=>r.run()));e=t&&!!(n[Ie]&8192)}}var b5=100;function lw(n,e=0){let r=n[mo].rendererFactory,o=!1;o||r.begin?.();try{C5(n,e)}finally{o||r.end?.()}}function C5(n,e){let t=iC();try{Zu(!0),kC(n,e);let r=0;for(;Qd(n);){if(r===b5)throw new Te(103,!1);r++,kC(n,1)}}finally{Zu(t)}}function G_(n,e){sC(e?Jd.Exhaustive:Jd.OnlyDirtyViews);try{lw(n)}finally{sC(Jd.Off)}}function w5(n,e,t,r){if(Pa(e))return;let o=e[Ie],s=!1,i=!1;rg(e);let a=!0,c=null,l=null;s||(z_(n)?(l=m5(e),c=Ou(l)):Ah()===null?(a=!1,l=y5(e),c=Ou(l)):e[sr]&&(ba(e[sr]),e[sr]=null));try{K0(e),ak(n.bindingStartIndex),t!==null&&M_(n,e,t,2,r);let u=(o&3)===3;if(!s)if(u){let f=n.preOrderCheckHooks;f!==null&&ug(e,f,null)}else{let f=n.preOrderHooks;f!==null&&pg(e,f,0,null),mC(e,0)}if(i||I5(e),H_(e),W_(e,0),n.contentQueries!==null&&b_(n,e),!s)if(u){let f=n.contentCheckHooks;f!==null&&ug(e,f)}else{let f=n.contentHooks;f!==null&&pg(e,f,1),mC(e,1)}T5(n,e);let p=n.components;p!==null&&q_(e,p,0);let d=n.viewQuery;if(d!==null&&TC(2,d,r),!s)if(u){let f=n.viewCheckHooks;f!==null&&ug(e,f)}else{let f=n.viewHooks;f!==null&&pg(e,f,2),mC(e,2)}if(n.firstUpdatePass===!0&&(n.firstUpdatePass=!1),e[Zh]){for(let f of e[Zh])f();e[Zh]=null}s||(V_(e),e[Ie]&=-73)}catch(u){throw s||La(e),u}finally{l!==null&&(Od(l,c),a&&g5(l)),og()}}function W_(n,e){for(let t=f_(n);t!==null;t=m_(t))for(let r=Cn;r<t.length;r++){let o=t[r];j_(o,e)}}function I5(n){for(let e=f_(n);e!==null;e=m_(e)){if(!(e[Ie]&2))continue;let t=e[Ma];for(let r=0;r<t.length;r++){let o=t[r];X0(o)}}}function E5(n,e,t){pt(18);let r=go(e,n);j_(r,t),pt(19,r[pn])}function j_(n,e){Jh(n)&&kC(n,e)}function kC(n,e){let r=n[we],o=n[Ie],s=n[sr],i=!!(e===0&&o&16);if(i||=!!(o&64&&e===0),i||=!!(o&1024),i||=!!(s?.dirty&&$u(s)),i||=!1,s&&(s.dirty=!1),n[Ie]&=-9217,i)w5(r,n,r.template,n[pn]);else if(o&8192){let a=Me(null);try{H_(n),W_(n,1);let c=r.components;c!==null&&q_(n,c,1),V_(n)}finally{Me(a)}}}function q_(n,e,t){for(let r=0;r<e.length;r++)E5(n,e[r],t)}function T5(n,e){let t=n.hostBindingOpCodes;if(t!==null)try{for(let r=0;r<t.length;r++){let o=t[r];if(o<0)zs(~o);else{let s=o,i=t[++r],a=t[++r];uk(i,s);let c=e[s];pt(24,c),a(2,c),pt(25,c)}}}finally{zs(-1)}}function uw(n,e){let t=iC()?64:1088;for(n[mo].changeDetectionScheduler?.notify(e);n;){n[Ie]|=t;let r=Ls(n);if(Xu(n)&&!r)return n;n=r}return null}function K_(n,e,t,r){return[n,!0,0,e,null,r,null,t,null,null]}function S5(n,e){let t=Cn+e;if(t<n.length)return n[t]}function X_(n,e,t,r=!0){let o=e[we];if(D5(o,e,n,t),r){let i=NC(t,n),a=e[Kt],c=a.parentNode(n[Us]);c!==null&&L8(o,n[gr],a,e,c,i)}let s=e[qd];s!==null&&s.firstChild!==null&&(s.firstChild=null)}function N5(n,e){let t=wg(n,e);return t!==void 0&&rw(t[we],t),t}function wg(n,e){if(n.length<=Cn)return;let t=Cn+e,r=n[t];if(r){let o=r[Vs];o!==null&&o!==n&&nw(o,r),e>0&&(n[t-1][hr]=r[hr]);let s=Gd(n,Cn+e);P8(r[we],r);let i=s[ho];i!==null&&i.detachView(s[we]),r[nn]=null,r[hr]=null,r[Ie]&=-129}return r}function D5(n,e,t,r){let o=Cn+r,s=t.length;r>0&&(t[o-1][hr]=e),r<s-Cn?(e[hr]=t[o],$0(t,Cn+r,e)):(t.push(e),e[hr]=null),e[nn]=t;let i=e[Vs];i!==null&&t!==i&&Y_(i,e);let a=e[ho];a!==null&&a.insertView(n),eg(e),e[Ie]|=128}function Y_(n,e){let t=n[Ma],r=e[nn];if(Yo(r))n[Ie]|=2;else{let o=r[nn][Or];e[Or]!==o&&(n[Ie]|=2)}t===null?n[Ma]=[e]:t.push(e)}var tp=class{_lView;_cdRefInjectingView;_appRef=null;_attachedToViewContainer=!1;exhaustive;get rootNodes(){let e=this._lView,t=e[we];return uf(t,e,t.firstChild,[])}constructor(e,t){this._lView=e,this._cdRefInjectingView=t}get context(){return this._lView[pn]}set context(e){this._lView[pn]=e}get destroyed(){return Pa(this._lView)}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){let e=this._lView[nn];if($r(e)){let t=e[Xd],r=t?t.indexOf(this):-1;r>-1&&(wg(e,r),Gd(t,r))}this._attachedToViewContainer=!1}rw(this._lView[we],this._lView)}onDestroy(e){Y0(this._lView,e)}markForCheck(){uw(this._cdRefInjectingView||this._lView,4)}detach(){this._lView[Ie]&=-129}reattach(){eg(this._lView),this._lView[Ie]|=128}detectChanges(){this._lView[Ie]|=1024,lw(this._lView)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Te(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;let e=Xu(this._lView),t=this._lView[Vs];t!==null&&!e&&nw(t,this._lView),R_(this._lView[we],this._lView)}attachToAppRef(e){if(this._attachedToViewContainer)throw new Te(902,!1);this._appRef=e;let t=Xu(this._lView),r=this._lView[Vs];r!==null&&!t&&Y_(r,this._lView),eg(this._lView)}};var Wa=(()=>{class n{_declarationLView;_declarationTContainer;elementRef;static __NG_ELEMENT_ID__=k5;constructor(t,r,o){this._declarationLView=t,this._declarationTContainer=r,this.elementRef=o}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,r){return this.createEmbeddedViewImpl(t,r)}createEmbeddedViewImpl(t,r,o){let s=L_(this._declarationLView,this._declarationTContainer,t,{embeddedViewInjector:r,dehydratedView:o});return new tp(s)}}return n})();function k5(){return pw(yr(),Je())}function pw(n,e){return n.type&4?new Wa(e,n,rp(n,e)):null}function gf(n,e,t,r,o){let s=n.data[e];if(s===null)s=_5(n,e,t,r,o),lk()&&(s.flags|=32);else if(s.type&64){s.type=t,s.value=r,s.attrs=o;let i=ok();s.injectorIndex=i===null?-1:i.injectorIndex}return Yu(s,!0),s}function _5(n,e,t,r,o){let s=rC(),i=oC(),a=i?s:s&&s.parent,c=n.data[e]=R5(n,a,t,e,r,o);return A5(n,c,s,i),c}function A5(n,e,t,r){n.firstChild===null&&(n.firstChild=e),t!==null&&(r?t.child==null&&e.parent!==null&&(t.child=e):t.next===null&&(t.next=e,e.prev=t))}function R5(n,e,t,r,o,s){let i=e?e.injectorIndex:-1,a=0;return rk()&&(a|=128),{type:t,index:r,insertBeforeIndex:null,injectorIndex:i,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:o,attrs:s,mergedAttrs:null,localNames:null,initialInputs:null,inputs:null,hostDirectiveInputs:null,outputs:null,hostDirectiveOutputs:null,directiveToIndex:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}var Fme=new RegExp(`^(\\d+)*(${p8}|${u8})*(.*)`);var F5=()=>null,M5=()=>null;function Ak(n,e){return F5(n,e)}function O5(n,e,t){return M5(n,e,t)}var Z_=class{},Og=class{},_C=class{resolveComponentFactory(e){throw new Te(917,!1)}},$g=class{static NULL=new _C},ja=class{};var Q_=(()=>{class n{static \u0275prov=ut({token:n,providedIn:"root",factory:()=>null})}return n})();var fg={},AC=class{injector;parentInjector;constructor(e,t){this.injector=e,this.parentInjector=t}get(e,t,r){let o=this.injector.get(e,fg,r);return o!==fg||t===fg?o:this.parentInjector.get(e,t,r)}};function Ig(n,e,t){let r=t?n.styles:null,o=t?n.classes:null,s=0;if(e!==null)for(let i=0;i<e.length;i++){let a=e[i];if(typeof a=="number")s=a;else if(s==1)o=N0(o,a);else if(s==2){let c=a,l=e[++i];r=N0(r,c+": "+l+";")}}t?n.styles=r:n.stylesWithoutHost=r,t?n.classes=o:n.classesWithoutHost=o}function wo(n,e=0){let t=Je();if(t===null)return Qe(n,e);let r=yr();return c_(r,t,or(n),e)}function J_(n,e,t,r,o){let s=r===null?null:{"":-1},i=o(n,t);if(i!==null){let a=i,c=null,l=null;for(let u of i)if(u.resolveHostDirectives!==null){[a,c,l]=u.resolveHostDirectives(i);break}L5(n,e,t,a,s,c,l)}s!==null&&r!==null&&$5(t,r,s)}function $5(n,e,t){let r=n.localNames=[];for(let o=0;o<e.length;o+=2){let s=t[e[o+1]];if(s==null)throw new Te(-301,!1);r.push(e[o],s)}}function P5(n,e,t){e.componentOffset=t,(n.components??=[]).push(e.index)}function L5(n,e,t,r,o,s,i){let a=r.length,c=!1;for(let d=0;d<a;d++){let f=r[d];!c&&$a(f)&&(c=!0,P5(n,t,d)),Q6(o_(t,e),n,f.type)}G5(t,n.data.length,a);for(let d=0;d<a;d++){let f=r[d];f.providersResolver&&f.providersResolver(f)}let l=!1,u=!1,p=__(n,e,a,null);a>0&&(t.directiveToIndex=new Map);for(let d=0;d<a;d++){let f=r[d];if(t.mergedAttrs=Dg(t.mergedAttrs,f.hostAttrs),V5(n,t,e,p,f),H5(p,f,o),i!==null&&i.has(f)){let[h,g]=i.get(f);t.directiveToIndex.set(f.type,[p,h+t.directiveStart,g+t.directiveStart])}else(s===null||!s.has(f))&&t.directiveToIndex.set(f.type,p);f.contentQueries!==null&&(t.flags|=4),(f.hostBindings!==null||f.hostAttrs!==null||f.hostVars!==0)&&(t.flags|=64);let m=f.type.prototype;!l&&(m.ngOnChanges||m.ngOnInit||m.ngDoCheck)&&((n.preOrderHooks??=[]).push(t.index),l=!0),!u&&(m.ngOnChanges||m.ngDoCheck)&&((n.preOrderCheckHooks??=[]).push(t.index),u=!0),p++}B5(n,t,s)}function B5(n,e,t){for(let r=e.directiveStart;r<e.directiveEnd;r++){let o=n.data[r];if(t===null||!t.has(o))Rk(0,e,o,r),Rk(1,e,o,r),Mk(e,r,!1);else{let s=t.get(o);Fk(0,e,s,r),Fk(1,e,s,r),Mk(e,r,!0)}}}function Rk(n,e,t,r){let o=n===0?t.inputs:t.outputs;for(let s in o)if(o.hasOwnProperty(s)){let i;n===0?i=e.inputs??={}:i=e.outputs??={},i[s]??=[],i[s].push(r),eA(e,s)}}function Fk(n,e,t,r){let o=n===0?t.inputs:t.outputs;for(let s in o)if(o.hasOwnProperty(s)){let i=o[s],a;n===0?a=e.hostDirectiveInputs??={}:a=e.hostDirectiveOutputs??={},a[i]??=[],a[i].push(r,s),eA(e,i)}}function eA(n,e){e==="class"?n.flags|=8:e==="style"&&(n.flags|=16)}function Mk(n,e,t){let{attrs:r,inputs:o,hostDirectiveInputs:s}=n;if(r===null||!t&&o===null||t&&s===null||ZC(n)){n.initialInputs??=[],n.initialInputs.push(null);return}let i=null,a=0;for(;a<r.length;){let c=r[a];if(c===0){a+=4;continue}else if(c===5){a+=2;continue}else if(typeof c=="number")break;if(!t&&o.hasOwnProperty(c)){let l=o[c];for(let u of l)if(u===e){i??=[],i.push(c,r[a+1]);break}}else if(t&&s.hasOwnProperty(c)){let l=s[c];for(let u=0;u<l.length;u+=2)if(l[u]===e){i??=[],i.push(l[u+1],r[a+1]);break}}a+=2}n.initialInputs??=[],n.initialInputs.push(i)}function V5(n,e,t,r,o){n.data[r]=o;let s=o.factory||(o.factory=Ta(o.type,!0)),i=new lf(s,$a(o),wo,null);n.blueprint[r]=i,t[r]=i,U5(n,e,r,__(n,t,o.hostVars,Co),o)}function U5(n,e,t,r,o){let s=o.hostBindings;if(s){let i=n.hostBindingOpCodes;i===null&&(i=n.hostBindingOpCodes=[]);let a=~e.index;z5(i)!=a&&i.push(a),i.push(t,r,s)}}function z5(n){let e=n.length;for(;e>0;){let t=n[--e];if(typeof t=="number"&&t<0)return t}return 0}function H5(n,e,t){if(t){if(e.exportAs)for(let r=0;r<e.exportAs.length;r++)t[e.exportAs[r]]=n;$a(e)&&(t[""]=n)}}function G5(n,e,t){n.flags|=1,n.directiveStart=e,n.directiveEnd=e+t,n.providerIndexes=e}function tA(n,e,t,r,o,s,i,a){let c=e[we],l=c.consts,u=xo(l,i),p=gf(c,n,t,r,u);return s&&J_(c,e,p,xo(l,a),o),p.mergedAttrs=Dg(p.mergedAttrs,p.attrs),p.attrs!==null&&Ig(p,p.attrs,!1),p.mergedAttrs!==null&&Ig(p,p.mergedAttrs,!0),c.queries!==null&&c.queries.elementStart(c,p),p}function nA(n,e){Jk(n,e),G0(e)&&n.queries.elementEnd(e)}function W5(n,e,t,r,o,s){let i=e.consts,a=xo(i,o),c=gf(e,n,t,r,a);if(c.mergedAttrs=Dg(c.mergedAttrs,c.attrs),s!=null){let l=xo(i,s);c.localNames=[];for(let u=0;u<l.length;u+=2)c.localNames.push(l[u],-1)}return c.attrs!==null&&Ig(c,c.attrs,!1),c.mergedAttrs!==null&&Ig(c,c.mergedAttrs,!0),e.queries!==null&&e.queries.elementStart(e,c),c}function j5(n,e,t){return n[e]=t}function qa(n,e,t){if(t===Co)return!1;let r=n[e];return Object.is(r,t)?!1:(n[e]=t,!0)}function q5(n,e,t,r){let o=qa(n,e,t);return qa(n,e+1,r)||o}function xC(n,e,t){return function r(o){let s=Oa(n)?go(n.index,e):e;uw(s,5);let i=e[pn],a=Ok(e,i,t,o),c=r.__ngNextListenerFn__;for(;c;)a=Ok(e,i,c,o)&&a,c=c.__ngNextListenerFn__;return a}}function Ok(n,e,t,r){let o=Me(null);try{return pt(6,e,t),t(r)!==!1}catch(s){return l5(n,s),!1}finally{pt(7,e,t),Me(o)}}function K5(n,e,t,r,o,s,i,a){let c=Yd(n),l=!1,u=null;if(!r&&c&&(u=X5(e,t,s,n.index)),u!==null){let p=u.__ngLastListenerFn__||u;p.__ngNextListenerFn__=i,u.__ngLastListenerFn__=i,l=!0}else{let p=Pr(n,t),d=r?r(p):p;f8(t,d,s,a);let f=o.listen(d,s,a),m=r?h=>r(xr(h[n.index])):n.index;rA(m,e,t,s,a,f,!1)}return l}function X5(n,e,t,r){let o=n.cleanup;if(o!=null)for(let s=0;s<o.length-1;s+=2){let i=o[s];if(i===t&&o[s+1]===r){let a=e[qu],c=o[s+2];return a&&a.length>c?a[c]:null}typeof i=="string"&&(s+=2)}return null}function rA(n,e,t,r,o,s,i){let a=e.firstCreatePass?Q0(e):null,c=Z0(t),l=c.length;c.push(o,s),a&&a.push(r,n,l,(l+1)*(i?-1:1))}function $k(n,e,t,r,o,s){let i=e[t],a=e[we],l=a.data[t].outputs[r],p=i[l].subscribe(s);rA(n.index,a,e,o,s,p,!0)}var RC=Symbol("BINDING");var FC=class extends $g{ngModule;constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){let t=_a(e);return new pf(t,this.ngModule)}};function Y5(n){return Object.keys(n).map(e=>{let[t,r,o]=n[e],s={propName:t,templateName:e,isSignal:(r&Rg.SignalBased)!==0};return o&&(s.transform=o),s})}function Z5(n){return Object.keys(n).map(e=>({propName:n[e],templateName:e}))}function Q5(n,e,t){let r=e instanceof mr?e:e?.injector;return r&&n.getStandaloneInjector!==null&&(r=n.getStandaloneInjector(r)||r),r?new AC(t,r):t}function J5(n){let e=n.get(ja,null);if(e===null)throw new Te(407,!1);let t=n.get(Q_,null),r=n.get(fo,null);return{rendererFactory:e,sanitizer:t,changeDetectionScheduler:r,ngReflect:!1}}function eq(n,e){let t=oA(n);return S_(e,t,t==="svg"?W0:t==="math"?K1:null)}function oA(n){return(n.selectors[0][0]||"div").toLowerCase()}var pf=class extends Og{componentDef;ngModule;selector;componentType;ngContentSelectors;isBoundToModule;cachedInputs=null;cachedOutputs=null;get inputs(){return this.cachedInputs??=Y5(this.componentDef.inputs),this.cachedInputs}get outputs(){return this.cachedOutputs??=Z5(this.componentDef.outputs),this.cachedOutputs}constructor(e,t){super(),this.componentDef=e,this.ngModule=t,this.componentType=e.type,this.selector=S8(e.selectors),this.ngContentSelectors=e.ngContentSelectors??[],this.isBoundToModule=!!t}create(e,t,r,o,s,i){pt(22);let a=Me(null);try{let c=this.componentDef,l=tq(r,c,i,s),u=Q5(c,o||this.ngModule,e),p=J5(u),d=p.rendererFactory.createRenderer(null,c),f=r?Y8(d,r,c.encapsulation,u):eq(c,d),m=i?.some(Pk)||s?.some(x=>typeof x!="function"&&x.bindings.some(Pk)),h=JC(null,l,null,512|k_(c),null,null,p,d,u,null,v_(f,u,!0));h[Xt]=f,rg(h);let g=null;try{let x=tA(Xt,h,2,"#host",()=>l.directiveRegistry,!0,0);f&&(D_(d,f,x),ep(f,h)),iw(l,h,x),C_(l,x,h),nA(l,x),t!==void 0&&rq(x,this.ngContentSelectors,t),g=go(x.index,h),h[pn]=g[pn],cw(l,h,null)}catch(x){throw g!==null&&IC(g),IC(h),x}finally{pt(23),og()}return new Eg(this.componentType,h,!!m)}finally{Me(a)}}};function tq(n,e,t,r){let o=n?["ng-version","20.3.0"]:N8(e.selectors[0]),s=null,i=null,a=0;if(t)for(let u of t)a+=u[RC].requiredVars,u.create&&(u.targetIdx=0,(s??=[]).push(u)),u.update&&(u.targetIdx=0,(i??=[]).push(u));if(r)for(let u=0;u<r.length;u++){let p=r[u];if(typeof p!="function")for(let d of p.bindings){a+=d[RC].requiredVars;let f=u+1;d.create&&(d.targetIdx=f,(s??=[]).push(d)),d.update&&(d.targetIdx=f,(i??=[]).push(d))}}let c=[e];if(r)for(let u of r){let p=typeof u=="function"?u:u.type,d=B0(p);c.push(d)}return QC(0,null,nq(s,i),1,a,c,null,null,null,[o],null)}function nq(n,e){return!n&&!e?null:t=>{if(t&1&&n)for(let r of n)r.create();if(t&2&&e)for(let r of e)r.update()}}function Pk(n){let e=n[RC].kind;return e==="input"||e==="twoWay"}var Eg=class extends Z_{_rootLView;_hasInputBindings;instance;hostView;changeDetectorRef;componentType;location;previousInputValues=null;_tNode;constructor(e,t,r){super(),this._rootLView=t,this._hasInputBindings=r,this._tNode=Zd(t[we],Xt),this.location=rp(this._tNode,t),this.instance=go(this._tNode.index,t)[pn],this.hostView=this.changeDetectorRef=new tp(t,void 0),this.componentType=e}setInput(e,t){this._hasInputBindings;let r=this._tNode;if(this.previousInputValues??=new Map,this.previousInputValues.has(e)&&Object.is(this.previousInputValues.get(e),t))return;let o=this._rootLView,s=aw(r,o[we],o,e,t);this.previousInputValues.set(e,t);let i=go(r.index,o);uw(i,1)}get injector(){return new Ga(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(e){this.hostView.onDestroy(e)}};function rq(n,e,t){let r=n.projection=[];for(let o=0;o<e.length;o++){let s=t[o];r.push(s!=null&&s.length?Array.from(s):null)}}var ip=(()=>{class n{static __NG_ELEMENT_ID__=oq}return n})();function oq(){let n=yr();return iA(n,Je())}var sq=ip,sA=class extends sq{_lContainer;_hostTNode;_hostLView;constructor(e,t,r){super(),this._lContainer=e,this._hostTNode=t,this._hostLView=r}get element(){return rp(this._hostTNode,this._hostLView)}get injector(){return new Ga(this._hostTNode,this._hostLView)}get parentInjector(){let e=GC(this._hostTNode,this._hostLView);if(t_(e)){let t=gg(e,this._hostLView),r=hg(e),o=t[we].data[r+8];return new Ga(o,t)}else return new Ga(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){let t=Lk(this._lContainer);return t!==null&&t[e]||null}get length(){return this._lContainer.length-Cn}createEmbeddedView(e,t,r){let o,s;typeof r=="number"?o=r:r!=null&&(o=r.index,s=r.injector);let i=Ak(this._lContainer,e.ssrId),a=e.createEmbeddedViewImpl(t||{},s,i);return this.insertImpl(a,o,DC(this._hostTNode,i)),a}createComponent(e,t,r,o,s,i,a){let c=e&&!$6(e),l;if(c)l=t;else{let g=t||{};l=g.index,r=g.injector,o=g.projectableNodes,s=g.environmentInjector||g.ngModuleRef,i=g.directives,a=g.bindings}let u=c?e:new pf(_a(e)),p=r||this.parentInjector;if(!s&&u.ngModule==null){let x=(c?p:this.parentInjector).get(mr,null);x&&(s=x)}let d=_a(u.componentType??{}),f=Ak(this._lContainer,d?.id??null),m=f?.firstChild??null,h=u.create(p,o,m,s,i,a);return this.insertImpl(h.hostView,l,DC(this._hostTNode,f)),h}insert(e,t){return this.insertImpl(e,t,!0)}insertImpl(e,t,r){let o=e._lView;if(Z1(o)){let a=this.indexOf(e);if(a!==-1)this.detach(a);else{let c=o[nn],l=new sA(c,c[gr],c[nn]);l.detach(l.indexOf(e))}}let s=this._adjustIndex(t),i=this._lContainer;return X_(i,o,s,r),e.attachToViewContainerRef(),$0(yC(i),s,e),e}move(e,t){return this.insert(e,t)}indexOf(e){let t=Lk(this._lContainer);return t!==null?t.indexOf(e):-1}remove(e){let t=this._adjustIndex(e,-1),r=wg(this._lContainer,t);r&&(Gd(yC(this._lContainer),t),rw(r[we],r))}detach(e){let t=this._adjustIndex(e,-1),r=wg(this._lContainer,t);return r&&Gd(yC(this._lContainer),t)!=null?new tp(r):null}_adjustIndex(e,t=0){return e??this.length+t}};function Lk(n){return n[Xd]}function yC(n){return n[Xd]||(n[Xd]=[])}function iA(n,e){let t,r=e[n.index];return $r(r)?t=r:(t=K_(r,e,null,n),e[n.index]=t,ew(e,t)),aq(t,e,n,r),new sA(t,n,e)}function iq(n,e){let t=n[Kt],r=t.createComment(""),o=Pr(e,n),s=t.parentNode(o);return Cg(t,s,r,t.nextSibling(o),!1),r}var aq=uq,cq=()=>!1;function lq(n,e,t){return cq(n,e,t)}function uq(n,e,t,r){if(n[Us])return;let o;t.type&8?o=xr(r):o=iq(e,t),n[Us]=o}var MC=class n{queryList;matches=null;constructor(e){this.queryList=e}clone(){return new n(this.queryList)}setDirty(){this.queryList.setDirty()}},OC=class n{queries;constructor(e=[]){this.queries=e}createEmbeddedView(e){let t=e.queries;if(t!==null){let r=e.contentQueries!==null?e.contentQueries[0]:t.length,o=[];for(let s=0;s<r;s++){let i=t.getByIndex(s),a=this.queries[i.indexInDeclarationView];o.push(a.clone())}return new n(o)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}finishViewCreation(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let t=0;t<this.queries.length;t++)dw(e,t).matches!==null&&this.queries[t].setDirty()}},$C=class{flags;read;predicate;constructor(e,t,r=null){this.flags=t,this.read=r,typeof e=="string"?this.predicate=yq(e):this.predicate=e}},PC=class n{queries;constructor(e=[]){this.queries=e}elementStart(e,t){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(e,t)}elementEnd(e){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(e)}embeddedTView(e){let t=null;for(let r=0;r<this.length;r++){let o=t!==null?t.length:0,s=this.getByIndex(r).embeddedTView(e,o);s&&(s.indexInDeclarationView=r,t!==null?t.push(s):t=[s])}return t!==null?new n(t):null}template(e,t){for(let r=0;r<this.queries.length;r++)this.queries[r].template(e,t)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}},LC=class n{metadata;matches=null;indexInDeclarationView=-1;crossesNgTemplate=!1;_declarationNodeIndex;_appliesToNextNode=!0;constructor(e,t=-1){this.metadata=e,this._declarationNodeIndex=t}elementStart(e,t){this.isApplyingToNode(t)&&this.matchTNode(e,t)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,t){this.elementStart(e,t)}embeddedTView(e,t){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,t),new n(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&(this.metadata.flags&1)!==1){let t=this._declarationNodeIndex,r=e.parent;for(;r!==null&&r.type&8&&r.index!==t;)r=r.parent;return t===(r!==null?r.index:-1)}return this._appliesToNextNode}matchTNode(e,t){let r=this.metadata.predicate;if(Array.isArray(r))for(let o=0;o<r.length;o++){let s=r[o];this.matchTNodeWithReadOption(e,t,pq(t,s)),this.matchTNodeWithReadOption(e,t,dg(t,e,s,!1,!1))}else r===Wa?t.type&4&&this.matchTNodeWithReadOption(e,t,-1):this.matchTNodeWithReadOption(e,t,dg(t,e,r,!1,!1))}matchTNodeWithReadOption(e,t,r){if(r!==null){let o=this.metadata.read;if(o!==null)if(o===op||o===ip||o===Wa&&t.type&4)this.addMatch(t.index,-2);else{let s=dg(t,e,o,!1,!1);s!==null&&this.addMatch(t.index,s)}else this.addMatch(t.index,r)}}addMatch(e,t){this.matches===null?this.matches=[e,t]:this.matches.push(e,t)}};function pq(n,e){let t=n.localNames;if(t!==null){for(let r=0;r<t.length;r+=2)if(t[r]===e)return t[r+1]}return null}function dq(n,e){return n.type&11?rp(n,e):n.type&4?pw(n,e):null}function fq(n,e,t,r){return t===-1?dq(e,n):t===-2?mq(n,e,r):yg(n,n[we],t,e)}function mq(n,e,t){if(t===op)return rp(e,n);if(t===Wa)return pw(e,n);if(t===ip)return iA(e,n)}function aA(n,e,t,r){let o=e[ho].queries[r];if(o.matches===null){let s=n.data,i=t.matches,a=[];for(let c=0;i!==null&&c<i.length;c+=2){let l=i[c];if(l<0)a.push(null);else{let u=s[l];a.push(fq(e,u,i[c+1],t.metadata.read))}}o.matches=a}return o.matches}function BC(n,e,t,r){let o=n.queries.getByIndex(t),s=o.matches;if(s!==null){let i=aA(n,e,o,t);for(let a=0;a<s.length;a+=2){let c=s[a];if(c>0)r.push(i[a/2]);else{let l=s[a+1],u=e[-c];for(let p=Cn;p<u.length;p++){let d=u[p];d[Vs]===d[nn]&&BC(d[we],d,l,r)}if(u[Ma]!==null){let p=u[Ma];for(let d=0;d<p.length;d++){let f=p[d];BC(f[we],f,l,r)}}}}}return r}function hq(n,e){return n[ho].queries[e].queryList}function gq(n,e,t){let r=new vg((t&4)===4);return ek(n,e,r,r.destroy),(e[ho]??=new OC).queries.push(new MC(r))-1}function xq(n,e,t){let r=zn();return r.firstCreatePass&&(vq(r,new $C(n,e,t),-1),(e&2)===2&&(r.staticViewQueries=!0)),gq(r,Je(),e)}function yq(n){return n.split(",").map(e=>e.trim())}function vq(n,e,t){n.queries===null&&(n.queries=new PC),n.queries.track(new LC(e,t))}function dw(n,e){return n.queries.getByIndex(e)}function bq(n,e){let t=n[we],r=dw(t,e);return r.crossesNgTemplate?BC(t,n,e,[]):aA(t,n,r,e)}var Bk=new Set;function ap(n){Bk.has(n)||(Bk.add(n),performance?.mark?.("mark_feature_usage",{detail:{feature:n}}))}var df=class{};var ff=class extends df{injector;componentFactoryResolver=new FC(this);instance=null;constructor(e){super();let t=new Sa([...e.providers,{provide:df,useValue:this},{provide:$g,useValue:this.componentFactoryResolver}],e.parent||jd(),e.debugName,new Set(["environment"]));this.injector=t,e.runEnvironmentInitializers&&t.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(e){this.injector.onDestroy(e)}};function cA(n,e,t=null){return new ff({providers:n,parent:e,debugName:t,runEnvironmentInitializers:!0}).injector}var Cq=(()=>{class n{_injector;cachedInjectors=new Map;constructor(t){this._injector=t}getOrCreateStandaloneInjector(t){if(!t.standalone)return null;if(!this.cachedInjectors.has(t)){let r=V0(!1,t.type),o=r.length>0?cA([r],this._injector,`Standalone[${t.type.name}]`):null;this.cachedInjectors.set(t,o)}return this.cachedInjectors.get(t)}ngOnDestroy(){try{for(let t of this.cachedInjectors.values())t!==null&&t.destroy()}finally{this.cachedInjectors.clear()}}static \u0275prov=ut({token:n,providedIn:"environment",factory:()=>new n(Qe(mr))})}return n})();function Xa(n){return Ng(()=>{let e=lA(n),t=Lt(Rt({},e),{decls:n.decls,vars:n.vars,template:n.template,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,onPush:n.changeDetection===WC.OnPush,directiveDefs:null,pipeDefs:null,dependencies:e.standalone&&n.dependencies||null,getStandaloneInjector:e.standalone?o=>o.get(Cq).getOrCreateStandaloneInjector(t):null,getExternalStyles:null,signals:n.signals??!1,data:n.data||{},encapsulation:n.encapsulation||Qo.Emulated,styles:n.styles||fr,_:null,schemas:n.schemas||null,tView:null,id:""});e.standalone&&ap("NgStandalone"),uA(t);let r=n.dependencies;return t.directiveDefs=Vk(r,wq),t.pipeDefs=Vk(r,V1),t.id=Tq(t),t})}function wq(n){return _a(n)||B0(n)}function Pg(n){return Ng(()=>({type:n.type,bootstrap:n.bootstrap||fr,declarations:n.declarations||fr,imports:n.imports||fr,exports:n.exports||fr,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function Iq(n,e){if(n==null)return ka;let t={};for(let r in n)if(n.hasOwnProperty(r)){let o=n[r],s,i,a,c;Array.isArray(o)?(a=o[0],s=o[1],i=o[2]??s,c=o[3]||null):(s=o,i=o,a=Rg.None,c=null),t[s]=[r,a,c],e[s]=i}return t}function Eq(n){if(n==null)return ka;let e={};for(let t in n)n.hasOwnProperty(t)&&(e[n[t]]=t);return e}function fw(n){return Ng(()=>{let e=lA(n);return uA(e),e})}function mw(n){return{type:n.type,name:n.name,factory:null,pure:n.pure!==!1,standalone:n.standalone??!0,onDestroy:n.type.prototype.ngOnDestroy||null}}function lA(n){let e={};return{type:n.type,providersResolver:null,factory:null,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:e,inputConfig:n.inputs||ka,exportAs:n.exportAs||null,standalone:n.standalone??!0,signals:n.signals===!0,selectors:n.selectors||fr,viewQuery:n.viewQuery||null,features:n.features||null,setInput:null,resolveHostDirectives:null,hostDirectives:null,inputs:Iq(n.inputs,e),outputs:Eq(n.outputs),debugInfo:null}}function uA(n){n.features?.forEach(e=>e(n))}function Vk(n,e){return n?()=>{let t=typeof n=="function"?n():n,r=[];for(let o of t){let s=e(o);s!==null&&r.push(s)}return r}:null}function Tq(n){let e=0,t=typeof n.consts=="function"?"":n.consts,r=[n.selectors,n.ngContentSelectors,n.hostVars,n.hostAttrs,t,n.vars,n.decls,n.encapsulation,n.standalone,n.signals,n.exportAs,JSON.stringify(n.inputs),JSON.stringify(n.outputs),Object.getOwnPropertyNames(n.type.prototype),!!n.contentQueries,!!n.viewQuery];for(let s of r.join("|"))e=Math.imul(31,e)+s.charCodeAt(0)<<0;return e+=2147483648,"c"+e}function pA(n,e,t,r,o,s,i,a){if(t.firstCreatePass){n.mergedAttrs=Dg(n.mergedAttrs,n.attrs);let u=n.tView=QC(2,n,o,s,i,t.directiveRegistry,t.pipeRegistry,null,t.schemas,t.consts,null);t.queries!==null&&(t.queries.template(t,n),u.queries=t.queries.embeddedTView(n))}a&&(n.flags|=a),Yu(n,!1);let c=Nq(t,e,n,r);sg()&&ow(t,e,c,n),ep(c,e);let l=K_(c,e,c,n);e[r+Xt]=l,ew(e,l),lq(l,n,e)}function Sq(n,e,t,r,o,s,i,a,c,l,u){let p=t+Xt,d;return e.firstCreatePass?(d=gf(e,p,4,i||null,a||null),eC()&&J_(e,n,d,xo(e.consts,l),O_),Jk(e,d)):d=e.data[p],pA(d,n,e,t,r,o,s,c),Yd(d)&&iw(e,n,d),l!=null&&Mg(n,d,u),d}function dA(n,e,t,r,o,s,i,a,c,l,u){let p=t+Xt,d;if(e.firstCreatePass){if(d=gf(e,p,4,i||null,a||null),l!=null){let f=xo(e.consts,l);d.localNames=[];for(let m=0;m<f.length;m+=2)d.localNames.push(f[m],-1)}}else d=e.data[p];return pA(d,n,e,t,r,o,s,c),l!=null&&Mg(n,d,u),d}function xf(n,e,t,r,o,s,i,a){let c=Je(),l=zn(),u=xo(l.consts,s);return Sq(c,l,n,e,t,r,o,u,void 0,i,a),xf}var Nq=Dq;function Dq(n,e,t,r){return ig(!0),e[Kt].createComment("")}var hw=(function(n){return n[n.CHANGE_DETECTION=0]="CHANGE_DETECTION",n[n.AFTER_NEXT_RENDER=1]="AFTER_NEXT_RENDER",n})(hw||{}),yf=new qe(""),fA=!1,VC=class extends $s{__isAsync;destroyRef=void 0;pendingTasks=void 0;constructor(e=!1){super(),this.__isAsync=e,j1()&&(this.destroyRef=Ae(Va,{optional:!0})??void 0,this.pendingTasks=Ae(Ua,{optional:!0})??void 0)}emit(e){let t=Me(null);try{super.next(e)}finally{Me(t)}}subscribe(e,t,r){let o=e,s=t||(()=>null),i=r;if(e&&typeof e=="object"){let c=e;o=c.next?.bind(c),s=c.error?.bind(c),i=c.complete?.bind(c)}this.__isAsync&&(s=this.wrapInTimeout(s),o&&(o=this.wrapInTimeout(o)),i&&(i=this.wrapInTimeout(i)));let a=super.subscribe({next:o,error:s,complete:i});return e instanceof kn&&e.add(a),a}wrapInTimeout(e){return t=>{let r=this.pendingTasks?.add();setTimeout(()=>{try{e(t)}finally{r!==void 0&&this.pendingTasks?.remove(r)}})}}},Zo=VC;function mA(n){let e,t;function r(){n=za;try{t!==void 0&&typeof cancelAnimationFrame=="function"&&cancelAnimationFrame(t),e!==void 0&&clearTimeout(e)}catch{}}return e=setTimeout(()=>{n(),r()}),typeof requestAnimationFrame=="function"&&(t=requestAnimationFrame(()=>{n(),r()})),()=>r()}function Uk(n){return queueMicrotask(()=>n()),()=>{n=za}}var gw="isAngularZone",Tg=gw+"_ID",kq=0,rn=class n{hasPendingMacrotasks=!1;hasPendingMicrotasks=!1;isStable=!0;onUnstable=new Zo(!1);onMicrotaskEmpty=new Zo(!1);onStable=new Zo(!1);onError=new Zo(!1);constructor(e){let{enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:r=!1,shouldCoalesceRunChangeDetection:o=!1,scheduleInRootZone:s=fA}=e;if(typeof Zone>"u")throw new Te(908,!1);Zone.assertZonePatched();let i=this;i._nesting=0,i._outer=i._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(i._inner=i._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(i._inner=i._inner.fork(Zone.longStackTraceZoneSpec)),i.shouldCoalesceEventChangeDetection=!o&&r,i.shouldCoalesceRunChangeDetection=o,i.callbackScheduled=!1,i.scheduleInRootZone=s,Rq(i)}static isInAngularZone(){return typeof Zone<"u"&&Zone.current.get(gw)===!0}static assertInAngularZone(){if(!n.isInAngularZone())throw new Te(909,!1)}static assertNotInAngularZone(){if(n.isInAngularZone())throw new Te(909,!1)}run(e,t,r){return this._inner.run(e,t,r)}runTask(e,t,r,o){let s=this._inner,i=s.scheduleEventTask("NgZoneEvent: "+o,e,_q,za,za);try{return s.runTask(i,t,r)}finally{s.cancelTask(i)}}runGuarded(e,t,r){return this._inner.runGuarded(e,t,r)}runOutsideAngular(e){return this._outer.run(e)}},_q={};function xw(n){if(n._nesting==0&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function Aq(n){if(n.isCheckStableRunning||n.callbackScheduled)return;n.callbackScheduled=!0;function e(){mA(()=>{n.callbackScheduled=!1,UC(n),n.isCheckStableRunning=!0,xw(n),n.isCheckStableRunning=!1})}n.scheduleInRootZone?Zone.root.run(()=>{e()}):n._outer.run(()=>{e()}),UC(n)}function Rq(n){let e=()=>{Aq(n)},t=kq++;n._inner=n._inner.fork({name:"angular",properties:{[gw]:!0,[Tg]:t,[Tg+t]:!0},onInvokeTask:(r,o,s,i,a,c)=>{if(Fq(c))return r.invokeTask(s,i,a,c);try{return zk(n),r.invokeTask(s,i,a,c)}finally{(n.shouldCoalesceEventChangeDetection&&i.type==="eventTask"||n.shouldCoalesceRunChangeDetection)&&e(),Hk(n)}},onInvoke:(r,o,s,i,a,c,l)=>{try{return zk(n),r.invoke(s,i,a,c,l)}finally{n.shouldCoalesceRunChangeDetection&&!n.callbackScheduled&&!Mq(c)&&e(),Hk(n)}},onHasTask:(r,o,s,i)=>{r.hasTask(s,i),o===s&&(i.change=="microTask"?(n._hasPendingMicrotasks=i.microTask,UC(n),xw(n)):i.change=="macroTask"&&(n.hasPendingMacrotasks=i.macroTask))},onHandleError:(r,o,s,i)=>(r.handleError(s,i),n.runOutsideAngular(()=>n.onError.emit(i)),!1)})}function UC(n){n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&n.callbackScheduled===!0?n.hasPendingMicrotasks=!0:n.hasPendingMicrotasks=!1}function zk(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function Hk(n){n._nesting--,xw(n)}var mf=class{hasPendingMicrotasks=!1;hasPendingMacrotasks=!1;isStable=!0;onUnstable=new Zo;onMicrotaskEmpty=new Zo;onStable=new Zo;onError=new Zo;run(e,t,r){return e.apply(t,r)}runGuarded(e,t,r){return e.apply(t,r)}runOutsideAngular(e){return e()}runTask(e,t,r,o){return e.apply(t,r)}};function Fq(n){return hA(n,"__ignore_ng_zone__")}function Mq(n){return hA(n,"__scheduler_tick__")}function hA(n,e){return!Array.isArray(n)||n.length!==1?!1:n[0]?.data?.[e]===!0}var gA=(()=>{class n{impl=null;execute(){this.impl?.execute()}static \u0275prov=ut({token:n,providedIn:"root",factory:()=>new n})}return n})();var yw=new qe("");function Lg(n){return!!n&&typeof n.then=="function"}function vw(n){return!!n&&typeof n.subscribe=="function"}var bw=new qe("");function Cw(n){return ju([{provide:bw,multi:!0,useValue:n}])}var ww=(()=>{class n{resolve;reject;initialized=!1;done=!1;donePromise=new Promise((t,r)=>{this.resolve=t,this.reject=r});appInits=Ae(bw,{optional:!0})??[];injector=Ae(Ko);constructor(){}runInitializers(){if(this.initialized)return;let t=[];for(let o of this.appInits){let s=Yh(this.injector,o);if(Lg(s))t.push(s);else if(vw(s)){let i=new Promise((a,c)=>{s.subscribe({complete:a,error:c})});t.push(i)}}let r=()=>{this.done=!0,this.resolve()};Promise.all(t).then(()=>{r()}).catch(o=>{this.reject(o)}),t.length===0&&r(),this.initialized=!0}static \u0275fac=function(r){return new(r||n)};static \u0275prov=ut({token:n,factory:n.\u0275fac,providedIn:"root"})}return n})(),xA=new qe("");function yA(){s0(()=>{let n="";throw new Te(600,n)})}function vA(n){return n.isBoundToModule}var Oq=10;var vf=(()=>{class n{_runningTick=!1;_destroyed=!1;_destroyListeners=[];_views=[];internalErrorHandler=Ae(yo);afterRenderManager=Ae(gA);zonelessEnabled=Ae(rf);rootEffectScheduler=Ae(sf);dirtyFlags=0;tracingSnapshot=null;allTestViews=new Set;autoDetectTestViews=new Set;includeAllTestViews=!1;afterTick=new $s;get allViews(){return[...(this.includeAllTestViews?this.allTestViews:this.autoDetectTestViews).keys(),...this._views]}get destroyed(){return this._destroyed}componentTypes=[];components=[];internalPendingTask=Ae(Ua);get isStable(){return this.internalPendingTask.hasPendingTasksObservable.pipe(h0(t=>!t))}constructor(){Ae(yf,{optional:!0})}whenStable(){let t;return new Promise(r=>{t=this.isStable.subscribe({next:o=>{o&&r()}})}).finally(()=>{t.unsubscribe()})}_injector=Ae(mr);_rendererFactory=null;get injector(){return this._injector}bootstrap(t,r){return this.bootstrapImpl(t,r)}bootstrapImpl(t,r,o=Ko.NULL){return this._injector.get(rn).run(()=>{pt(10);let i=t instanceof Og;if(!this._injector.get(ww).done){let m="";throw new Te(405,m)}let c;i?c=t:c=this._injector.get($g).resolveComponentFactory(t),this.componentTypes.push(c.componentType);let l=vA(c)?void 0:this._injector.get(df),u=r||c.selector,p=c.create(o,[],u,l),d=p.location.nativeElement,f=p.injector.get(yw,null);return f?.registerApplication(d),p.onDestroy(()=>{this.detachView(p.hostView),cf(this.components,p),f?.unregisterApplication(d)}),this._loadComponent(p),pt(11,p),p})}tick(){this.zonelessEnabled||(this.dirtyFlags|=1),this._tick()}_tick(){pt(12),this.tracingSnapshot!==null?this.tracingSnapshot.run(hw.CHANGE_DETECTION,this.tickImpl):this.tickImpl()}tickImpl=()=>{if(this._runningTick)throw new Te(101,!1);let t=Me(null);try{this._runningTick=!0,this.synchronize()}finally{this._runningTick=!1,this.tracingSnapshot?.dispose(),this.tracingSnapshot=null,Me(t),this.afterTick.next(),pt(13)}};synchronize(){this._rendererFactory===null&&!this._injector.destroyed&&(this._rendererFactory=this._injector.get(ja,null,{optional:!0}));let t=0;for(;this.dirtyFlags!==0&&t++<Oq;)pt(14),this.synchronizeOnce(),pt(15)}synchronizeOnce(){this.dirtyFlags&16&&(this.dirtyFlags&=-17,this.rootEffectScheduler.flush());let t=!1;if(this.dirtyFlags&7){let r=!!(this.dirtyFlags&1);this.dirtyFlags&=-8,this.dirtyFlags|=8;for(let{_lView:o}of this.allViews){if(!r&&!Qd(o))continue;let s=r&&!this.zonelessEnabled?0:1;lw(o,s),t=!0}if(this.dirtyFlags&=-5,this.syncDirtyFlagsWithViews(),this.dirtyFlags&23)return}t||(this._rendererFactory?.begin?.(),this._rendererFactory?.end?.()),this.dirtyFlags&8&&(this.dirtyFlags&=-9,this.afterRenderManager.execute()),this.syncDirtyFlagsWithViews()}syncDirtyFlagsWithViews(){if(this.allViews.some(({_lView:t})=>Qd(t))){this.dirtyFlags|=2;return}else this.dirtyFlags&=-8}attachView(t){let r=t;this._views.push(r),r.attachToAppRef(this)}detachView(t){let r=t;cf(this._views,r),r.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView);try{this.tick()}catch(o){this.internalErrorHandler(o)}this.components.push(t),this._injector.get(xA,[]).forEach(o=>o(t))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(t=>t()),this._views.slice().forEach(t=>t.destroy())}finally{this._destroyed=!0,this._views=[],this._destroyListeners=[]}}onDestroy(t){return this._destroyListeners.push(t),()=>cf(this._destroyListeners,t)}destroy(){if(this._destroyed)throw new Te(406,!1);let t=this._injector;t.destroy&&!t.destroyed&&t.destroy()}get viewCount(){return this._views.length}static \u0275fac=function(r){return new(r||n)};static \u0275prov=ut({token:n,factory:n.\u0275fac,providedIn:"root"})}return n})();function cf(n,e){let t=n.indexOf(e);t>-1&&n.splice(t,1)}function Io(n,e,t,r){let o=Je(),s=ef();if(qa(o,s,e)){let i=zn(),a=uC();i5(a,o,n,e,t,r)}return Io}var Iw=new qe("",{providedIn:"root",factory:()=>!1}),Ew=new qe("",{providedIn:"root",factory:()=>$q}),$q=4e3;var Bme=typeof document<"u"&&typeof document?.documentElement?.getAnimations=="function";function Hs(n,e,t,r,o,s,i,a){ap("NgControlFlow");let c=Je(),l=zn(),u=xo(l.consts,s);return dA(c,l,n,e,t,r,o,u,256,i,a),Tw}function Tw(n,e,t,r,o,s,i,a){ap("NgControlFlow");let c=Je(),l=zn(),u=xo(l.consts,s);return dA(c,l,n,e,t,r,o,u,512,i,a),Tw}function Gs(n,e){ap("NgControlFlow");let t=Je(),r=ef(),o=t[r]!==Co?t[r]:-1,s=o!==-1?Gk(t,Xt+o):void 0,i=0;if(qa(t,r,n)){let a=Me(null);try{if(s!==void 0&&N5(s,i),n!==-1){let c=Xt+n,l=Gk(t,c),u=Pq(t[we],c),p=O5(l,u,t),d=L_(t,u,e,{dehydratedView:p});X_(l,d,i,DC(u,p))}}finally{Me(a)}}else if(s!==void 0){let a=S5(s,i);a!==void 0&&(a[pn]=e)}}function Gk(n,e){return n[e]}function Pq(n,e){return Zd(n,e)}function An(n,e,t){let r=Je(),o=ef();if(qa(r,o,e)){let s=zn(),i=uC();e5(i,r,n,e,r[Kt],t)}return An}function Wk(n,e,t,r,o){aw(e,n,t,o?"class":"style",r)}function Re(n,e,t,r){let o=Je(),s=o[we],i=n+Xt,a=s.firstCreatePass?tA(i,o,2,e,O_,eC(),t,r):s.data[i];if($_(a,o,n,e,bA),Yd(a)){let c=o[we];iw(c,o,a),C_(c,a,o)}return r!=null&&Mg(o,a),Re}function Oe(){let n=zn(),e=yr(),t=P_(e);return n.firstCreatePass&&nA(n,t),tC(t)&&nC(),J0(),t.classesWithoutHost!=null&&H6(t)&&Wk(n,t,Je(),t.classesWithoutHost,!0),t.stylesWithoutHost!=null&&G6(t)&&Wk(n,t,Je(),t.stylesWithoutHost,!1),Oe}function tt(n,e,t,r){return Re(n,e,t,r),Oe(),tt}function Sw(n,e,t,r){let o=Je(),s=o[we],i=n+Xt,a=s.firstCreatePass?W5(i,s,2,e,t,r):s.data[i];return $_(a,o,n,e,bA),r!=null&&Mg(o,a),Sw}function Nw(){let n=yr(),e=P_(n);return tC(e)&&nC(),J0(),Nw}function Bg(n,e,t,r){return Sw(n,e,t,r),Nw(),Bg}var bA=(n,e,t,r,o)=>(ig(!0),S_(e[Kt],r,xk()));function Ya(){return Je()}var Ha=void 0;function Lq(n){let e=Math.floor(Math.abs(n)),t=n.toString().replace(/^[^.]*\.?/,"").length;return e===1&&t===0?1:5}var Bq=["en",[["a","p"],["AM","PM"],Ha],[["AM","PM"],Ha,Ha],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Ha,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Ha,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Ha,"{1} 'at' {0}",Ha],[".",",",";","%","+","-","E","\xD7","\u2030","\u221E","NaN",":"],["#,##0.###","#,##0%","\xA4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",Lq],vC={};function Vg(n){let e=Vq(n),t=jk(e);if(t)return t;let r=e.split("-")[0];if(t=jk(r),t)return t;if(r==="en")return Bq;throw new Te(701,!1)}function jk(n){return n in vC||(vC[n]=Na.ng&&Na.ng.common&&Na.ng.common.locales&&Na.ng.common.locales[n]),vC[n]}var Za=(function(n){return n[n.LocaleId=0]="LocaleId",n[n.DayPeriodsFormat=1]="DayPeriodsFormat",n[n.DayPeriodsStandalone=2]="DayPeriodsStandalone",n[n.DaysFormat=3]="DaysFormat",n[n.DaysStandalone=4]="DaysStandalone",n[n.MonthsFormat=5]="MonthsFormat",n[n.MonthsStandalone=6]="MonthsStandalone",n[n.Eras=7]="Eras",n[n.FirstDayOfWeek=8]="FirstDayOfWeek",n[n.WeekendRange=9]="WeekendRange",n[n.DateFormat=10]="DateFormat",n[n.TimeFormat=11]="TimeFormat",n[n.DateTimeFormat=12]="DateTimeFormat",n[n.NumberSymbols=13]="NumberSymbols",n[n.NumberFormats=14]="NumberFormats",n[n.CurrencyCode=15]="CurrencyCode",n[n.CurrencySymbol=16]="CurrencySymbol",n[n.CurrencyName=17]="CurrencyName",n[n.Currencies=18]="Currencies",n[n.Directionality=19]="Directionality",n[n.PluralCase=20]="PluralCase",n[n.ExtraData=21]="ExtraData",n})(Za||{});function Vq(n){return n.toLowerCase().replace(/_/g,"-")}var bf="en-US";var Uq=bf;function CA(n){typeof n=="string"&&(Uq=n.toLowerCase().replace(/_/g,"-"))}function Ur(n,e,t){let r=Je(),o=zn(),s=yr();return zq(o,r,r[Kt],s,n,e,t),Ur}function zq(n,e,t,r,o,s,i){let a=!0,c=null;if((r.type&3||i)&&(c??=xC(r,e,s),K5(r,n,e,i,t,o,s,c)&&(a=!1)),a){let l=r.outputs?.[o],u=r.hostDirectiveOutputs?.[o];if(u&&u.length)for(let p=0;p<u.length;p+=2){let d=u[p],f=u[p+1];c??=xC(r,e,s),$k(r,e,d,f,o,c)}if(l&&l.length)for(let p of l)c??=xC(r,e,s),$k(r,e,p,o,o,c)}}function ir(n=1){return gk(n)}function zr(n,e,t){xq(n,e,t)}function Hr(n){let e=Je(),t=zn(),r=aC();ng(r+1);let o=dw(t,r);if(n.dirty&&Y1(e)===((o.metadata.flags&2)===2)){if(o.matches===null)n.reset([]);else{let s=bq(e,r);n.reset(s,o8),n.notifyOnChanges()}return!0}return!1}function Gr(){return hq(Je(),aC())}function lg(n,e){return n<<17|e<<2}function Ka(n){return n>>17&32767}function Hq(n){return(n&2)==2}function Gq(n,e){return n&131071|e<<17}function zC(n){return n|2}function np(n){return(n&131068)>>2}function bC(n,e){return n&-131069|e<<2}function Wq(n){return(n&1)===1}function HC(n){return n|1}function jq(n,e,t,r,o,s){let i=s?e.classBindings:e.styleBindings,a=Ka(i),c=np(i);n[r]=t;let l=!1,u;if(Array.isArray(t)){let p=t;u=p[1],(u===null||Wu(p,u)>0)&&(l=!0)}else u=t;if(o)if(c!==0){let d=Ka(n[a+1]);n[r+1]=lg(d,a),d!==0&&(n[d+1]=bC(n[d+1],r)),n[a+1]=Gq(n[a+1],r)}else n[r+1]=lg(a,0),a!==0&&(n[a+1]=bC(n[a+1],r)),a=r;else n[r+1]=lg(c,0),a===0?a=r:n[c+1]=bC(n[c+1],r),c=r;l&&(n[r+1]=zC(n[r+1])),qk(n,u,r,!0),qk(n,u,r,!1),qq(e,u,n,r,s),i=lg(a,c),s?e.classBindings=i:e.styleBindings=i}function qq(n,e,t,r,o){let s=o?n.residualClasses:n.residualStyles;s!=null&&typeof e=="string"&&Wu(s,e)>=0&&(t[r+1]=HC(t[r+1]))}function qk(n,e,t,r){let o=n[t+1],s=e===null,i=r?Ka(o):np(o),a=!1;for(;i!==0&&(a===!1||s);){let c=n[i],l=n[i+1];Kq(c,e)&&(a=!0,n[i+1]=r?HC(l):zC(l)),i=r?Ka(l):np(l)}a&&(n[t+1]=r?zC(o):HC(o))}function Kq(n,e){return n===null||e==null||(Array.isArray(n)?n[1]:n)===e?!0:Array.isArray(n)&&typeof e=="string"?Wu(n,e)>=0:!1}function Cf(n,e,t){return wA(n,e,t,!1),Cf}function cp(n,e){return wA(n,e,null,!0),cp}function wA(n,e,t,r){let o=Je(),s=zn(),i=ck(2);if(s.firstUpdatePass&&Yq(s,n,i,r),e!==Co&&qa(o,i,e)){let a=s.data[Ba()];tK(s,a,o,o[Kt],n,o[i+1]=nK(e,t),r,i)}}function Xq(n,e){return e>=n.expandoStartIndex}function Yq(n,e,t,r){let o=n.data;if(o[t+1]===null){let s=o[Ba()],i=Xq(n,t);rK(s,r)&&e===null&&!i&&(e=!1),e=Zq(o,s,e,r),jq(o,s,e,t,i,r)}}function Zq(n,e,t,r){let o=dk(n),s=r?e.residualClasses:e.residualStyles;if(o===null)(r?e.classBindings:e.styleBindings)===0&&(t=CC(null,n,e,t,r),t=hf(t,e.attrs,r),s=null);else{let i=e.directiveStylingLast;if(i===-1||n[i]!==o)if(t=CC(o,n,e,t,r),s===null){let c=Qq(n,e,r);c!==void 0&&Array.isArray(c)&&(c=CC(null,n,e,c[1],r),c=hf(c,e.attrs,r),Jq(n,e,r,c))}else s=eK(n,e,r)}return s!==void 0&&(r?e.residualClasses=s:e.residualStyles=s),t}function Qq(n,e,t){let r=t?e.classBindings:e.styleBindings;if(np(r)!==0)return n[Ka(r)]}function Jq(n,e,t,r){let o=t?e.classBindings:e.styleBindings;n[Ka(o)]=r}function eK(n,e,t){let r,o=e.directiveEnd;for(let s=1+e.directiveStylingLast;s<o;s++){let i=n[s].hostAttrs;r=hf(r,i,t)}return hf(r,e.attrs,t)}function CC(n,e,t,r,o){let s=null,i=t.directiveEnd,a=t.directiveStylingLast;for(a===-1?a=t.directiveStart:a++;a<i&&(s=e[a],r=hf(r,s.hostAttrs,o),s!==n);)a++;return n!==null&&(t.directiveStylingLast=a),r}function hf(n,e,t){let r=t?1:2,o=-1;if(e!==null)for(let s=0;s<e.length;s++){let i=e[s];typeof i=="number"?o=i:o===r&&(Array.isArray(n)||(n=n===void 0?[]:["",n]),B1(n,i,t?!0:e[++s]))}return n===void 0?null:n}function tK(n,e,t,r,o,s,i,a){if(!(e.type&3))return;let c=n.data,l=c[a+1],u=Wq(l)?Kk(c,e,t,o,np(l),i):void 0;if(!Sg(u)){Sg(s)||Hq(l)&&(s=Kk(c,null,t,o,a,i));let p=j0(Ba(),t);X8(r,i,p,o,s)}}function Kk(n,e,t,r,o,s){let i=e===null,a;for(;o>0;){let c=n[o],l=Array.isArray(c),u=l?c[1]:c,p=u===null,d=t[o+1];d===Co&&(d=p?fr:void 0);let f=p?Xh(d,r):u===r?d:void 0;if(l&&!Sg(f)&&(f=Xh(c,r)),Sg(f)&&(a=f,i))return a;let m=n[o+1];o=i?Ka(m):np(m)}if(e!==null){let c=s?e.residualClasses:e.residualStyles;c!=null&&(a=Xh(c,r))}return a}function Sg(n){return n!==void 0}function nK(n,e){return n==null||n===""||(typeof e=="string"?n=n+e:typeof n=="object"&&(n=Ps(KC(n)))),n}function rK(n,e){return(n.flags&(e?8:16))!==0}function dn(n,e=""){let t=Je(),r=zn(),o=n+Xt,s=r.firstCreatePass?gf(r,o,1,e,null):r.data[o],i=oK(r,t,s,e,n);t[o]=i,sg()&&ow(r,t,i,s),Yu(s,!1)}var oK=(n,e,t,r,o)=>(ig(!0),D8(e[Kt],r));function sK(n,e,t,r=""){return qa(n,ef(),t)?e+Hd(t)+r:Co}function wf(n){return lp("",n),wf}function lp(n,e,t){let r=Je(),o=sK(r,n,e,t);return o!==Co&&iK(r,Ba(),o),lp}function iK(n,e,t){let r=j0(e,n);k8(n[Kt],r,t)}function aK(n,e){let t=n[e];return t===Co?void 0:t}function cK(n,e,t,r,o,s,i){let a=e+t;return q5(n,a,o,s)?j5(n,a+2,i?r.call(i,o,s):r(o,s)):aK(n,a+2)}function Ug(n,e){let t=zn(),r,o=n+Xt;t.firstCreatePass?(r=lK(e,t.pipeRegistry),t.data[o]=r,r.onDestroy&&(t.destroyHooks??=[]).push(o,r.onDestroy)):r=t.data[o];let s=r.factory||(r.factory=Ta(r.type,!0)),i,a=_n(wo);try{let c=xg(!1),l=s();return xg(c),q0(t,Je(),o,l),l}finally{_n(a)}}function lK(n,e){if(e)for(let t=e.length-1;t>=0;t--){let r=e[t];if(n===r.name)return r}}function zg(n,e,t,r){let o=n+Xt,s=Je(),i=X1(s,o);return uK(s,o)?cK(s,ik(),e,i.transform,t,r,i):i.transform(t,r)}function uK(n,e){return n[we].data[e].pure}var pK=(()=>{class n{zone=Ae(rn);changeDetectionScheduler=Ae(fo);applicationRef=Ae(vf);applicationErrorHandler=Ae(yo);_onMicrotaskEmptySubscription;initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.changeDetectionScheduler.runningTick||this.zone.run(()=>{try{this.applicationRef.dirtyFlags|=1,this.applicationRef._tick()}catch(t){this.applicationErrorHandler(t)}})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static \u0275fac=function(r){return new(r||n)};static \u0275prov=ut({token:n,factory:n.\u0275fac,providedIn:"root"})}return n})();function IA({ngZoneFactory:n,ignoreChangesOutsideZone:e,scheduleInRootZone:t}){return n??=()=>new rn(Lt(Rt({},EA()),{scheduleInRootZone:t})),[{provide:rn,useFactory:n},{provide:Bs,multi:!0,useFactory:()=>{let r=Ae(pK,{optional:!0});return()=>r.initialize()}},{provide:Bs,multi:!0,useFactory:()=>{let r=Ae(dK);return()=>{r.initialize()}}},e===!0?{provide:fC,useValue:!0}:[],{provide:cg,useValue:t??fA},{provide:yo,useFactory:()=>{let r=Ae(rn),o=Ae(mr),s;return i=>{r.runOutsideAngular(()=>{o.destroyed&&!s?setTimeout(()=>{throw i}):(s??=o.get(Fr),s.handleError(i))})}}}]}function EA(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:n?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:n?.runCoalescing??!1}}var dK=(()=>{class n{subscription=new kn;initialized=!1;zone=Ae(rn);pendingTasks=Ae(Ua);initialize(){if(this.initialized)return;this.initialized=!0;let t=null;!this.zone.isStable&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(t=this.pendingTasks.add()),this.zone.runOutsideAngular(()=>{this.subscription.add(this.zone.onStable.subscribe(()=>{rn.assertNotInAngularZone(),queueMicrotask(()=>{t!==null&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(this.pendingTasks.remove(t),t=null)})}))}),this.subscription.add(this.zone.onUnstable.subscribe(()=>{rn.assertInAngularZone(),t??=this.pendingTasks.add()}))}ngOnDestroy(){this.subscription.unsubscribe()}static \u0275fac=function(r){return new(r||n)};static \u0275prov=ut({token:n,factory:n.\u0275fac,providedIn:"root"})}return n})();var Dw=(()=>{class n{applicationErrorHandler=Ae(yo);appRef=Ae(vf);taskService=Ae(Ua);ngZone=Ae(rn);zonelessEnabled=Ae(rf);tracing=Ae(yf,{optional:!0});disableScheduling=Ae(fC,{optional:!0})??!1;zoneIsDefined=typeof Zone<"u"&&!!Zone.root.run;schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}];subscriptions=new kn;angularZoneId=this.zoneIsDefined?this.ngZone._inner?.get(Tg):null;scheduleInRootZone=!this.zonelessEnabled&&this.zoneIsDefined&&(Ae(cg,{optional:!0})??!1);cancelScheduledCallback=null;useMicrotaskScheduler=!1;runningTick=!1;pendingRenderTaskId=null;constructor(){this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{this.runningTick||this.cleanup()})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()})),this.disableScheduling||=!this.zonelessEnabled&&(this.ngZone instanceof mf||!this.zoneIsDefined)}notify(t){if(!this.zonelessEnabled&&t===5)return;let r=!1;switch(t){case 0:{this.appRef.dirtyFlags|=2;break}case 3:case 2:case 4:case 5:case 1:{this.appRef.dirtyFlags|=4;break}case 6:{this.appRef.dirtyFlags|=2,r=!0;break}case 12:{this.appRef.dirtyFlags|=16,r=!0;break}case 13:{this.appRef.dirtyFlags|=2,r=!0;break}case 11:{r=!0;break}case 9:case 8:case 7:case 10:default:this.appRef.dirtyFlags|=8}if(this.appRef.tracingSnapshot=this.tracing?.snapshot(this.appRef.tracingSnapshot)??null,!this.shouldScheduleTick(r))return;let o=this.useMicrotaskScheduler?Uk:mA;this.pendingRenderTaskId=this.taskService.add(),this.scheduleInRootZone?this.cancelScheduledCallback=Zone.root.run(()=>o(()=>this.tick())):this.cancelScheduledCallback=this.ngZone.runOutsideAngular(()=>o(()=>this.tick()))}shouldScheduleTick(t){return!(this.disableScheduling&&!t||this.appRef.destroyed||this.pendingRenderTaskId!==null||this.runningTick||this.appRef._runningTick||!this.zonelessEnabled&&this.zoneIsDefined&&Zone.current.get(Tg+this.angularZoneId))}tick(){if(this.runningTick||this.appRef.destroyed)return;if(this.appRef.dirtyFlags===0){this.cleanup();return}!this.zonelessEnabled&&this.appRef.dirtyFlags&7&&(this.appRef.dirtyFlags|=1);let t=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick()},void 0,this.schedulerTickApplyArgs)}catch(r){this.taskService.remove(t),this.applicationErrorHandler(r)}finally{this.cleanup()}this.useMicrotaskScheduler=!0,Uk(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(t)})}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,this.pendingRenderTaskId!==null){let t=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(t)}}static \u0275fac=function(r){return new(r||n)};static \u0275prov=ut({token:n,factory:n.\u0275fac,providedIn:"root"})}return n})();function kw(){return ap("NgZoneless"),ju([{provide:fo,useExisting:Dw},{provide:rn,useClass:mf},{provide:rf,useValue:!0},{provide:cg,useValue:!1},[]])}function fK(){return typeof $localize<"u"&&$localize.locale||bf}var If=new qe("",{providedIn:"root",factory:()=>Ae(If,{optional:!0,skipSelf:!0})||fK()});var _w=class{[Vn];constructor(e){this[Vn]=e}destroy(){this[Vn].destroy()}};function Aw(n,e){let t=e?.injector??Ae(Ko),r=e?.manualCleanup!==!0?t.get(Va):null,o,s=t.get(of,null,{optional:!0}),i=t.get(fo);return s!==null?(o=gK(s.view,i,n),r instanceof Ud&&r._lView===s.view&&(r=null)):o=xK(n,t.get(sf),i),o.injector=t,r!==null&&(o.onDestroyFn=r.onDestroy(()=>o.destroy())),new _w(o)}var TA=Lt(Rt({},S1),{cleanupFns:void 0,zone:null,onDestroyFn:za,run(){let n=Zu(!1);try{N1(this)}finally{Zu(n)}},cleanup(){if(!this.cleanupFns?.length)return;let n=Me(null);try{for(;this.cleanupFns.length;)this.cleanupFns.pop()()}finally{this.cleanupFns=[],Me(n)}}}),mK=Lt(Rt({},TA),{consumerMarkedDirty(){this.scheduler.schedule(this),this.notifier.notify(12)},destroy(){ba(this),this.onDestroyFn(),this.cleanup(),this.scheduler.remove(this)}}),hK=Lt(Rt({},TA),{consumerMarkedDirty(){this.view[Ie]|=8192,La(this.view),this.notifier.notify(13)},destroy(){ba(this),this.onDestroyFn(),this.cleanup(),this.view[Xo]?.delete(this)}});function gK(n,e,t){let r=Object.create(hK);return r.view=n,r.zone=typeof Zone<"u"?Zone.current:null,r.notifier=e,r.fn=SA(r,t),n[Xo]??=new Set,n[Xo].add(r),r.consumerMarkedDirty(r),r}function xK(n,e,t){let r=Object.create(mK);return r.fn=SA(r,n),r.scheduler=e,r.notifier=t,r.zone=typeof Zone<"u"?Zone.current:null,r.scheduler.add(r),r.notifier.notify(12),r}function SA(n,e){return()=>{e(t=>(n.cleanupFns??=[]).push(t))}}var DA=Symbol("InputSignalNode#UNSET"),AK=Lt(Rt({},Rh),{transformFn:void 0,applyValueToInputSignal(n,e){Lu(n,e)}});function kA(n,e){let t=Object.create(AK);t.value=n,t.transformFn=e?.transform;function r(){if(Md(t),t.value===DA){let o=null;throw new Te(-950,o)}return t.value}return r[Vn]=t,r}var RK=new qe("");RK.__NG_ELEMENT_ID__=n=>{let e=yr();if(e===null)throw new Te(204,!1);if(e.type&2)return e.value;if(n&8)return null;throw new Te(204,!1)};function NA(n,e){return kA(n,e)}function FK(n){return kA(DA,n)}var Gg=(NA.required=FK,NA);var Rw=new qe(""),MK=new qe("");function Ef(n){return!n.moduleRef}function OK(n){let e=Ef(n)?n.r3Injector:n.moduleRef.injector,t=e.get(rn);return t.run(()=>{Ef(n)?n.r3Injector.resolveInjectorInitializers():n.moduleRef.resolveInjectorInitializers();let r=e.get(yo),o;if(t.runOutsideAngular(()=>{o=t.onError.subscribe({next:r})}),Ef(n)){let s=()=>e.destroy(),i=n.platformInjector.get(Rw);i.add(s),e.onDestroy(()=>{o.unsubscribe(),i.delete(s)})}else{let s=()=>n.moduleRef.destroy(),i=n.platformInjector.get(Rw);i.add(s),n.moduleRef.onDestroy(()=>{cf(n.allPlatformModules,n.moduleRef),o.unsubscribe(),i.delete(s)})}return PK(r,t,()=>{let s=e.get(Ua),i=s.add(),a=e.get(ww);return a.runInitializers(),a.donePromise.then(()=>{let c=e.get(If,bf);if(CA(c||bf),!e.get(MK,!0))return Ef(n)?e.get(vf):(n.allPlatformModules.push(n.moduleRef),n.moduleRef);if(Ef(n)){let u=e.get(vf);return n.rootComponent!==void 0&&u.bootstrap(n.rootComponent),u}else return $K?.(n.moduleRef,n.allPlatformModules),n.moduleRef}).finally(()=>void s.remove(i))})})}var $K;function PK(n,e,t){try{let r=t();return Lg(r)?r.catch(o=>{throw e.runOutsideAngular(()=>n(o)),o}):r}catch(r){throw e.runOutsideAngular(()=>n(r)),r}}var Hg=null;function LK(n=[],e){return Ko.create({name:e,providers:[{provide:Wd,useValue:"platform"},{provide:Rw,useValue:new Set([()=>Hg=null])},...n]})}function BK(n=[]){if(Hg)return Hg;let e=LK(n);return Hg=e,yA(),VK(e),e}function VK(n){let e=n.get(_g,null);Yh(n,()=>{e?.forEach(t=>t())})}function _A(n){let{rootComponent:e,appProviders:t,platformProviders:r,platformRef:o}=n;pt(8);try{let s=o?.injector??BK(r),i=[IA({}),{provide:fo,useExisting:Dw},bk,...t||[]],a=new ff({providers:i,parent:s,debugName:"",runEnvironmentInitializers:!1});return OK({r3Injector:a.injector,platformInjector:s,rootComponent:e})}catch(s){return Promise.reject(s)}finally{pt(9)}}var AA=null;function Sf(){return AA}function Mw(n){AA??=n}var Tf=class{};var Pw=(function(n){return n[n.Decimal=0]="Decimal",n[n.Percent=1]="Percent",n[n.Currency=2]="Currency",n[n.Scientific=3]="Scientific",n})(Pw||{});var Eo={Decimal:0,Group:1,List:2,PercentSign:3,PlusSign:4,MinusSign:5,Exponential:6,SuperscriptingExponent:7,PerMille:8,Infinity:9,NaN:10,TimeSeparator:11,CurrencyDecimal:12,CurrencyGroup:13};function up(n,e){let t=Vg(n),r=t[Za.NumberSymbols][e];if(typeof r>"u"){if(e===Eo.CurrencyDecimal)return t[Za.NumberSymbols][Eo.Decimal];if(e===Eo.CurrencyGroup)return t[Za.NumberSymbols][Eo.Group]}return r}function MA(n,e){return Vg(n)[Za.NumberFormats][e]}var UK=/^(\d+)?\.((\d+)(-(\d+))?)?$/,RA=22,Wg=".",Nf="0",zK=";",HK=",",Ow="#";function GK(n,e,t,r,o,s,i=!1){let a="",c=!1;if(!isFinite(n))a=up(t,Eo.Infinity);else{let l=qK(n);i&&(l=jK(l));let u=e.minInt,p=e.minFrac,d=e.maxFrac;if(s){let v=s.match(UK);if(v===null)throw new Te(2306,!1);let w=v[1],I=v[3],_=v[5];w!=null&&(u=$w(w)),I!=null&&(p=$w(I)),_!=null?d=$w(_):I!=null&&p>d&&(d=p)}KK(l,p,d);let f=l.digits,m=l.integerLen,h=l.exponent,g=[];for(c=f.every(v=>!v);m<u;m++)f.unshift(0);for(;m<0;m++)f.unshift(0);m>0?g=f.splice(m,f.length):(g=f,f=[0]);let x=[];for(f.length>=e.lgSize&&x.unshift(f.splice(-e.lgSize,f.length).join(""));f.length>e.gSize;)x.unshift(f.splice(-e.gSize,f.length).join(""));f.length&&x.unshift(f.join("")),a=x.join(up(t,r)),g.length&&(a+=up(t,o)+g.join("")),h&&(a+=up(t,Eo.Exponential)+"+"+h)}return n<0&&!c?a=e.negPre+a+e.negSuf:a=e.posPre+a+e.posSuf,a}function OA(n,e,t){let r=MA(e,Pw.Decimal),o=WK(r,up(e,Eo.MinusSign));return GK(n,o,e,Eo.Group,Eo.Decimal,t)}function WK(n,e="-"){let t={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},r=n.split(zK),o=r[0],s=r[1],i=o.indexOf(Wg)!==-1?o.split(Wg):[o.substring(0,o.lastIndexOf(Nf)+1),o.substring(o.lastIndexOf(Nf)+1)],a=i[0],c=i[1]||"";t.posPre=a.substring(0,a.indexOf(Ow));for(let u=0;u<c.length;u++){let p=c.charAt(u);p===Nf?t.minFrac=t.maxFrac=u+1:p===Ow?t.maxFrac=u+1:t.posSuf+=p}let l=a.split(HK);if(t.gSize=l[1]?l[1].length:0,t.lgSize=l[2]||l[1]?(l[2]||l[1]).length:0,s){let u=o.length-t.posPre.length-t.posSuf.length,p=s.indexOf(Ow);t.negPre=s.substring(0,p).replace(/'/g,""),t.negSuf=s.slice(p+u).replace(/'/g,"")}else t.negPre=e+t.posPre,t.negSuf=t.posSuf;return t}function jK(n){if(n.digits[0]===0)return n;let e=n.digits.length-n.integerLen;return n.exponent?n.exponent+=2:(e===0?n.digits.push(0,0):e===1&&n.digits.push(0),n.integerLen+=2),n}function qK(n){let e=Math.abs(n)+"",t=0,r,o,s,i,a;for((o=e.indexOf(Wg))>-1&&(e=e.replace(Wg,"")),(s=e.search(/e/i))>0?(o<0&&(o=s),o+=+e.slice(s+1),e=e.substring(0,s)):o<0&&(o=e.length),s=0;e.charAt(s)===Nf;s++);if(s===(a=e.length))r=[0],o=1;else{for(a--;e.charAt(a)===Nf;)a--;for(o-=s,r=[],i=0;s<=a;s++,i++)r[i]=Number(e.charAt(s))}return o>RA&&(r=r.splice(0,RA-1),t=o-1,o=1),{digits:r,exponent:t,integerLen:o}}function KK(n,e,t){if(e>t)throw new Te(2307,!1);let r=n.digits,o=r.length-n.integerLen,s=Math.min(Math.max(e,o),t),i=s+n.integerLen,a=r[i];if(i>0){r.splice(Math.max(n.integerLen,i));for(let p=i;p<r.length;p++)r[p]=0}else{o=Math.max(0,o),n.integerLen=1,r.length=Math.max(1,i=s+1),r[0]=0;for(let p=1;p<i;p++)r[p]=0}if(a>=5)if(i-1<0){for(let p=0;p>i;p--)r.unshift(0),n.integerLen++;r.unshift(1),n.integerLen++}else r[i-1]++;for(;o<Math.max(0,s);o++)r.push(0);let c=s!==0,l=e+n.integerLen,u=r.reduceRight(function(p,d,f,m){return d=d+p,m[f]=d<10?d:d-10,c&&(m[f]===0&&f>=l?m.pop():c=!1),d>=10?1:0},0);u&&(r.unshift(u),n.integerLen++)}function $w(n){let e=parseInt(n);if(isNaN(e))throw new Te(2305,!1);return e}var Lw=(()=>{class n{_viewContainer;_context=new jg;_thenTemplateRef=null;_elseTemplateRef=null;_thenViewRef=null;_elseViewRef=null;constructor(t,r){this._viewContainer=t,this._thenTemplateRef=r}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){FA(t,!1),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){FA(t,!1),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngIfUseIfTypeGuard;static ngTemplateGuard_ngIf;static ngTemplateContextGuard(t,r){return!0}static \u0275fac=function(r){return new(r||n)(wo(ip),wo(Wa))};static \u0275dir=fw({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}})}return n})(),jg=class{$implicit=null;ngIf=null};function FA(n,e){if(n&&!n.createEmbeddedView)throw new Te(2020,!1)}function XK(n,e){return new Te(2100,!1)}var Bw=(()=>{class n{_locale;constructor(t){this._locale=t}transform(t,r,o){if(!YK(t))return null;o||=this._locale;try{let s=ZK(t);return OA(s,o,r)}catch(s){throw XK(n,s.message)}}static \u0275fac=function(r){return new(r||n)(wo(If,16))};static \u0275pipe=mw({name:"number",type:n,pure:!0})}return n})();function YK(n){return!(n==null||n===""||n!==n)}function ZK(n){if(typeof n=="string"&&!isNaN(Number(n)-parseFloat(n)))return Number(n);if(typeof n!="number")throw new Te(2309,!1);return n}var qg=(()=>{class n{static \u0275fac=function(r){return new(r||n)};static \u0275mod=Pg({type:n});static \u0275inj=zd({})}return n})();function Vw(n,e){e=encodeURIComponent(e);for(let t of n.split(";")){let r=t.indexOf("="),[o,s]=r==-1?[t,""]:[t.slice(0,r),t.slice(r+1)];if(o.trim()===e)return decodeURIComponent(s)}return null}var Df=class{};var $A="browser";var Xg=new qe(""),Ww=(()=>{class n{_zone;_plugins;_eventNameToPlugin=new Map;constructor(t,r){this._zone=r,t.forEach(o=>{o.manager=this}),this._plugins=t.slice().reverse()}addEventListener(t,r,o,s){return this._findPluginFor(r).addEventListener(t,r,o,s)}getZone(){return this._zone}_findPluginFor(t){let r=this._eventNameToPlugin.get(t);if(r)return r;if(r=this._plugins.find(s=>s.supports(t)),!r)throw new Te(5101,!1);return this._eventNameToPlugin.set(t,r),r}static \u0275fac=function(r){return new(r||n)(Qe(Xg),Qe(rn))};static \u0275prov=ut({token:n,factory:n.\u0275fac})}return n})(),kf=class{_doc;constructor(e){this._doc=e}manager},Uw="ng-app-id";function PA(n){for(let e of n)e.remove()}function LA(n,e){let t=e.createElement("style");return t.textContent=n,t}function e9(n,e,t,r){let o=n.head?.querySelectorAll(`style[${Uw}="${e}"],link[${Uw}="${e}"]`);if(o)for(let s of o)s.removeAttribute(Uw),s instanceof HTMLLinkElement?r.set(s.href.slice(s.href.lastIndexOf("/")+1),{usage:0,elements:[s]}):s.textContent&&t.set(s.textContent,{usage:0,elements:[s]})}function Hw(n,e){let t=e.createElement("link");return t.setAttribute("rel","stylesheet"),t.setAttribute("href",n),t}var jw=(()=>{class n{doc;appId;nonce;inline=new Map;external=new Map;hosts=new Set;constructor(t,r,o,s={}){this.doc=t,this.appId=r,this.nonce=o,e9(t,r,this.inline,this.external),this.hosts.add(t.head)}addStyles(t,r){for(let o of t)this.addUsage(o,this.inline,LA);r?.forEach(o=>this.addUsage(o,this.external,Hw))}removeStyles(t,r){for(let o of t)this.removeUsage(o,this.inline);r?.forEach(o=>this.removeUsage(o,this.external))}addUsage(t,r,o){let s=r.get(t);s?s.usage++:r.set(t,{usage:1,elements:[...this.hosts].map(i=>this.addElement(i,o(t,this.doc)))})}removeUsage(t,r){let o=r.get(t);o&&(o.usage--,o.usage<=0&&(PA(o.elements),r.delete(t)))}ngOnDestroy(){for(let[,{elements:t}]of[...this.inline,...this.external])PA(t);this.hosts.clear()}addHost(t){this.hosts.add(t);for(let[r,{elements:o}]of this.inline)o.push(this.addElement(t,LA(r,this.doc)));for(let[r,{elements:o}]of this.external)o.push(this.addElement(t,Hw(r,this.doc)))}removeHost(t){this.hosts.delete(t)}addElement(t,r){return this.nonce&&r.setAttribute("nonce",this.nonce),t.appendChild(r)}static \u0275fac=function(r){return new(r||n)(Qe(vr),Qe(kg),Qe(Ag,8),Qe(sp))};static \u0275prov=ut({token:n,factory:n.\u0275fac})}return n})(),zw={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/Math/MathML"},qw=/%COMP%/g;var VA="%COMP%",t9=`_nghost-${VA}`,n9=`_ngcontent-${VA}`,r9=!0,o9=new qe("",{providedIn:"root",factory:()=>r9});function s9(n){return n9.replace(qw,n)}function i9(n){return t9.replace(qw,n)}function UA(n,e){return e.map(t=>t.replace(qw,n))}var Kw=(()=>{class n{eventManager;sharedStylesHost;appId;removeStylesOnCompDestroy;doc;platformId;ngZone;nonce;animationDisabled;maxAnimationTimeout;tracingService;rendererByCompId=new Map;defaultRenderer;platformIsServer;registry;constructor(t,r,o,s,i,a,c,l=null,u,p,d=null){this.eventManager=t,this.sharedStylesHost=r,this.appId=o,this.removeStylesOnCompDestroy=s,this.doc=i,this.platformId=a,this.ngZone=c,this.nonce=l,this.animationDisabled=u,this.maxAnimationTimeout=p,this.tracingService=d,this.platformIsServer=!1,this.defaultRenderer=new _f(t,i,c,this.platformIsServer,this.tracingService,this.registry=ag(),this.maxAnimationTimeout)}createRenderer(t,r){if(!t||!r)return this.defaultRenderer;let o=this.getOrCreateRenderer(t,r);return o instanceof Kg?o.applyToHost(t):o instanceof Af&&o.applyStyles(),o}getOrCreateRenderer(t,r){let o=this.rendererByCompId,s=o.get(r.id);if(!s){let i=this.doc,a=this.ngZone,c=this.eventManager,l=this.sharedStylesHost,u=this.removeStylesOnCompDestroy,p=this.platformIsServer,d=this.tracingService;switch(r.encapsulation){case Qo.Emulated:s=new Kg(c,l,r,this.appId,u,i,a,p,d,this.registry,this.animationDisabled,this.maxAnimationTimeout);break;case Qo.ShadowDom:return new Gw(c,l,t,r,i,a,this.nonce,p,d,this.registry,this.maxAnimationTimeout);default:s=new Af(c,l,r,u,i,a,p,d,this.registry,this.animationDisabled,this.maxAnimationTimeout);break}o.set(r.id,s)}return s}ngOnDestroy(){this.rendererByCompId.clear()}componentReplaced(t){this.rendererByCompId.delete(t)}static \u0275fac=function(r){return new(r||n)(Qe(Ww),Qe(jw),Qe(kg),Qe(o9),Qe(vr),Qe(sp),Qe(rn),Qe(Ag),Qe(Iw),Qe(Ew),Qe(yf,8))};static \u0275prov=ut({token:n,factory:n.\u0275fac})}return n})(),_f=class{eventManager;doc;ngZone;platformIsServer;tracingService;registry;maxAnimationTimeout;data=Object.create(null);throwOnSyntheticProps=!0;constructor(e,t,r,o,s,i,a){this.eventManager=e,this.doc=t,this.ngZone=r,this.platformIsServer=o,this.tracingService=s,this.registry=i,this.maxAnimationTimeout=a}destroy(){}destroyNode=null;createElement(e,t){return t?this.doc.createElementNS(zw[t]||t,e):this.doc.createElement(e)}createComment(e){return this.doc.createComment(e)}createText(e){return this.doc.createTextNode(e)}appendChild(e,t){(BA(e)?e.content:e).appendChild(t)}insertBefore(e,t,r){e&&(BA(e)?e.content:e).insertBefore(t,r)}removeChild(e,t){let{elements:r}=this.registry;if(r){r.animate(t,()=>t.remove(),this.maxAnimationTimeout);return}t.remove()}selectRootElement(e,t){let r=typeof e=="string"?this.doc.querySelector(e):e;if(!r)throw new Te(-5104,!1);return t||(r.textContent=""),r}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,t,r,o){if(o){t=o+":"+t;let s=zw[o];s?e.setAttributeNS(s,t,r):e.setAttribute(t,r)}else e.setAttribute(t,r)}removeAttribute(e,t,r){if(r){let o=zw[r];o?e.removeAttributeNS(o,t):e.removeAttribute(`${r}:${t}`)}else e.removeAttribute(t)}addClass(e,t){e.classList.add(t)}removeClass(e,t){e.classList.remove(t)}setStyle(e,t,r,o){o&(bo.DashCase|bo.Important)?e.style.setProperty(t,r,o&bo.Important?"important":""):e.style[t]=r}removeStyle(e,t,r){r&bo.DashCase?e.style.removeProperty(t):e.style[t]=""}setProperty(e,t,r){e!=null&&(e[t]=r)}setValue(e,t){e.nodeValue=t}listen(e,t,r,o){if(typeof e=="string"&&(e=Sf().getGlobalEventTarget(this.doc,e),!e))throw new Te(5102,!1);let s=this.decoratePreventDefault(r);return this.tracingService?.wrapEventListener&&(s=this.tracingService.wrapEventListener(e,t,s)),this.eventManager.addEventListener(e,t,s,o)}decoratePreventDefault(e){return t=>{if(t==="__ngUnwrap__")return e;e(t)===!1&&t.preventDefault()}}};function BA(n){return n.tagName==="TEMPLATE"&&n.content!==void 0}var Gw=class extends _f{sharedStylesHost;hostEl;shadowRoot;constructor(e,t,r,o,s,i,a,c,l,u,p){super(e,s,i,c,l,u,p),this.sharedStylesHost=t,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);let d=o.styles;d=UA(o.id,d);for(let m of d){let h=document.createElement("style");a&&h.setAttribute("nonce",a),h.textContent=m,this.shadowRoot.appendChild(h)}let f=o.getExternalStyles?.();if(f)for(let m of f){let h=Hw(m,s);a&&h.setAttribute("nonce",a),this.shadowRoot.appendChild(h)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}appendChild(e,t){return super.appendChild(this.nodeOrShadowRoot(e),t)}insertBefore(e,t,r){return super.insertBefore(this.nodeOrShadowRoot(e),t,r)}removeChild(e,t){return super.removeChild(null,t)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}},Af=class extends _f{sharedStylesHost;removeStylesOnCompDestroy;styles;styleUrls;_animationDisabled;constructor(e,t,r,o,s,i,a,c,l,u,p,d){super(e,s,i,a,c,l,p),this.sharedStylesHost=t,this.removeStylesOnCompDestroy=o,this._animationDisabled=u;let f=r.styles;this.styles=d?UA(d,f):f,this.styleUrls=r.getExternalStyles?.(d)}applyStyles(){this.sharedStylesHost.addStyles(this.styles,this.styleUrls)}destroy(){if(this.removeStylesOnCompDestroy){if(!this._animationDisabled&&this.registry.elements){this.ngZone.runOutsideAngular(()=>{setTimeout(()=>{this.sharedStylesHost.removeStyles(this.styles,this.styleUrls)},this.maxAnimationTimeout)});return}this.sharedStylesHost.removeStyles(this.styles,this.styleUrls)}}},Kg=class extends Af{contentAttr;hostAttr;constructor(e,t,r,o,s,i,a,c,l,u,p,d){let f=o+"-"+r.id;super(e,t,r,s,i,a,c,l,u,p,d,f),this.contentAttr=s9(f),this.hostAttr=i9(f)}applyToHost(e){this.applyStyles(),this.setAttribute(e,this.hostAttr,"")}createElement(e,t){let r=super.createElement(e,t);return super.setAttribute(r,this.contentAttr,""),r}};var Yg=class n extends Tf{supportsDOMEvents=!0;static makeCurrent(){Mw(new n)}onAndCancel(e,t,r,o){return e.addEventListener(t,r,o),()=>{e.removeEventListener(t,r,o)}}dispatchEvent(e,t){e.dispatchEvent(t)}remove(e){e.remove()}createElement(e,t){return t=t||this.getDefaultDocument(),t.createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,t){return t==="window"?window:t==="document"?e:t==="body"?e.body:null}getBaseHref(e){let t=a9();return t==null?null:c9(t)}resetBaseElement(){Rf=null}getUserAgent(){return window.navigator.userAgent}getCookie(e){return Vw(document.cookie,e)}},Rf=null;function a9(){return Rf=Rf||document.head.querySelector("base"),Rf?Rf.getAttribute("href"):null}function c9(n){return new URL(n,document.baseURI).pathname}var l9=(()=>{class n{build(){return new XMLHttpRequest}static \u0275fac=function(r){return new(r||n)};static \u0275prov=ut({token:n,factory:n.\u0275fac})}return n})(),HA=(()=>{class n extends kf{constructor(t){super(t)}supports(t){return!0}addEventListener(t,r,o,s){return t.addEventListener(r,o,s),()=>this.removeEventListener(t,r,o,s)}removeEventListener(t,r,o,s){return t.removeEventListener(r,o,s)}static \u0275fac=function(r){return new(r||n)(Qe(vr))};static \u0275prov=ut({token:n,factory:n.\u0275fac})}return n})(),zA=["alt","control","meta","shift"],u9={"\b":"Backspace","	":"Tab","\x7F":"Delete","\x1B":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},p9={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey},GA=(()=>{class n extends kf{constructor(t){super(t)}supports(t){return n.parseEventName(t)!=null}addEventListener(t,r,o,s){let i=n.parseEventName(r),a=n.eventCallback(i.fullKey,o,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Sf().onAndCancel(t,i.domEventName,a,s))}static parseEventName(t){let r=t.toLowerCase().split("."),o=r.shift();if(r.length===0||!(o==="keydown"||o==="keyup"))return null;let s=n._normalizeKey(r.pop()),i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),zA.forEach(l=>{let u=r.indexOf(l);u>-1&&(r.splice(u,1),i+=l+".")}),i+=s,r.length!=0||s.length===0)return null;let c={};return c.domEventName=o,c.fullKey=i,c}static matchEventFullKeyCode(t,r){let o=u9[t.key]||t.key,s="";return r.indexOf("code.")>-1&&(o=t.code,s="code."),o==null||!o?!1:(o=o.toLowerCase(),o===" "?o="space":o==="."&&(o="dot"),zA.forEach(i=>{if(i!==o){let a=p9[i];a(t)&&(s+=i+".")}}),s+=o,s===r)}static eventCallback(t,r,o){return s=>{n.matchEventFullKeyCode(s,t)&&o.runGuarded(()=>r(s))}}static _normalizeKey(t){return t==="esc"?"escape":t}static \u0275fac=function(r){return new(r||n)(Qe(vr))};static \u0275prov=ut({token:n,factory:n.\u0275fac})}return n})();function Xw(n,e,t){let r=Rt({rootComponent:n,platformRef:t?.platformRef},d9(e));return _A(r)}function d9(n){return{appProviders:[...x9,...n?.providers??[]],platformProviders:g9}}function f9(){Yg.makeCurrent()}function m9(){return new Fr}function h9(){return jC(document),document}var g9=[{provide:sp,useValue:$A},{provide:_g,useValue:f9,multi:!0},{provide:vr,useFactory:h9}];var x9=[{provide:Wd,useValue:"root"},{provide:Fr,useFactory:m9},{provide:Xg,useClass:HA,multi:!0,deps:[vr]},{provide:Xg,useClass:GA,multi:!0,deps:[vr]},Kw,jw,Ww,{provide:ja,useExisting:Kw},{provide:Df,useClass:l9},[]];var pp=class n{config=rt(null);constructor(){}async loadConfig(){try{let r=`config/config-${new URLSearchParams(window.location.search).get("variant")??"dev"}.json`,s=await(await fetch(r)).json();this.config.set(s),console.log("\u2705 Configuraci\xF3n cargada:",s)}catch(e){console.error("\u274C No se pudo cargar la configuraci\xF3n:",e)}}getFeature(e){return this.config()?.features[e]??!1}get variant(){return this.config()?.variant??"default"}static \u0275fac=function(t){return new(t||n)};static \u0275prov=ut({token:n,factory:n.\u0275fac,providedIn:"root"})};var WA={providers:[pC(),kw(),Cw(()=>Ae(pp).loadConfig())]};T();T();T();function X(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}var Rte=Jt.whereImpl,WP=(()=>{class n extends To{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new js(this,lr())}write(t,r,o){this.firstUse&&(this.firstUse=!1,O().get("IS_NODE")&&S.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:o,refCount:1}),s}makeTensorInfo(t,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&y.isString(o[0])){let i=o.map(a=>y.encodeString(a));s=this.write(i,t,r)}else s=this.write(o,t,r);return{dataId:s,shape:t,dtype:r}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let r=this.data.get(t);r.refCount++}decRef(t){if(this.data.has(t)){let r=this.data.get(t);r.refCount--}}move(t,r,o,s,i){this.data.set(t,{values:r,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:r,complexTensorInfos:o}=this.data.get(t);if(r==="complex64"){let s=this.readSync(o.real.dataId),i=this.readSync(o.imag.dataId);return S.mergeRealAndImagArrays(s,i)}return y.convertBackendValuesAndArrayBuffer(this.data.get(t).values,r)}bufferSync(t){let r=this.readSync(t.dataId);if(t.dtype==="string")try{let o=r.map(s=>y.decodeString(s));return le(t.shape,t.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return le(t.shape,t.dtype,r)}makeOutput(t,r,o){return lr().makeTensorFromTensorInfo(this.makeTensorInfo(r,o,t),this)}disposeData(t,r=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!r&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:o}=this.data.get(t);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let r=y.now();return t(),{kernelMs:y.now()-r}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){X([t],"where");let r=this.readSync(t.dataId);return Rte(t.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();var FN={};Ue(FN,{addImpl:()=>sN,bincountImpl:()=>sd,bincountReduceImpl:()=>xy,bitwiseAndImpl:()=>iN,castImpl:()=>oN,ceilImpl:()=>aN,concatImpl:()=>yy,equalImpl:()=>cN,expImpl:()=>uN,expm1Impl:()=>dN,floorDivImpl:()=>mN,floorImpl:()=>fN,gatherNdImpl:()=>vy,gatherV2Impl:()=>by,greaterEqualImpl:()=>gN,greaterImpl:()=>hN,lessEqualImpl:()=>yN,lessImpl:()=>xN,linSpaceImpl:()=>Cy,logImpl:()=>vN,maxImpl:()=>wy,maximumImpl:()=>bN,minimumImpl:()=>CN,multiplyImpl:()=>th,negImpl:()=>wN,notEqualImpl:()=>IN,prodImpl:()=>EN,raggedGatherImpl:()=>Iy,raggedRangeImpl:()=>Ey,raggedTensorToTensorImpl:()=>Ty,rangeImpl:()=>Sy,rsqrtImpl:()=>SN,scatterImpl:()=>so,sigmoidImpl:()=>wL,simpleAbsImpl:()=>rN,sliceImpl:()=>DN,sparseFillEmptyRowsImpl:()=>Ny,sparseReshapeImpl:()=>Dy,sparseSegmentReductionImpl:()=>ad,sqrtImpl:()=>TL,squaredDifferenceImpl:()=>kN,staticRegexReplaceImpl:()=>_N,stridedSliceImpl:()=>ky,stringNGramsImpl:()=>_y,stringSplitImpl:()=>Ay,stringToHashBucketFastImpl:()=>Ry,subImpl:()=>RN,tileImpl:()=>Fy,topKImpl:()=>My,transposeImpl:()=>id,uniqueImpl:()=>Oy});T();function rN(n){let e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}var Fte=n=>{let{x:e}=n.inputs,t=n.backend;X(e,"abs");let r=new Float32Array(y.sizeFromShape(e.shape)),o=t.data.get(e.dataId).values;return r=rN(o),t.makeOutput(r,e.shape,e.dtype)},jP={kernelName:"Abs",backendName:"cpu",kernelFunc:Fte};T();T();function ke(n){return(e,t,r,o,s)=>{let i=S.assertAndGetBroadcastShape(e,t),a=i.length,c=y.computeStrides(i),l=y.sizeFromShape(i),u=y.getTypedArrayFromDType(s,l),p=e.length,d=t.length,f=y.computeStrides(e),m=y.computeStrides(t),h=S.getBroadcastDims(e,i),g=S.getBroadcastDims(t,i);if(h.length+g.length===0)for(let x=0;x<u.length;++x)u[x]=n(r[x%r.length],o[x%o.length]);else for(let x=0;x<u.length;++x){let v=y.indexToLoc(x,a,c),w=v.slice(-p);h.forEach(R=>w[R]=0);let I=y.locToIndex(w,p,f),_=v.slice(-d);g.forEach(R=>_[R]=0);let A=y.locToIndex(_,d,m);u[x]=n(r[I],o[A])}return[u,i]}}T();T();T();T();function Pt(n){let{inputs:e,backend:t}=n,{real:r,imag:o}=e,s=t.data.get(r.dataId).values,i=t.data.get(o.dataId).values,a=t.makeTensorInfo(r.shape,"complex64"),c=t.data.get(a.dataId);return c.complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",s),imag:t.makeTensorInfo(o.shape,"float32",i)},a}var qP={kernelName:pc,backendName:"cpu",kernelFunc:Pt};function rd(n,e,t="float32"){if(t==="complex64"){let o=rd(n,e,"float32"),s=rd(n,e,"float32");return Pt({inputs:{real:o,imag:s},backend:n})}let r=y.makeZerosTypedArray(y.sizeFromShape(e),t);return n.makeTensorInfo(e,t,r)}T();function ln(n){let{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var KP={kernelName:ns,backendName:"cpu",kernelFunc:ln};T();function Sr(n){let{inputs:e,backend:t}=n,{input:r}=e,o=t.data.get(r.dataId).complexTensorInfos.real,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var XP={kernelName:dl,backendName:"cpu",kernelFunc:Sr};function oN(n,e,t,r){if(r==="int32"){let o=Int32Array.from(n);return[e,"int32",o]}if(r==="bool"){let o=y.toTypedArray([0],t),[s,i]=ke((a,c)=>a!==c?1:0)(e,[],n,o,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}function Nr(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return ln({inputs:{x:o},backend:t});let u=rd(t,o.shape,o.dtype),p=Nr({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),d=Pt({inputs:{real:p,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(p),d}if(o.dtype==="complex64"){let u=Sr({inputs:{input:o},backend:t}),p=Nr({inputs:{x:u},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(u),p}if(!y.hasEncodingLoss(o.dtype,s)){let u=ln({inputs:{x:o},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:s}}let i=t.data.get(o.dataId).values,[a,c,l]=oN(i,o.shape,o.dtype,s);return t.makeTensorInfo(a,c,l)}var YP={kernelName:ts,backendName:"cpu",kernelFunc:Nr};function Ve(n,e,t,r){return t==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,c=s;X([i,a],n);let l=c.data.get(i.dataId).values,u=c.data.get(a.dataId).values,p=i.dtype==="string"?S.fromUint8ToStringArray(l):l,d=i.dtype==="string"?S.fromUint8ToStringArray(u):u,f=r||i.dtype,[m,h]=e(i.shape,a.shape,p,d,f);return c.makeTensorInfo(h,f,m)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,c=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let l=Nr({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),u=c.data.get(l.dataId),p=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,f=c.data.get(p.dataId).values,m=c.data.get(d.dataId).values,h=Nr({inputs:{x:a},backend:c,attrs:{dtype:"complex64"}}),g=c.data.get(h.dataId),x=g.complexTensorInfos.real,v=g.complexTensorInfos.imag,w=c.data.get(x.dataId).values,I=c.data.get(v.dataId).values,[_,A,R]=t(i.shape,a.shape,f,m,w,I),F=c.makeTensorInfo(R,"float32",_),P=c.makeTensorInfo(R,"float32",A),L=Pt({inputs:{real:F,imag:P},backend:c});return c.disposeIntermediateTensorInfo(l),c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(F),c.disposeIntermediateTensorInfo(P),L}else{let l=c.data.get(i.dataId).values,u=c.data.get(a.dataId).values,p=r||i.dtype,[d,f]=e(i.shape,a.shape,l,u,p);return c.makeTensorInfo(f,p,d)}}}function od(n){return(e,t,r,o,s,i)=>{let a=S.assertAndGetBroadcastShape(e,t),c=y.sizeFromShape(a),l=a.length,u=y.computeStrides(a),p=y.getTypedArrayFromDType("float32",c),d=y.getTypedArrayFromDType("float32",c),f=S.getBroadcastDims(e,a),m=S.getBroadcastDims(t,a),h=S.mergeRealAndImagArrays(r,o),g=S.mergeRealAndImagArrays(s,i),x=e.length,v=y.computeStrides(e),w=t.length,I=y.computeStrides(t);if(f.length+m.length===0)for(let _=0;_<p.length;_++){let A=_%h.length,R=_%g.length,F=n(h[A*2],h[A*2+1],g[R*2],g[R*2+1]);p[_]=F.real,d[_]=F.imag}else for(let _=0;_<p.length;_++){let A=y.indexToLoc(_,l,u),R=A.slice(-x);f.forEach(z=>R[z]=0);let F=y.locToIndex(R,x,v),P=A.slice(-w);m.forEach(z=>P[z]=0);let L=y.locToIndex(P,w,I),V=n(h[F*2],h[F*2+1],g[L*2],g[L*2+1]);p[_]=V.real,d[_]=V.imag}return[p,d,a]}}var sN=ke((n,e)=>n+e),Mte=od((n,e,t,r)=>({real:n+t,imag:e+r})),Vo=Ve("Add",sN,Mte),ZP={kernelName:"Add",backendName:"cpu",kernelFunc:Vo};T();function sd(n,e,t,r,o){let s=y.sizeFromShape(r),i=y.makeZerosTypedArray(o,t);for(let a=0;a<n.length;a++){let c=n[a];if(c<0)throw new Error("Input x must be non-negative!");c>=o||(s>0?i[c]+=e[a]:i[c]+=1)}return i}function xy(n,e,t,r=!1){let o=n.shape[0],s=n.shape[1],i=le([o,t],e.dtype);for(let a=0;a<o;a++)for(let c=0;c<s;c++){let l=n.get(a,c);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(r?i.set(1,a,l):e.size>0?i.set(i.get(a,l)+e.get(a,c),a,l):i.set(i.get(a,l)+1,a,l))}return i}T();var iN=ke((n,e)=>n&e),Ote=Ve(ni,iN),QP={kernelName:ni,backendName:"cpu",kernelFunc:Ote};T();T();function jt(n){return(e,t,r)=>{let o=y.getArrayFromDType(t,e.length);for(let s=0;s<e.length;++s)o[s]=n(e[s],r);return o}}T();function he(n,e,t){let r=jt(e);return $n(n,r,t)}function $n(n,e,t){return({inputs:r,attrs:o,backend:s})=>{let{x:i}=r;X(i,n);let a=s,c=a.data.get(i.dataId).values,l;if(i.dtype==="string"){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");l=S.fromUint8ToStringArray(c)}else l=c;let u=t||i.dtype,p=e(l,u,o);return a.makeTensorInfo(i.shape,u,p)}}var aN=jt(n=>Math.ceil(n)),$te=$n(ri,aN),JP={kernelName:ri,backendName:"cpu",kernelFunc:$te};T();function yy(n,e,t,r){let o=y.getArrayFromDType(t,y.sizeFromShape(e));if(r&&t!=="string"){let s=0;n.forEach(i=>{let a=y.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;n.forEach(i=>{let a=t==="string"?S.fromUint8ToStringArray(i.vals):i.vals,c=0;for(let l=0;l<i.shape[0];++l){let u=l*e[1]+s;for(let p=0;p<i.shape[1];++p)o[u+p]=a[c++]}s+=i.shape[1]})}return o}T();var cN=ke((n,e)=>n===e?1:0),lN=Ve(ai,cN,null,"bool"),eL={kernelName:ai,backendName:"cpu",kernelFunc:lN};T();var uN=jt(n=>Math.exp(n)),pN=$n("Exp",uN,"float32"),tL={kernelName:"Exp",backendName:"cpu",kernelFunc:pN};T();var dN=jt(n=>Math.expm1(n)),Pte=$n(ci,dN),nL={kernelName:ci,backendName:"cpu",kernelFunc:Pte};T();var fN=jt(n=>Math.floor(n)),Lte=$n(li,fN),rL={kernelName:li,backendName:"cpu",kernelFunc:Lte};T();var mN=ke((n,e)=>Math.floor(n/e)),Bte=Ve(ui,mN,null,"int32"),oL={kernelName:ui,backendName:"cpu",kernelFunc:Bte};T();function vy(n,e,t,r,o,s,i,a,c){let l=le([r,s],t);for(let u=0;u<r;u++){let p=[],d=0;for(let f=0;f<o;f++){let m=n[u*o+f];d+=m*i[f],p.push(m)}if(d<0||d>=c/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let f=0;f<s;f++)l.values[u*s+f]=e.get(...e.indexToLoc(d*s+f))}return l}T();function by(n,e,t){let r=le(t,n.dtype);for(let o=0;o<r.size;++o){let i=r.indexToLoc(o).slice(),a=i[0],c=i[2],l=e.locToIndex([a,c]);i[2]=e.values[l];let u=n.locToIndex(i);0<=u&&u<n.values.length&&(r.values[o]=n.values[u])}return r}T();var hN=ke((n,e)=>n>e?1:0),Vte=Ve(pi,hN,null,"bool"),sL={kernelName:pi,backendName:"cpu",kernelFunc:Vte};T();var gN=ke((n,e)=>n>=e?1:0),Ute=Ve(di,gN,null,"bool"),iL={kernelName:di,backendName:"cpu",kernelFunc:Ute};T();var xN=ke((n,e)=>n<e?1:0),zte=Ve(gi,xN,null,"bool"),aL={kernelName:gi,backendName:"cpu",kernelFunc:zte};T();var yN=ke((n,e)=>n<=e?1:0),Hte=Ve(xi,yN,null,"bool"),cL={kernelName:xi,backendName:"cpu",kernelFunc:Hte};T();function Cy(n,e,t){let r=(e-n)/(t-1),o=y.makeZerosTypedArray(t,"float32");o[0]=n;for(let s=1;s<o.length;s++)o[s]=o[s-1]+r;return o}T();var vN=jt(n=>Math.log(n)),Gte=$n("Log",vN),lL={kernelName:"Log",backendName:"cpu",kernelFunc:Gte};T();function wy(n,e,t,r){let o=y.getTypedArrayFromDType(r,y.sizeFromShape(t));for(let s=0;s<o.length;++s){let i=s*e,a=n[i];for(let c=0;c<e;++c){let l=n[i+c];(Number.isNaN(l)||l>a)&&(a=l)}o[s]=a}return o}T();var bN=ke((n,e)=>Math.max(n,e)),Wte=Ve(wi,bN),uL={kernelName:wi,backendName:"cpu",kernelFunc:Wte};T();var CN=ke((n,e)=>Math.min(n,e)),jte=Ve(Ii,CN),pL={kernelName:Ii,backendName:"cpu",kernelFunc:jte};T();var th=ke((n,e)=>n*e),qte=od((n,e,t,r)=>({real:n*t-e*r,imag:n*r+e*t})),bu=Ve(Ei,th,qte),dL={kernelName:Ei,backendName:"cpu",kernelFunc:bu};T();function wN(n,e,t){let r=y.createScalarValue(-1,t);return th([],e,r,n,t)}function Kte(n){let{inputs:e,backend:t}=n,{x:r}=e;X(r,"neg");let o=t.data.get(r.dataId).values,[s,i]=wN(o,r.shape,r.dtype);return t.makeTensorInfo(i,r.dtype,s)}var fL={kernelName:"Neg",backendName:"cpu",kernelFunc:Kte};T();var IN=ke((n,e)=>n!==e?1:0),Xte=Ve(Ti,IN,null,"bool"),mL={kernelName:Ti,backendName:"cpu",kernelFunc:Xte};T();T();T();function id(n,e,t,r,o){let s=e.length,i=y.sizeFromShape(e),a=y.computeStrides(e),c=y.computeStrides(o),l=y.getTypedArrayFromDType(t,y.sizeFromShape(o));for(let u=0;u<i;++u){let p=y.indexToLoc(u,s,a),d=new Array(p.length);for(let m=0;m<d.length;m++)d[m]=p[r[m]];let f=y.locToIndex(d,s,c);l[f]=n[u]}return l}function gt(n){let{inputs:e,attrs:t,backend:r}=n,{x:o}=e,{perm:s}=t;X(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let c=r.data.get(o.dataId).values,l=id(c,o.shape,o.dtype,s,a);return{dataId:r.write(l,a,o.dtype),shape:a,dtype:o.dtype}}var hL={kernelName:os,backendName:"cpu",kernelFunc:gt};function EN(n,e,t,r){let[o,s]=S.computeOutAndReduceShapes(n,r),i=Dt(e,"int32"),a=y.makeZerosTypedArray(y.sizeFromShape(o),i),c=y.sizeFromShape(s);for(let l=0;l<a.length;++l){let u=l*c,p=1;for(let d=0;d<c;++d)p*=t[u+d];a[l]=p}return{outVals:a,outShape:o,outDtype:i}}function Yte(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;X(o,"prod");let a=o.shape.length,c=y.parseAxisParam(s,o.shape),l=S.getAxesPermutation(c,a),u=c,p=o,d=[];l!=null&&(p=gt({inputs:{x:o},backend:t,attrs:{perm:l}}),d.push(p),u=S.getInnerMostAxes(u.length,a));let f=t.data.get(p.dataId).values,{outVals:m,outShape:h,outDtype:g}=EN(p.shape,p.dtype,f,u),x=h;return i&&(x=S.expandShapeToKeepDim(h,c)),d.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(x,g,m)}var gL={kernelName:al,backendName:"cpu",kernelFunc:Yte};T();function Zte(n,e,t){n.forEach((r,o)=>{if(r<0||r>=t){let s=y.indexToLoc(o,e.length,y.computeStrides(e)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${t})`)}})}function Qte(n,e){for(let t=0;t<n.length;++t){let r=n[t],o=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>o)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function Jte(n,e,t,r){let o=[],s=0,i=e.length-1+t.length,a=new Array(i).fill(null).map(()=>[0]);Qte(t,r);let c=1;for(let l=0;l<e.length-1;++l){c*=e[l];let u=e[l+1];for(let p=1;p<c+1;++p)a[l].push(p*u)}for(let l=0;l<n.length;++l){let u=n[l],p=n[l]+1;for(let d=0;d<t.length;++d){let f=t[d],m=d+e.length-1;if(m>=0){let h=a[m],g=h[h.length-1]-f[u];for(let x=u;x<p;++x)a[m].push(f[x+1]+g)}u=f[u],p=f[p]}p!==u&&(o.push([u,p]),s+=p-u)}return{outSplits:a,valueSlices:o,numValues:s}}function ene(n){let e=[];for(let t=0;t<n.length;++t){let r=n[t].length,o=y.getArrayFromDType("int32",r);e.push(o),n[t].forEach((s,i)=>o[i]=s)}return e}function xL(n,e){let t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function tne(n,e,t,r,o,s){let i=xL(e,2)[1],a=xL(s,2)[1],c=0;for(let l of t)for(let u=l[0];u<l[1];++u){for(let p=0;p<r;++p)o[c*a+p]=n[u*i+p];++c}}function nne(n,e,t,r,o){let s=e.slice();s[0]=o;let i=y.getArrayFromDType(t,y.sizeFromShape(s)),a=n.length,c=a===0?0:a/e[0];return tne(n,e,r,c,i,s),[i,s]}function Iy(n,e,t,r,o,s,i,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");let c=e[0][0]-1;if(Zte(s,i,c),r.length===0)throw new Error("params.rank must be nonzero");let l=r[0],{outSplits:u,valueSlices:p,numValues:d}=Jte(s,i,n,l),f=ene(u),m=nne(t,r,o,p,d);return[f,m[0],m[1]]}T();var yL=2147483647;function Ey(n,e,t,r,o,s,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let a=e.length===0,c=o.length===0,l=i.length===0,u=[];a||u.push(e[0]),c||u.push(o[0]),l||u.push(i[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");let p=u.length===0?1:u[0],d=y.getArrayFromDType("int32",p+1);d[0]=0;for(let g=0;g<p;++g){let x=a?n[0]:n[g],v=c?r[0]:r[g],w=l?s[0]:s[g];if(w===0)throw new Error("Requires delta != 0");let I;if(w>0&&v<x||w<0&&v>x)I=0;else if(I=Math.ceil(Math.abs((v-x)/w)),I>yL)throw new Error(`Requires ((limit - start) / delta) <= ${yL}`);d[g+1]=d[g]+I}let f=d[p],m=y.getArrayFromDType(t,f),h=0;for(let g=0;g<p;++g){let x=d[g+1]-d[g],v=a?n[0]:n[g],w=l?s[0]:s[g];for(let I=0;I<x;++I)m[h++]=v,v+=w}return[d,m]}T();var Dr=S.RowPartitionType,TN=class n{constructor(e,t,r,o,s,i,a,c,l,u){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=o,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=c,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=S.getRowPartitionTypesHelper(u),this.raggedRank=S.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Dr.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Dr.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Dr.VALUE_ROWIDS:return n.getMaxWidthValueRowID(t);case Dr.ROW_SPLITS:return n.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Dr[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(t===0||t===1)return 0;let r=0;for(let o=0;o<t-1;++o){let s=e[o+1]-e[o];s>r&&(r=s)}return r}static getMaxWidthValueRowID(e){let t=e.length;if(t===0)return 0;let r=0,o=e[0],s=0;for(let i=1;i<t;++i){let a=e[i];a!==o&&(o=a,s=Math.max(i-r,s),r=i)}return Math.max(t-r,s)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return bL(e,r)}calculateOutputSize(e){let t=this.valuesShape,r=this.defaultValueShape;S.validateDefaultValueShape(r,t);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=S.combineRaggedTensorToTensorShapes(this.raggedRank,o,t);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,t,r){let o=Math.min(e,r),s=[],i=0;for(let a=0;a<o;++a,i+=t)s.push(i);for(let a=o;a<e;++a)s.push(-1);return y.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,r,o){let s=e.length,i=[];for(let a=0;a<s-1;++a){let c=e[a+1]-e[a],l=Math.min(o,c),u=t[a];u===-1&&(l=0);for(let p=0;p<l;++p)i.push(u),u+=r;for(let p=0;p<c-l;++p)i.push(-1)}if(s>0&&i.length!==e[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,r,o){let s=e.length,i=[];if(s===0)return[];let a=0,c=e[0];if(c>=t.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${t.length}`);let l=t[c];i.push(l);for(let u=1;u<s;++u){let p=e[u];if(p===c)l>=0&&(++a,a<o?l+=r:l=-1);else{if(a=0,c=p,p>=t.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${t.length}`);l=t[p]}i.push(l)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,r,o){let s=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case Dr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,r,o);case Dr.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,r,o);default:throw new Error(`Unsupported partition type: ${Dr[i]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case Dr.FIRST_DIM_SIZE:return e[0];case Dr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Dr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Dr[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let c=o.length-2;c>=0;--c)o[c]=o[c+1]*r[c+1];let s=bL(r,!1),i=y.getArrayFromDType(this.valuesDType,y.sizeFromShape(s));if(o[0]*r[0]>0){let c=this.calculateFirstParentOutputIndex(t,o[0],r[0]);for(let l=1;l<=this.raggedRank;++l)c=this.calculateOutputIndex(l-1,c,o[l],r[l]);this.setOutput(this.raggedRank,c,i,s)}return[s,i]}setOutput(e,t,r,o){if(r.length===0)return;let s=this.values,i=r,a=o.slice();a=a.slice(e+1);let c=y.sizeFromShape(a),l=t.length,u=this.defaultValue;if(u.length!==c&&u.length!==1){let m=this.defaultValueShape;Ce(()=>{let h=U(u,m);u=fs(h,a).dataSync()})}let p=0,d=0,f=0;for(let m=0;m<=l;++m){let h=m<l?t[m]:-1;if(h===f){++f;continue}if(d<f){let g=s.subarray(p*c),x=i.subarray(d*c),v=(f-d)*c;vL(x,g,v)}if(m>=l){let g=r.length;h=Math.floor(g/c)}if(h>f)if(this.defaultValue.length===1)i.subarray(f*c,h*c).fill(this.defaultValue[0]),f=h;else for(;h>f;){let g=i.slice(f*c);vL(g,u,c),++f}h<0?(p=m+1,d=f):(p=m,d=f,f=d+1)}}};function vL(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function bL(n,e){let t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function Ty(n,e,t,r,o,s,i,a,c,l){return new TN(n,e,t,r,o,s,i,a,c,l).compute()}T();function Sy(n,e,t,r){let o=n===e,s=n<e&&t<0,i=e<n&&t>1;if(o||s||i)return y.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((e-n)/t)),c=y.makeZerosTypedArray(a,r);e<n&&t===1&&(t=-1),c[0]=n;for(let l=1;l<c.length;l++)c[l]=c[l-1]+t;return c}T();var SN=jt(n=>1/Math.sqrt(n)),rne=$n(_i,SN),CL={kernelName:_i,backendName:"cpu",kernelFunc:rne};T();function so(n,e,t,r,o,s,i,a,c,l){let u=[r/o,o],p=n.values,d=e.values;if(r===0)return le(t,e.dtype);let f=c instanceof He?c:le(u,e.dtype);typeof c=="string"||typeof c=="number"?f.values.fill(c):typeof c=="boolean"&&f.values.fill(+c);for(let m=0;m<s;m++){let h=[],g=0;for(let x=0;x<i;x++){let v=p[m*i+x];h.push(v),g+=v*a[x]}if(g<0||g>=r/o)throw new Error(`Invalid indices: ${h} does not index into ${t}`);for(let x=0;x<o;x++)l?f.values[g*o+x]+=d[m*o+x]:f.values[g*o+x]=e.rank===0?d[0]:d[m*o+x]}return f}T();var wL=jt(n=>1/(1+Math.exp(-n))),NN=he(Mi,n=>1/(1+Math.exp(-n))),IL={kernelName:Mi,backendName:"cpu",kernelFunc:NN};T();function DN(n,e,t,r,o){let s=$t.isSliceContinous(r,e,t),i=y.sizeFromShape(t),a=y.computeStrides(r);if(s){let p=$t.computeFlatOffset(e,a);return o==="string"?n.slice(p,p+i):n.subarray(p,p+i)}let c=o==="string"?S.fromUint8ToStringArray(n):n,l=le(r,o,c),u=le(t,o);for(let p=0;p<u.size;++p){let d=u.indexToLoc(p),f=d.map((m,h)=>m+e[h]);u.set(l.get(...f),...d)}return o==="string"?S.fromStringArrayToUint8(u.values):u.values}function kr(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{begin:s,size:i}=r;X(o,"slice");let[a,c]=$t.parseSliceParams(o,s,i);$t.assertParamsValid(o,a,c);let l=t.data.get(o.dataId).values,u=DN(l,a,c,o.shape,o.dtype);return t.makeTensorInfo(c,o.dtype,u)}var EL={kernelName:Cl,backendName:"cpu",kernelFunc:kr};T();function Ny(n,e,t,r,o,s,i){let a=e[0],c=s[0],l=new Array(c),u=new Array(a),p=e[1];if(c===0){if(a!==0)throw new Error(S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let g=y.getArrayFromDType(t,0),x=y.getArrayFromDType(o,0);return[g,[0,p],x,l,u]}let d=!0,f=0,m=new Array(c).fill(0);for(let g=0;g<a;++g){let x=n[g*p];if(x<0)throw new Error(S.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,x));if(x>=c)throw new Error(S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,x,c));++m[x],d=d&&x>=f,f=x}let h=!0;for(let g=0;g<c;++g){let x=m[g]===0;l[g]=x,h=h&&!x,m[g]=Math.max(m[g],1),g>0&&(m[g]+=m[g-1])}if(h&&d){let g=n,x=r;for(let v=0;v<a;++v)u[v]=v;return[g,[a,p],x,l,u]}else{let g=m[c-1],x=y.getArrayFromDType(t,g*p),v=y.getArrayFromDType(o,g),w=new Array(c).fill(0);for(let I=0;I<a;++I){let _=n[I*p],A=w[_],R=(_===0?0:m[_-1])+A;w[_]++;for(let F=0;F<p;++F)x[R*p+F]=n[I*p+F];v[R]=r[I],u[I]=R}for(let I=0;I<c;++I)if(w[I]===0){let A=I===0?0:m[I-1];x[A*p+0]=I;for(let R=1;R<p;++R)x[A*p+R]=0;v[A]=i}return[x,[g,p],v,l,u]}}T();function Dy(n,e,t,r,o){let s=y.sizeFromShape(r),i=e[0],a=o.length,c=[],l=1,u=-1;for(let g=0;g<a;++g){let x=o[g];if(x===-1){if(u!==-1)throw new Error(S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,g));u=g,c.push(1)}else{if(x<0)throw new Error(S.getSparseReshapeNegativeOutputDimErrorMessage(g,x));l*=x,c.push(x)}}if(u!==-1){if(l<=0)throw new Error(S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/l);if(l*g!==s)throw new Error(S.getSparseReshapeInputOutputMultipleErrorMessage(r,c));c[u]=g}if(y.sizeFromShape(c)!==s)throw new Error(S.getSparseReshapeInputOutputMismatchErrorMessage(r,c));let d=r.length,f=[];if(d>0){f[d-1]=1;for(let g=d-2;g>=0;--g)f[g]=f[g+1]*r[g+1]}let m=[];if(a>0){m[a-1]=1;for(let g=a-2;g>=0;--g)m[g]=m[g+1]*c[g+1]}let h=y.getArrayFromDType(t,i*a);for(let g=0;g<i;++g){let x=0;for(let v=0;v<d;++v)x+=n[g*d+v]*f[v];for(let v=0;v<a;++v)h[g*a+v]=Math.trunc(x/m[v]),x%=m[v]}return[h,[i,a],c]}T();function ad(n,e,t,r,o,s=!1,i=0){let a=r.length,c=[e[0],n.length/e[0]],l=c[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=e.slice();d[0]=p;let f=d.reduce((w,I)=>w*I,1),m=y.getArrayFromDType(t,f);if(a===0)return p>0&&m.fill(i),[m,d];if(p<=0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,x=0,v=o[h];for(;;){let w=0;if(g<a){if(w=o[g],v===w){++g;continue}if(v>=w)throw new Error(S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(v<0||v>=p)throw new Error(S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v,p));v>x&&m.fill(i,x*l,v*l);for(let I=h;I<g;++I){let _=r[I];if(_<0||_>=c[0])throw new Error(S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(I,r[I],c[0]));for(let A=0;A<l;A++)m[v*l+A]+=n[_*l+A]}if(s)for(let I=0;I<l;I++)m[v*l+I]/=g-h;if(h=g,++g,x=v+1,v=w,g>a)break}return x<p&&m.fill(i,x*l,p*l),[m,d]}T();var TL=jt(n=>Math.sqrt(n)),one=he($i,n=>Math.sqrt(n)),SL={kernelName:$i,backendName:"cpu",kernelFunc:one};T();var kN=ke((n,e)=>{let t=n-e;return t*t}),sne=Ve(Pi,kN),NL={kernelName:Pi,backendName:"cpu",kernelFunc:sne};T();var _N=jt((n,e)=>{let{pattern:t,replaceGlobal:r,rewrite:o}=e;return n.replace(new RegExp(t,r?"g":""),o)}),ine=$n(Li,_N),DL={kernelName:Li,backendName:"cpu",kernelFunc:ine};T();function ky(n,e,t,r){let o=le(n,e.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let c=0;c<a.length;c++)a[c]=i[c]*t[c]+r[c];o.set(e.get(...a),...i)}return o}T();var AN=class{constructor(e,t,r,o,s,i){this.separator=y.encodeString(e),this.nGramWidths=t,this.leftPad=y.encodeString(r),this.rightPad=y.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,o,s,i){for(let a=0;a<s;++a){let c=this.getPadWidth(i),l=Math.max(0,c-a),u=Math.max(0,c-(s-(a+1))),p=i-(l+u),d=t+(l>0?0:a-c),f=0;f+=l*this.leftPad.length;for(let v=0;v<p;++v)f+=e[d+v].length;f+=u*this.rightPad.length;let m=l+u+p-1;f+=m*this.separator.length,r[o+a]=new Uint8Array(f);let h=r[o+a],g=0,x=v=>v.forEach(w=>h[g++]=w);for(let v=0;v<l;++v)x(this.leftPad),x(this.separator);for(let v=0;v<p-1;++v)x(e[d+v]),x(this.separator);if(p>0){x(e[d+p-1]);for(let v=0;v<u;++v)x(this.separator),x(this.rightPad)}else{for(let v=0;v<u-1;++v)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,t){let r=e.length,o=t.length;if(o>0){let c=t[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let l=1;l<o;++l){let u=t[l]>=c;if(u=u&&t[l]<=r,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${c}, ${r}]`);c=t[l]}if(c!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${c}`)}let s=o-1,i=y.getArrayFromDType("int32",o);if(r===0||o===0){let c=new Array(r);for(let l=0;l<=s;++l)i[l]=0;return[c,i]}i[0]=0;for(let c=1;c<=s;++c){let l=t[c]-t[c-1],u=0;this.nGramWidths.forEach(p=>{u+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&u===0&&(u=1),i[c]=i[c-1]+u}let a=new Array(i[s]);for(let c=0;c<s;++c){let l=t[c],u=i[c];if(this.nGramWidths.forEach(p=>{let d=t[c+1]-t[c],f=this.getNumNGrams(d,p);this.createNGrams(e,l,a,u,f,p),u+=f}),this.preserveShort&&u===i[c]){let p=t[c+1]-t[c];if(p===0)continue;let d=p+2*this.padWidth;this.createNGrams(e,l,a,u,1,d)}}return[a,i]}};function _y(n,e,t,r,o,s,i,a){return new AN(t,r,o,s,i,a).compute(n,e)}T();function ane(n,e,t,r){if(!n.length)return;if(e.length===0){for(let s=0;s<n.length;++s)r.push(n.subarray(s,s+1));return}if(e.length===1){let s=e[0],i=n.indexOf(s);for(;i!==-1;){let a=n.subarray(0,i);(!t||a.length!==0)&&r.push(a),n=n.subarray(i+1),i=n.indexOf(s)}(!t||n.length!==0)&&r.push(n);return}let o=0;for(let s=0;s<n.length+1;s++)if(s===n.length||e.indexOf(n[s])!==-1){let i=n.subarray(o,s);(!t||i.length!==0)&&r.push(i),o=s+1}}function Ay(n,e,t){let r=n.length,o=[],s=0,i=0,a=new Array(r);for(let d=0;d<r;++d){let f=o.length;ane(n[d],e,t,o);let m=o.length-f;a[d]=m,s+=m,i=Math.max(i,m)}let c=y.getArrayFromDType("int32",s*2),l=new Array(s),u=[r,i],p=0;for(let d=0;d<r;++d)for(let f=0;f<a[d];++f)c[p*2]=d,c[p*2+1]=f,l[p]=o[p],++p;return[c,l,u]}T();function Ry(n,e){let t=y.getArrayFromDType("int32",n.length);for(let r=0;r<n.length;++r)t[r]=y.fingerPrint64(n[r]).modulo(e).getLowBitsUnsigned();return t}T();var RN=ke((n,e)=>n-e),cne=od((n,e,t,r)=>({real:n-t,imag:e-r})),nh=Ve("Sub",RN,cne),kL={kernelName:"Sub",backendName:"cpu",kernelFunc:nh};T();function Fy(n,e){let t=new Array(n.rank);for(let o=0;o<t.length;o++)t[o]=n.shape[o]*e[o];let r=le(t,n.dtype);for(let o=0;o<r.values.length;++o){let s=r.indexToLoc(o),i=new Array(n.rank);for(let c=0;c<i.length;c++)i[c]=s[c]%n.shape[c];let a=n.locToIndex(i);r.values[o]=n.values[a]}return r}T();var rh=(n,e)=>{let t=e.value-n.value;return t===0?n.index-e.index:t};function _L(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){let a=r-t+1,c=e-t+1,l=Math.log(a),u=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*u*(a-u)/a)*Math.sign(c-a/2),d=Math.max(t,Math.floor(e-c*u/a+p)),f=Math.min(r,Math.floor(e+(a-c)*u/a+p));_L(n,e,d,f)}let o=n[e],s=t,i=r;for(y.swap(n,t,e),rh(n[r],o)>0&&y.swap(n,t,r);s<i;){for(y.swap(n,s,i),s++,i--;rh(n[s],o)<0;)s=s+1;for(;rh(n[i],o)>0;)i=i-1}rh(n[t],o)===0?y.swap(n,t,i):(i=i+1,y.swap(n,i,r)),i<=e&&(t=i+1),e<=i&&(r=i-1)}}function My(n,e,t,r,o){let s=e[e.length-1],[i,a]=[n.length/s,s],c=y.getTypedArrayFromDType(t,i*r),l=y.getTypedArrayFromDType("int32",i*r);for(let p=0;p<i;p++){let d=p*a,f=n.subarray(d,d+a),m=new Array(f.length);f.forEach((v,w)=>m[w]={value:v,index:w}),r<m.length&&(_L(m,r),m=m.slice(0,r)),o&&m.sort(rh);let h=p*r,g=c.subarray(h,h+r),x=l.subarray(h,h+r);for(let v=0;v<r;v++)g[v]=m[v].value,x[v]=m[v].index}let u=e.slice();return u[u.length-1]=r,[le(u,t,c),le(u,"int32",l)]}T();function Oy(n,e,t,r){let o=y.parseAxisParam(e,t)[0],s=[1,t[0],1];for(let m=0;m<o;m++)s[0]*=t[m];s[1]=t[o];for(let m=o+1;m<t.length;m++)s[2]*=t[m];let i=new Map,a=new Int32Array(t[o]),c=new He(s,r,n),l=[],u=s[0]===1&&s[2]===1;for(let m=0;m<t[o];m++){let h;if(u)h=n[m].toString();else{let x=[];for(let v=0;v<s[0];v++)for(let w=0;w<s[2];w++)x.push(c.get(v,m,w));h=x.join(",")}let g=i.get(h);if(g!=null)a[m]=g;else{let x=i.size;i.set(h,x),a[m]=x,l.push(m)}}let p=s.slice();p[1]=i.size;let d=new He(p,r);l.forEach((m,h)=>{for(let g=0;g<s[0];g++)for(let x=0;x<s[2];x++)d.set(c.get(g,m,x),g,h,x)});let f=t.slice();return f[o]=p[1],{outputValues:d.values,outputShape:f,indices:a}}Jf("cpu",()=>new WP,1);T();T();T();var MN=he("Elu",n=>n>=0?n:Math.exp(n)-1),AL={kernelName:"Elu",backendName:"cpu",kernelFunc:MN};T();function ON(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{alpha:s}=r;X([o],"leakyRelu");let i=y.sizeFromShape(o.shape),a=t.data.get(o.dataId).values,c=y.getTypedArrayFromDType("float32",i);for(let l=0;l<a.length;l++)c[l]=a[l]<0?s*a[l]:a[l];return t.makeTensorInfo(o.shape,"float32",c)}var RL={kernelName:zc,backendName:"cpu",kernelFunc:ON};T();var lne=ke((n,e)=>n<0?e*n:n);function $N(n){let{inputs:e,backend:t}=n,{x:r,alpha:o}=e;X([r,o],"prelu");let s=t.data.get(r.dataId).values,i=t.data.get(o.dataId).values,[a,c]=lne(r.shape,o.shape,s,i,"float32");return t.makeTensorInfo(c,"float32",a)}var FL={kernelName:il,backendName:"cpu",kernelFunc:$N};T();var PN=he(Ni,n=>Math.max(0,n)),ML={kernelName:Ni,backendName:"cpu",kernelFunc:PN};T();var LN=he(Di,n=>Math.min(Math.max(0,n),6)),OL={kernelName:Di,backendName:"cpu",kernelFunc:LN};function Cu(n,e,t,r,o){if(t==="linear")return ln({inputs:{x:e},backend:n});if(t==="relu")return PN({inputs:{x:e},backend:n});if(t==="elu")return MN({inputs:{x:e},backend:n});if(t==="relu6")return LN({inputs:{x:e},backend:n});if(t==="prelu")return $N({inputs:{x:e,alpha:r},backend:n});if(t==="leakyrelu")return ON({inputs:{x:e},backend:n,attrs:{alpha:o}});if(t==="sigmoid")return NN({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}T();T();function _e(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{shape:s}=r,i=y.sizeFromShape(o.shape),a=y.inferFromImplicitShape(s,i),c=y.sizeFromShape(a);y.assert(i===c,()=>`The new shape (${a}) has ${c} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.incRef(o.dataId);let l=t.data.get(o.dataId);if(l.complexTensorInfos!=null){let u=l.complexTensorInfos.real,p=l.complexTensorInfos.imag;u.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var $L={kernelName:fl,backendName:"cpu",kernelFunc:_e};function BN(n){let{inputs:e,backend:t,attrs:r}=n,{a:o,b:s}=e,{transposeA:i,transposeB:a}=r;X([o,s],"matMul");let c=o.shape.length,l=s.shape.length,u=i?o.shape[c-2]:o.shape[c-1],p=a?s.shape[l-1]:s.shape[l-2],d=i?o.shape[c-1]:o.shape[c-2],f=a?s.shape[l-2]:s.shape[l-1],m=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(m),x=y.sizeFromShape(h),w=Jr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,f]);y.assert(u===p,()=>`Error in matMul: inner shapes (${u}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let I=i?[g,u,d]:[g,d,u],_=a?[x,f,p]:[x,p,f],A=_e({inputs:{x:o},backend:t,attrs:{shape:I}}),R=_e({inputs:{x:s},backend:t,attrs:{shape:_}}),F=i?A.shape[1]:A.shape[2],P=i?A.shape[2]:A.shape[1],L=a?R.shape[1]:R.shape[2],V=Math.max(g,x),z=t.data.get(A.dataId).values,H=t.data.get(R.dataId).values,j=y.computeStrides(A.shape),W=y.computeStrides(R.shape),[Y,Z,K]=i?[j[0],1,j[1]]:[j[0],j[1],1],[Q,te,ne]=a?[1,W[1],W[0]]:[W[1],1,W[0]],se=P*L,re=le([V,P,L],A.dtype),ae=re.values,oe=t.blockSize;for(let ue=0;ue<V;ue++){let xe=ue%g,be=ue%x;for(let ye=0;ye<P;ye+=oe){let Fe=Math.min(ye+oe,P);for(let $e=0;$e<L;$e+=oe){let et=Math.min($e+oe,L);for(let ct=0;ct<F;ct+=oe){let kt=Math.min(ct+oe,F);for(let lt=ye;lt<Fe;lt++)for(let nt=$e;nt<et;nt++){let St=0;for(let bt=ct;bt<kt;bt++){let Wo=z[xe*Y+lt*Z+bt*K],tn=H[bt*Q+nt*te+be*ne];St+=Wo*tn}ae[ue*se+(lt*L+nt)]+=St}}}}}return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(R),t.makeTensorInfo(w,re.dtype,re.values)}var PL={kernelName:ac,backendName:"cpu",kernelFunc:BN};function une(n){let{inputs:e,backend:t,attrs:r}=n,{a:o,b:s,bias:i,preluActivationWeights:a}=e,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:p}=r,d,f,m,h=[];d=BN({inputs:{a:o,b:s},attrs:{transposeA:c,transposeB:l},backend:t}),i&&(f=Vo({inputs:{a:d,b:i},backend:t}),h.push(d),d=f),u&&(m=Cu(t,d,u,a,p),h.push(d),d=m);for(let x of h)t.disposeIntermediateTensorInfo(x);return d}var LL={kernelName:Ui,backendName:"cpu",kernelFunc:une};T();var pne=he(Xs,n=>Math.acos(n)),BL={kernelName:Xs,backendName:"cpu",kernelFunc:pne};T();var dne=he(Ys,n=>Math.acosh(n)),VL={kernelName:Ys,backendName:"cpu",kernelFunc:dne};T();function fne(n){let{inputs:e,backend:t}=n,r=e;X(e,"addN");let o=r.map(a=>t.data.get(a.dataId).values),s=le(r[0].shape,r[0].dtype),i=s.values;for(let a=0;a<r.length;a++){let c=o[a];for(let l=0;l<i.length;l++)i[l]+=c[l]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}var UL={kernelName:nc,backendName:"cpu",kernelFunc:fne};T();function mne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;X(o,"all");let a=y.parseAxisParam(s,o.shape),c=a,l=S.getAxesPermutation(c,o.shape.length),u=o;l!=null&&(u=gt({inputs:{x:o},backend:t,attrs:{perm:l}}),c=S.getInnerMostAxes(c.length,o.shape.length)),S.assertAxesAreInnerMostDims("all",c,u.shape.length);let[p,d]=S.computeOutAndReduceShapes(u.shape,c),f=y.sizeFromShape(d),m=y.makeZerosTypedArray(y.sizeFromShape(p),u.dtype),h=t.data.get(u.dataId).values;for(let x=0;x<m.length;++x){let v=x*f,w=h[v];for(let I=0;I<f;++I){let _=h[v+I];w=w&&_}m[x]=w}l!=null&&t.disposeIntermediateTensorInfo(u);let g=t.makeTensorInfo(p,u.dtype,m);if(i){let x=S.expandShapeToKeepDim(p,a),v=_e({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),v}return g}var zL={kernelName:"All",backendName:"cpu",kernelFunc:mne};T();function hne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;X(o,"any");let a=y.parseAxisParam(s,o.shape),c=a,l=S.getAxesPermutation(c,o.shape.length),u=o;l!=null&&(u=gt({inputs:{x:o},backend:t,attrs:{perm:l}}),c=S.getInnerMostAxes(c.length,o.shape.length)),S.assertAxesAreInnerMostDims("any",c,u.shape.length);let[p,d]=S.computeOutAndReduceShapes(u.shape,c),f=y.sizeFromShape(d),m=y.makeZerosTypedArray(y.sizeFromShape(p),u.dtype),h=t.data.get(u.dataId).values;for(let x=0;x<m.length;++x){let v=x*f,w=h[v];for(let I=0;I<f;++I){let _=h[v+I];w=w||_}m[x]=w}l!=null&&t.disposeIntermediateTensorInfo(u);let g=t.makeTensorInfo(p,u.dtype,m);if(i){let x=S.expandShapeToKeepDim(p,a),v=_e({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),v}return g}var HL={kernelName:"Any",backendName:"cpu",kernelFunc:hne};T();function gne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s}=r;X(o,"argMax");let i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,l=[];a!=null&&(c=gt({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMax",i,c.shape.length);let[u,p]=S.computeOutAndReduceShapes(c.shape,i),d=y.sizeFromShape(u),f=y.makeZerosTypedArray(d,"int32"),m=y.sizeFromShape(p),h=t.data.get(c.dataId).values;for(let g=0;g<f.length;++g){let x=g*m,v=h[x],w=0;for(let I=0;I<m;++I){let _=h[x+I];_>v&&(v=_,w=I)}f[g]=w}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",f)}var GL={kernelName:rc,backendName:"cpu",kernelFunc:gne};T();function xne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s}=r;X(o,"argMin");let i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,l=[];a!=null&&(c=gt({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMin",i,c.shape.length);let[u,p]=S.computeOutAndReduceShapes(c.shape,i),d=y.sizeFromShape(u),f=y.makeZerosTypedArray(d,"int32"),m=y.sizeFromShape(p),h=t.data.get(c.dataId).values;for(let g=0;g<f.length;++g){let x=g*m,v=h[x],w=0;for(let I=0;I<m;++I){let _=h[x+I];_<v&&(v=_,w=I)}f[g]=w}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",f)}var WL={kernelName:oc,backendName:"cpu",kernelFunc:xne};T();var yne=he(Zs,n=>Math.asin(n)),jL={kernelName:Zs,backendName:"cpu",kernelFunc:yne};T();var vne=he(Qs,n=>Math.asinh(n)),qL={kernelName:Qs,backendName:"cpu",kernelFunc:vne};T();var bne=he(Js,n=>Math.atan(n)),KL={kernelName:Js,backendName:"cpu",kernelFunc:bne};T();var Cne=ke((n,e)=>Math.atan2(n,e)),wne=Ve(ti,Cne),XL={kernelName:ti,backendName:"cpu",kernelFunc:wne};T();var Ine=he(ei,n=>Math.atanh(n)),YL={kernelName:ei,backendName:"cpu",kernelFunc:Ine};T();T();function cd(n,e,t,r,o,s){let i=o.strideHeight,a=o.strideWidth,c=o.dilationHeight,l=o.dilationWidth,u=o.effectiveFilterHeight,p=o.effectiveFilterWidth,d=o.padInfo.top,f=o.padInfo.left,m=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=le(o.outShape,t),g=h.values,x=o.outShape[1]*o.outShape[2]*o.outShape[3],v=o.outShape[2]*o.outShape[3],w=o.outShape[3];for(let I=0;I<o.batchSize;++I){let _=I*x,A=I*r[0];for(let R=0;R<o.inChannels;++R)for(let F=0;F<o.outHeight;++F){let P=F*i-d,L=Math.max(0,P),V=Math.min(o.inHeight,u+P),z=_+F*v;for(let H=0;H<o.outWidth;++H){let j=H*a-f,W=Math.max(0,j),Y=Math.min(o.inWidth,p+j),Z=m,K=0,Q=0;for(let ne=L;ne<V;ne+=c){let se=A+ne*r[1];for(let re=W;re<Y;re+=l){let ae=se+re*r[2],oe=n[ae+R];s==="max"&&oe>Z?Z=oe:s==="avg"&&(K+=oe,Q++)}if(isNaN(Z))break}let te=z+H*w+R;g[te]=s==="avg"?K/Q:Z}}}return h}function $y(n,e,t,r,o=!1,s=!1){let i=le(r.outShape,"int32"),a=r.strideHeight,c=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,p=r.effectiveFilterHeight,d=r.effectiveFilterWidth,f=r.padInfo.top,m=r.padInfo.left,h=le(e,t,n);for(let g=0;g<r.batchSize;++g)for(let x=0;x<r.inChannels;++x)for(let v=0;v<r.outHeight;++v){let w=v*a-f,I=w;for(;I<0;)I+=l;let _=Math.min(r.inHeight,p+w);for(let A=0;A<r.outWidth;++A){let R=A*c-m,F=R;for(;F<0;)F+=u;let P=Math.min(r.inWidth,d+R),L=Number.NEGATIVE_INFINITY,V=-1;for(let z=I;z<_;z+=l){let H=z-w;for(let j=F;j<P;j+=u){let W=j-R,Y=h.get(g,z,j,x);Y>L&&(L=Y,o?V=s?((g*r.inHeight+z)*r.inWidth+j)*r.inChannels+x:(z*r.inWidth+j)*r.inChannels+x:V=H*d+W)}}i.set(V,g,v,A,x)}}return i}function Py(n,e,t,r,o,s){let i=o.strideDepth,a=o.strideHeight,c=o.strideWidth,l=o.dilationDepth,u=o.dilationHeight,p=o.dilationWidth,d=o.effectiveFilterDepth,f=o.effectiveFilterHeight,m=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,x=o.padInfo.left,v=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=le(o.outShape,t),I=w.values,_=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],A=o.outShape[2]*o.outShape[3]*o.outShape[4],R=o.outShape[3]*o.outShape[4],F=o.outShape[4];for(let P=0;P<o.batchSize;++P){let L=P*_,V=P*r[0];for(let z=0;z<o.inChannels;++z)for(let H=0;H<o.outDepth;++H){let j=H*i-h,W=j;for(;W<0;)W+=l;let Y=Math.min(o.inDepth,d+j),Z=L+H*A;for(let K=0;K<o.outHeight;++K){let Q=K*a-g,te=Q;for(;te<0;)te+=u;let ne=Math.min(o.inHeight,f+Q),se=Z+K*R;for(let re=0;re<o.outWidth;++re){let ae=re*c-x,oe=ae;for(;oe<0;)oe+=p;let ue=Math.min(o.inWidth,m+ae),xe=se+re*F,be=v,ye=0,Fe=0;for(let et=W;et<Y;et+=l){let ct=V+et*r[1];for(let kt=te;kt<ne;kt+=u){let lt=ct+kt*r[2];for(let nt=oe;nt<ue;nt+=p){let St=lt+nt*r[3],bt=n[St+z];if(s==="max"&&bt>be?be=bt:s==="avg"&&(ye+=bt,Fe++),isNaN(be))break}if(isNaN(be))break}if(isNaN(be))break}let $e=xe+z;I[$e]=s==="avg"?ye/Math.max(Fe,1):be}}}}return w}function ZL(n,e){let t=le(e.outShape,"int32"),r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=e.padInfo.front,f=e.padInfo.top,m=e.padInfo.left;for(let h=0;h<e.batchSize;++h)for(let g=0;g<e.inChannels;++g)for(let x=0;x<e.outDepth;++x){let v=x*r-d,w=v;for(;w<0;)w+=i;let I=Math.min(e.inDepth,l+v);for(let _=0;_<e.outHeight;++_){let A=_*o-f,R=A;for(;R<0;)R+=a;let F=Math.min(e.inHeight,u+A);for(let P=0;P<e.outWidth;++P){let L=P*s-m,V=L;for(;V<0;)V+=c;let z=Math.min(e.inWidth,p+L),H=Number.NEGATIVE_INFINITY,j=-1;for(let W=w;W<I;W+=i){let Y=W-v;for(let Z=R;Z<F;Z+=a){let K=Z-A;for(let Q=V;Q<z;Q+=c){let te=Q-L,ne=n.get(h,W,Z,Q,g);ne>=H&&(H=ne,j=Y*u*p+K*u+te)}}}t.set(j,h,x,_,P,g)}}}return t}function Ene(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e;X(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let u=S.computePool2DInfo(o.shape,s,i,l,a,c),p;if(u.filterWidth===1&&u.filterHeight===1&&y.arraysEqual(u.inShape,u.outShape))p=ln({inputs:{x:o},backend:t});else{let d=t.data.get(o.dataId).values,f=y.computeStrides(o.shape),m=cd(d,o.shape,o.dtype,f,u,"avg");p=t.makeTensorInfo(u.outShape,o.dtype,m.values)}return p}var QL={kernelName:sc,backendName:"cpu",kernelFunc:Ene};T();function Tne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:c,dataFormat:l}=r;X(o,"avgPool3d");let u=S.computePool3DInfo(o.shape,s,i,1,a,c,l),p=t.data.get(o.dataId).values,d=Py(p,o.shape,o.dtype,y.computeStrides(o.shape),u,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}var JL={kernelName:ic,backendName:"cpu",kernelFunc:Tne};T();function Sne(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,{filterSize:i,strides:a,pad:c,dimRoundingMode:l}=r;X([o,s],"avgPool3DGrad");let u=S.computePool3DInfo(s.shape,i,a,1,c,l),p=u.strideDepth,d=u.strideHeight,f=u.strideWidth,m=u.filterDepth,h=u.filterHeight,g=u.filterWidth,x=u.dilationDepth,v=u.dilationHeight,w=u.dilationWidth,I=u.effectiveFilterDepth,_=u.effectiveFilterHeight,A=u.effectiveFilterWidth,R=I-1-u.padInfo.front,F=A-1-u.padInfo.left,P=_-1-u.padInfo.top,L=le(s.shape,"float32"),V=1/(m*h*g),z=t.bufferSync(o);for(let H=0;H<u.batchSize;++H)for(let j=0;j<u.inChannels;++j)for(let W=0;W<u.inDepth;++W)for(let Y=0;Y<u.inHeight;++Y)for(let Z=0;Z<u.inWidth;++Z){let K=W-R,Q=Y-P,te=Z-F,ne=0;for(let se=0;se<I;se+=x){let re=(K+se)/p;if(!(re<0||re>=u.outDepth||Math.floor(re)!==re))for(let ae=0;ae<_;ae+=v){let oe=(Q+ae)/d;if(!(oe<0||oe>=u.outHeight||Math.floor(oe)!==oe))for(let ue=0;ue<A;ue+=w){let xe=(te+ue)/f;if(xe<0||xe>=u.outWidth||Math.floor(xe)!==xe)continue;let be=z.get(H,re,oe,xe,j);ne+=be}}}L.set(ne*V,H,W,Y,Z,j)}return t.makeTensorInfo(L.shape,L.dtype,L.values)}var eB={kernelName:$f,backendName:"cpu",kernelFunc:Sne};T();function Nne(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,i=s;X([o,s],"avgPoolGrad");let{filterSize:a,strides:c,pad:l}=r,u=S.computePool2DInfo(i.shape,a,c,1,l),p=u.strideHeight,d=u.strideWidth,f=u.filterHeight,m=u.filterWidth,h=u.dilationHeight,g=u.dilationWidth,x=u.effectiveFilterHeight,v=u.effectiveFilterWidth,w=v-1-u.padInfo.left,I=x-1-u.padInfo.top,_=le(i.shape,"float32"),A=1/(f*m),R=t.data.get(o.dataId).values,F=le(o.shape,"float32",R);for(let P=0;P<u.batchSize;++P)for(let L=0;L<u.inChannels;++L)for(let V=0;V<u.inHeight;++V)for(let z=0;z<u.inWidth;++z){let H=V-I,j=z-w,W=0;for(let Y=0;Y<x;Y+=h){let Z=(H+Y)/p;if(!(Z<0||Z>=u.outHeight||Math.floor(Z)!==Z))for(let K=0;K<v;K+=g){let Q=(j+K)/d;if(Q<0||Q>=u.outWidth||Math.floor(Q)!==Q)continue;let te=F.get(P,Z,Q,L);W+=te}}_.set(W*A,P,V,z,L)}return t.makeTensorInfo(_.shape,_.dtype,_.values)}var tB={kernelName:Of,backendName:"cpu",kernelFunc:Nne};T();function Dne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,scale:s,offset:i,mean:a,variance:c}=e;y.assert(a.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),X([o,a,c,s,i],"batchNorm");let{varianceEpsilon:l}=r;l==null&&(l=.001);let u=t.data.get(o.dataId).values,p=t.data.get(a.dataId).values,d=t.data.get(c.dataId).values,f=s?t.data.get(s.dataId).values:new Float32Array([1]),m=i?t.data.get(i.dataId).values:new Float32Array([0]),h=new Float32Array(u.length),g=m.length,x=f.length,v=d.length,w=p.length,I=0,_=0,A=0,R=0;for(let F=0;F<u.length;++F)h[F]=m[I++]+(u[F]-p[_++])*f[A++]/Math.sqrt(d[R++]+l),I>=g&&(I=0),_>=w&&(_=0),A>=x&&(A=0),R>=v&&(R=0);return t.makeTensorInfo(o.shape,o.dtype,h)}var nB={kernelName:Pc,backendName:"cpu",kernelFunc:Dne};T();function kne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockShape:s,crops:i}=r;X([o],"batchToSpaceND");let a=s.reduce((x,v)=>x*v),c=S.getReshaped(o.shape,s,a),l=S.getPermuted(c.length,s.length),u=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),d=S.getSliceSize(u,i,s.length),f=_e({inputs:{x:o},backend:t,attrs:{shape:c}}),m=gt({inputs:{x:f},backend:t,attrs:{perm:l}}),h=_e({inputs:{x:m},backend:t,attrs:{shape:u}}),g=kr({inputs:{x:h},backend:t,attrs:{begin:p,size:d}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),g}var rB={kernelName:cc,backendName:"cpu",kernelFunc:kne};T();function _ne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,weights:s}=e,{size:i}=r,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,l=sd(a,c,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,l)}var oB={kernelName:lc,backendName:"cpu",kernelFunc:_ne};T();function Ane(n){let{inputs:e,backend:t}=n,{s0:r,s1:o}=e,s=t.data.get(r.dataId).values,i=t.data.get(o.dataId).values,a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var sB={kernelName:uc,backendName:"cpu",kernelFunc:Ane};T();var Rne=he(oi,(n,e)=>{let t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),iB={kernelName:oi,backendName:"cpu",kernelFunc:Rne};T();var Fne=n=>{let{x:e}=n.inputs,t=n.backend,r=new Float32Array(y.sizeFromShape(e.shape)),o=t.data.get(e.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values;for(let l=0;l<a.length;l++){let u=a[l],p=c[l];r[l]=Math.hypot(u,p)}return t.makeOutput(r,e.shape,"float32")},aB={kernelName:dc,backendName:"cpu",kernelFunc:Fne};T();T();function Uo(n){let{inputs:e,backend:t}=n,{input:r}=e,o=t.data.get(r.dataId).complexTensorInfos.imag,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var cB={kernelName:Uc,backendName:"cpu",kernelFunc:Uo};function da(n){let{inputs:e,backend:t,attrs:r}=n,{axis:o}=r,s=y.parseAxisParam(o,e[0].shape)[0],i=e.map(h=>h.shape);S.assertParamsConsistent(i,s);let a=S.computeOutShape(e.map(h=>h.shape),s);if(y.sizeFromShape(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);let c=e.filter(h=>y.sizeFromShape(h.shape)>0);if(c.length===1)return ln({inputs:{x:c[0]},backend:t});if(c[0].dtype==="complex64"){let h=c.map(I=>Sr({inputs:{input:I},backend:t})),g=c.map(I=>Uo({inputs:{input:I},backend:t})),x=da({inputs:h,backend:t,attrs:{axis:s}}),v=da({inputs:g,backend:t,attrs:{axis:s}}),w=Pt({inputs:{real:x,imag:v},backend:t});return h.forEach(I=>t.disposeIntermediateTensorInfo(I)),g.forEach(I=>t.disposeIntermediateTensorInfo(I)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(v),w}let l=c.map(h=>{let x=[-1,y.sizeFromShape(h.shape.slice(s))];return _e({inputs:{x:h},backend:t,attrs:{shape:x}})}),u=l.map(h=>({vals:t.data.get(h.dataId).values,shape:h.shape}));a=S.computeOutShape(l.map(h=>h.shape),1);let p=l[0].shape[0]===1,d=yy(u,a,e[0].dtype,p),f=S.computeOutShape(c.map(h=>h.shape),s),m=t.makeTensorInfo(f,e[0].dtype,d);return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),m}var lB={kernelName:fc,backendName:"cpu",kernelFunc:da};T();function VN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dataFormat:c,dilations:l,dimRoundingMode:u}=r;X([o,s],"conv2d");let p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,s.shape,i,l,a,u,!1,p),f=d.filterHeight,m=d.filterWidth,h=d.dilationHeight,g=d.dilationWidth,x=d.padInfo.left,v=d.padInfo.top,w=d.dataFormat==="channelsLast",I=new He(d.outShape,o.dtype),_=y.computeStrides(o.shape),A=y.computeStrides(s.shape),R=_[0],F=w?_[1]:_[2],P=w?_[2]:1,L=w?1:_[1],V=I.strides[0],z=w?I.strides[1]:I.strides[2],H=w?I.strides[2]:1,j=w?1:I.strides[1],W=t.data.get(o.dataId).values,Y=t.data.get(s.dataId).values,Z=I.values;for(let K=0;K<d.batchSize;++K){let Q=K*R,te=K*V;for(let ne=0;ne<d.outHeight;++ne){let se=te+ne*z,re=ne*d.strideHeight-v;for(let ae=0;ae<f;++ae){let oe=re+ae*h;if(oe<0||oe>=d.inHeight)continue;let ue=ae*A[0],xe=Q+oe*F;for(let be=0;be<d.outWidth;++be){let ye=se+be*H,Fe=be*d.strideWidth-x;for(let $e=0;$e<m;++$e){let et=Fe+$e*g;if(et<0||et>=d.inWidth)continue;let ct=ue+$e*A[1],kt=xe+et*P,lt=ct;for(let nt=0;nt<d.inChannels;++nt){let St=W[kt+nt*L];for(let bt=0;bt<d.outChannels;++bt)Z[ye+bt*j]+=St*Y[lt+bt];lt+=d.outChannels}}}}}}return t.makeTensorInfo(I.shape,I.dtype,Z)}var uB={kernelName:mc,backendName:"cpu",kernelFunc:VN};T();function Mne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,pad:a,dataFormat:c,dimRoundingMode:l,filterShape:u}=r;X([o,s],"conv2dBackpropFilter");let p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,u,i,1,a,l,!1,p),{strideHeight:f,strideWidth:m,filterHeight:h,filterWidth:g}=d,x=d.dataFormat==="channelsLast",v=new He(d.filterShape,"float32"),w=d.padInfo.left,I=d.padInfo.top,_=t.data.get(o.dataId).values,A=t.data.get(s.dataId).values,R=new He(o.shape,o.dtype,_),F=new He(s.shape,s.dtype,A);for(let P=0;P<h;++P){let L=Math.max(0,Math.ceil((I-P)/f)),V=Math.min(d.outHeight,(d.inHeight+I-P)/f);for(let z=0;z<g;++z){let H=Math.max(0,Math.ceil((w-z)/m)),j=Math.min(d.outWidth,(d.inWidth+w-z)/m);for(let W=0;W<d.inChannels;++W)for(let Y=0;Y<d.outChannels;++Y){let Z=0;for(let K=0;K<d.batchSize;++K)for(let Q=L;Q<V;++Q){let te=P+Q*f-I;for(let ne=H;ne<j;++ne){let se=z+ne*m-w;x?Z+=R.get(K,te,se,W)*F.get(K,Q,ne,Y):Z+=R.get(K,W,te,se)*F.get(K,Y,Q,ne)}}v.set(Z,P,z,W,Y)}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}var pB={kernelName:hc,backendName:"cpu",kernelFunc:Mne};T();function One(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{inputShape:i,strides:a,pad:c,dataFormat:l,dimRoundingMode:u}=r;X([o,s],"conv2dBackpropInput");let p=y.computeStrides(s.shape),d=y.computeStrides(o.shape),f=S.convertConv2DDataFormat(l),m=S.computeConv2DInfo(i,s.shape,a,1,c,u,!1,f),h=new He(m.inShape,"float32"),g=h.values,x=t.data.get(o.dataId).values,v=t.data.get(s.dataId).values,[w,I,_]=p,{batchSize:A,filterHeight:R,filterWidth:F,inChannels:P,inHeight:L,inWidth:V,outChannels:z,outHeight:H,outWidth:j,strideHeight:W,strideWidth:Y}=m;f=m.dataFormat;let Z=R-1-m.padInfo.top,K=F-1-m.padInfo.left,Q=f==="channelsLast",te=h.strides[0],ne=Q?h.strides[1]:h.strides[2],se=Q?h.strides[2]:1,re=Q?1:h.strides[1],ae=d[0],oe=Q?d[1]:d[2],ue=Q?d[2]:1,xe=Q?1:d[1];for(let be=0;be<A;++be)for(let ye=0;ye<P;++ye)for(let Fe=0;Fe<L;++Fe){let $e=Fe-Z,et=Math.max(0,Math.ceil($e/W)),ct=Math.min(H,(R+$e)/W);for(let kt=0;kt<V;++kt){let lt=kt-K,nt=Math.max(0,Math.ceil(lt/Y)),St=Math.min(j,(F+lt)/Y),bt=0;for(let tn=et;tn<ct;++tn){let Rs=tn*W-$e;for(let nr=nt;nr<St;++nr){let va=nr*Y-lt,Ar=ae*be+oe*tn+ue*nr,jo=w*(R-1-Rs)+I*(F-1-va)+_*ye;for(let Fs=0;Fs<z;++Fs){let Ms=x[Ar+xe*Fs],Os=v[jo+Fs];bt+=Ms*Os}}}let Wo=te*be+ne*Fe+se*kt+re*ye;g[Wo]=bt}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}var dB={kernelName:gc,backendName:"cpu",kernelFunc:One};T();function $ne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dilations:c}=r;X([o,s],"conv3d");let l=S.computeConv3DInfo(o.shape,s.shape,i,c,a),{filterDepth:u,filterHeight:p,filterWidth:d,dilationDepth:f,dilationHeight:m,dilationWidth:h,padInfo:g}=l,x=g.front,v=g.left,w=g.top,I=new He(l.outShape,o.dtype),_=t.data.get(o.dataId).values,A=t.data.get(s.dataId).values,R=I.values,F=y.computeStrides(o.shape),P=y.computeStrides(s.shape);for(let L=0;L<l.batchSize;++L){let V=L*F[0],z=L*I.strides[0];for(let H=0;H<l.outDepth;++H){let j=z+H*I.strides[1],W=H*l.strideDepth-x;for(let Y=0;Y<u;++Y){let Z=W+Y*f;if(Z<0||Z>=l.inDepth)continue;let K=Y*P[0],Q=V+Z*F[1];for(let te=0;te<l.outHeight;++te){let ne=j+te*I.strides[2],se=te*l.strideHeight-w;for(let re=0;re<p;++re){let ae=se+re*m;if(ae<0||ae>=l.inHeight)continue;let oe=K+re*P[1],ue=Q+ae*F[2];for(let xe=0;xe<l.outWidth;++xe){let be=ne+xe*l.outChannels,ye=xe*l.strideWidth-v;for(let Fe=0;Fe<d;++Fe){let $e=ye+Fe*h;if($e<0||$e>=l.inWidth)continue;let et=oe+Fe*P[2],ct=ue+$e*l.inChannels,kt=et;for(let lt=0;lt<l.inChannels;++lt){let nt=_[ct+lt];for(let St=0;St<l.outChannels;++St)R[be+St]+=nt*A[kt+St];kt+=l.outChannels}}}}}}}}return t.makeTensorInfo(I.shape,I.dtype,I.values)}var fB={kernelName:xc,backendName:"cpu",kernelFunc:$ne};T();function Pne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,pad:a,filterShape:c}=r;X([o,s],"conv3dBackpropFilterV2");let l=y.computeStrides(o.shape),u=y.computeStrides(s.shape),p=S.computeConv3DInfo(o.shape,c,i,1,a),d=p.strideDepth,f=p.strideHeight,m=p.strideWidth,h=p.filterDepth,g=p.filterHeight,x=p.filterWidth,v=new He(p.filterShape,"float32"),w=v.values,[I,_,A,R]=v.strides,F=t.data.get(s.dataId).values,[P,L,V,z]=u,H=t.data.get(o.dataId).values,[j,W,Y,Z]=l,K=p.padInfo.front,Q=p.padInfo.left,te=p.padInfo.top;for(let ne=0;ne<h;++ne){let se=Math.max(0,Math.ceil((K-ne)/d)),re=Math.min(p.outDepth,(p.inDepth+K-ne)/d),ae=ne*I;for(let oe=0;oe<g;++oe){let ue=Math.max(0,Math.ceil((te-oe)/f)),xe=Math.min(p.outHeight,(p.inHeight+te-oe)/f),be=oe*_+ae;for(let ye=0;ye<x;++ye){let Fe=Math.max(0,Math.ceil((Q-ye)/m)),$e=Math.min(p.outWidth,(p.inWidth+Q-ye)/m),et=ye*A+be;for(let ct=0;ct<p.inChannels;++ct){let kt=ct*R+et;for(let lt=0;lt<p.outChannels;++lt){let nt=0;for(let St=0;St<p.batchSize;++St){let bt=St*j,Wo=St*P;for(let tn=se;tn<re;++tn){let nr=(ne+tn*d-K)*W+bt,va=tn*L+Wo;for(let Ar=ue;Ar<xe;++Ar){let Fs=(oe+Ar*f-te)*Y+nr,Ms=Ar*V+va;for(let Os=Fe;Os<$e;++Os){let Xb=(ye+Os*m-Q)*Z+Fs,Yb=Os*z+Ms;nt+=H[Xb+ct]*F[Yb+lt]}}}}w[kt+lt]=nt}}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}var mB={kernelName:Pf,backendName:"cpu",kernelFunc:Pne};T();function Lne(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{pad:i,strides:a,inputShape:c}=r;X([o],"conv3dBackpropInputV2");let l=y.computeStrides(o.shape),u=y.computeStrides(s.shape),p=S.computeConv3DInfo(c,s.shape,a,1,i),d=new He(p.inShape,"float32"),f=d.values,[m,h,g,x]=d.strides,v=t.data.get(o.dataId).values,[w,I,_,A]=l,R=t.data.get(s.dataId).values,[F,P,L,V]=u,{batchSize:z,filterDepth:H,filterHeight:j,filterWidth:W,inChannels:Y,inDepth:Z,inHeight:K,inWidth:Q,outChannels:te,outDepth:ne,outHeight:se,outWidth:re,strideDepth:ae,strideHeight:oe,strideWidth:ue}=p,xe=H-1-p.padInfo.front,be=j-1-p.padInfo.top,ye=W-1-p.padInfo.left;for(let Fe=0;Fe<z;++Fe)for(let $e=0;$e<Y;++$e)for(let et=0;et<Z;++et){let ct=et-xe,kt=Math.max(0,Math.ceil(ct/ae)),lt=Math.min(ne,(H+ct)/ae);for(let nt=0;nt<K;++nt){let St=nt-be,bt=Math.max(0,Math.ceil(St/oe)),Wo=Math.min(se,(j+St)/oe);for(let tn=0;tn<Q;++tn){let Rs=tn-ye,nr=Math.max(0,Math.ceil(Rs/ue)),va=Math.min(re,(W+Rs)/ue),Ar=0;for(let jo=kt;jo<lt;++jo){let Fs=jo*ae-ct;for(let Ms=bt;Ms<Wo;++Ms){let Os=Ms*oe-St;for(let Rd=nr;Rd<va;++Rd){let Xb=Rd*ue-Rs,Yb=w*Fe+I*jo+_*Ms+A*Rd,Aj=F*(H-1-Fs)+P*(j-1-Os)+L*(W-1-Xb)+V*$e;for(let Sh=0;Sh<te;++Sh){let Rj=v[Yb+Sh],Fj=R[Aj+Sh];Ar+=Rj*Fj}}}}f[m*Fe+h*et+g*nt+x*tn+$e]=Ar}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}var hB={kernelName:yc,backendName:"cpu",kernelFunc:Lne};T();var Bne=he("Cos",n=>Math.cos(n)),gB={kernelName:"Cos",backendName:"cpu",kernelFunc:Bne};T();var Vne=he(si,n=>Math.cosh(n)),xB={kernelName:si,backendName:"cpu",kernelFunc:Vne};T();function Une(n){let{inputs:e,backend:t,attrs:r}=n,{image:o,boxes:s,boxInd:i}=e,{cropSize:a,method:c,extrapolationValue:l}=r,[u,p,d,f]=o.shape,m=s.shape[0],[h,g]=a,x=le([m,h,g,f],"float32"),v=t.data.get(s.dataId).values,w=t.data.get(i.dataId).values,I=t.data.get(o.dataId).values,_=y.computeStrides(o.shape),A=y.computeStrides(x.shape);for(let R=0;R<m;R++){let F=R*4,P=v[F],L=v[F+1],V=v[F+2],z=v[F+3],H=w[R];if(H>=u)continue;let j=h>1?(V-P)*(p-1)/(h-1):0,W=g>1?(z-L)*(d-1)/(g-1):0;for(let Y=0;Y<h;Y++){let Z=h>1?P*(p-1)+Y*j:.5*(P+V)*(p-1);if(Z<0||Z>p-1){for(let K=0;K<g;K++)for(let Q=0;Q<f;Q++){let te=Q+K*A[2]+Y*A[1]+R*A[0];x.values[te]=l}continue}if(c==="bilinear"){let K=Math.floor(Z),Q=Math.ceil(Z),te=Z-K;for(let ne=0;ne<g;ne++){let se=g>1?L*(d-1)+ne*W:.5*(L+z)*(d-1);if(se<0||se>d-1){for(let ue=0;ue<f;ue++){let xe=ue+ne*A[2]+Y*A[1]+R*A[0];x.values[xe]=l}continue}let re=Math.floor(se),ae=Math.ceil(se),oe=se-re;for(let ue=0;ue<f;ue++){let xe=ue+re*_[2]+K*_[1]+H*_[0],be=I[xe];xe=ue+ae*_[2]+K*_[1]+H*_[0];let ye=I[xe];xe=ue+re*_[2]+Q*_[1]+H*_[0];let Fe=I[xe];xe=ue+ae*_[2]+Q*_[1]+H*_[0];let $e=I[xe],et=be+(ye-be)*oe,ct=Fe+($e-Fe)*oe;xe=ue+ne*A[2]+Y*A[1]+R*A[0],x.values[xe]=et+(ct-et)*te}}}else for(let K=0;K<g;++K){let Q=g>1?L*(d-1)+K*W:.5*(L+z)*(d-1);if(Q<0||Q>d-1){for(let se=0;se<f;se++){let re=se+K*A[2]+Y*A[1]+R*A[0];x.values[re]=l}continue}let te=Math.round(Q),ne=Math.round(Z);for(let se=0;se<f;se++){let re=se+te*_[2]+ne*_[1]+H*_[0],ae=se+K*A[2]+Y*A[1]+R*A[0];x.values[ae]=I[re]}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}var yB={kernelName:wc,backendName:"cpu",kernelFunc:Une};T();function zne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,exclusive:i,reverse:a}=r;X(o,"cumprod");let c=S.getAxesPermutation([s],o.shape.length),l=o;c!=null&&(l=gt({inputs:{x:o},backend:t,attrs:{perm:c}}));let u=S.getInnerMostAxes(1,o.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);let p=Dt(l.dtype,"int32"),d=y.makeOnesTypedArray(y.sizeFromShape(l.shape),p),f=t.data.get(l.dataId).values,m=l.shape[l.shape.length-1],h=a?(x,v)=>x+m-v-1:(x,v)=>x+v;for(let x=0;x<f.length;x+=m)for(let v=0;v<m;v++){let w=h(x,v);if(v===0)d[w]=i?1:f[w];else{let I=h(x,v-1);d[w]=i?f[I]*d[I]:f[w]*d[I]}}let g=t.makeTensorInfo(l.shape,p,d);if(c!=null){let x=S.getUndoAxesPermutation(c),v=gt({inputs:{x:g},backend:t,attrs:{perm:x}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),v}return g}var vB={kernelName:bc,backendName:"cpu",kernelFunc:zne};T();function Hne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,exclusive:i,reverse:a}=r;X(o,"cumsum");let c=S.getAxesPermutation([s],o.shape.length),l=o;c!=null&&(l=gt({inputs:{x:o},backend:t,attrs:{perm:c}}));let u=S.getInnerMostAxes(1,o.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);let p=Dt(l.dtype,"int32"),d=y.makeZerosTypedArray(y.sizeFromShape(l.shape),p),f=t.data.get(l.dataId).values,m=l.shape[l.shape.length-1],h=a?(x,v)=>x+m-v-1:(x,v)=>x+v;for(let x=0;x<f.length;x+=m)for(let v=0;v<m;v++){let w=h(x,v);if(v===0)d[w]=i?0:f[w];else{let I=h(x,v-1);d[w]=i?f[I]+d[I]:f[w]+d[I]}}let g=t.makeTensorInfo(l.shape,p,d);if(c!=null){let x=S.getUndoAxesPermutation(c),v=gt({inputs:{x:g},backend:t,attrs:{perm:x}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),v}return g}var bB={kernelName:Cc,backendName:"cpu",kernelFunc:Hne};T();function Gne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,weights:s}=e,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let c=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,u=sd(c,l,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,u)}else if(o.shape.length===2){let c=t.bufferSync(o),l=t.bufferSync(s),u=xy(c,l,i,a);return t.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var CB={kernelName:Ic,backendName:"cpu",kernelFunc:Gne};T();function Wne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockSize:s,dataFormat:i}=r;y.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],c=o.shape[1],l=o.shape[2],u=o.shape[3],p=c*s,d=l*s,f=u/(s*s),m=t.data.get(o.dataId).values,h=new Float32Array(a*p*d*f),g=0;for(let x=0;x<a;++x)for(let v=0;v<p;++v){let w=Math.floor(v/s),I=v%s;for(let _=0;_<d;++_){let A=Math.floor(_/s),R=_%s,F=(I*s+R)*f;for(let P=0;P<f;++P){let V=P+F+u*(A+l*(w+c*x));h[g++]=m[V]}}}return t.makeTensorInfo([a,p,d,f],o.dtype,h)}var wB={kernelName:Ec,backendName:"cpu",kernelFunc:Wne};T();function UN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dilations:c,dimRoundingMode:l}=r;X([o,s],"depthwiseConv2DNative");let u=y.computeStrides(o.shape),p=y.computeStrides(s.shape),d=c;d==null&&(d=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let f=S.computeConv2DInfo(o.shape,s.shape,i,d,a,l,!0),{filterHeight:m,filterWidth:h,dilationHeight:g,dilationWidth:x,padInfo:v}=f,w=v.left,I=v.top,_=f.outChannels/f.inChannels,A=new He(f.outShape,o.dtype),R=t.data.get(o.dataId).values,F=t.data.get(s.dataId).values,P=A.values;for(let L=0;L<f.batchSize;++L){let V=L*u[0],z=L*A.strides[0];for(let H=0;H<f.outHeight;++H){let j=z+H*A.strides[1],W=H*f.strideHeight-I;for(let Y=0;Y<m;++Y){let Z=W+Y*g;if(Z<0||Z>=f.inHeight)continue;let K=Y*p[0],Q=V+Z*u[1];for(let te=0;te<f.outWidth;++te){let ne=j+te*A.strides[2],se=te*f.strideWidth-w;for(let re=0;re<h;++re){let ae=se+re*x;if(ae<0||ae>=f.inWidth)continue;let oe=K+re*p[1],ue=Q+ae*f.inChannels,xe=ne,be=oe;for(let ye=0;ye<f.inChannels;++ye){let Fe=R[ue+ye];for(let $e=0;$e<_;++$e)P[xe+$e]+=Fe*F[be+$e];xe+=_,be+=_}}}}}}return t.makeTensorInfo(A.shape,A.dtype,A.values)}var IB={kernelName:Tc,backendName:"cpu",kernelFunc:UN};T();function jne(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,dilations:a,pad:c,dimRoundingMode:l,filterShape:u}=r;X([o,s],"depthwiseConv2dNativeBackpropFilter");let p=S.computeConv2DInfo(o.shape,u,i,a,c,l,!0),{strideHeight:d,strideWidth:f,filterHeight:m,filterWidth:h}=p,g=new He(p.filterShape,"float32"),x=p.padInfo.left,v=p.padInfo.top,w=p.outChannels/p.inChannels,I=t.data.get(o.dataId).values,_=new He(o.shape,o.dtype,I),A=t.data.get(s.dataId).values,R=new He(s.shape,s.dtype,A);for(let F=0;F<m;++F){let P=Math.max(0,Math.ceil((v-F)/d)),L=Math.min(p.outHeight,(p.inHeight+v-F)/d);for(let V=0;V<h;++V){let z=Math.max(0,Math.ceil((x-V)/f)),H=Math.min(p.outWidth,(p.inWidth+x-V)/f);for(let j=0;j<p.outChannels;++j){let W=Math.trunc(j/w),Y=j%w,Z=0;for(let K=0;K<p.batchSize;++K)for(let Q=P;Q<L;++Q){let te=F+Q*d-v;for(let ne=z;ne<H;++ne){let se=V+ne*f-x;Z+=_.get(K,te,se,W)*R.get(K,Q,ne,j)}}g.set(Z,F,V,W,Y)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}var EB={kernelName:Sc,backendName:"cpu",kernelFunc:jne};T();function qne(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{strides:i,dilations:a,pad:c,dimRoundingMode:l,inputShape:u}=r;X([o,s],"depthwiseConv2DNativeBackpropInput");let p=y.computeStrides(o.shape),d=y.computeStrides(s.shape),f=S.computeConv2DInfo(u,s.shape,i,a,c,l,!0),m=new He(f.inShape,"float32"),h=m.values,[g,x,v]=m.strides,w=t.data.get(o.dataId).values,[I,_,A]=p,R=t.data.get(s.dataId).values,[F,P,L]=d,{batchSize:V,filterHeight:z,filterWidth:H,inChannels:j,inHeight:W,inWidth:Y,outChannels:Z,outHeight:K,outWidth:Q,strideHeight:te,strideWidth:ne}=f,se=z-1-f.padInfo.top,re=H-1-f.padInfo.left,ae=Z/j;for(let oe=0;oe<V;++oe)for(let ue=0;ue<j;++ue)for(let xe=0;xe<W;++xe){let be=xe-se,ye=Math.max(0,Math.ceil(be/te)),Fe=Math.min(K,(z+be)/te);for(let $e=0;$e<Y;++$e){let et=$e-re,ct=Math.max(0,Math.ceil(et/ne)),kt=Math.min(Q,(H+et)/ne),lt=0;for(let nt=ye;nt<Fe;++nt){let St=nt*te-be;for(let bt=ct;bt<kt;++bt){let Wo=bt*ne-et,tn=I*oe+_*nt+A*bt,Rs=F*(z-1-St)+P*(H-1-Wo)+L*ue;for(let nr=0;nr<ae;++nr){let va=ue*ae+nr,Ar=w[tn+va],jo=R[Rs+nr];lt+=Ar*jo}}}h[g*oe+x*xe+v*$e+ue]=lt}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}var TB={kernelName:Nc,backendName:"cpu",kernelFunc:qne};T();function Kne(n){let{inputs:e,backend:t}=n,{x:r}=e,o=y.sizeFromShape(r.shape),s=t.data.get(r.dataId).values,i=le([o,o],r.dtype),a=i.values;for(let l=0;l<s.length;l++)a[l*o+l]=s[l];let c=[...r.shape,...r.shape];return t.makeTensorInfo(c,i.dtype,i.values)}var SB={kernelName:Dc,backendName:"cpu",kernelFunc:Kne};T();var NB={kernelName:kc,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{let{x:r,filter:o}=n,{strides:s,pad:i,dilations:a}=t,c=e,l=c.data.get(r.dataId).values,u=r.shape.length,p=c.data.get(o.dataId).values,d=o.shape.length,{batchSize:f,inHeight:m,inWidth:h,inChannels:g,outHeight:x,outWidth:v,padInfo:w,strideHeight:I,strideWidth:_,filterHeight:A,filterWidth:R,dilationHeight:F,dilationWidth:P,outShape:L}=S.computeDilation2DInfo(r.shape,o.shape,s,i,"NHWC",a),V=y.sizeFromShape(L),z=L.length,H=y.getArrayFromDType(r.dtype,V);for(let W=0;W<f;++W)for(let Y=0;Y<x;++Y){let Z=Y*I-w.top;for(let K=0;K<v;++K){let Q=K*_-w.left;for(let te=0;te<g;++te){let ne=Number.MIN_SAFE_INTEGER;for(let re=0;re<A;++re){let ae=Z+re*F;if(ae>=0&&ae<m)for(let oe=0;oe<R;++oe){let ue=Q+oe*P;if(ue>=0&&ue<h){let xe=y.locToIndex([W,ae,ue,te],u,y.computeStrides(r.shape)),be=y.locToIndex([re,oe,te],d,y.computeStrides(o.shape)),ye=l[xe]+p[be];ye>ne&&(ne=ye)}}}let se=y.locToIndex([W,Y,K,te],z,y.computeStrides(L));H[se]=ne}}}return{dataId:c.write(y.toTypedArray(H,r.dtype),L,r.dtype),shape:L,dtype:r.dtype}}};T();var DB={kernelName:nx,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{let{x:r,filter:o,dy:s}=n,{strides:i,pad:a,dilations:c}=t,l=e,u=y.toNestedArray(r.shape,l.data.get(r.dataId).values),p=y.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:h,outHeight:g,outWidth:x,padInfo:v,strideHeight:w,strideWidth:I,filterHeight:_,filterWidth:A,dilationHeight:R,dilationWidth:F,outShape:P}=S.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",c);y.assert(s.rank===P.length,()=>`Error in ${nx}, dy must have the same rank as output ${P.length}, but got ${s.rank}`);let L=y.toNestedArray(P,l.data.get(s.dataId).values),V=y.makeZerosNestedTypedArray(o.shape,o.dtype);for(let H=0;H<d;++H)for(let j=0;j<g;++j){let W=j*w-v.top;for(let Y=0;Y<x;++Y){let Z=Y*I-v.left;for(let K=0;K<h;++K){let Q=Number.MIN_SAFE_INTEGER,te=0,ne=0;for(let se=0;se<_;++se){let re=W+se*R;if(re>=0&&re<f)for(let ae=0;ae<A;++ae){let oe=Z+ae*F;if(oe>=0&&oe<m){let ue=u[H][re][oe][K]+p[se][ae][K];ue>Q&&(Q=ue,te=se,ne=ae)}}}V[te][ne][K]+=L[H][j][Y][K]}}}return{dataId:l.write(y.toTypedArray(V,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};T();var kB={kernelName:tx,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{let{x:r,filter:o,dy:s}=n,{strides:i,pad:a,dilations:c}=t,l=e,u=y.toNestedArray(r.shape,l.data.get(r.dataId).values),p=y.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:h,outHeight:g,outWidth:x,padInfo:v,strideHeight:w,strideWidth:I,filterHeight:_,filterWidth:A,dilationHeight:R,dilationWidth:F,outShape:P}=S.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",c);y.assert(s.rank===P.length,()=>`Error in ${tx}, dy must have the same rank as output ${P.length}, but got ${s.rank}`);let L=y.toNestedArray(P,l.data.get(s.dataId).values),V=y.makeZerosNestedTypedArray(r.shape,r.dtype);for(let H=0;H<d;++H)for(let j=0;j<g;++j){let W=j*w-v.top;for(let Y=0;Y<x;++Y){let Z=Y*I-v.left;for(let K=0;K<h;++K){let Q=Number.MIN_SAFE_INTEGER,te=W<0?0:W,ne=Z<0?0:Z;for(let se=0;se<_;++se){let re=W+se*R;if(re>=0&&re<f)for(let ae=0;ae<A;++ae){let oe=Z+ae*F;if(oe>=0&&oe<m){let ue=u[H][re][oe][K]+p[se][ae][K];ue>Q&&(Q=ue,te=re,ne=oe)}}}V[H][te][ne][K]+=L[H][j][Y][K]}}}return{dataId:l.write(y.toTypedArray(V,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};T();function Xne(n){let{inputs:e,backend:t,attrs:r}=n,{image:o}=e,{canvas:s,options:i}=r,{contextOptions:a,imageOptions:c}=i||{},l=c?.alpha||1,u=a?.contextType||"2d";if(u!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);let p=s.getContext(u,a?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${u} type.`);let[d,f]=o.shape.slice(0,2),m=o.shape.length===2?1:o.shape[2],h=t.data.get(o.dataId).values,g=o.dtype==="float32"?255:1,x=new Uint8ClampedArray(f*d*4);for(let w=0;w<d*f;++w){let I=[0,0,0,255*l];for(let A=0;A<m;A++){let R=h[w*m+A];if(o.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(o.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);m===1?(I[0]=R*g,I[1]=R*g,I[2]=R*g):I[A]=R*g}let _=w*4;x[_+0]=Math.round(I[0]),x[_+1]=Math.round(I[1]),x[_+2]=Math.round(I[2]),x[_+3]=Math.round(I[3])}s.width=f,s.height=d;let v=new ImageData(x,f,d);return p.putImageData(v,0,0),o}var _B={kernelName:vp,backendName:"cpu",kernelFunc:Xne};T();T();function Ns(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;X(o,"sum");let a;o.dtype==="bool"?a=Nr({inputs:{x:o},backend:t,attrs:{dtype:"int32"}}):a=ln({inputs:{x:o},backend:t});let c=a.shape.length,l=y.parseAxisParam(s,a.shape),u=S.getAxesPermutation(l,c),p=l,d=a;u!=null&&(d=gt({inputs:{x:a},backend:t,attrs:{perm:u}}),p=S.getInnerMostAxes(p.length,c)),S.assertAxesAreInnerMostDims("sum",p,d.shape.length);let[f,m]=S.computeOutAndReduceShapes(d.shape,p),h=S.upcastType(d.dtype,"int32"),g=rd(t,f,h),x=y.sizeFromShape(m),v=t.data.get(g.dataId).values,w=t.data.get(d.dataId).values;for(let I=0;I<v.length;++I){let _=I*x,A=0;for(let R=0;R<x;++R)A+=w[_+R];v[I]=A}if(i){let I=S.expandShapeToKeepDim(g.shape,l),_=g;g=_e({inputs:{x:g},backend:t,attrs:{shape:I}}),t.disposeIntermediateTensorInfo(_)}return t.disposeIntermediateTensorInfo(a),u!=null&&t.disposeIntermediateTensorInfo(d),g}var AB={kernelName:"Sum",backendName:"cpu",kernelFunc:Ns};function Yne(n){let{inputs:e,backend:t,attrs:r}=n,{equation:o}=r,s=e,{allDims:i,summedDims:a,idDims:c}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,c,s);let{path:l,steps:u}=S.getEinsumComputePath(a,c),p=u.length,d=null,f=i.length,m=[];for(let h=0;h<p;++h){for(let g of u[h]){let{permutationIndices:x,expandDims:v}=S.getEinsumPermutation(f,c[g]),w;S.isIdentityPermutation(x)?w=s[g]:(w=gt({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),m.push(w));let I=w.shape.slice();for(let _=0;_<v.length;++_)I.splice(v[_],0,1);y.arraysEqual(w.shape,I)||(w=_e({inputs:{x:w},backend:t,attrs:{shape:I}}),m.push(w)),d===null?d=w:(d=bu({inputs:{a:w,b:d},backend:t}),m.push(d))}h<p-1&&(l[h]>=0&&(d=Ns({inputs:{x:d},backend:t,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),m.push(d)),f--)}for(let h of m)h!==d&&t.disposeIntermediateTensorInfo(h);return d}var RB={kernelName:_c,backendName:"cpu",kernelFunc:Yne};T();function Zne(n){let{inputs:e,backend:t}=n,{dy:r,y:o}=e;X([r,o],"eluGrad");let s=new Float32Array(y.sizeFromShape(o.shape)),i=t.data.get(o.dataId).values,a=t.data.get(r.dataId).values;for(let c=0;c<i.length;++c){let l=i[c];l>=0?s[c]=a[c]:s[c]=a[c]*(l+1)}return t.makeTensorInfo(o.shape,"float32",s)}var FB={kernelName:Lf,backendName:"cpu",kernelFunc:Zne};T();var Qne=S.ERF_P,Jne=S.ERF_A1,ere=S.ERF_A2,tre=S.ERF_A3,nre=S.ERF_A4,rre=S.ERF_A5,ore=he("Erf",n=>{let e=Math.sign(n),t=Math.abs(n),r=1/(1+Qne*t);return e*(1-((((rre*r+nre)*r+tre)*r+ere)*r+Jne)*r*Math.exp(-t*t))}),MB={kernelName:"Erf",backendName:"cpu",kernelFunc:ore};T();function ld(n){let{inputs:e,backend:t,attrs:r}=n,{input:o}=e,{dim:s}=r,i=o.shape.length,a=o.shape.slice(),c=s;return s<0&&(y.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),c=i+s+1),a.splice(c,0,1),_e({inputs:{x:o},backend:t,attrs:{shape:a}})}var OB={kernelName:Mc,backendName:"cpu",kernelFunc:ld};T();T();T();var sre=ke((n,e)=>n/e),oh=Ve(ii,sre),sh={kernelName:ii,backendName:"cpu",kernelFunc:oh};function Ly(n,e,t){let r=n.shape,o=r[0],s=r[1],i=t.data.get(n.dataId),a=i.complexTensorInfos.real,c=i.complexTensorInfos.imag,l=[o,s],u=y.sizeFromShape(l),p=y.getTypedArrayFromDType("float32",u),d=y.getTypedArrayFromDType("float32",u);for(let g=0;g<o;g++){let x=kr({inputs:{x:a},backend:t,attrs:{begin:[g,0],size:[1,s]}}),v=kr({inputs:{x:c},backend:t,attrs:{begin:[g,0],size:[1,s]}}),w=Pt({inputs:{real:x,imag:v},backend:t}),{real:I,imag:_}=ire(w,e,t),A=S.mergeRealAndImagArrays(I,_);for(let R=0;R<s;R++){let F=S.getComplexWithIndex(A,R);p[g*s+R]=F.real,d[g*s+R]=F.imag}t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(w)}let f=t.makeTensorInfo(l,"float32",p),m=t.makeTensorInfo(l,"float32",d),h=Pt({inputs:{real:f,imag:m},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),h}function ire(n,e,t){let r=y.sizeFromShape(n.shape),o=t.data.get(n.dataId),s=t.data.get(o.complexTensorInfos.real.dataId).values,i=t.data.get(o.complexTensorInfos.imag.dataId).values;if(are(r)){let a=zN(s,i,r,e,t),c=[n.shape[0],n.shape[1]];if(e){let l=t.makeTensorInfo(c,"float32",a.real),u=t.makeTensorInfo(c,"float32",a.imag),p=t.makeTensorInfo([],"float32",y.createScalarValue(r,"float32")),d=ln({inputs:{x:p},backend:t}),f=sh.kernelFunc({inputs:{a:l,b:p},backend:t}),m=sh.kernelFunc({inputs:{a:u,b:d},backend:t}),h=t.data.get(f.dataId).values,g=t.data.get(m.dataId).values;return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),{real:h,imag:g}}return a}else{let a=S.mergeRealAndImagArrays(s,i),c=cre(a,r,e);return S.splitRealAndImagArrays(c)}}function are(n){return(n&n-1)===0}function zN(n,e,t,r,o){if(t===1)return{real:n,imag:e};let s=S.mergeRealAndImagArrays(n,e),i=t/2,a=S.complexWithEvenIndex(s),c=a.real,l=a.imag,u=[c.length],p=o.makeTensorInfo(u,"float32",c),d=o.makeTensorInfo(u,"float32",l),f=Pt({inputs:{real:p,imag:d},backend:o}),m=S.complexWithOddIndex(s),h=m.real,g=m.imag,x=[h.length],v=o.makeTensorInfo(x,"float32",h),w=o.makeTensorInfo(x,"float32",g),I=Pt({inputs:{real:v,imag:w},backend:o}),_=zN(c,l,i,r,o),A=_.real,R=_.imag,F=[A.length],P=o.makeTensorInfo(F,"float32",A),L=o.makeTensorInfo(F,"float32",R),V=Pt({inputs:{real:P,imag:L},backend:o}),z=zN(h,g,i,r,o),H=z.real,j=z.imag,W=[H.length],Y=o.makeTensorInfo(W,"float32",H),Z=o.makeTensorInfo(W,"float32",j),K=Pt({inputs:{real:Y,imag:Z},backend:o}),Q=S.exponents(t,r),te=[Q.real.length],ne=o.makeTensorInfo(te,"float32",Q.real),se=o.makeTensorInfo(te,"float32",Q.imag),re=Pt({inputs:{real:ne,imag:se},backend:o}),ae=bu({inputs:{a:re,b:K},backend:o}),oe=Vo({inputs:{a:V,b:ae},backend:o}),ue=nh({inputs:{a:V,b:ae},backend:o}),xe=Sr({inputs:{input:oe},backend:o}),be=Sr({inputs:{input:ue},backend:o}),ye=Uo({inputs:{input:oe},backend:o}),Fe=Uo({inputs:{input:ue},backend:o}),$e=da({inputs:[xe,be],backend:o,attrs:{axis:0}}),et=da({inputs:[ye,Fe],backend:o,attrs:{axis:0}}),ct=o.data.get($e.dataId).values,kt=o.data.get(et.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(I),o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(L),o.disposeIntermediateTensorInfo(V),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(Z),o.disposeIntermediateTensorInfo(K),o.disposeIntermediateTensorInfo(ne),o.disposeIntermediateTensorInfo(se),o.disposeIntermediateTensorInfo(re),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(oe),o.disposeIntermediateTensorInfo(ue),o.disposeIntermediateTensorInfo(xe),o.disposeIntermediateTensorInfo(ye),o.disposeIntermediateTensorInfo(be),o.disposeIntermediateTensorInfo(Fe),o.disposeIntermediateTensorInfo($e),o.disposeIntermediateTensorInfo(et),{real:ct,imag:kt}}function cre(n,e,t){let r=new Float32Array(e*2);for(let o=0;o<e;o++){let s=0,i=0;for(let a=0;a<e;a++){let c=S.exponent(o*a,e,t),l=S.getComplexWithIndex(n,a);s+=l.real*c.real-l.imag*c.imag,i+=l.real*c.imag+l.imag*c.real}t&&(s/=e,i/=e),S.assignToTypedArray(r,s,i,o)}return r}function lre(n){let{inputs:e,backend:t}=n,{input:r}=e,o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=_e({inputs:{x:r},backend:t,attrs:{shape:[i,s]}}),c=Ly(a,!1,t),l=_e({inputs:{x:c},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),l}var $B={kernelName:"FFT",backendName:"cpu",kernelFunc:lre};T();function ih(n){let{backend:e,attrs:t}=n,{shape:r,value:o,dtype:s}=t,i=s||y.inferDtype(o),a=y.getArrayFromDType(i,y.sizeFromShape(r));return ure(a,o,i),e.makeTensorInfo(r,i,a)}var PB={kernelName:Oc,backendName:"cpu",kernelFunc:ih};function ure(n,e,t){n.fill(e)}T();var LB={kernelName:$c,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{image:r}=n,o=t,s=y.getTypedArrayFromDType(r.dtype,y.sizeFromShape(r.shape)),[i,a,c,l]=r.shape,u=o.data.get(r.dataId).values;for(let d=0;d<i;d++){let f=d*c*a*l;for(let m=0;m<a;m++){let h=m*(c*l);for(let g=0;g<c;g++){let x=g*l;for(let v=0;v<l;v++){let w=Math.round(c-g-1),I=f+h+x+v,_=u[I];if(w>=0&&w<c){let A=w*l,R=f+h+A+v;_=u[R]}s[I]=_}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};T();function pre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:c,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,h=VN({inputs:{x:o,filter:s},backend:t,attrs:{strides:c,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d}});if(i){let g=h;if(u==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let x=_e({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});h=Vo({inputs:{a:h,b:x},backend:t}),t.disposeIntermediateTensorInfo(x)}else h=Vo({inputs:{a:h,b:i},backend:t});t.disposeIntermediateTensorInfo(g)}if(f){let g=h;if(u==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){let x=_e({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});h=Cu(t,h,f,x,m),t.disposeIntermediateTensorInfo(x)}else h=Cu(t,h,f,a,m);t.disposeIntermediateTensorInfo(g)}return h}var BB={kernelName:zi,backendName:"cpu",kernelFunc:pre};T();function dre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:c,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,h=UN({inputs:{x:o,filter:s},backend:t,attrs:{strides:c,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d}});if(i){let g=h;h=Vo({inputs:{a:h,b:i},backend:t}),t.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=Cu(t,h,f,a,m),t.disposeIntermediateTensorInfo(g)}return h}var VB={kernelName:Hi,backendName:"cpu",kernelFunc:dre};T();function fre(n){let{inputs:e,backend:t}=n,{params:r,indices:o}=e,s=y.sizeFromShape(r.shape),i=o.shape,a=i[i.length-1],[c,l,u,p]=S.prepareAndValidate(r,o);if(l===0)return t.makeTensorInfo(c,r.dtype,[]);let d=t.data.get(o.dataId).values,f=t.bufferSync(r),m=vy(d,f,r.dtype,l,a,u,p,r.shape,s);return t.makeTensorInfo(c,r.dtype,m.values)}var UB={kernelName:Bc,backendName:"cpu",kernelFunc:fre};T();function mre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,indices:s}=e,{axis:i,batchDims:a}=r;X([o,s],"gatherV2");let c=y.parseAxisParam(i,o.shape)[0],l=t.data.get(s.dataId).values,u=o.shape[c];for(let I=0;I<l.length;++I){let _=l[I];y.assert(_<=u-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${u-1}]`)}let p=a;a==null&&(p=0);let d=y.sizeFromShape(s.shape),f=S.segment_util.collectGatherOpShapeInfo(o,s,c,p),m=_e({inputs:{x:o},backend:t,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),h=_e({inputs:{x:s},backend:t,attrs:{shape:[f.batchSize,d/f.batchSize]}}),g=[f.batchSize,f.outerSize,d/f.batchSize,f.sliceSize],x=t.bufferSync(h),v=t.bufferSync(m),w=by(v,x,g);return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),t.makeTensorInfo(f.outputShape,w.dtype,w.values)}var zB={kernelName:Lc,backendName:"cpu",kernelFunc:mre};T();function hre(n){let{inputs:e,backend:t}=n,{input:r}=e,o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=_e({inputs:{x:r},backend:t,attrs:{shape:[i,s]}}),c=Ly(a,!0,t),l=_e({inputs:{x:c},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),l}var HB={kernelName:Vc,backendName:"cpu",kernelFunc:hre};T();var gre=he(fi,n=>Number.isFinite(n)?1:0,"bool"),GB={kernelName:fi,backendName:"cpu",kernelFunc:gre};T();var xre=he(mi,n=>Math.abs(n)===1/0?1:0,"bool"),WB={kernelName:mi,backendName:"cpu",kernelFunc:xre};T();var yre=he(hi,n=>Number.isNaN(n)?1:0,"bool"),jB={kernelName:hi,backendName:"cpu",kernelFunc:yre};T();function vre(n){let{backend:e,attrs:t}=n,{start:r,stop:o,num:s}=t,i=Cy(r,o,s);return e.makeTensorInfo([i.length],"float32",i)}var qB={kernelName:Hc,backendName:"cpu",kernelFunc:vre};T();var bre=he(yi,n=>Math.log1p(n)),KB={kernelName:yi,backendName:"cpu",kernelFunc:bre};T();var Cre=ke((n,e)=>n&&e),wre=Ve(vi,Cre,null,"bool"),XB={kernelName:vi,backendName:"cpu",kernelFunc:wre};T();var Ire=he(bi,n=>n?0:1,"bool"),YB={kernelName:bi,backendName:"cpu",kernelFunc:Ire};T();var Ere=ke((n,e)=>n||e),Tre=Ve(Ci,Ere,null,"bool"),ZB={kernelName:Ci,backendName:"cpu",kernelFunc:Tre};T();function Sre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{depthRadius:s,bias:i,alpha:a,beta:c}=r;X(o,"LRN");let l=o.shape[3],u=l-1,p=t.data.get(o.dataId).values,d=y.sizeFromShape(o.shape),f=new Float32Array(d);function m(h){let g=h%l,x=h-g+Math.max(0,g-s),v=h-g+Math.min(g+s,u),w=0;for(;x<=v;x++){let I=p[x];w+=I*I}return w}for(let h=0;h<d;h++){let g=m(h),x=p[h]*Math.pow(i+a*g,-c);f[h]=x}return t.makeTensorInfo(o.shape,o.dtype,f)}var QB={kernelName:"LRN",backendName:"cpu",kernelFunc:Sre};T();function Nre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,y:s,dy:i}=e,{depthRadius:a,bias:c,alpha:l,beta:u}=r;X(i,"LRNGrad");let p=y.sizeFromShape(i.shape),d=i.shape[3],f=t.data.get(i.dataId).values,m=t.data.get(o.dataId).values,h=t.data.get(s.dataId).values,g=new Float32Array(p),x=p;for(let v=0;v<x;v++){let w=v%d,I=v-w+Math.max(0,w-a),_=v-w+Math.min(d,w+a+1),A=0;for(let R=I;R<_;R++)A+=Math.pow(m[R],2);A=l*A+c;for(let R=I;R<_;R++){let F=-2*l*u*m[R]*h[v]/A;v===R&&(F+=Math.pow(A,-u)),F*=f[v],g[R]+=F}}return t.makeTensorInfo(i.shape,o.dtype,g)}var JB={kernelName:Bf,backendName:"cpu",kernelFunc:Nre};T();T();T();function HN(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{reductionIndices:s,keepDims:i}=r,a=t,c=o.shape,l=c.length,u=y.parseAxisParam(s,c),p=u,d=S.getAxesPermutation(p,l),f=a.data.get(o.dataId).values;if(d!=null){let I=new Array(l);for(let _=0;_<I.length;_++)I[_]=c[d[_]];f=id(f,c,o.dtype,d,I),p=S.getInnerMostAxes(p.length,l),c=I}X(o,"max"),S.assertAxesAreInnerMostDims("max",p,l);let[m,h]=S.computeOutAndReduceShapes(c,p),g=y.sizeFromShape(h),x=wy(f,g,m,o.dtype),v=a.write(x,m,o.dtype),w=m;return i&&(w=S.expandShapeToKeepDim(m,u)),{dataId:v,shape:w,dtype:o.dtype}}var eV={kernelName:"Max",backendName:"cpu",kernelFunc:HN};T();function Dre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e;X(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let u=S.computePool2DInfo(o.shape,s,i,l,a,c),p;if(u.filterWidth===1&&u.filterHeight===1&&y.arraysEqual(u.inShape,u.outShape))p=ln({inputs:{x:o},backend:t});else{let d=t.data.get(o.dataId).values,f=y.computeStrides(o.shape),m=cd(d,o.shape,o.dtype,f,u,"max");p=t.makeTensorInfo(u.outShape,o.dtype,m.values)}return p}var tV={kernelName:Wc,backendName:"cpu",kernelFunc:Dre};T();function kre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:c,dataFormat:l}=r;X(o,"maxPool3d");let u=S.computePool3DInfo(o.shape,s,i,1,a,c,l),p=t.data.get(o.dataId).values,d=Py(p,o.shape,o.dtype,y.computeStrides(o.shape),u,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}var nV={kernelName:jc,backendName:"cpu",kernelFunc:kre};T();function _re(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,{filterSize:i,strides:a,pad:c,dimRoundingMode:l}=r;X([o,s],"maxPool3DGrad");let u=S.computePool3DInfo(s.shape,i,a,1,c,l),p=t.bufferSync(s),d=ZL(p,u),f=u.strideDepth,m=u.strideHeight,h=u.strideWidth,g=u.dilationDepth,x=u.dilationHeight,v=u.dilationWidth,w=u.effectiveFilterDepth,I=u.effectiveFilterHeight,_=u.effectiveFilterWidth,A=w-1-u.padInfo.front,R=_-1-u.padInfo.left,F=I-1-u.padInfo.top,P=le(s.shape,"float32"),L=t.bufferSync(o);for(let V=0;V<u.batchSize;++V)for(let z=0;z<u.inChannels;++z)for(let H=0;H<u.inDepth;++H)for(let j=0;j<u.inHeight;++j)for(let W=0;W<u.inWidth;++W){let Y=H-A,Z=j-F,K=W-R,Q=0;for(let te=0;te<w;te+=g){let ne=(Y+te)/f;if(!(ne<0||ne>=u.outDepth||Math.floor(ne)!==ne))for(let se=0;se<I;se+=x){let re=(Z+se)/m;if(!(re<0||re>=u.outHeight||Math.floor(re)!==re))for(let ae=0;ae<_;ae+=v){let oe=(K+ae)/h;if(oe<0||oe>=u.outWidth||Math.floor(oe)!==oe)continue;let ue=w*I*_-1-d.get(V,ne,re,oe,z),xe=te*I*_+se*_+ae,be=ue===xe?1:0;if(be===0)continue;let ye=L.get(V,ne,re,oe,z);Q+=ye*be}}}P.set(Q,V,H,j,W,z)}return t.makeTensorInfo(P.shape,P.dtype,P.values)}var rV={kernelName:Uf,backendName:"cpu",kernelFunc:_re};T();function Are(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s,output:i}=e,a=s;X([s,i],"maxPoolGrad");let{filterSize:c,strides:l,pad:u,dimRoundingMode:p}=r,d=S.computePool2DInfo(a.shape,c,l,1,u,p),f=t.data.get(a.dataId).values,m=le(d.outShape,a.dtype,$y(f,a.shape,a.dtype,d).values),h=d.strideHeight,g=d.strideWidth,x=d.dilationHeight,v=d.dilationWidth,w=d.effectiveFilterHeight,I=d.effectiveFilterWidth,_=I-1-d.padInfo.left,A=w-1-d.padInfo.top,R=le(a.shape,"float32"),F=t.data.get(o.dataId).values,P=le(o.shape,"float32",F);for(let L=0;L<d.batchSize;++L)for(let V=0;V<d.inChannels;++V)for(let z=0;z<d.inHeight;++z)for(let H=0;H<d.inWidth;++H){let j=z-A,W=H-_,Y=0;for(let Z=0;Z<w;Z+=x){let K=(j+Z)/h;if(!(K<0||K>=d.outHeight||Math.floor(K)!==K))for(let Q=0;Q<I;Q+=v){let te=(W+Q)/g;if(te<0||te>=d.outWidth||Math.floor(te)!==te)continue;let ne=w*I-1-m.get(L,K,te,V),se=Z*I+Q,re=ne===se?1:0;if(re===0)continue;let ae=P.get(L,K,te,V);Y+=ae*re}}R.set(Y,L,z,H,V)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}var oV={kernelName:Vf,backendName:"cpu",kernelFunc:Are};T();T();T();function sV(n,e,t,r,o){let s=y.computeStrides(e),i=cd(n,e,t,s,o,"max"),a=$y(n,e,t,o,!0,r);return[i.values,a.values]}var iV={kernelName:qc,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{x:r}=n,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=e,c=t;X(r,"MaxPoolWithArgmax");let l=c.data.get(r.dataId).values,u=S.computePool2DInfo(r.shape,o,s,[1,1],i),[p,d]=sV(l,r.shape,r.dtype,a,u),f=c.write(p,u.outShape,r.dtype),m=c.write(d,u.outShape,r.dtype);return[{dataId:f,shape:u.outShape,dtype:r.dtype},{dataId:m,shape:u.outShape,dtype:"int32"}]}};T();function Rre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r,a=y.parseAxisParam(s,o.shape),l=S.computeOutAndReduceShapes(o.shape,a)[1],u=y.sizeFromShape(l),p=[],d=t.makeTensorInfo([],"float32",new Float32Array([u]));p.push(d);let f=Nr({inputs:{x:o},backend:t,attrs:{dtype:"float32"}});p.push(f);let m=oh({inputs:{a:f,b:d},backend:t});p.push(m);let h=Ns({inputs:{x:m},backend:t,attrs:{axis:s,keepDims:i}});return p.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}var aV={kernelName:Kc,backendName:"cpu",kernelFunc:Rre};T();function Fre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;X(o,"min");let a=y.parseAxisParam(s,o.shape),c=a,l=S.getAxesPermutation(c,o.shape.length),u=o;l!=null&&(u=gt({inputs:{x:o},backend:t,attrs:{perm:l}}),c=S.getInnerMostAxes(c.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",c,u.shape.length);let[p,d]=S.computeOutAndReduceShapes(u.shape,c),f=y.sizeFromShape(d),m=y.makeZerosTypedArray(y.sizeFromShape(p),u.dtype),h=t.data.get(u.dataId).values;for(let x=0;x<m.length;++x){let v=x*f,w=h[v];for(let I=0;I<f;++I){let _=h[v+I];(Number.isNaN(_)||_<w)&&(w=_)}m[x]=w}l!=null&&t.disposeIntermediateTensorInfo(u);let g=t.makeTensorInfo(p,u.dtype,m);if(i){let x=S.expandShapeToKeepDim(p,a),v=_e({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),v}return g}var cV={kernelName:"Min",backendName:"cpu",kernelFunc:Fre};T();function Mre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{paddings:s,mode:i}=r;X(o,"mirrorPad");let a=s.map((w,I)=>w[0]+o.shape[I]+w[1]),c=s.map(w=>w[0]),l=s.map((w,I)=>w[0]+o.shape[I]),u=i==="reflect"?0:1,p=t.data.get(o.dataId).values,d=o.shape.length,f=y.computeStrides(o.shape),m=y.sizeFromShape(a),h=a.length,g=y.computeStrides(a),x=y.getTypedArrayFromDType(o.dtype,m);for(let w=0;w<m;w++){let I=y.indexToLoc(w,h,g);for(let A=0;A<h;A++)I[A]<c[A]?I[A]=c[A]*2-I[A]-u:I[A]>=l[A]&&(I[A]=(l[A]-1)*2-I[A]+u);I=I.map((A,R)=>A-c[R]);let _=y.locToIndex(I,d,f);x[w]=p[_]}return{dataId:t.write(x,a,o.dtype),shape:a,dtype:o.dtype}}var lV={kernelName:Xc,backendName:"cpu",kernelFunc:Mre};T();var Ore=ke((n,e)=>{let t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),$re=Ve("Mod",Ore),uV={kernelName:"Mod",backendName:"cpu",kernelFunc:$re};T();var dV=Nh(VT());T();function GN(n){let{inputs:e,backend:t,attrs:r}=n,{logits:o}=e,{dim:s}=r,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let c=y.parseAxisParam([a],o.shape),l=HN({inputs:{x:o},backend:t,attrs:{reductionIndices:c,keepDims:!1}}),u=S.expandShapeToKeepDim(l.shape,c),p=_e({inputs:{x:l},backend:t,attrs:{shape:u}}),d=nh({inputs:{a:o,b:p},backend:t}),f=pN({inputs:{x:d},backend:t}),m=Ns({inputs:{x:f},backend:t,attrs:{axis:c,keepDims:!1}}),h=_e({inputs:{x:m},backend:t,attrs:{shape:u}}),g=oh({inputs:{a:f,b:h},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),g}var pV={kernelName:Tl,backendName:"cpu",kernelFunc:GN};function Pre(n){let{inputs:e,backend:t,attrs:r}=n,{logits:o}=e,{numSamples:s,seed:i,normalized:a}=r;X(o,"multinomial");let c=a?o:GN({inputs:{logits:o},backend:t,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],p=t.data.get(c.dataId).values,d=[l,s],f=y.makeZerosTypedArray(y.sizeFromShape(d),"int32");for(let m=0;m<l;++m){let h=m*u,g=new Float32Array(u-1);g[0]=p[h];for(let w=1;w<g.length;++w)g[w]=g[w-1]+p[h+w];let x=dV.alea(i.toString()),v=m*s;for(let w=0;w<s;++w){let I=x();f[v+w]=g.length;for(let _=0;_<g.length;_++)if(I<g[_]){f[v+w]=_;break}}}return a||t.disposeIntermediateTensorInfo(c),t.makeTensorInfo(d,"int32",f)}var fV={kernelName:Zc,backendName:"cpu",kernelFunc:Pre};T();var Lre=Jt.nonMaxSuppressionV3Impl;function Bre(n){let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c}=r;X(o,"NonMaxSuppression");let l=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,{selectedIndices:p}=Lre(l,u,i,a,c);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}var mV={kernelName:Qc,backendName:"cpu",kernelFunc:Bre};T();var Vre=Jt.nonMaxSuppressionV4Impl;function Ure(n){let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,padToMaxOutputSize:l}=r;X(o,"NonMaxSuppressionPadded");let u=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,{selectedIndices:d,validOutputs:f}=Vre(u,p,i,a,c,l);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var hV={kernelName:Jc,backendName:"cpu",kernelFunc:Ure};T();var zre=Jt.nonMaxSuppressionV5Impl;function Hre(n){let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,softNmsSigma:l}=r;X(o,"NonMaxSuppressionWithScore");let u=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,d=i,f=a,m=c,h=l,{selectedIndices:g,selectedScores:x}=zre(u,p,d,f,m,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var gV={kernelName:el,backendName:"cpu",kernelFunc:Hre};T();function Gre(n){let{inputs:e,backend:t,attrs:r}=n,{indices:o}=e,{dtype:s,depth:i,onValue:a,offValue:c}=r;X(o,"oneHot");let l=y.sizeFromShape(o.shape),u=new Float32Array(l*i);u.fill(c);let p=t.data.get(o.dataId).values;for(let d=0;d<l;++d)p[d]>=0&&p[d]<i&&(u[d*i+p[d]]=a);return t.makeTensorInfo([...o.shape,i],s,u)}var xV={kernelName:nl,backendName:"cpu",kernelFunc:Gre};T();T();function ah(n){let{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let o=Sr({inputs:{input:r},backend:t}),s=ah({inputs:{x:o},backend:t}),i=Uo({inputs:{input:r},backend:t}),a=ah({inputs:{x:i},backend:t}),c=Pt({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return ih({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var yV={kernelName:zl,backendName:"cpu",kernelFunc:ah};function vV(n){let{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let o=Sr({inputs:{input:r},backend:t}),s=vV({inputs:{x:o},backend:t}),i=Uo({inputs:{input:r},backend:t}),a=ah({inputs:{x:i},backend:t}),c=Pt({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return ih({backend:t,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var bV={kernelName:tl,backendName:"cpu",kernelFunc:vV};T();function WN(n){let{inputs:e,backend:t,attrs:r}=n,{axis:o}=r;if(e.length===1)return ld({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,i=e[0].dtype;e.forEach(u=>{y.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],c=e.map(u=>{let p=ld({inputs:{input:u},backend:t,attrs:{dim:o}});return a.push(p),p}),l=da({inputs:c,backend:t,attrs:{axis:o}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),l}var CV={kernelName:rl,backendName:"cpu",kernelFunc:WN};T();function Wre(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{paddings:s,constantValue:i}=r;X(o,"pad");let a=s.map((v,w)=>v[0]+o.shape[w]+v[1]),c=s.map(v=>v[0]),l=t.data.get(o.dataId).values,u=y.sizeFromShape(o.shape),p=o.shape.length,d=y.computeStrides(o.shape),f=y.sizeFromShape(a),m=a.length,h=y.computeStrides(a),g=y.getTypedArrayFromDType(o.dtype,f);i!==0&&g.fill(i);for(let v=0;v<u;v++){let I=y.indexToLoc(v,p,d).map((A,R)=>A+c[R]),_=y.locToIndex(I,m,h);g[_]=l[v]}return{dataId:t.write(g,a,o.dtype),shape:a,dtype:o.dtype}}var By={kernelName:ol,backendName:"cpu",kernelFunc:Wre};T();var jre=ke((n,e)=>Math.pow(n,e)),qre=Ve("Pow",jre),wV={kernelName:"Pow",backendName:"cpu",kernelFunc:qre};T();function Kre(n){let{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=e,{outputRaggedRank:a}=r,c=o.map(x=>t.data.get(x.dataId).values),l=o.map(x=>x.shape),u=t.data.get(s.dataId).values,p=t.data.get(i.dataId).values,[d,f,m]=Iy(c,l,u,s.shape,s.dtype,p,i.shape,a),h=d.map(x=>t.makeTensorInfo([x.length],"int32",x)),g=t.makeTensorInfo(m,s.dtype,f);return h.concat([g])}var IV={kernelName:cl,backendName:"cpu",kernelFunc:Kre};T();function Xre(n){let{inputs:e,backend:t}=n,{starts:r,limits:o,deltas:s}=e,i=t.data.get(r.dataId).values,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,[l,u]=Ey(i,r.shape,r.dtype,a,o.shape,c,s.shape),p=t.makeTensorInfo([l.length],"int32",l),d=t.makeTensorInfo([u.length],r.dtype,u);return[p,d]}var EV={kernelName:ll,backendName:"cpu",kernelFunc:Xre};T();function Yre(n){let{inputs:e,backend:t,attrs:r}=n,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:c}=r,l=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,p=t.data.get(i.dataId).values,d=a.map(g=>t.data.get(g.dataId).values),f=a.map(g=>g.shape),[m,h]=Ty(l,o.shape,u,s.shape,s.dtype,p,i.shape,d,f,c);return t.makeTensorInfo(m,s.dtype,h)}var TV={kernelName:ul,backendName:"cpu",kernelFunc:Yre};T();function Zre(n){let{backend:e,attrs:t}=n,{start:r,stop:o,dtype:s,step:i}=t,a=Sy(r,o,i,s);return e.makeTensorInfo([a.length],s,a)}var SV={kernelName:pl,backendName:"cpu",kernelFunc:Zre};T();var Qre=he(Si,n=>1/n),NV={kernelName:Si,backendName:"cpu",kernelFunc:Qre};T();function Jre(n){let{inputs:e,backend:t,attrs:r}=n,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=r;X(o,"resizeBilinear");let c=y.computeStrides(o.shape),[l,u]=a,[p,d,f,m]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(y.sizeFromShape([p,l,u,m])),x=[s&&l>1?d-1:d,s&&u>1?f-1:f],v=[s&&l>1?l-1:l,s&&u>1?u-1:u],w=0,I=x[0]/v[0],_=x[1]/v[1];for(let A=0;A<p;A++)for(let R=0;R<l;R++){let F;i?F=I*(R+.5)-.5:F=I*R;let P=Math.max(0,Math.floor(F)),L=F-P,V=Math.min(d-1,Math.ceil(F)),z=A*c[0]+P*c[1],H=A*c[0]+V*c[1];for(let j=0;j<u;j++){let W;i?W=_*(j+.5)-.5:W=_*j;let Y=Math.max(0,Math.floor(W)),Z=W-Y,K=Math.min(f-1,Math.ceil(W)),Q=z+Y*c[2],te=H+Y*c[2],ne=z+K*c[2],se=H+K*c[2];for(let re=0;re<m;re++){let ae=h[Q+re],oe=h[te+re],ue=h[ne+re],xe=h[se+re],be=ae+(ue-ae)*Z,ye=oe+(xe-oe)*Z,Fe=be+(ye-be)*L;g[w++]=Fe}}}return t.makeTensorInfo([p,l,u,m],"float32",g)}var DV={kernelName:hl,backendName:"cpu",kernelFunc:Jre};T();function eoe(n){let{inputs:e,backend:t,attrs:r}=n,{images:o,dy:s}=e,{alignCorners:i}=r;X([s,o],"resizeBilinearGrad");let a=y.computeStrides(o.shape),[c,l,u,p]=o.shape,[,d,f]=s.shape,m=new Float32Array(c*l*u*p),h=[i&&d>1?l-1:l,i&&f>1?u-1:u],g=[i&&d>1?d-1:d,i&&f>1?f-1:f],x=h[0]/g[0],v=h[1]/g[1],w=t.data.get(s.dataId).values,I=0;for(let _=0;_<c;_++){let A=_*a[0];for(let R=0;R<d;R++){let F=R*x,P=Math.floor(F),L=Math.min(Math.ceil(F),l-1),V=A+P*a[1],z=A+L*a[1],H=F-P,j=1-H;for(let W=0;W<f;W++){let Y=W*v,Z=Math.floor(Y),K=Math.min(Math.ceil(Y),u-1),Q=Y-Z,te=1-Q,ne=V+Z*a[2],se=V+K*a[2],re=z+Z*a[2],ae=z+K*a[2],oe=j*te,ue=j*Q,xe=H*te,be=H*Q;for(let ye=0;ye<p;ye++){let Fe=w[I++];m[ne+ye]+=Fe*oe,m[se+ye]+=Fe*ue,m[re+ye]+=Fe*xe,m[ae+ye]+=Fe*be}}}}return t.makeTensorInfo([c,u,l,p],"float32",m)}var kV={kernelName:Hf,backendName:"cpu",kernelFunc:eoe};T();function toe(n){let{inputs:e,backend:t,attrs:r}=n,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=r;X(o,"resizeNearestNeighbor");let c=y.computeStrides(o.shape),[l,u]=a,[p,d,f,m]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(p*l*u*m),x=[s&&l>1?d-1:d,s&&u>1?f-1:f],v=[s&&l>1?l-1:l,s&&u>1?u-1:u],w=x[0]/v[0],I=x[1]/v[1],_=0;for(let A=0;A<p;A++){let R=A*c[0];for(let F=0;F<l;F++){let P=i?w*(F+.5):w*F,L=Math.min(d-1,s?Math.round(P):Math.floor(P));i&&(L=Math.max(0,L));let V=R+L*c[1];for(let z=0;z<u;z++){let H=i?I*(z+.5):I*z,j=Math.min(f-1,s?Math.round(H):Math.floor(H));i&&(j=Math.max(0,j));let W=V+j*c[2];for(let Y=0;Y<m;Y++){let Z=h[W+Y];g[_++]=Z}}}}return t.makeTensorInfo([p,l,u,m],o.dtype,g)}var _V={kernelName:ml,backendName:"cpu",kernelFunc:toe};T();function noe(n){let{inputs:e,backend:t,attrs:r}=n,{images:o,dy:s}=e,{alignCorners:i}=r;X([s,o],"resizeNearestNeighborGrad");let a=y.computeStrides(o.shape),c=y.computeStrides(s.shape),[l,u,p,d]=o.shape,[,f,m]=s.shape,h=new Float32Array(l*u*p*d),g=t.data.get(s.dataId).values,x=[i&&f>1?u-1:u,i&&m>1?p-1:p],v=[i&&f>1?f-1:f,i&&m>1?m-1:m],w=x[0]/v[0],I=x[1]/v[1],_=1/w,A=1/I,R=Math.ceil(_)*2+2,F=Math.ceil(A)*2+2;for(let P=0;P<l;P++){let L=P*a[0];for(let V=0;V<u;V++){let z=L+V*a[1],H=Math.floor(V*_),j=Math.floor(H-R/2);for(let W=0;W<p;W++){let Y=z+W*a[2],Z=Math.floor(W*A),K=Math.floor(Z-F/2);for(let Q=0;Q<d;Q++){let te=0;for(let ne=0;ne<R;ne++){let se=ne+j;if(se<0||se>=f)continue;let re=L+se*c[1],ae=se*w,oe=Math.min(u-1,i?Math.round(ae):Math.floor(ae));if(V===oe)for(let ue=0;ue<F;ue++){let xe=ue+K;if(xe<0||xe>=m)continue;let be=re+xe*c[2],ye=xe*I,Fe=Math.min(p-1,i?Math.round(ye):Math.floor(ye));W===Fe&&(te+=g[be+Q])}}h[Y+Q]=te}}}}return t.makeTensorInfo(o.shape,o.dtype,h)}var AV={kernelName:zf,backendName:"cpu",kernelFunc:noe};T();function roe(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{dims:s}=r;X(o,"reverse");let i=o.shape.length,a=y.parseAxisParam(s,o.shape);if(i===0)return ln({inputs:{x:o},backend:t});let c=new He(o.shape,o.dtype),l=t.bufferSync(o);for(let u=0;u<c.size;u++){let p=c.indexToLoc(u),d=p.slice();a.forEach(f=>d[f]=o.shape[f]-1-d[f]),c.set(l.get(...d),...p)}return t.makeTensorInfo(c.shape,c.dtype,c.values)}var RV={kernelName:gl,backendName:"cpu",kernelFunc:roe};T();var FV={kernelName:Hl,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{image:r}=n,{radians:o,fillValue:s,center:i}=e,a=t,c=y.getTypedArrayFromDType(r.dtype,y.sizeFromShape(r.shape)),[l,u,p,d]=r.shape,[f,m]=S.getImageCenter(i,u,p),h=255,g=Math.sin(o),x=Math.cos(o),v=a.data.get(r.dataId).values;for(let I=0;I<l;I++){let _=I*p*u*d;for(let A=0;A<u;A++){let R=A*(p*d);for(let F=0;F<p;F++){let P=F*d;for(let L=0;L<d;L++){let V=[l,A,F,L],z=V[2],H=V[1],j=(z-f)*x-(H-m)*g,W=(z-f)*g+(H-m)*x;j=Math.round(j+f),W=Math.round(W+m);let Y=s;if(typeof s!="number"&&(L===3?Y=h:Y=s[L]),j>=0&&j<p&&W>=0&&W<u){let K=W*(p*d),Q=j*d,te=_+K+Q+L;Y=v[te]}let Z=_+R+P+L;c[Z]=Y}}}}return{dataId:a.write(c,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};T();var ooe=he(ki,n=>{let e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),MV={kernelName:ki,backendName:"cpu",kernelFunc:ooe};T();function soe(n){let{inputs:e,backend:t,attrs:r}=n,{indices:o,updates:s}=e,{shape:i}=r,{sliceRank:a,numUpdates:c,sliceSize:l,strides:u,outputSize:p}=S.calculateShapes(s,o,i),d=!0,f=t.bufferSync(o),m=t.bufferSync(s),h=so(f,m,i,p,l,c,a,u,0,d);return t.makeTensorInfo(i,h.dtype,h.values)}var OV={kernelName:xl,backendName:"cpu",kernelFunc:soe};T();T();function ioe(n,e){let t=0,r=n.length,o=0;for(;t<r;)o=Math.floor((t+r)/2),n[o]<e?t=o+1:r=o;return r}function aoe(n,e){let t=0,r=n.length,o=0;for(;t<r;)o=Math.floor((t+r)/2),n[o]<=e?t=o+1:r=o;return r}function $V(n,e,t,r,o,s){let i=y.getArrayFromDType("int32",t*o);for(let a=0;a<t;++a){let c=n.slice(a*r,(a+1)*r),l=a*o;for(let u=0;u<o;++u)i[l+u]=s==="left"?ioe(c,e[u+l]):aoe(c,e[u+l])}return i}function coe(n){let{inputs:e,backend:t,attrs:r}=n,{sortedSequence:o,values:s}=e,{side:i}=r,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,l=$V(a,c,o.shape[0],o.shape[1],s.shape[1],i);return t.makeTensorInfo(s.shape,"int32",l)}var PV={kernelName:vl,backendName:"cpu",kernelFunc:coe};T();function loe(n){let{inputs:e,backend:t}=n,{condition:r,t:o,e:s}=e;X([r,o,s],"select");let i=r.shape.length,a=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,u=Dt(o.dtype,s.dtype),p=y.makeZerosTypedArray(y.sizeFromShape(o.shape),u),d=0,f=i===0||i>1||o.shape.length===1?1:y.sizeFromShape(o.shape.slice(1));for(let m=0;m<a.length;m++)for(let h=0;h<f;h++)a[m]===1?p[d++]=c[m]:p[d++]=l[m];return t.makeTensorInfo(o.shape,u,p)}var LV={kernelName:bl,backendName:"cpu",kernelFunc:loe};T();var uoe=S.SELU_SCALEALPHA,poe=S.SELU_SCALE,doe=he(Ai,n=>n>=0?poe*n:uoe*(Math.exp(n)-1)),BV={kernelName:Ai,backendName:"cpu",kernelFunc:doe};T();var foe=he(Fi,n=>n<0?-1:n>0?1:0),VV={kernelName:Fi,backendName:"cpu",kernelFunc:foe};T();var moe=he("Sin",n=>Math.sin(n)),UV={kernelName:"Sin",backendName:"cpu",kernelFunc:moe};T();var hoe=he(Ri,n=>Math.sinh(n)),zV={kernelName:Ri,backendName:"cpu",kernelFunc:hoe};T();var goe=11920928955078125e-23,HV=Math.log(goe)+2,xoe=he(Oi,n=>{let e=n>-HV,t=n<HV,r=Math.exp(n),o;return t?o=r:e?o=n:o=Math.log(1+r),o}),GV={kernelName:Oi,backendName:"cpu",kernelFunc:xoe};T();function yoe(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockShape:s,paddings:i}=r;X([o],"spaceToBatchND");let a=y.sizeFromShape(s),c=[[0,0]];c.push(...i);for(let A=1+s.length;A<o.shape.length;++A)c.push([0,0]);let l=By.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:c,constantValue:0}}),u=S.getReshaped(l.shape,s,a,!1),p=S.getPermuted(u.length,s.length,!1),d=S.getReshapedPermuted(l.shape,s,a,!1),h=_e({inputs:{x:l},backend:t,attrs:{shape:u}}),v=gt({inputs:{x:h},backend:t,attrs:{perm:p}}),_=_e({inputs:{x:v},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(v),_}var WV={kernelName:Il,backendName:"cpu",kernelFunc:yoe};T();function voe(n){let{inputs:e,backend:t}=n,{indices:r,values:o,denseShape:s,defaultValue:i}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values[0],[p,d,f,m,h]=Ny(a,r.shape,r.dtype,c,o.dtype,l,u);return[t.makeTensorInfo(d,r.dtype,p),t.makeTensorInfo([d[0]],o.dtype,f),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}var jV={kernelName:Sl,backendName:"cpu",kernelFunc:voe};T();function boe(n){let{inputs:e,backend:t}=n,{inputIndices:r,inputShape:o,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(t.data.get(o.dataId).values),a=t.data.get(r.dataId).values,c=Array.from(t.data.get(s.dataId).values),[l,u,p]=Dy(a,r.shape,r.dtype,i,c);return[t.makeTensorInfo(u,r.dtype,l),t.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var qV={kernelName:Nl,backendName:"cpu",kernelFunc:boe};T();function Coe(n){let{inputs:e,backend:t}=n,{data:r,indices:o,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=t.data.get(r.dataId).values,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,[l,u]=ad(i,r.shape,r.dtype,a,c,!0);return t.makeTensorInfo(u,r.dtype,l)}var KV={kernelName:Dl,backendName:"cpu",kernelFunc:Coe};T();function woe(n){let{inputs:e,backend:t}=n,{data:r,indices:o,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=t.data.get(r.dataId).values,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,[l,u]=ad(i,r.shape,r.dtype,a,c);return t.makeTensorInfo(u,r.dtype,l)}var XV={kernelName:kl,backendName:"cpu",kernelFunc:woe};T();function Ioe(n){let{inputs:e,backend:t,attrs:r}=n,{sparseIndices:o,sparseValues:s,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:c,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=S.calculateShapes(s,o,a),f=!1,m=t.bufferSync(o),h;switch(s.dtype){case"bool":{let g=t.bufferSync(s),x=!!t.data.get(i.dataId).values[0];h=so(m,g,a,d,u,l,c,p,x,f);break}case"float32":{let g=t.bufferSync(s),x=t.data.get(i.dataId).values[0];h=so(m,g,a,d,u,l,c,p,x,f);break}case"int32":{let g=t.bufferSync(s),x=t.data.get(i.dataId).values[0];h=so(m,g,a,d,u,l,c,p,x,f);break}case"string":{let g=t.bufferSync(s),x=y.decodeString(t.data.get(i.dataId).values[0]);h=so(m,g,a,d,u,l,c,p,x,f);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return t.makeTensorInfo(a,h.dtype,h.values)}var YV={kernelName:_l,backendName:"cpu",kernelFunc:Ioe};T();T();function Eoe(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{numOrSizeSplits:s,axis:i}=r,a=y.parseAxisParam(i,o.shape)[0],c=S.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),u=o.shape.slice();return c.map(p=>{let d=[...u];d[a]=p;let f=kr({inputs:{x:o},backend:t,attrs:{begin:l,size:d}});return l[a]+=p,f})}var ZV={kernelName:El,backendName:"cpu",kernelFunc:Eoe};T();var QV={kernelName:Gf,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{let{x:t}=n,r=e;X(t,"square");let o=r.data.get(t.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let c=o[a];s[a]=c*c}return{dataId:r.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};T();var Toe=he(Vi,(n,e)=>{let t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),JV={kernelName:Vi,backendName:"cpu",kernelFunc:Toe};T();function Soe(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{begin:s,end:i,strides:a,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:p,shrinkAxisMask:d}=r;X(o,"stridedSlice");let{finalShapeSparse:f,finalShape:m,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:v,end:w,strides:I}=$t.sliceInfo(o.shape,s,i,a,c,l,u,p,d),_;if(h)_=_e({inputs:{x:o},backend:t,attrs:{shape:m}});else if(g||x){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let A=$t.computeOutShape(v,w,I),R=kr({inputs:{x:o},backend:t,attrs:{begin:v,size:A}});_=_e({inputs:{x:R},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(R)}else{let A=t.bufferSync(o),R=ky(f,A,I,v);_=t.makeTensorInfo(m,R.dtype,R.values)}return _}var e3={kernelName:Al,backendName:"cpu",kernelFunc:Soe};T();function Noe(n){let{inputs:e,backend:t,attrs:r}=n,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:c,preserveShortSequences:l}=r,{data:u,dataSplits:p}=e,d=t.data.get(u.dataId).values,f=t.data.get(p.dataId).values,[m,h]=_y(d,f,o,s,i,a,c,l);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(p.shape,"int32",h)]}var t3={kernelName:Rl,backendName:"cpu",kernelFunc:Noe};T();function Doe(n){let{inputs:e,backend:t,attrs:r}=n,{skipEmpty:o}=r,{input:s,delimiter:i}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values[0],[l,u,p]=Ay(a,c,o),d=u.length;return[t.makeTensorInfo([d,2],"int32",l),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(p))]}var n3={kernelName:Fl,backendName:"cpu",kernelFunc:Doe};T();function koe(n){let{inputs:e,backend:t,attrs:r}=n,{numBuckets:o}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=t.data.get(s.dataId).values,a=Ry(i,o);return t.makeTensorInfo(s.shape,"int32",a)}var r3={kernelName:Ml,backendName:"cpu",kernelFunc:koe};T();var _oe=he("Tan",n=>Math.tan(n)),o3={kernelName:"Tan",backendName:"cpu",kernelFunc:_oe};T();var Aoe=he(Bi,n=>Math.tanh(n)),s3={kernelName:Bi,backendName:"cpu",kernelFunc:Aoe};T();function Roe(n){let{inputs:e,backend:t}=n,{tensor:r,indices:o,updates:s}=e,{sliceRank:i,numUpdates:a,sliceSize:c,strides:l,outputSize:u}=S.calculateShapes(s,o,r.shape),p=!1,d=t.bufferSync(o),f=t.bufferSync(s),m=t.bufferSync(r),h=so(d,f,r.shape,u,c,a,i,l,m,p);return t.makeTensorInfo(r.shape,h.dtype,h.values)}var i3={kernelName:yl,backendName:"cpu",kernelFunc:Roe};T();function Foe(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{reps:s}=r;X(o,"tile");let i=Fy(t.bufferSync(o),s);return t.makeTensorInfo(i.shape,i.dtype,i.values)}var a3={kernelName:rs,backendName:"cpu",kernelFunc:Foe};T();function Moe(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{k:s,sorted:i}=r;X(o,"topk");let a=t.data.get(o.dataId).values,[c,l]=My(a,o.shape,o.dtype,s,i);return[t.makeTensorInfo(c.shape,c.dtype,c.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}var c3={kernelName:Pl,backendName:"cpu",kernelFunc:Moe};T();function Ooe(n){let{inputs:e,attrs:t,backend:r}=n,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:c,outputShape:l}=t,[u,p,d,f]=o.shape,[m,h]=l??[p,d],g=[u,m,h,f],x=y.computeStrides(o.shape),v=x[0],w=x[1],I=x[2],_=y.computeStrides(g),A=_[0],R=_[1],F=_[2],P=y.getTypedArrayFromDType(o.dtype,y.sizeFromShape(g));P.fill(c);let L=r.data.get(o.dataId).values,V=r.data.get(s.dataId).values;for(let H=0;H<u;++H){let j=s.shape[0]===1?V:V.subarray(H*8,H*8+8);for(let W=0;W<m;++W)for(let Y=0;Y<h;++Y)for(let Z=0;Z<f;++Z){let K,Q=j[6]*Y+j[7]*W+1;if(Q===0)continue;let te=(j[0]*Y+j[1]*W+j[2])/Q,ne=(j[3]*Y+j[4]*W+j[5])/Q,se=l3(te,d,a),re=l3(ne,p,a);switch(i){case"nearest":K=Voe(L,p,d,v,w,I,H,re,se,Z,c);break;case"bilinear":K=Uoe(L,p,d,v,w,I,H,re,se,Z,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let ae=H*A+W*R+Y*F+Z;P[ae]=K}return r.makeTensorInfo(g,o.dtype,P)}return{dataId:r.write(P,g,o.dtype),shape:o.shape,dtype:o.dtype}}var u3={kernelName:Ll,backendName:"cpu",kernelFunc:Ooe};function l3(n,e,t){switch(t){case"reflect":return $oe(n,e);case"wrap":return Poe(n,e);case"nearest":return Boe(n,e);case"constant":default:return Loe(n,e)}}function $oe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{let r=2*e;t<r&&(t=r*Math.trunc(-t/r)+t),t=t<-e?t+r:-t-1}else if(t>e-1)if(e<=1)t=0;else{let r=2*e;t-=r*Math.trunc(t/r),t>=e&&(t=r-t-1)}return y.clamp(0,t,e-1)}function Poe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{let r=e-1;t+=e*(Math.trunc(-t/r)+1)}else if(t>e-1)if(e<=1)t=0;else{let r=e-1;t-=e*Math.trunc(t/r)}return y.clamp(0,t,e-1)}function Loe(n,e){return n}function Boe(n,e){return y.clamp(0,n,e-1)}function ch(n,e,t,r,o,s,i,a,c,l,u){let p=i*r+a*o+c*s+l;return 0<=a&&a<e&&0<=c&&c<t?n[p]:u}function Voe(n,e,t,r,o,s,i,a,c,l,u){let p=Math.round(a),d=Math.round(c);return ch(n,e,t,r,o,s,i,p,d,l,u)}function Uoe(n,e,t,r,o,s,i,a,c,l,u){let p=Math.floor(a),d=Math.floor(c),f=p+1,m=d+1,h=(m-c)*ch(n,e,t,r,o,s,i,p,d,l,u)+(c-d)*ch(n,e,t,r,o,s,i,p,m,l,u),g=(m-c)*ch(n,e,t,r,o,s,i,f,d,l,u)+(c-d)*ch(n,e,t,r,o,s,i,f,m,l,u);return(f-a)*h+(a-p)*g}T();function zoe(n){let{inputs:e,attrs:t,backend:r}=n,{axis:o}=t,{x:s}=e;X(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:a,outputShape:c,indices:l}=Oy(i,o,s.shape,s.dtype);return[r.makeTensorInfo(c,s.dtype,a),r.makeTensorInfo([l.length],"int32",l)]}var p3={kernelName:Bl,backendName:"cpu",kernelFunc:zoe};T();function Hoe(n){let{inputs:e,backend:t,attrs:r}=n,{value:o}=e,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],c=new Array(i-1),l=0;for(let f=0;f<i;f++)f!==s&&(c[l++]=o.shape[f]);let u=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let d=new Array(a);for(let f=0;f<d.length;f++){u[s]=f;let m=kr({inputs:{x:o},backend:t,attrs:{begin:u,size:p}});d[f]=_e({inputs:{x:m},backend:t,attrs:{shape:c}}),t.disposeIntermediateTensorInfo(m)}return d}var d3={kernelName:Vl,backendName:"cpu",kernelFunc:Hoe};T();function Goe(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,segmentIds:s}=e,{numSegments:i}=r;X(o,"unsortedSegmentSum");let a=o.shape.length,c=s.shape.length,l=[],u=[],p=a-c,d=s;for(let m=0;m<p;++m){let h=ld({inputs:{input:d},backend:t,attrs:{dim:m+1}});d=h,u.push(h)}for(let m=0;m<i;++m){let h=y.createScalarValue(m,"int32"),g=t.makeTensorInfo([],"int32",h),x=lN({inputs:{a:g,b:d},backend:t}),v=Nr({inputs:{x},backend:t,attrs:{dtype:"float32"}}),w=bu({inputs:{a:v,b:o},backend:t}),I=Ns({inputs:{x:w},backend:t,attrs:{axis:0,keepDims:!1}});l.push(I),u.push(g),u.push(x),u.push(v),u.push(w),u.push(I)}let f=WN({inputs:l,backend:t,attrs:{axis:0}});return u.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}var f3={kernelName:Ul,backendName:"cpu",kernelFunc:Goe};var Woe=[LL,jP,BL,VL,ZP,UL,zL,HL,GL,WL,jL,qL,KL,XL,YL,QL,JL,eB,tB,PL,nB,rB,oB,QP,sB,YP,JP,iB,qP,aB,lB,uB,pB,dB,fB,mB,hB,gB,xB,yB,vB,bB,CB,wB,IB,EB,TB,SB,NB,DB,kB,_B,RB,AL,FB,eL,MB,tL,OB,nL,$B,PB,LB,rL,oL,BB,VB,UB,zB,sL,iL,KP,HB,cB,GB,WB,jB,RL,aL,cL,qB,lL,KB,XB,YB,ZB,QB,JB,eV,uL,tV,nV,rV,oV,iV,aV,cV,pL,lV,uV,fV,dL,fL,mV,hV,gV,mL,xV,bV,CV,By,wV,FL,gL,IV,EV,TV,SV,XP,sh,NV,ML,OL,$L,DV,kV,_V,AV,RV,FV,MV,CL,OV,PV,LV,BV,IL,VV,UV,zV,EL,pV,GV,WV,jV,qV,KV,XV,YV,ZV,SL,QV,NL,DL,JV,e3,t3,n3,r3,kL,AB,o3,s3,i3,a3,c3,u3,hL,p3,d3,f3,yV];for(let n of Woe)Dp(n);T();T();T();T();var wu={},Vy={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function m3(n,e){wu[n]=e}function Yn(n,e){if(!(n in wu)||e!=null){let r=qoe(n,e);if(r!==null)wu[n]=r;else return console.log("Could not get context for WebGL version",n),null}let t=wu[n];return t==null||t.isContextLost()?(delete wu[n],Yn(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),wu[n])}function joe(n){if(!O().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function qoe(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=e??joe(n);return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete wu[n]},!1),O().getBool("SOFTWARE_WEBGL_ENABLED")&&(Vy.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Vy)||t.getContext("experimental-webgl",Vy):t.getContext("webgl2",Vy)}T();var Iu=(function(n){return n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",n})(Iu||{}),vn=(function(n){return n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",n})(vn||{}),un=(function(n){return n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",n})(un||{});function Eu(n,e){return[e,n]}function h3(n,e){return n*e}function lh(n){let e=y.sizeFromShape(n),t=Math.ceil(e/4);return y.sizeToSquarishShape(t)}function zo(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function g3(n,e){let[t,r]=zo(n,e);return t*r*4}function uh(n,e){let t=n,r,o,s,i,a,c,l,u,p,d;return O().getNumber("WEBGL_VERSION")===2?(r=t.R32F,o=t.R16F,s=t.RGBA16F,i=t.RGBA32F,a=t.RED,l=4,u=1,p=t.HALF_FLOAT,d=t.FLOAT,c=t.RGBA8):(r=n.RGBA,o=n.RGBA,s=n.RGBA,i=t.RGBA,a=n.RGBA,l=4,u=4,p=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,c=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:p,textureTypeFloat:d}}function ce(n,e){let t=e();return O().getBool("DEBUG")&&Koe(n),t}function Koe(n){let e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+Zoe(n,e))}var Xoe=596e-10,Yoe=65504;function x3(n){return!!(O().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Xoe<Math.abs(n)&&Math.abs(n)<Yoe)}function Zoe(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function ph(n,e){return Ds(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function y3(n,e){let t=Ds(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ce(n,()=>n.shaderSource(t,e)),ce(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function v3(n,e){let t=Ds(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ce(n,()=>n.shaderSource(t,e)),ce(n,()=>n.compileShader(t)),O().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw YN(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var Qoe=/ERROR: [0-9]+:([0-9]+):/g;function YN(n,e){let t=Qoe.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}let r=+t[1],o=n.split(`
`),s=o.length.toString().length+2,i=o.map((p,d)=>y.rightPad((d+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let c=i.slice(0,r-1),l=i.slice(r-1,r),u=i.slice(r);console.log(c.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${y.rightPad(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function b3(n){return Ds(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function C3(n,e){if(ce(n,()=>n.linkProgram(e)),!O().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function zy(n,e){if(ce(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function w3(n,e){let t=Ds(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ce(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),ce(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function I3(n,e){let t=Ds(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ce(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),ce(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function E3(n){return Ds(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function T3(n,e){let t=O().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){let r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){let r=`[${n}x${e}]`,o=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+o+".")}}function S3(n){return Ds(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function ZN(n,e,t,r,o,s,i){let a=n.getAttribLocation(e,t);return a===-1?!1:(ce(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),ce(n,()=>n.vertexAttribPointer(a,o,n.FLOAT,!1,s,i)),ce(n,()=>n.enableVertexAttribArray(a)),!0)}function Joe(n,e,t){tse(n,t),ce(n,()=>n.activeTexture(n.TEXTURE0+t)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function N3(n,e,t){return Ds(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function D3(n,e,t){return n.getUniformLocation(e,t)}function k3(n,e,t,r){ce(n,()=>Joe(n,e,r)),ce(n,()=>n.uniform1i(t,r))}function Hy(n,e,t){ce(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ce(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function QN(n,e){ce(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ce(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function dh(n){let e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+ese(n,e))}function ese(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Ds(n,e,t){let r=ce(n,()=>e());if(r==null)throw new Error(t);return r}function tse(n,e){let t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){let o=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${o}.`)}}function fa(n,e=2){return y.sizeFromShape(n.slice(0,n.length-e))}function ma(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function fh(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[fa(n),...ma(n)]),e}function _3(n,e=!1){let t=O().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=O().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&O().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),e&&(t=t*2,r=r*2,n=n.map((a,c)=>c>=n.length-2?y.nearestLargerEven(n[c]):n[c]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=y.squeezeShape(n).newShape);let o=y.sizeFromShape(n),s=null;n.length<=1&&o<=t?s=[1,o]:n.length===2&&n[0]<=t&&n[1]<=t?s=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?s=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?s=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?s=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(s=[n[0],n[1]*n[2]*n[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(s==null||i)if(e){let a=fa(n),c=2,l=2;n.length&&([c,l]=ma(n)),o=a*(c/2)*(l/2),s=y.sizeToSquarishShape(o).map(u=>u*2)}else s=y.sizeToSquarishShape(o);return s}function Uy(n){return n%2===0}function Tu(n,e){if(n=n.slice(-2),e=e.slice(-2),y.arraysEqual(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){let t=n[n.length-1],r=e[e.length-1];if(t===r||Uy(t)&&Uy(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Uy(n[0])&&Uy(e[0])}var qN,KN;function A3(n){if(qN==null){let e=Yn(n);qN=e.getParameter(e.MAX_TEXTURE_SIZE)}return qN}function R3(n){if(KN==null){let e=Yn(n);KN=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,KN)}function F3(n){if(n===0)return 0;let e,t=Yn(n);return dr(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:dr(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function dr(n,e){return n.getExtension(e)!=null}function JN(n){try{if(Yn(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function M3(n){if(n===0)return!1;let e=Yn(n);if(n===1){if(!dr(e,"OES_texture_float"))return!1}else if(!dr(e,"EXT_color_buffer_float"))return!1;return XN(e)}function O3(n){if(n===0)return!1;let e=Yn(n);if(n===1){if(!dr(e,"OES_texture_float")||!dr(e,"WEBGL_color_buffer_float"))return!1}else{if(dr(e,"EXT_color_buffer_float"))return XN(e);let r="EXT_color_buffer_half_float";if(dr(e,r)){let o=e.getExtension(r);return nse(e,o)}return!1}return XN(e)}function XN(n){let e=uh(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);let s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);let i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(s),i}function nse(n,e){let t=uh(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);let i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);let a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(i),a}function $3(n){return n!==2?!1:Yn(n).fenceSync!=null}function Ho(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}var fe=O();fe.registerFlag("HAS_WEBGL",()=>fe.getNumber("WEBGL_VERSION")>0);fe.registerFlag("WEBGL_VERSION",()=>JN(2)?2:JN(1)?1:0);fe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);fe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>fe.get("WEBGL_VERSION")===2);fe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);fe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);fe.registerFlag("WEBGL_PACK",()=>fe.getBool("HAS_WEBGL"));fe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_CLIP",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_REDUCE",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_LAZILY_UNPACK",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_CONV_IM2COL",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>A3(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>R3(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let n=fe.getNumber("WEBGL_VERSION");return n===0?0:F3(n)});fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>fe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ss.isMobile());fe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>M3(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>fe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:fe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));fe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>O3(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>$3(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>fe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);fe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});fe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>ss.isMobile()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});fe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);fe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);fe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);fe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);fe.registerFlag("WEBGL_EXP_CONV",()=>!1);fe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>fe.getBool("IS_TEST"));fe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);fe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);fe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);fe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);T();T();function xt(){let n,e,t,r,o,s,i,a,c,l;return O().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=O().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:c,defineRound:l}}T();T();T();function io(n,e,t="index"){let r=y.computeStrides(e);return r.map((o,s)=>{let i=`int ${n[s]} = ${t} / ${o}`,a=s===r.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * ${o}`:`index -= ${n[s]} * ${o}`;return`${i}; ${a};`}).join("")}function Su(n,e,t="index"){let r=y.computeStrides(e);return r.map((o,s)=>{let i=`int ${n[s]} = ${t} / outShapeStrides[${s}]`,a=s===r.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * outShapeStrides[${s}]`:`index -= ${n[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function rse(n,e){let t=n.length,r=n.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=r[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${r[s+1]})`;return o}function P3(n,e,t="index"){let r=n.map((s,i)=>i),o=rse(r,e);return o.map((s,i)=>{let a=`int ${n[i]} = ${t} / ${o[i]}`,c=i===o.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${o[i]}`:`index -= ${n[i]} * ${o[i]}`;return`${a}; ${c};`}).join("")}function ud(n){let e=y.computeStrides(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function pd(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Wy=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:L3}=S;function B3(n,e,t){let r=[];if(n.forEach(f=>{let m=y.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${m>1?`[${m}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),t.enableShapeUniforms){let{uniformShape:h}=jy(t.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(h.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let o=r.join(`
`),s=n.map(f=>ose(f,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=e.texShape,a=xt(),c=ase(a),l,u,p=use(a);return e.isPacked?(l=sse(e.logicalShape,i,t.enableShapeUniforms),u=lse(a)):(l=ise(e.logicalShape,i,t.enableShapeUniforms),u=cse(a)),t.packedInputs&&(p+=mse),[p,c,u,o,l,s,t.userCode].join(`
`)}function fd(n,e=!1){let t=n.shapeInfo.logicalShape;switch(t.length){case 0:return Sse(n,e);case 1:return Dse(n,e);case 2:return _se(n,e);case 3:return Rse(n,e);case 4:return Mse(n,e);case 5:return Ose(n);case 6:return $se(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function V3(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return Tse(n);case 1:return Nse(n,e);case 2:return kse(n,e);case 3:return Ase(n,e);default:return Fse(n,e)}}function ose(n,e,t=!1,r){let o="";t?o+=V3(n,r):o+=fd(n,r);let s=n.shapeInfo.logicalShape,i=e.logicalShape;return s.length<=i.length&&(t?o+=Pse(n,e):o+=Lse(n,e)),o}function sse(n,e,t){switch(n.length){case 0:return U3();case 1:return hse(n,e,t);case 2:return Ise(n,e,t);case 3:return xse(n,e,t);default:return vse(n,e,t)}}function ise(n,e,t){switch(n.length){case 0:return U3();case 1:return gse(n,e,t);case 2:return Ese(n,e,t);case 3:return yse(n,e,t);case 4:return bse(n,e,t);case 5:return Cse(n,e);case 6:return wse(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function ase(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function cse(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function lse(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function use(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${pse}
    ${dse}
    ${fse}
  `}var pse=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,dse=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,fse=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,mse=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function U3(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function hse(n,e,t){let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function gse(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function xse(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(n[2]/2),s=o*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function yse(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Su(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;let r=io(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function vse(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(n[n.length-1]/2),s=o*Math.ceil(n[n.length-2]/2),i=s,a="",c="b, r, c";for(let l=2;l<n.length-1;l++)i*=n[n.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,c=`b${l}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${n.length}(${c});
    }
  `}function bse(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Su(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;let r=io(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function Cse(n,e){let t=io(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function wse(n,e){let t=io(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Ise(n,e,t){let r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(y.arraysEqual(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let o=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function Ese(n,e,t){return y.arraysEqual(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Nu(n){return`offset${n}`}function Tse(n){let e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=xt();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function Sse(n,e){let t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;let[o,s]=n.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let i=Nu(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;let[a,c]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${c}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function Nse(n,e){let t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=n.shapeInfo.texShape,s=xt();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function Dse(n,e){let t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${md(n)}
      }
    `;let o=n.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=Nu(t);return i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function kse(n,e){let t=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,i=s[0],a=s[1],c=xt();if(s!=null&&y.arraysEqual(t,s))return e?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${c.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${c.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `}function _se(n,e){let t=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape;if(s!=null&&y.arraysEqual(t,s)){if(e)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let d=s[0],f=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:a}=y.squeezeShape(t),c=i;if(c.length<t.length){let d=hd(n,c),f=["row","col"];return`
      ${fd(d,e)}
      float ${o}(int row, int col) {
        return ${o}(${gd(f,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${md(n)}
      }
    `;let l=s[0],u=s[1],p=Nu(r);return u===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${r}, uv);
    }
  `:l===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${p};
    vec2 uv = uvFromFlat(${l}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function Ase(n,e){let t=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let d=t.slice(1),f=[1,2],m=hd(n,d),h=["b","row","col"];return`
        ${V3(m,e)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${gd(h,f)});
        }
      `}let a=xt();if(e)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;let c=i[0],l=i[1],u=Math.ceil(t[2]/2),p=u*Math.ceil(t[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${l}, ${p}, ${u}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function Rse(n,e){let t=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t[1]*t[2],i=t[2],{newShape:a,keptDims:c}=y.squeezeShape(t),l=a;if(l.length<t.length){let h=hd(n,l),g=["row","col","depth"];return`
        ${fd(h,e)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${gd(g,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${md(n)}
      }
    `;let u=n.shapeInfo.texShape,p=u[0],d=u[1],f=n.shapeInfo.flatOffset;if(d===s&&f==null)return e?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===i&&f==null)return e?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;let m=Nu(r);return e?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${m};
        vec2 uv = uvFromFlat(${p}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Fse(n,e){let t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=xt();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);
    }
  `;let s=n.shapeInfo.logicalShape,i=s.length,a=n.shapeInfo.texShape,c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=c[0],u=c[1],p=Math.ceil(s[i-1]/2),d=p*Math.ceil(s[i-2]/2),f="int b, int row, int col",m=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let h=2;h<i-1;h++)f=`int b${h}, `+f,d*=s[i-h-1],m=`b${h} * ${d} + `+m;return`
    vec4 ${r}(${f}) {
      int index = ${m};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${l});
      return ${o.texture2D}(${t}, uv);
    }
  `}function Mse(n,e){let t=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t[3],i=t[2]*s,a=t[1]*i,{newShape:c,keptDims:l}=y.squeezeShape(t);if(c.length<t.length){let v=hd(n,c),w=["row","col","depth","depth2"];return`
      ${fd(v,e)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${gd(w,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${md(n)}
      }
    `;let u=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,d=p[0],f=p[1],m=`int stride2 = ${r}Shape[3];`,h=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===a&&u==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${m}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(f===s&&u==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;let x=Nu(r);return e?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${x});
      return sampleTexture(${r}, uv);
    }
  `}function Ose(n){let e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e[4],s=e[3]*o,i=e[2]*s,a=e[1]*i,{newShape:c,keptDims:l}=y.squeezeShape(e);if(c.length<e.length){let h=hd(n,c),g=["row","col","depth","depth2","depth3"];return`
      ${fd(h)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${gd(g,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${md(n)}
      }
    `;let u=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,d=p[0],f=p[1];if(f===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;let m=Nu(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${m};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function $se(n){let e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:s}=y.squeezeShape(e);if(o.length<e.length){let g=hd(n,o),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${fd(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${gd(x,s)});
      }
    `}let i=e[5],a=e[4]*i,c=e[3]*a,l=e[2]*c,u=e[1]*l;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${l}, ${c}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${md(n)}
      }
    `;let p=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,f=d[0],m=d[1];if(m===u&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${c}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(m===i&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;let h=Nu(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${l} + depth * ${c} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${t}, uv);
    }
  `}function md(n){let e=n.name,t=y.sizeFromShape(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Pse(n,e){let t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),o="get"+r+"AtOutCoords",s=n.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=L3(n.shapeInfo.logicalShape,e.logicalShape),c=ve(i),l=i-s,u,p=["x","y","z","w","u","v"];s===0?u="":i<2&&a.length>=1?u="coords = 0;":u=a.map(v=>`coords.${p[v+l]} = 0;`).join(`
`);let d="";i<2&&s>0?d="coords":d=n.shapeInfo.logicalShape.map((v,w)=>`coords.${p[w+l]}`).join(", ");let f="return outputValue;",h=y.sizeFromShape(n.shapeInfo.logicalShape)===1,x=y.sizeFromShape(e.logicalShape)===1;if(s===1&&!h&&!x)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!x)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){let v=s-2,w=s-1;a.indexOf(v)>-1&&a.indexOf(w)>-1?f="return vec4(outputValue.x);":a.indexOf(v)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${c} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${d});
      ${f}
    }
  `}function Lse(n,e){let t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),o="get"+r+"AtOutCoords",s=e.texShape,i=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,c=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===c&&n.shapeInfo.flatOffset==null&&y.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${t}, resultUV);
      }
    `;let l=ve(c),u=L3(n.shapeInfo.logicalShape,e.logicalShape),p=c-a,d,f=["x","y","z","w","u","v"];a===0?d="":c<2&&u.length>=1?d="coords = 0;":d=u.map(h=>`coords.${f[h+p]} = 0;`).join(`
`);let m="";return c<2&&a>0?m="coords":m=n.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${d}
      return get${r}(${m});
    }
  `}function ve(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function jy(n,e,t){let{newShape:r,keptDims:o}=y.squeezeShape(e),s=e.length,i=n&&s===3&&e[0]===1,a=i?e.slice(1):r,c=!n&&s>1&&!y.arraysEqual(e,t)&&r.length<s||i;return{useSqueezeShape:c,uniformShape:c?a:e,keptDims:o}}function hd(n,e){let t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function gd(n,e){return e.map(t=>n[t]).join(", ")}function H3(n,e,t,r){let o=t.map((u,p)=>{let d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[p],shapeInfo:d}}),s=o.map(u=>u.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=B3(o,i,e),c=v3(n.gl,a),l=n.createProgram(c);return O().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:c,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(l),Object.assign({program:e,fragmentShader:c,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i},eD(n,e,l)))}function eD(n,e,t){let r=[],o=[],s,i,a,c=null,l=null;l=n.getUniformLocation(t,"NAN",!1),O().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(t,"INFINITY",!1));let u=!1;for(let p of e.variableNames){let d={name:p,uniform:n.getUniformLocation(t,p,u),offset:n.getUniformLocation(t,`offset${p}`,u)};e.enableShapeUniforms&&(d.shape=n.getUniformLocation(t,`${p}Shape`,u),d.texShape=n.getUniformLocation(t,`${p}TexShape`,u)),r.push(d)}if(e.enableShapeUniforms&&(s=n.getUniformLocation(t,"outShape",u),a=n.getUniformLocation(t,"outShapeStrides",u),i=n.getUniformLocation(t,"outTexShape",u)),e.customUniforms)for(let p of e.customUniforms)o.push(n.getUniformLocation(t,p.name,u));return{variablesLocations:r,customUniformLocations:o,infLoc:c,nanLoc:l,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:i}}function z3(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{let o=t.logicalShape,s=e[r],i=s.shape;if(!y.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(t.isUniform&&s.isUniform)return;let a=t.texShape,c=s.isUniform?null:s.texData.texShape;if(!y.arraysEqual(a,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${c} must match`)})}function G3(n,e,t,r,o){e.program.enableShapeUniforms||(z3(e.inShapeInfos,t),z3([e.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):n.setOutputMatrixTexture(s.texture,i[0],i[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),O().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let c=0;c<t.length;++c){let l=t[c],{uniform:u,offset:p,shape:d,texShape:f}=e.variablesLocations[c];if(d){let{uniformShape:m}=jy(e.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(d,new Int32Array(m));break;case 2:n.gl.uniform2iv(d,new Int32Array(m));break;case 3:n.gl.uniform3iv(d,new Int32Array(m));break;case 4:n.gl.uniform4iv(d,new Int32Array(m));break;default:break}}if(f&&n.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),u!=null){if(l.isUniform){if(y.sizeFromShape(l.shape)<2)n.gl.uniform1f(u,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(u,m)}continue}l.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,u,c)}}let a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape));break;default:break}if(e.outShapeStridesLocation){let c=y.computeStrides(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(c));break;default:break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&o)for(let c=0;c<e.program.customUniforms.length;++c){let l=e.program.customUniforms[c],u=e.customUniformLocations[c],p=o[c];if(l.type==="float")n.gl.uniform1fv(u,p);else if(l.type==="vec2")n.gl.uniform2fv(u,p);else if(l.type==="vec3")n.gl.uniform3fv(u,p);else if(l.type==="vec4")n.gl.uniform4fv(u,p);else if(l.type==="int")n.gl.uniform1iv(u,p);else if(l.type==="ivec2")n.gl.uniform2iv(u,p);else if(l.type==="ivec3")n.gl.uniform3iv(u,p);else if(l.type==="ivec4")n.gl.uniform4iv(u,p);else throw Error(`uniform type ${l.type} is not supported yet.`)}n.executeProgram()}function W3(n,e,t){let r="";e.concat(t).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){let c=i.texData.texShape,{useSqueezeShape:l,uniformShape:u,keptDims:p}=jy(n.packedInputs,i.shape,c),d="",f="",m="";if(u.length===1&&n.packedInputs){let _=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];d=`${_[0]>1}_${_[1]>1}`}else if(u.length===2&&!n.packedInputs)f=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){let _=y.computeStrides(u);m=`${_[0]===c[1]}_${_[_.length-1]===c[1]}`}let h=i.shape.length,g=u.length===2&&y.arraysEqual(i.shape,c),x=y.sizeFromShape(i.shape)===1,v=S.getBroadcastDims(i.shape,t.shape),w=!n.packedInputs&&h===t.shape.length&&y.arraysEqual(c,t.texData.texShape),I=n.packedInputs||u.length>2?"":`${c[0]>1}_${c[1]>1}`;r+=`${h}_${w}_${l?p:""}_${u.length}_${x}_${v}_${g}_${d}_${f}_${m}_${I}_${a}`}else{let c=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${c}_${a}`}});let o=n.userCode,s=n.constructor.name;return s+="_"+r+"_"+o+`${O().getNumber("WEBGL_VERSION")}`,s}function Ye(n){return O().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}var qy=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Iu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=xt();this.outputShape=e,this.enableShapeUniforms=Ye(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Su(["r","c","d"],e):io(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}};var Ky=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Iu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=xt();this.outputShape=e,this.enableShapeUniforms=Ye(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Su(["r","c","d"],e):io(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}};var Xy=class{constructor(e){this.variableNames=["A"],this.outTexUsage=vn.DOWNLOAD;let t=xt();this.outputShape=e,this.userCode=`
      ${Wy}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}};var Yy=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=vn.DOWNLOAD;let t=xt();this.outputShape=e,this.userCode=`
      ${Wy}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}};var Use={R:0,G:1,B:2,A:3},mh=class{constructor(e,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let o=xt();this.outputShape=e,this.enableShapeUniforms=Ye(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++){let c=r[a];i+=`
          if(offset == ${a}) {
            result = values[${Use[c]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?pd():ud(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${i}
        }
        ${o.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var Zy=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=xt();this.outputShape=e,this.enableShapeUniforms=Ye(this.outputShape.length);let o="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let c=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?pd():ud(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${r.output} = ${s};
        }
    `}};T();T();function j3(n){let e=xt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return y3(n,t)}function q3(n){let e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return w3(n,e)}function K3(n){let e=new Uint16Array([0,1,2,2,1,3]);return I3(n,e)}function hh(n,e,t,r,o,s){T3(e,t);let i=E3(n),a=n.TEXTURE_2D;return ce(n,()=>n.bindTexture(a,i)),ce(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ce(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ce(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),ce(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),O().getNumber("WEBGL_VERSION")===1?ce(n,()=>n.texImage2D(a,0,r,e,t,0,o,s,null)):ce(n,()=>n.texStorage2D(a,1,r,e,t)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[t,e]}}function tD(n){return n.internalFormatFloat}function X3(n,e,t,r){let[o,s]=Eu(e,t);return hh(n,o,s,tD(r),r.textureFormatFloat,n.FLOAT)}function nD(n){return n.internalFormatHalfFloat}function Y3(n,e,t,r){let[o,s]=Eu(e,t);return hh(n,o,s,nD(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function rD(n){return n.downloadTextureFormat}function Z3(n,e,t,r){let[o,s]=Eu(e,t);return hh(n,o,s,rD(r),n.RGBA,n.UNSIGNED_BYTE)}function oD(n){return n.internalFormatPackedFloat}function Q3(n,e,t,r){let[o,s]=zo(e,t);return hh(n,o,s,oD(r),n.RGBA,n.FLOAT)}function sD(n){return n.internalFormatPackedHalfFloat}function J3(n,e,t,r){let[o,s]=zo(e,t);return hh(n,o,s,sD(r),n.RGBA,r.textureTypeHalfFloat)}function eU(n,e,t){return ce(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),ZN(n,e,"clipSpacePos",t,3,20,0)&&ZN(n,e,"uv",t,2,20,12)}function tU(n,e,t,r,o,s){ce(n,()=>n.bindTexture(n.TEXTURE_2D,e));let i,a,c;o instanceof Uint8Array?(i=new Uint8Array(t*r*4),a=n.UNSIGNED_BYTE,c=n.RGBA):(i=new Float32Array(t*r*4),a=n.FLOAT,c=s.internalFormatPackedFloat),i.set(o),O().getNumber("WEBGL_VERSION")===2?ce(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,a,i)):ce(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,t,r,0,n.RGBA,a,i)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function nU(n,e,t){ce(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?O().getNumber("WEBGL_VERSION")===2?ce(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):ce(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):O().getNumber("WEBGL_VERSION")===2?ce(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):ce(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function rU(n,e,t,r){let o=n.createBuffer();ce(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,o));let a=4*4*e*t;return ce(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),ce(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),ce(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),o}function oU(n,e,t){let r=n,o=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function sU(n,e,t,r){let[o,s]=Eu(e,t),i=4,a=new Uint8Array(h3(e*t,i));return ce(n,()=>n.readPixels(0,0,o,s,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function iU(n,e,t,r,o,s,i,a){let c=n,l=new Float32Array(g3(s,i));return c.bindBuffer(c.PIXEL_PACK_BUFFER,e),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}function aU(n,e,t){let r=new Float32Array(e*t*4);return ce(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}var xd=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=O().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,m3(t,e)):this.gl=Yn(t),e=this.gl,O().getNumber("WEBGL_VERSION")===2){let s=e;this.createVertexArray=()=>ce(s,()=>s.createVertexArray()),this.bindVertexArray=i=>ce(s,()=>s.bindVertexArray(i)),this.deleteVertexArray=i=>ce(s,()=>s.deleteVertexArray(i)),this.getVertexArray=()=>ce(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){let s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ce(e,()=>s.createVertexArrayOES()),this.bindVertexArray=i=>ce(e,()=>s.bindVertexArrayOES(i)),this.deleteVertexArray=i=>ce(e,()=>s.deleteVertexArrayOES(i)),this.getVertexArray=()=>ce(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),O().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=ph(this.gl,s),dr(this.gl,i))this.textureHalfFloatExtension=ph(this.gl,i);else if(O().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),dr(this.gl,o))this.colorBufferHalfFloatExtension=ph(this.gl,o);else if(O().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",dr(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(dr(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=q3(this.gl),this.indexBuffer=K3(this.gl),this.framebuffer=S3(this.gl),this.textureConfig=uh(this.gl,this.textureHalfFloatExtension)}get debug(){return O().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;ce(e,()=>e.finish()),ce(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ce(e,()=>e.deleteFramebuffer(this.framebuffer)),ce(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ce(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ce(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),X3(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Y3(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Z3(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),nU(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,o){this.throwIfDisposed(),tU(this.gl,e,t,r,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),J3(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Q3(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(QN(this.gl,this.framebuffer),this.outputTexture=null),ce(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>sU(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,o,s,i){return iU(this.gl,e,t,r,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return oU(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);let o=rU(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(O().getBool("WEBGL_FENCE_API_ENABLED")){let o=e,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},t=s}else O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>aU(this.gl,t,r))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=j3(t));let r=b3(t);ce(t,()=>t.attachShader(r,this.vertexShader)),ce(t,()=>t.attachShader(r,e)),C3(t,r);let o=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&zy(t,o),o}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;ce(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),eU(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(ce(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&zy(this.gl,this.program),ce(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?N3(this.gl,e,t):D3(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ce(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),k3(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();let[o,s]=zo(t,r);this.setOutputMatrixTextureDriver(e,o,s)}setOutputMatrixWriteRegion(e,t,r,o){this.setOutputMatrixWriteRegionDriver(r,e,o,t)}setOutputPackedMatrixWriteRegion(e,t,r,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&zy(this.gl,this.program),dh(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ce(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ce(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ph(this.gl,O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(o.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await y.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{let r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let r=this.getQueryTimerExtensionWebGL1(),o=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=Hse(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in O().platform&&(r=O().platform.setTimeoutCustom.bind(O().platform)),y.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Hy(this.gl,e,this.framebuffer),this.debug&&dh(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Hy(this.gl,this.outputTexture,this.framebuffer),this.debug&&dh(this.gl)):QN(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();let o=this.gl;Hy(o,e,this.framebuffer),this.debug&&dh(o),this.outputTexture=e,ce(o,()=>o.viewport(0,0,t,r)),ce(o,()=>o.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,o){this.throwIfDisposed(),ce(this.gl,()=>this.gl.scissor(e,t,r,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Hse(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}var{addImpl:cU,bincountImpl:Qy,bincountReduceImpl:lU,bitwiseAndImpl:uU,castImpl:pU,ceilImpl:dU,concatImpl:fU,equalImpl:mU,expImpl:hU,expm1Impl:gU,floorImpl:xU,gatherNdImpl:yU,gatherV2Impl:vU,greaterImpl:bU,greaterEqualImpl:CU,lessImpl:wU,lessEqualImpl:IU,linSpaceImpl:EU,logImpl:TU,maxImpl:SU,maximumImpl:NU,minimumImpl:DU,multiplyImpl:kU,negImpl:_U,notEqualImpl:AU,prodImpl:RU,raggedGatherImpl:FU,raggedRangeImpl:MU,raggedTensorToTensorImpl:OU,rangeImpl:$U,rsqrtImpl:PU,scatterImpl:LU,sigmoidImpl:BU,simpleAbsImpl:Jy,sliceImpl:VU,sparseFillEmptyRowsImpl:UU,sparseReshapeImpl:zU,sparseSegmentReductionImpl:ev,sqrtImpl:HU,staticRegexReplaceImpl:GU,stridedSliceImpl:WU,stringNGramsImpl:jU,stringSplitImpl:qU,stringToHashBucketFastImpl:KU,subImpl:XU,tileImpl:YU,topKImpl:ZU,transposeImpl:Du,uniqueImpl:QU}=FN;function iD(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function It(n,e){return e===1?[n]:iD(n,e)}function JU(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}var tv=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Ye(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=It("rc",this.rank),r=ve(this.rank),o=this.getOutOfBoundsCondition(t),s=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){let s=`${r===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${e[e.length-1-i]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${o};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}};var yd=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Ye(this.outputShape.length);let r="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),r+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Gse(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?pd():ud(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}};function Gse(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?P3(["r","c","d"],"inputShape"):io(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}T();var nv=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,r){let o=t4(t,r),s=n4(e,o,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=e4(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let c=this.freeTextures[s].pop();return this.usedTextures[s].push(c),c}let a;return o===un.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===un.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===un.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===un.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===un.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,r,o){if(this.freeTextures==null)return;let s=t4(r,o),i=n4(t,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=e4(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),c=O().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[i],u=l&&l.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Wse(n,e){let t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function e4(n,e,t,r,o){let s=jse(e,r),i;if(o){let[c,l]=zo(n[0],n[1]);i=c*l}else{let[c,l]=Eu(n[0],n[1]);i=c*l}let a=Wse(t,s);return i*a}function jse(n,e){switch(n){case un.PACKED_2X2_FLOAT32:return oD(e);case un.PACKED_2X2_FLOAT16:return sD(e);case un.UNPACKED_FLOAT32:return tD(e);case un.UNPACKED_FLOAT16:return nD(e);case un.PACKED_4X1_UNSIGNED_BYTE:return rD(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function qse(n){return O().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?un.PACKED_2X2_FLOAT32:un.UNPACKED_FLOAT32:n?un.PACKED_2X2_FLOAT16:un.UNPACKED_FLOAT16}function t4(n,e){if(n===vn.UPLOAD)return un.PACKED_2X2_FLOAT32;if(n===vn.RENDER||n==null)return qse(e);if(n===vn.DOWNLOAD||n===vn.PIXELS)return un.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function n4(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}var en=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Ye(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Mt="if (isnan(x)) return x;",r4="return x;",aD="return abs(x);";var o4="return (x >= 0.0) ? x : (exp(x) - 1.0);",s4=Mt+`
  return (x < 0.0) ? 0.0 : x;
`,i4=Mt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Go="return x;",a4="return 1.0 / (1.0 + exp(-1.0 * x));";var l4="return x;",u4=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,p4=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,d4=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,f4="return 1.0 / (1.0 + exp(-1.0 * x));",Pn=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Ye(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var rv=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Ye(this.outputShape.length);let t=e.length,r=It("rc",t),o=ve(t),s=JU(t,r),i=r.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var Xse=Jt.whereImpl,Yse=1e-7,Zse=1e-4,ov={};function Qse(n){return n in ov||(ov[n]={}),ov[n]}var Jse=O().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),eie=600;function tie(){return O().global.screen==null?1024:O().global.screen.height*O().global.screen.width*window.devicePixelRatio*eie/1024/1024}var m4=(()=>{class n extends To{nextDataId(){return n.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!O().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(t!=null){if(t instanceof xd)r=t;else{let o=Yn(O().getNumber("WEBGL_VERSION"),t);r=new xd(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let o=Yn(O().getNumber("WEBGL_VERSION"));r=new xd(o),this.binaryCache=Qse(O().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new nv(this.gpgpu),this.numMBBeforeWarning=tie(),this.texData=new js(this,lr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,r,o,s,i,a){let c=this.makeTensorInfo(r,o),l=this.texData.get(c.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[s,i]},l.texShape=[s,i];let u=fh(r),p=new mh(u,!1,a),d=this.runWebGLProgram(p,[c],o,[[s,i]]);return d.shape=r,l.texture=null,this.disposeIntermediateTensorInfo(c),d.dataId}write(t,r,o){if((O().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||O().getBool("DEBUG"))&&this.checkNumericalProblems(t),o==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:r,dtype:o,values:t,usage:vn.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let r=this.texData.get(t);r.refCount++}decRef(t){if(this.texData.has(t)){let r=this.texData.get(t);r.refCount--}}move(t,r,o,s,i){if(O().getBool("DEBUG")&&this.checkNumericalProblems(r),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:o,dtype:s,values:r,usage:vn.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let r=this.texData.get(t),{values:o,dtype:s,complexTensorInfos:i,slice:a,shape:c,isPacked:l}=r;if(a!=null){let f;l?f=new Pn(c,Go):f=new en(c,Go);let m=this.runWebGLProgram(f,[{dataId:t,shape:c,dtype:s}],s),h=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),h}if(o!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return o;let u=this.activeTimers!=null,p;u&&(p=y.now());let d;if(s==="complex64"){let f=this.readSync(i.real.dataId),m=this.readSync(i.imag.dataId);d=S.mergeRealAndImagArrays(f,m)}else d=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=y.now()-p),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){let h=this.pendingRead.get(t);return new Promise(g=>h.push(g))}let r=this.texData.get(t),{values:o,shape:s,slice:i,dtype:a,complexTensorInfos:c,isPacked:l}=r;if(i!=null){let h;l?h=new Pn(s,Go):h=new en(s,Go);let g=this.runWebGLProgram(h,[{dataId:t,shape:s,dtype:a}],a),x=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),x}if(o!=null)return this.convertAndCacheOnCPU(t);if(O().getBool("DEBUG")&&!O().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&O().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,p;if(a!=="complex64"&&O().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(t);let h=this.texData.get(p.dataId);u=this.gpgpu.createBufferFromTexture(h.texture.texture,...lh(s))}this.pendingRead.set(t,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(a==="complex64"){let h=await Promise.all([this.read(c.real.dataId),this.read(c.imag.dataId)]),g=h[0],x=h[1];d=S.mergeRealAndImagArrays(g,x)}else if(u==null)d=this.getValuesFromTexture(t);else{let h=y.sizeFromShape(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,h)}if(p!=null&&this.disposeIntermediateTensorInfo(p),u!=null){let h=this.gpgpu.gl;ce(h,()=>h.deleteBuffer(u))}let f=this.convertAndCacheOnCPU(t,d),m=this.pendingRead.get(t);return this.pendingRead.delete(t),m.forEach(h=>h(f)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&lr().removeDataId(t,this),this.pendingDeletes--),f}readToGPU(t,r={}){let o=this.texData.get(t),{values:s,shape:i,slice:a,dtype:c,isPacked:l,texture:u}=o;if(c==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let m;l?m=new Pn(i,Go):m=new en(i,Go);let h=this.runWebGLProgram(m,[{dataId:t,shape:i,dtype:c}],c),g=this.readToGPU(h,r);return this.disposeIntermediateTensorInfo(h),g}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(t,r.customTexShape),d=lr().makeTensorFromTensorInfo(p),f=this.texData.get(p.dataId);return Object.assign({tensorRef:d},f.texture)}bufferSync(t){let r=this.readSync(t.dataId);if(t.dtype==="string")try{let o=r.map(s=>y.decodeString(s));return le(t.shape,t.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return le(t.shape,t.dtype,r)}checkNumericalProblems(t){if(t!=null)for(let r=0;r<t.length;r++){let o=t[r];if(!x3(o))throw O().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:r,dtype:o,isPacked:s}=this.texData.get(t),i=y.sizeFromShape(r);if(O().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let f=this.decode(t),m=this.texData.get(f.dataId),h=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...lh(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),h}let a=O().getBool("WEBGL_PACK")&&s===!0,c=a?fh(r):r,l=a?new Yy(c):new Xy(c),u=this.runWebGLProgram(l,[{shape:c,dtype:o,dataId:t}],"float32"),p=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let r=this.activeTimers,o=[],s=!1;this.programTimersStack==null?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,t();let i=y.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=y.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=r,s&&(this.programTimersStack=null);let c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(i);c.kernelMs=y.sum(l),c.getExtraProfileInfo=()=>l.map((u,p)=>({name:a[p],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:y.now(),endMs:null}}endTimer(t){return O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=y.now(),t)}async getQueryTime(t){if(O().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let r=t;return r.endMs-r.startMs}disposeData(t,r=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(r?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!r&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:o}=this.texData.get(t);return o!=null&&(this.disposeData(o.real.dataId,r),this.disposeData(o.imag.dataId,r)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:r,dtype:o,texShape:s,usage:i,isPacked:a,slice:c}=this.texData.get(t),l=c&&c.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),r!=null&&(this.numBytesInGPU-=this.computeBytes(s,o),this.textureManager.releaseTexture(r,s,i,a)));let p=this.texData.get(t);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,r=Jse){return O().getBool("WEBGL_CPU_FORWARD")&&t.every(o=>this.texData.get(o.dataId).texture==null&&y.sizeFromShape(o.shape)<r)}getGPGPUContext(){return this.gpgpu}where(t){S.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let r=t.dataSync();return Xse(t.shape,r)}packedUnaryOp(t,r,o){let s=new Pn(t.shape,r),i=this.compileAndRun(s,[t],o);return lr().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let s=Jy(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if(O().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,aD,t.dtype);let r=new en(t.shape,aD),o=this.compileAndRun(r,[t]);return lr().makeTensorFromTensorInfo(o)}makeTensorInfo(t,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&y.isString(o[0])){let i=o.map(a=>y.encodeString(a));s=this.write(i,t,r)}else s=this.write(o,t,r);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:r}}makeOutput(t,r,o){return lr().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,o),this)}unpackTensor(t){let r=new rv(t.shape);return this.runWebGLProgram(r,[t],t.dtype)}packTensor(t){let r=new tv(t.shape);return this.runWebGLProgram(r,[t],t.dtype,null,!0)}packedReshape(t,r){let o=[fa(t.shape),...ma(t.shape)],s={dtype:t.dtype,shape:o,dataId:t.dataId},i=[fa(r),...ma(r)],a=new yd(i,o),c=!0,l=[o],u=this.runWebGLProgram(a,[s],t.dtype,l,c);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(t,r){let o=this.texData.get(t),{isPacked:s,shape:i,dtype:a}=o;if(r!=null){let f=y.sizeFromShape(i),m=r[0]*r[1]*4;y.assert(f<=m,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let c=fh(i),l;s?l=new Ky(c):l=new qy(c);let u=!0,p=[r??lh(c)],d=this.runWebGLProgram(l,[{shape:c,dtype:a,dataId:t}],a,p,u,r);return{dtype:a,shape:i,dataId:d.dataId}}runWebGLProgram(t,r,o,s,i=!1,a){let c=this.makeTensorInfo(t.outputShape,o),l=this.texData.get(c.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===Iu.DENSE){let v=a??lh(t.outputShape);l.texShape=v.map(w=>w*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),y.sizeFromShape(c.shape)===0)return l.values=y.getTypedArrayFromDType(c.dtype,0),c;let u=[],p=r.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(v.dataId);if(w.texture==null){if(!t.packedInputs&&y.sizeFromShape(v.shape)<=O().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:w.values};t.packedInputs&&(w.isPacked=!0,w.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!w.isPacked!=!!t.packedInputs)v=w.isPacked?this.unpackTensor(v):this.packTensor(v),u.push(v),w=this.texData.get(v.dataId);else if(w.isPacked&&!Tu(w.shape,v.shape)){let I=v,_=v.shape;v.shape=w.shape,v=this.packedReshape(v,_),u.push(v),w=this.texData.get(v.dataId),I.shape=_}return{shape:v.shape,texData:w,isUniform:!1}});this.uploadToGPU(c.dataId);let d={shape:c.shape,texData:l,isUniform:!1},f=W3(t,p,d),m=this.getAndSaveBinary(f,()=>H3(this.gpgpu,t,p,d)),h=this.activeTimers!=null,g;h&&(g=this.startTimer()),O().get("ENGINE_COMPILE_ONLY")||G3(this.gpgpu,m,p,d,s),u.forEach(v=>this.disposeIntermediateTensorInfo(v)),h&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));let x=O().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){let v=y.now();v-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!O().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){let v=this.unpackTensor(c);return this.disposeIntermediateTensorInfo(c),v}return c}compileAndRun(t,r,o,s,i=!1){return o=o||r[0].dtype,this.runWebGLProgram(t,r,o,s,i)}getAndSaveBinary(t,r){return t in this.binaryCache||(this.binaryCache[t]=r()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(O().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Ce(()=>{if(!O().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=O().getBool("DEBUG");O().set("DEBUG",!1);let r=this.abs(me(1e-8)).dataSync()[0];if(O().set("DEBUG",t),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Yse:Zse}uploadToGPU(t){let r=this.texData.get(t),{shape:o,dtype:s,values:i,texture:a,usage:c,isPacked:l}=r;if(a!=null)return;let u=this.activeTimers!=null,p;u&&(p=y.now());let d=r.texShape;if(d==null&&(d=_3(o,l),r.texShape=d),i!=null){let f=fh(o),m,h=d[1],g=d[0],x=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!x)&&([h,g]=zo(d[0],d[1])),l?m=new Zy(f,x):m=new mh(f,x);let v=x?[g,h]:d,w=this.makeTensorInfo(v,s),I=this.texData.get(w.dataId);x?I.usage=vn.PIXELS:I.usage=vn.UPLOAD,I.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),h,g,i);let _=[[g,h]],R=this.runWebGLProgram(m,[w],s,_,!0),F=this.texData.get(R.dataId);r.texShape=F.texShape,r.isPacked=F.isPacked,r.usage=F.usage,O().get("ENGINE_COMPILE_ONLY")?this.disposeData(R.dataId):(r.texture=F.texture,r.values=null,this.texData.delete(R.dataId)),this.disposeIntermediateTensorInfo(w),u&&(this.uploadWaitMs+=y.now()-p)}else{let f=this.acquireTexture(d,c,s,l);r.texture=f}}convertAndCacheOnCPU(t,r){let o=this.texData.get(t),{dtype:s}=o;return r!=null&&(o.values=nie(r,s)),o.values}acquireTexture(t,r,o,s){if(this.numBytesInGPU+=this.computeBytes(t,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,r,s)}computeBytes(t,r){return t[0]*t[1]*y.bytesPerElement(r)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,r]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(r));return Promise.all(t)}else{for(let[,r]of Object.entries(this.binaryCache)){let o=new Promise(s=>{try{this.checkCompletion_(r),s(!0)}catch(i){throw i}});t.push(o)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await my(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(YN(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:r,customUniformLocations:o,infLoc:s,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}=eD(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=r,t.customUniformLocations=o,t.infLoc=s,t.nanLoc=i,t.outShapeLocation=a,t.outShapeStridesLocation=c,t.outTexShapeLocation=l}}createTensorFromGPUData(t,r,o){t.channels=t.channels||"RGBA";let{texture:s,height:i,width:a,channels:c}=t,l=lr().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=l.writeTexture(s,r,o,i,a,c);return lr().makeTensorFromDataId(u,r,o,l)}}return n.nextDataId=0,n})();function nie(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){let t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}ss.isBrowser()&&Jf("webgl",()=>new m4,2);T();T();T();T();T();var vd=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Ln=class{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=S.assertAndGetBroadcastShape(t,r),this.enableShapeUniforms=Ye(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};T();var Qn=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var Zn=class{constructor(e,t,r,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S.assertAndGetBroadcastShape(t,r);let s=this.outputShape.length;this.enableShapeUniforms=Ye(s);let i="";if(o)if(s===0||y.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${ve(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let c=It("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${c[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${c[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${c[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${c[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};T();T();function Et(n){let{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var h4={kernelName:ns,backendName:"webgl",kernelFunc:Et};function Bn(n){let{inputs:e,backend:t}=n,{real:r,imag:o}=e,s=t.makeTensorInfo(r.shape,"complex64"),i=t.texData.get(s.dataId),a=Et({inputs:{x:r},backend:t}),c=Et({inputs:{x:o},backend:t});return i.complexTensorInfos={real:a,imag:c},s}var g4={kernelName:pc,backendName:"webgl",kernelFunc:Bn};T();var cD="return (a < 0.) ? b * a : a;",lD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function rie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{alpha:s}=r,i=t.makeTensorInfo([],"float32",y.createScalarValue(s,"float32")),a=O().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zn(lD,o.shape,i.shape):new Ln(cD,o.shape,i.shape),c=t.runWebGLProgram(a,[o,i],"float32");return t.disposeIntermediateTensorInfo(i),c}var x4={kernelName:zc,backendName:"webgl",kernelFunc:rie};T();var uD="return (a < 0.) ? b * a : a;",pD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function oie(n){let{inputs:e,backend:t}=n,{x:r,alpha:o}=e,s=O().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zn(pD,r.shape,o.shape):new Ln(uD,r.shape,o.shape);return t.runWebGLProgram(s,[r,o],"float32")}var y4={kernelName:il,backendName:"webgl",kernelFunc:oie};var _r="if (isnan(x)) return x;";function pe({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,c=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){let p=a.texData.get(i.dataId),d=t(p.values,c);return a.makeTensorInfo(i.shape,c,d)}let l=O().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null,u;return l?u=new Pn(i.shape,e):u=new en(i.shape,n),a.runWebGLProgram(u,[i],c)}}function Ke({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:c,b:l}=i,u=a;if(r&&c.dtype==="complex64"){let m=u.texData.get(c.dataId),h=u.texData.get(l.dataId),[g,x]=[[m.complexTensorInfos.real,h.complexTensorInfos.real],[m.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(w=>{let[I,_]=w,A={dataId:I.dataId,dtype:I.dtype,shape:c.shape},R={dataId:_.dataId,dtype:_.dtype,shape:l.shape},F=new Ln(n,c.shape,l.shape);return u.runWebGLProgram(F,[A,R],Dt(I.dtype,_.dtype))}),v=Bn({inputs:{real:g,imag:x},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(x),v}let p=s||Dt(c.dtype,l.dtype);if((c.dtype==="string"||l.dtype==="string"||u.shouldExecuteOnCPU([c,l]))&&o!=null){let m=u.texData.get(c.dataId).values,h=u.texData.get(l.dataId).values,g=c.dtype==="string"?S.fromUint8ToStringArray(m):m,x=c.dtype==="string"?S.fromUint8ToStringArray(h):h,[v,w]=o(c.shape,l.shape,g,x,p),I=u.makeTensorInfo(w,p),_=u.texData.get(I.dataId);return _.values=v,I}let d=O().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null,f;return d?f=new Zn(e,c.shape,l.shape,t):f=new Ln(n,c.shape,l.shape),u.runWebGLProgram(f,[c,l],p)}}function ks(n,e=!1){if(n==="linear")return e?l4:r4;if(n==="relu")return e?p4:s4;if(n==="elu")return e?u4:o4;if(n==="relu6")return e?d4:i4;if(n==="prelu")return e?pD:uD;if(n==="leakyrelu")return e?lD:cD;if(n==="sigmoid")return e?f4:a4;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}var bd=class{constructor(e,t,r,o=!1,s=!1,i=!1,a=null,c=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Ye(this.outputShape.length);let u=o?e[1]:e[2],p=Math.ceil(u/2),d=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",m=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",x="";a&&(c?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");let v=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let w="rc.x",I="rc.x";e[0]<t[0]?w=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(I=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w};
        int batchB = ${I};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${h[0]});
          result += (${m[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${v}

        ${x}

        setOutput(result);
      }
    `}};T();T();var dD={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},gh=class{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=S.assertAndGetBroadcastShape(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var v4="return a * b;";function xh(n){let{inputs:e,backend:t}=n,{a:r,b:o}=e,s=S.upcastType(r.dtype,o.dtype);if(r.dtype==="complex64"){let a=t.texData.get(r.dataId),c=t.texData.get(o.dataId),l=new gh(dD.REAL,r.shape,o.shape),u=new gh(dD.IMAG,r.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:o.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:o.shape}],d=t.runWebGLProgram(l,p,"float32"),f=t.runWebGLProgram(u,p,"float32"),m=Bn({inputs:{real:d,imag:f},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),m}if(t.shouldExecuteOnCPU([r,o])){let a=t.texData.get(r.dataId),c=t.texData.get(o.dataId),[l,u]=kU(r.shape,o.shape,a.values,c.values,s),p=t.makeTensorInfo(u,s),d=t.texData.get(p.dataId);return d.values=l,p}let i;return O().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Zn(v4,r.shape,o.shape):i=new Ln(v4,r.shape,o.shape),t.runWebGLProgram(i,[r,o],s)}var b4={kernelName:Ei,backendName:"webgl",kernelFunc:xh};T();function C4(n,e,t){let r=[fa(n.shape),...ma(n.shape)],o={dtype:n.dtype,shape:r,dataId:n.dataId},s=[fa(e),...ma(e)],i=new yd(s,r),a=!0,c=[r],l=t.runWebGLProgram(i,[o],n.dtype,c,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}function J(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{shape:s}=r,i=t,a=y.sizeFromShape(o.shape),c=y.inferFromImplicitShape(s,a),l=y.sizeFromShape(c);y.assert(a===l,()=>`The new shape (${c}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let u=i.texData.get(o.dataId);return u.isPacked&&!Tu(o.shape,c)&&!(u.texture!==null&&Tu(u.shape,c))?C4(o,c,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:c,dtype:o.dtype})}var w4={kernelName:fl,backendName:"webgl",kernelFunc:J};T();T();T();T();var yh=class{constructor(e,t){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=e;this.outputShape=[o,i];let a=Math.floor(r/4)*4,c=r%4,l="sumValue += dot(values, ones);";if(t!=null){let p=1/t;l=`sumValue += dot(values * ${y.isInt(p)?p.toPrecision(2):p}, ones);`}let u="";s%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var sv=class{constructor(e,t){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=e;this.outputShape=[o,i];let a="0.0",c="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",c="min"):t==="max"&&(a="-1.0 / 1e-20",c="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let u=Math.floor(r/4)*4,p=r%4,d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let m="";s%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function iie(n){let e=[];for(;e.length===0||e[e.length-1].outSize!==1;){let t=e.length?e[e.length-1].outSize:n[1],r=S.computeOptimalWindowSize(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function Jn(n,e,t,r){let o=iie(n.shape),s=n;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:c,outSize:l}=o[i],u,p;t==="mean"?u=i===0?new yh({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:l},a):new yh({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:l}):u=new sv({windowSize:c,inSize:a,batchSize:n.shape[0],outSize:l},t),p=s,s=r.runWebGLProgram(u,[s],e),p.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(p)}return s}T();var iv=class{constructor(e,t){this.variableNames=["A"];let r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[t[i]];this.outputShape=r,this.rank=r.length;let o=ve(this.rank),s=aie(t);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function aie(n){let e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let o=0;o<n.length;o++)r[n[o]]=t[o];return r.join()}var av=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let r=new Array(e.length);for(let u=0;u<r.length;u++)r[u]=e[t[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=ve(this.rank),s=iD("rc",this.rank),i=new Array(this.rank);for(let u=0;u<t.length;u++)i[t[u]]=s[u];let a=`vec2(${i.slice(-2).join()})`,c=`++${s[this.rank-1]} < ${r[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${c}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${l};
        if(${c}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function ha(n,e,t){let r=O().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new av(n.shape,e):new iv(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}function I4(n,e,t,r){let o=e,s=n.shape.length,i=y.parseAxisParam(o,n.shape),a=i,c=S.getAxesPermutation(a,s),l=c!=null,u=n;l&&(u=ha(n,c,r),a=S.getInnerMostAxes(a.length,s)),S.assertAxesAreInnerMostDims("sum",a,s);let[p,d]=S.computeOutAndReduceShapes(u.shape,a),f=p;t&&(f=S.expandShapeToKeepDim(p,i));let m=y.sizeFromShape(d),g=y.sizeFromShape(n.shape)/m,x=J({inputs:{x:u},attrs:{shape:[g,m]},backend:r}),v=ji(n.dtype),w=Jn(x,v,"sum",r),I=J({inputs:{x:w},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(w),l&&r.disposeIntermediateTensorInfo(u),I}function ku(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r;return I4(o,s,i,t)}var E4={kernelName:"Sum",backendName:"webgl",kernelFunc:ku};T();function at(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{perm:s}=r,i=t,a=o.shape.length,c=new Array(a);for(let u=0;u<c.length;u++)c[u]=o.shape[s[u]];let l;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,d=Du(p,o.shape,o.dtype,s,c);l=i.makeTensorInfo(c,o.dtype);let f=i.texData.get(l.dataId);f.values=d}else l=ha(o,s,i);return l}var T4={kernelName:os,backendName:"webgl",kernelFunc:at};var fD=1e3;function _u({a:n,b:e,transposeA:t,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:c=null}){let l=n.shape.length,u=e.shape.length,p=t?n.shape[l-2]:n.shape[l-1],d=r?e.shape[u-1]:e.shape[u-2],f=t?n.shape[l-1]:n.shape[l-2],m=r?e.shape[u-2]:e.shape[u-1],h=n.shape.slice(0,-2),g=e.shape.slice(0,-2),x=y.sizeFromShape(h),v=y.sizeFromShape(g),I=Jr.assertAndGetBroadcastShape(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,m]);y.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);let _=t?[x,p,f]:[x,f,p],A=r?[v,m,d]:[v,d,m],R=J({inputs:{x:n},backend:o,attrs:{shape:_}}),F=J({inputs:{x:e},backend:o,attrs:{shape:A}}),P=[R,F],L=Math.max(x,v),V=t?R.shape[1]:R.shape[2],z=s!=null,H=i!=null,j=c==="leakyrelu",W=c!=null?ks(c,!0):null,Y=z||H||j||W!=null,Z;if((f===1||m===1)&&V>fD&&Y===!1){let Q=R,te=F;t&&(Q=at({inputs:{x:R},backend:o,attrs:{perm:[0,2,1]}}),P.push(Q)),r&&(te=at({inputs:{x:F},backend:o,attrs:{perm:[0,2,1]}}),P.push(te));let ne=m!==1,se=m===1,re=Q;ne&&(re=J({inputs:{x:Q},backend:o,attrs:{shape:[L,V,1]}}),P.push(re));let ae=m===1?2:1,oe=te;se&&(oe=J({inputs:{x:te},backend:o,attrs:{shape:[L,1,V]}}),P.push(oe));let ue=xh({inputs:{a:re,b:oe},backend:o});Z=ku({inputs:{x:ue},backend:o,attrs:{axis:ae,keepDims:!0}}),P.push(ue)}else{let Q=Dt(n.dtype,e.dtype),te=new bd(_,A,[L,f,m],t,r,z,W,H,j),ne=[R,F];if(s!=null&&ne.push(s),H&&ne.push(i),j){let se=o.makeTensorInfo([],"float32",y.createScalarValue(a,"float32"));ne.push(se),P.push(se)}Z=o.runWebGLProgram(te,ne,Q)}let K=J({inputs:{x:Z},backend:o,attrs:{shape:I}});P.push(Z);for(let Q of P)o.disposeIntermediateTensorInfo(Q);return K}function cie(n){let{inputs:e,backend:t,attrs:r}=n,{a:o,b:s,bias:i,preluActivationWeights:a}=e,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:p}=r;return _u({a:o,b:s,transposeA:c,transposeB:l,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:u})}var S4={kernelName:Ui,backendName:"webgl",kernelFunc:cie};T();var N4="return abs(x);";function lie(n){let{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=t.texData.get(r.dataId),i=Jy(s.values);return t.makeTensorInfo(r.shape,r.dtype,i)}let o;return O().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Pn(r.shape,N4):o=new en(r.shape,N4),t.runWebGLProgram(o,[r],r.dtype)}var D4={kernelName:"Abs",backendName:"webgl",kernelFunc:lie};T();var uie=Mt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,pie=pe({opSnippet:uie}),k4={kernelName:Xs,backendName:"webgl",kernelFunc:pie};T();var die=Mt+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,fie=pe({opSnippet:die}),_4={kernelName:Ys,backendName:"webgl",kernelFunc:fie};T();var A4="return a + b;",mie=Ke({opSnippet:A4,packedOpSnippet:A4,supportsComplex:!0,cpuKernelImpl:cU}),R4={kernelName:"Add",backendName:"webgl",kernelFunc:mie};T();var cv=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var lv=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function uv(n){let{inputs:e,backend:t}=n,r=e;if(r.length===1)return Et({inputs:{x:r[0]},backend:t});if(r.length>O().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(r.length/2),l=uv({inputs:r.slice(0,c),backend:t}),u=uv({inputs:r.slice(c),backend:t});return uv({inputs:[l,u],backend:t})}let o=r.map(c=>c.dtype).reduce((c,l)=>Dt(c,l)),s=r.map(c=>c.shape),a=O().getBool("WEBGL_PACK")?new lv(r[0].shape,s):new cv(r[0].shape,s);return t.runWebGLProgram(a,r,o)}var F4={kernelName:nc,backendName:"webgl",kernelFunc:uv};T();function hie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),l=c,u=S.getAxesPermutation(l,a),p=o;u!=null&&(p=at({inputs:{x:o},backend:t,attrs:{perm:u}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("all",l,a);let[d,f]=S.computeOutAndReduceShapes(p.shape,l),m=y.sizeFromShape(f),h=J({inputs:{x:p},backend:t,attrs:{shape:[-1,m]}}),g=Jn(h,h.dtype,"all",t),x;if(i){let v=S.expandShapeToKeepDim(d,c);x=J({inputs:{x:g},backend:t,attrs:{shape:v}})}else x=J({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(p),x}var M4={kernelName:"All",backendName:"webgl",kernelFunc:hie};T();function gie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),l=c,u=S.getAxesPermutation(l,a),p=o;u!=null&&(p=at({inputs:{x:o},backend:t,attrs:{perm:u}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("any",l,a);let[d,f]=S.computeOutAndReduceShapes(p.shape,l),m=y.sizeFromShape(f),h=J({inputs:{x:p},backend:t,attrs:{shape:[-1,m]}}),g=Jn(h,h.dtype,"any",t),x;if(i){let v=S.expandShapeToKeepDim(d,c);x=J({inputs:{x:g},backend:t,attrs:{shape:v}})}else x=J({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(p),x}var O4={kernelName:"Any",backendName:"webgl",kernelFunc:gie};T();T();var pv=class{constructor(e,t,r){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=t==="max"?">":"<",c=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};T();var dv=class{constructor(e,t,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,y.assert(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],i=Math.ceil(s/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,c=a.length,l=ve(c),u=It("coords",c),p,d;if(i===1){d=c+1;let F=ve(d);p=`
        ${F} sourceLocR = ${F}(${u.join()}, 0);
        ++${u[c-1]};
        ${F} sourceLocG = ${F}(${u.join()}, 0);
        ++${u[c-2]};
        ${F} sourceLocA = ${F}(${u.join()}, 0);
        --${u[c-1]};
        ${F} sourceLocB = ${F}(${u.join()}, 0);
        --${u[c-2]};`}else d=c,p=`
        ${l} sourceLocR = coords;
        ++${u[c-1]};
        ${l} sourceLocG = coords;
        ++${u[c-2]};
        ${l} sourceLocA = coords;
        --${u[c-1]};
        ${l} sourceLocB = coords;
        --${u[c-2]};`;let f=["x","y","z","w","u","v"].slice(0,d),m="."+f[d-1],h=f.map(F=>"int "+F),g=It("sourceLocR",d-1).concat("inIdx.r"),x=It("sourceLocG",d-1).concat("inIdx.g"),v=It("sourceLocB",d-1).concat("inIdx.b"),w=It("sourceLocA",d-1).concat("inIdx.a"),I=r==="max"?"greaterThan":"lessThan",_=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()})));`,A=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${v.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,R=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[c-1]} < ${a[c-1]-1};
        bool hasNextRow = ${u[c-2]} < ${a[c-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${A};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${_}
          vec4 candidate = ${A};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${I}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function $4(n,e,t,r=null){let o=e.shape[0],s=e.shape[1];r!=null&&(o=r.shape[0],s=r.shape[1]);let i=S.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},c=new pv(a,t,r==null),l=[e];r!=null&&l.push(r);let u=n.runWebGLProgram(c,l,"int32");if(u.shape[1]===1)return u;let p=$4(n,e,t,u);return n.disposeIntermediateTensorInfo(u),p}function P4(n,e,t,r=null){let o=r!=null?r.shape:e.shape,s=o[o.length-1],i=S.computeOptimalWindowSize(s),a=new dv(o,i,t,r==null),c=r==null?[e]:[e,r],l=n.runWebGLProgram(a,c,"int32");if(l.shape.length===e.shape.length){let u=P4(n,e,t,l);return n.disposeIntermediateTensorInfo(l),u}return l}function fv(n,e,t,r){let o=[t];if(S.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,e.shape.length),!O().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){let s=[],i=n.texData.get(e.dataId),a=i!==null&&i.isPacked,c=e;a&&(c=n.unpackTensor(e),s.push(c));let[l,u]=S.computeOutAndReduceShapes(c.shape,o),p=y.sizeFromShape(u),d=J({inputs:{x:c},backend:n,attrs:{shape:[-1,p]}});s.push(d);let f=$4(n,d,r);s.push(f);let m=J({inputs:{x:f},backend:n,attrs:{shape:l}});return s.forEach(h=>n.disposeIntermediateTensorInfo(h)),m}return P4(n,e,r)}function xie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s}=r,i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,l=[];a!=null&&(c=at({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),S.assertAxesAreInnerMostDims("argMax",[i[0]],c.shape.length);let u=fv(t,c,i[0],"max");return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),u}var L4={kernelName:rc,backendName:"webgl",kernelFunc:xie};T();function yie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s}=r,i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,l=[];a!=null&&(c=at({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),S.assertAxesAreInnerMostDims("argMin",[i[0]],c.shape.length);let u=fv(t,c,i[0],"min");return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),u}var B4={kernelName:oc,backendName:"webgl",kernelFunc:yie};T();var vie=Mt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,bie=pe({opSnippet:vie}),V4={kernelName:Zs,backendName:"webgl",kernelFunc:bie};T();var Cie=Mt+"return log(x + sqrt(x * x + 1.0));",wie=pe({opSnippet:Cie}),U4={kernelName:Qs,backendName:"webgl",kernelFunc:wie};T();var Iie=Mt+`
  return atan(x);
`,Eie=pe({opSnippet:Iie}),z4={kernelName:Js,backendName:"webgl",kernelFunc:Eie};T();var Tie=vd+`
  return atan(a, b);
`,Sie=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Qn+`
  return result;
`,Nie=Ke({opSnippet:Tie,packedOpSnippet:Sie}),H4={kernelName:ti,backendName:"webgl",kernelFunc:Nie};T();var Die=Mt+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,kie=pe({opSnippet:Die}),G4={kernelName:ei,backendName:"webgl",kernelFunc:kie};T();var ao=class{constructor(e,t,r,o=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,a=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;let h=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,v="0.0";if(h||(v="-1.0 / 1e-20"),r){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${c});
        const ivec2 pads = ivec2(${f}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:x:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(I="avgValue / max(count, 1.0)");let _=Math.floor(i/4)*4,A=i%4,R=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${c});
      const ivec2 pads = ivec2(${f}, ${m});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${_};
          if (${A===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${A===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${A===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${I});
      }
    `}},ga=class{constructor(e,t,r,o=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,a=e.strideDepth,c=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,p=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,m=e.effectiveFilterHeight,h=e.effectiveFilterWidth,g=e.padInfo.front,x=e.padInfo.top,v=e.padInfo.left;this.outputShape=e.outShape;let w=t==="avg",I="0.0";if(w||(I="-1.0 / 1e-20"),r){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${c}, ${l});
        const ivec3 pads = ivec3(${g}, ${x}, ${v});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${m} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let _="max",A=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(A="avgValue / max(count, 1.0)");let R=Math.floor(i/4)*4,F=i%4,P=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${c}, ${l});
      const ivec3 pads = ivec3(${g}, ${x}, ${v});
      const float initializationValue = ${I};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${I});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${P}
            }

            int xC = xCCorner + ${R};
            if (${F===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${P}
            } else if (${F===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${P}
            } else if (${F===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${P}
            }
          }
        }
        setOutput(${A});
      }
    `}};function _ie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e;Ho(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let u=S.computePool2DInfo(o.shape,s,i,l,a,c);if(u.filterWidth===1&&u.filterHeight===1&&y.arraysEqual(u.inShape,u.outShape))return Et({inputs:{x:o},backend:t});let p=new ao(u,"avg",!1);return t.runWebGLProgram(p,[o],"float32")}var W4={kernelName:sc,backendName:"webgl",kernelFunc:_ie};T();function Aie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:c,dataFormat:l}=r,u=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,u,a,c,l),d=new ga(p,"avg",!1);return t.runWebGLProgram(d,[o],"float32")}var j4={kernelName:ic,backendName:"webgl",kernelFunc:Aie};T();var mv=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,r=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=c-1-e.padInfo.top,p=l-1-e.padInfo.left,d=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${p});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},hv=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,r=e.filterHeight,o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=p-1-e.padInfo.front,h=d-1-e.padInfo.top,g=f-1-e.padInfo.left,x=1/(t*r*o);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${h}, ${g});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Rie(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,i=s,{filterSize:a,strides:c,pad:l,dimRoundingMode:u}=r,p=[1,1,1],d=S.computePool3DInfo(i.shape,a,c,p,l,u),f=new hv(d);return t.runWebGLProgram(f,[o],i.dtype)}var q4={kernelName:$f,backendName:"webgl",kernelFunc:Rie};T();function Fie(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,i=s;Ho([o,s],"avgPoolGrad");let{filterSize:a,strides:c,pad:l}=r,u=S.computePool2DInfo(i.shape,a,c,1,l),p=new mv(u);return t.runWebGLProgram(p,[o],i.dtype)}var K4={kernelName:Of,backendName:"webgl",kernelFunc:Fie};T();function Mie(n){let{inputs:e,backend:t,attrs:r}=n,{a:o,b:s}=e,{transposeA:i,transposeB:a}=r;return _u({a:o,b:s,transposeA:i,transposeB:a,backend:t})}var X4={kernelName:ac,backendName:"webgl",kernelFunc:Mie};T();T();var gv=class{constructor(e,t,r,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(e,t),S.assertAndGetBroadcastShape(e,r);let a="0.0";o!=null&&(S.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let c="1.0";s!=null&&(S.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};T();var xv=class{constructor(e,t,r,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(e,t),S.assertAndGetBroadcastShape(e,r);let a="vec4(0.0)";o!=null&&(S.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let c="vec4(1.0)";s!=null&&(S.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var Oie=({inputs:n,backend:e,attrs:t})=>{let{x:r,mean:o,variance:s,offset:i,scale:a}=n;y.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=t;c==null&&(c=.001);let l=[r,o,s],u=null;i!=null&&(u=i.shape,l.push(i));let p=null;a!=null&&(p=a.shape,l.push(a));let d=O().getBool("WEBGL_PACK_NORMALIZATION")?new xv(r.shape,o.shape,s.shape,u,p,c):new gv(r.shape,o.shape,s.shape,u,p,c);return e.runWebGLProgram(d,l,l[0].dtype)},Y4={kernelName:Pc,backendName:"webgl",kernelFunc:Oie};T();T();var yv=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=ve(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let r=$ie(this.rank),o,s=e.map((i,a)=>`sourceLoc.${mD[a]} = start[${a}] + coords.${mD[a]};`);o=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${r}));
      }
    `}},mD=["x","y","z","w","u","v"];function $ie(n){if(n===1)return"sourceLoc";if(n<=6)return mD.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}var vv=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=ve(this.rank),r=It("coords",this.rank),o=It("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,p)=>`start[${p}]`).join()});`:e.map((u,p)=>`${o[p]} = ${r[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${c}
        setOutput(result);
      }
    `}};function Pie(n,e,t,r){let o=r.texData.get(n.dataId),s=r.makeTensorInfo(t,n.dtype),i=r.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=t,i.dtype=n.dtype;let a=$t.computeFlatOffset(e,y.computeStrides(n.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||n.dataId};let c=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,c+1),s}function co(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{begin:s,size:i}=r,[a,c]=$t.parseSliceParams(o,s,i);if($t.assertParamsValid(o,a,c),y.sizeFromShape(c)===0)return t.makeTensorInfo(c,o.dtype,[]);if(t.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=t.texData.get(o.dataId),d=VU(p.values,a,c,o.shape,o.dtype);return t.makeTensorInfo(c,o.dtype,d)}let{isPacked:l}=t.texData.get(o.dataId),u=$t.isSliceContinous(o.shape,a,c);if(l||!u){let p=O().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vv(c):new yv(c),d=[a];return t.runWebGLProgram(p,[o],o.dtype,d)}return t.uploadToGPU(o.dataId),Pie(o,a,c,t)}var Z4={kernelName:Cl,backendName:"webgl",kernelFunc:co};var Lie=n=>{let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockShape:s,crops:i}=r;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((v,w)=>v*w),c=S.getReshaped(o.shape,s,a),l=S.getPermuted(c.length,s.length),u=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),d=S.getSliceSize(u,i,s.length),f=[],m=J({inputs:{x:o},backend:t,attrs:{shape:c}}),h=at({inputs:{x:m},backend:t,attrs:{perm:l}}),g=J({inputs:{x:h},backend:t,attrs:{shape:u}}),x=co({inputs:{x:g},backend:t,attrs:{begin:p,size:d}});return f.push(m),f.push(h),f.push(g),f.forEach(v=>t.disposeIntermediateTensorInfo(v)),x},Q4={kernelName:cc,backendName:"webgl",kernelFunc:Lie};T();function Bie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,weights:s}=e,{size:i}=r,a=t.readSync(o.dataId),c=t.readSync(s.dataId),l=Qy(a,c,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,l)}var J4={kernelName:lc,backendName:"webgl",kernelFunc:Bie};T();var Vie=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Uie=`
  return float(int(a.r) & int(b.r));
`;function zie(n){let{inputs:e,backend:t}=n,{a:r,b:o}=e,s=O().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=O().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([r,o])||i===1){let c=t.texData.get(r.dataId).values,l=t.texData.get(o.dataId).values,[u,p]=uU(r.shape,o.shape,c,l,r.dtype),d=t.makeTensorInfo(p,r.dtype),f=t.texData.get(d.dataId);return f.values=u,d}let a;return s?a=new Zn(Vie,r.shape,o.shape,!1):a=new Ln(Uie,r.shape,o.shape),t.runWebGLProgram(a,[r,o],r.dtype)}var ez={kernelName:ni,backendName:"webgl",kernelFunc:zie};T();function Hie(n){let{inputs:e,backend:t}=n,{s0:r,s1:o}=e,s=t.readSync(r.dataId),i=t.readSync(o.dataId),a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var tz={kernelName:uc,backendName:"webgl",kernelFunc:Hie};T();T();T();var Gie="return float(a != b);",hD=Ke({opSnippet:Gie,cpuKernelImpl:AU,dtype:"bool"}),nz={kernelName:Ti,backendName:"webgl",kernelFunc:hD};T();function _s(n){let{inputs:e,backend:t}=n,{input:r}=e,o=t.texData.get(r.dataId);return Et({inputs:{x:o.complexTensorInfos.real},backend:t})}var rz={kernelName:dl,backendName:"webgl",kernelFunc:_s};var Wie="return float(int(x));";function oz(n,e){let t=new en(n.shape,Wie),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function gD(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return Et({inputs:{x:o},backend:t});let i=pr(o.shape),a=gD({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),c=Bn({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),c}if(o.dtype==="complex64"){let i=_s({inputs:{input:o},backend:t}),a=gD({inputs:{x:i},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(i),a}if(!y.hasEncodingLoss(o.dtype,s)){let i=Et({inputs:{x:o},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(t.shouldExecuteOnCPU([o])){let i=t.texData.get(o.dataId).values,[a,c,l]=pU(i,o.shape,o.dtype,s);return t.makeTensorInfo(a,c,l)}if(s==="int32")return oz(o,t);if(s==="bool"){let i=t.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),c=hD({inputs:{a:o,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),c}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var sz={kernelName:ts,backendName:"webgl",kernelFunc:gD};T();var iz="return ceil(x);",jie=pe({opSnippet:iz,packedOpSnippet:iz,cpuKernelImpl:dU}),az={kernelName:ri,backendName:"webgl",kernelFunc:jie};T();var bv=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var Cv=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function qie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{clipValueMin:s,clipValueMax:i}=r,a;O().getBool("WEBGL_PACK_CLIP")?a=new Cv(o.shape):a=new bv(o.shape);let c=[[s],[i]];return t.runWebGLProgram(a,[o],o.dtype,c)}var cz={kernelName:oi,backendName:"webgl",kernelFunc:qie};T();var wv=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function lz(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Kie(n){let{inputs:e,backend:t}=n,{x:r}=e,o=t.texData.get(r.dataId),s=new wv(r.shape),i=[lz(r,o.complexTensorInfos.real),lz(r,o.complexTensorInfos.imag)];return t.runWebGLProgram(s,i,i[0].dtype)}var uz={kernelName:dc,backendName:"webgl",kernelFunc:Kie};T();T();T();var Iv=class{constructor(e){this.outputShape=[],this.outputShape=S.computeOutShape(e,1),this.variableNames=e.map((i,a)=>`T${a}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];let r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){let a=t[i-1];r.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=t.length,s=t[t.length-1];r.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};T();var Tv=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=S.computeOutShape(e,t);let r=this.outputShape,o=r.length,s=ve(o),i=It("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((h,g)=>`T${g}`);let c=new Array(e.length-1);c[0]=e[0][t];for(let h=1;h<c.length;h++)c[h]=c[h-1]+e[h][t];let l=a[t],u=a.slice(-2),p=a.join(),d=`if (${l} < ${c[0]}) {
        return getChannel(
            getT0(${p}), vec2(${u.join()}));
        }`;for(let h=1;h<c.length;h++){let g=c[h-1];d+=`
        if (${l} < ${c[h]}  && ${l} >= ${c[h-1]}) {
          return getChannel(
            getT${h}(${Ev(a,l,g)}),
            vec2(${Ev(u,l,g)}));
        }`}let f=c.length,m=c[c.length-1];d+=`
        return getChannel(
          getT${f}(${Ev(a,l,m)}),
          vec2(${Ev(u,l,m)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${r[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${r[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${r[o-2]} &&
            ${i[o-1]} < ${r[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function Ev(n,e,t){let r=n.indexOf(e);return n.map((s,i)=>i===r?`${s} - ${t}`:s).join()}T();function Au(n){let{inputs:e,backend:t}=n,{input:r}=e,o=t.texData.get(r.dataId);return Et({inputs:{x:o.complexTensorInfos.imag},backend:t})}var pz={kernelName:Uc,backendName:"webgl",kernelFunc:Au};function Cd(n,e,t){let r=n[0].dtype;if(r==="complex64"){let f=n.map(v=>_s({inputs:{input:v},backend:t})),m=n.map(v=>Au({inputs:{input:v},backend:t})),h=Cd(f,e,t),g=Cd(m,e,t),x=Bn({inputs:{real:h,imag:g},backend:t});return f.forEach(v=>t.disposeIntermediateTensorInfo(v)),m.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),x}let o=t.shouldExecuteOnCPU(n);if(r==="string"&&(o=!0),o){let f=n.map(I=>{let A=[-1,y.sizeFromShape(I.shape.slice(e))];return J({inputs:{x:I},backend:t,attrs:{shape:A}})}),m=f.map(I=>({vals:t.readSync(I.dataId),shape:I.shape})),h=S.computeOutShape(f.map(I=>I.shape),1),g=f[0].shape[0]===1,x=fU(m,h,r,g),v=S.computeOutShape(n.map(I=>I.shape),e),w=t.makeTensorInfo(v,r,x);return f.forEach(I=>t.disposeIntermediateTensorInfo(I)),w}let s=n.filter(f=>y.sizeFromShape(f.shape)>0),i=O().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let f=i?new en(n[0].shape,Go):new Pn(n[0].shape,Go);return t.runWebGLProgram(f,n,r)}let a=O().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){let f=[];for(let h=0;h<s.length;h+=a){let g=s.slice(h,h+a);f.push(Cd(g,e,t))}let m=Cd(f,e,t);for(let h of f)t.disposeIntermediateTensorInfo(h);return m}if(i){let f=new Tv(s.map(m=>m.shape),e);return t.runWebGLProgram(f,s,r)}let{tensors2D:c,outShape:l}=Xie(s,e,t),u=new Iv(c.map(f=>f.shape)),p=t.runWebGLProgram(u,c,r);c.forEach(f=>t.disposeIntermediateTensorInfo(f));let d=J({inputs:{x:p},attrs:{shape:l},backend:t});return t.disposeIntermediateTensorInfo(p),d}function Xie(n,e,t){let r=S.computeOutShape(n.map(s=>s.shape),e);return{tensors2D:n.map(s=>J({inputs:{x:s},attrs:{shape:[-1,y.sizeFromShape(s.shape.slice(e))]},backend:t})),outShape:r}}function xD(n){let{inputs:e,backend:t,attrs:r}=n,{axis:o}=r,s=y.parseAxisParam(o,e[0].shape)[0],i=e.map(l=>l.shape);S.assertParamsConsistent(i,s);let a=S.computeOutShape(e.map(l=>l.shape),s);if(y.sizeFromShape(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);let c=e.filter(l=>y.sizeFromShape(l.shape)>0);return c.length===1?Et({inputs:{x:c[0]},backend:t}):Cd(c,s,t)}var dz={kernelName:fc,backendName:"webgl",kernelFunc:xD};T();var wd=class{constructor(e,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let i=e.padInfo.top,a=e.padInfo.left,c=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,p=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,m=Math.floor(e.inChannels/4)*4,h=e.inChannels%4,g=e.dataFormat==="channelsLast",x=g?1:2,v=g?2:3,w=g?3:1,I="",_="";r&&(o?I=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?I=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:I=`
          float activation(float x) {
            ${r}
          }
        `,_="result = activation(result);");let A=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${I}

      const ivec2 strides = ivec2(${c}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${v}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${A}
        ${_}
        setOutput(result);
      }
    `}},Sv=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,r=e.padInfo.top,o=e.padInfo.left,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.filterDepth,d=e.filterHeight,f=e.filterWidth,m=Math.floor(e.inChannels/4)*4,h=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${t}, ${r}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};T();var Id=class{constructor(e,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ye(this.outputShape.length);let i=e.padInfo.left,a=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,p=u,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<u;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(p+1)/2;g++){let x=g*2;if(d+=`
           xC = xCCorner + ${x*c};
           `,a===1){if(x<u&&(i%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,c===1&&x>0?d+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<u)){let v=i%2===0?y.nearestLargerEven(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${v};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,c>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:d+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):v===1?d+=`
                     xC${x+1} = xTexelC${x};
                     `:d+=`
                     xCOffset = xC + ${v};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<u&&(i%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<u&&(d+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<u&&(d+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<u&&(d+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let f="",m="";r&&(o?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:s?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:f=`vec4 activation(vec4 x) {
           ${r}
         }`,m="result = activation(result);");let h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${h}
         ${m}
         setOutput(result);
       }
     `}};T();var Nv=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Ye(this.outputShape.length);let{dataFormat:r}=t,o=xt(),s=r==="channelsLast",i=s?1:2,a=s?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let p=0;p<=1;p++)l+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${u};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function Dv(n,e){let t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function kv({x:n,filter:e,convInfo:t,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let c=n.shape,l=r.texData.get(n.dataId),u=t.inChannels,p=c[0]*c[1]*c[2],d=t.outChannels,f=t.dataFormat==="channelsLast",m=!1,h=!1,g,x=[];if(s!=null){let I=Dv(s.shape,f);I!=null&&(s=J({inputs:{x:s},backend:r,attrs:{shape:I}}),x.push(s))}if(o!=null){let I=Dv(o.shape,f);I!=null&&(o=J({inputs:{x:o},backend:r,attrs:{shape:I}}),x.push(o))}if(!((p===1||d===1)&&u>fD)&&l.isPacked&&f&&l.texture!=null&&c[2]%2!==0&&y.arraysEqual(l.shape.slice(-3),c.slice(-3))){let I=c[0]*c[1]*(c[2]+1),_={dataId:n.dataId,shape:[1,I,t.inChannels],dtype:n.dtype},A=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,y.assert(Tu(l.shape,_.shape),()=>`packed reshape ${l.shape} to ${_.shape} isn't free`);let R=J({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});x.push(R);let F=_u({a:_,b:R,backend:r,transposeA:m,transposeB:h,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),P=r.texData.get(F.dataId);y.assert(P.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=A,P.shape=t.outShape,g=Et({inputs:{x:F},backend:r}),g.shape=t.outShape,x.push(F)}else{let I=t.outHeight*t.outWidth,_=J({inputs:{x:n},backend:r,attrs:{shape:f?[t.batchSize,I,t.inChannels]:[t.batchSize,t.inChannels,I]}}),A=J({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),R=_u({a:f?_:A,b:f?A:_,transposeA:!f,transposeB:h,backend:r,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});g=J({inputs:{x:R},backend:r,attrs:{shape:t.outShape}}),x.push(_),x.push(A),x.push(R)}for(let I of x)r.disposeIntermediateTensorInfo(I);return g}function _v({x:n,filter:e,convInfo:t,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:c,filterHeight:l,inChannels:u,outWidth:p,outHeight:d,dataFormat:f}=t,m=f==="channelsLast",h=c*l*u,g=d*p,x=[t.batchSize,h,g],v=!0,w=!1,I=[];if(s!=null){let K=Dv(s.shape,m);K!=null&&(s=J({inputs:{x:s},backend:r,attrs:{shape:K}}),I.push(s))}if(o!=null){let K=Dv(o.shape,m);K!=null&&(o=J({inputs:{x:o},backend:r,attrs:{shape:K}}),I.push(o))}let _=J({inputs:{x:e},backend:r,attrs:{shape:[1,h,y.sizeFromShape(e.shape)/h]}});I.push(_);let A=new Nv(x,t),R=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],F=r.runWebGLProgram(A,[n],"float32",R),P=J({inputs:{x:F},backend:r,attrs:{shape:x}});I.push(F),I.push(P);let L=o!=null,V=s!=null,z=a==="leakyrelu",H=a?ks(a,!0):null,j=new bd(m?P.shape:_.shape,m?_.shape:P.shape,m?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],v,w,L,H,V,z),W=m?[P,_]:[_,P];if(o&&W.push(o),V&&W.push(s),z){let K=r.makeTensorInfo([],"float32",y.createScalarValue(i,"float32"));W.push(K),I.push(K)}let Y=r.runWebGLProgram(j,W,"float32"),Z=J({inputs:{x:Y},backend:r,attrs:{shape:t.outShape}});I.push(Y);for(let K of I)r.disposeIntermediateTensorInfo(K);return Z}function Yie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dataFormat:c,dilations:l,dimRoundingMode:u}=r,p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,s.shape,i,l,a,u,!1,p),f;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))f=kv({x:o,filter:s,convInfo:d,backend:t});else if(d.strideWidth<=2&&p==="channelsLast"&&O().getBool("WEBGL_EXP_CONV")){let h=new Id(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];f=t.runWebGLProgram(h,[o,s],"float32",g)}else if(O().getBool("WEBGL_CONV_IM2COL"))f=_v({x:o,filter:s,convInfo:d,backend:t});else{let h=new wd(d);f=t.runWebGLProgram(h,[o,s],"float32")}let m=J({inputs:{x:f},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(f),m}var fz={kernelName:mc,backendName:"webgl",kernelFunc:Yie};T();var Av=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,r=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Rv=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,r=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,c=r-1-e.padInfo.left,l=i?1:2,u=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Fv=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,r=e.strideHeight,o=e.strideWidth,s=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Mv=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,r=e.filterHeight,o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,c=t-1-e.padInfo.front,l=r-1-e.padInfo.top,u=o-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Zie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,pad:a,dataFormat:c,dimRoundingMode:l,filterShape:u}=r,p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,u,i,1,a,l,!1,p),f=new Av(d);return t.runWebGLProgram(f,[o,s],"float32")}var mz={kernelName:hc,backendName:"webgl",kernelFunc:Zie};T();var Ov=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Ye(this.outputShape.length);let t=e.filterHeight,r=e.filterWidth,o=t-1-e.padInfo.top,s=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function Qie(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{inputShape:i,strides:a,pad:c,dataFormat:l,dimRoundingMode:u}=r,p=S.convertConv2DDataFormat(l),d=S.computeConv2DInfo(i,s.shape,a,1,c,u,!1,p);if(O().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){let f=[[d.strideHeight,d.strideWidth]],m=new Ov(d);return t.runWebGLProgram(m,[o,s],"float32",f)}else{let f=new Rv(d);return t.runWebGLProgram(f,[o,s],"float32")}}var hz={kernelName:gc,backendName:"webgl",kernelFunc:Qie};T();function Jie(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dilations:c}=r,l=S.computeConv3DInfo(o.shape,s.shape,i,c,a),u=new Sv(l);return t.runWebGLProgram(u,[o,s],"float32")}var gz={kernelName:xc,backendName:"webgl",kernelFunc:Jie};T();function eae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,pad:a,filterShape:c}=r,l=S.computeConv3DInfo(o.shape,c,i,1,a),u=new Fv(l);return t.runWebGLProgram(u,[o,s],"float32")}var xz={kernelName:Pf,backendName:"webgl",kernelFunc:eae};T();function tae(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{pad:i,strides:a,inputShape:c}=r,l=S.computeConv3DInfo(c,s.shape,a,1,i),u=new Mv(l);return t.runWebGLProgram(u,[o,s],"float32")}var yz={kernelName:yc,backendName:"webgl",kernelFunc:tae};T();var nae=_r+`
  return cos(x);
`,rae=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Qn}
  return result;
`,oae=pe({opSnippet:nae,packedOpSnippet:rae}),vz={kernelName:"Cos",backendName:"webgl",kernelFunc:oae};T();var sae=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,iae=pe({opSnippet:sae}),bz={kernelName:si,backendName:"webgl",kernelFunc:iae};T();var $v=class{constructor(e,t,r,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,c,l]=e,[u]=t,[p,d]=r;this.outputShape=[u,p,d,l];let f=o==="bilinear"?1:0,[m,h]=[`${a-1}.0`,`${c-1}.0`],[g,x,v]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[w,I,_]=d>1?[`${(c-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${I};

        float in_y = ${v};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${_};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var aae=n=>{let{inputs:e,backend:t,attrs:r}=n,{image:o,boxes:s,boxInd:i}=e,{cropSize:a,method:c,extrapolationValue:l}=r,u=new $v(o.shape,s.shape,a,c,l);return t.runWebGLProgram(u,[o,s,i],"float32")},Cz={kernelName:wc,backendName:"webgl",kernelFunc:aae};T();var Ed=(function(n){return n.Prod="*",n.Sum="+",n})(Ed||{}),vh=class{constructor(e,t,r,o){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,i=this.op===Ed.Prod?"1.0":"0.0",a=r?i:`getX(${wz(s,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1],l="",u="";r?(l=o?`end != ${c-1}`:"end != 0",u=o?"end + 1":"end - 1"):(l=o?`end + pow2 < ${c}`:"end >= pow2",u=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ve(s)} coords = getOutputCoords();
        int end = ${Iz(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${Iz(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${wz(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function wz(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function Iz(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}T();function Pv(n,e,t,r,o,s){let i=e.shape.length,a=S.getAxesPermutation([r],i),c=e;a!=null&&(c=at({inputs:{x:e},backend:t,attrs:{perm:a}}));let l=S.getInnerMostAxes(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);let u=c.shape[l],p=Et({inputs:{x:c},backend:t});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){let f=new vh(n,c.shape,!1,s),m=[[d]],h=p;p=t.runWebGLProgram(f,[p],p.dtype,m),t.disposeIntermediateTensorInfo(h)}if(o){let d=new vh(n,c.shape,o,s),f=p;p=t.runWebGLProgram(d,[p],p.dtype),t.disposeIntermediateTensorInfo(f)}if(a!=null){let d=S.getUndoAxesPermutation(a),f=at({inputs:{x:p},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(c),f}return p}function cae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,exclusive:i,reverse:a}=r;return Pv(Ed.Prod,o,t,s,i,a)}var Ez={kernelName:bc,backendName:"webgl",kernelFunc:cae};T();function lae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,exclusive:i,reverse:a}=r;return Pv(Ed.Sum,o,t,s,i,a)}var Tz={kernelName:Cc,backendName:"webgl",kernelFunc:lae};T();function uae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,weights:s}=e,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let c=t.readSync(o.dataId),l=t.readSync(s.dataId),u=Qy(c,l,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,u)}else if(o.shape.length===2){let c=t.bufferSync(o),l=t.bufferSync(s),u=lU(c,l,i,a);return t.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var Sz={kernelName:Ic,backendName:"webgl",kernelFunc:uae};T();var Lv=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function pae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockSize:s,dataFormat:i}=r,a=o.shape[0],c=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],u=i==="NHWC"?o.shape[3]:o.shape[1],p=c*s,d=l*s,f=u/(s*s),m=i==="NHWC"?[a,p,d,f]:[a,f,p,d],h=new Lv(m,s,i);return t.runWebGLProgram(h,[o],o.dtype)}var Nz={kernelName:Ec,backendName:"webgl",kernelFunc:pae};T();var Td=class{constructor(e,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ye(this.outputShape.length);let i=e.filterHeight,a=e.filterWidth,c=e.outChannels/e.inChannels,l="",u="";r&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:l=`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);");let p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${u}
        setOutput(result);
      }
    `}};T();var Sd=class{constructor(e,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ye(this.outputShape.length);let i=e.outChannels/e.inChannels,a=e.padInfo.left,c=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,p=e.filterWidth,d=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<p;x++)f+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;f+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let x=0;x<p;x++)f+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(d+1)/2;x++){let v=x*2;if(f+=`
          xC = xCCorner + ${v*l};
          `,c===1){if(v<p&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }
              `,l===1&&v>0?f+=`
                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                  } else {
                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xC${v} = xTexelC${v};
                `,v+1<p)){let w=a%2===0?y.nearestLargerEven(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${v+1}.zw = vec2(0.0);
                    }
                    xTexelC${v+1}Ready = 1;
                  }
                  `,l>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                    } else {
                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                    }
                    `:f+=`
                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                    `):w===1?f+=`
                    xC${v+1} = xTexelC${v};
                    `:f+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${v+1}.zw = vec2(0.0);
                      }
                      xTexelC${v+1}Ready = 1;
                    }

                    xC${v+1} = xTexelC${v+1};
                    `}}else v<p&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.0);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
              `,v+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(
                  xTexelC${v}.xy, xTexelC${v+1}.xy);
              `,v+1<p&&(f+=`
                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                `)));v<p&&(f+=`
            wTexel = getW(r, ${v}, d1, q);
            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);
          `,v+1<p&&(f+=`
              wTexel = getW(r, ${v+1}, d1, q);
              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let m="",h="";r&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:m=`vec4 activation(vec4 x) {
          ${r}
        }`,h="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function dae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dilations:c,dimRoundingMode:l}=r,u=c;u==null&&(u=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(i,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=S.computeConv2DInfo(o.shape,s.shape,i,u,a,l,!0),d;O().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?d=new Sd(p):d=new Td(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return t.runWebGLProgram(d,[o,s],"float32",f)}var Dz={kernelName:Tc,backendName:"webgl",kernelFunc:dae};T();var Bv=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,r=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Vv=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,r=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.top,a=r-1-e.padInfo.left,c=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function fae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,dy:s}=e,{strides:i,dilations:a,pad:c,dimRoundingMode:l,filterShape:u}=r,p=S.computeConv2DInfo(o.shape,u,i,a,c,l,!0),d=new Bv(p);return t.runWebGLProgram(d,[o,s],"float32")}var kz={kernelName:Sc,backendName:"webgl",kernelFunc:fae};T();function mae(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,filter:s}=e,{strides:i,dilations:a,pad:c,dimRoundingMode:l,inputShape:u}=r,p=S.computeConv2DInfo(u,s.shape,i,a,c,l,!0),d=new Vv(p);return t.runWebGLProgram(d,[o,s],"float32")}var _z={kernelName:Nc,backendName:"webgl",kernelFunc:mae};T();var Uv=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function hae(n){let{inputs:e,backend:t}=n,{x:r}=e,o=[...r.shape,...r.shape],s=y.sizeFromShape(r.shape),i=J({inputs:{x:r},backend:t,attrs:{shape:[s]}}),a=new Uv(s),c=t.runWebGLProgram(a,[i],i.dtype),l=J({inputs:{x:c},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),l}var Az={kernelName:Dc,backendName:"webgl",kernelFunc:hae};T();var zv=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:r,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:c,dilationHeight:l,dilationWidth:u}=e,{top:p,left:d}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function gae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s}=e,{strides:i,pad:a,dilations:c}=r,l=S.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",c),u,p=new zv(l);u=t.runWebGLProgram(p,[o,s],"float32");let d=J({inputs:{x:u},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(u),d}var Rz={kernelName:kc,backendName:"webgl",kernelFunc:gae};T();function xae(n){let{inputs:e,backend:t,attrs:r}=n,{equation:o}=r,s=e,{allDims:i,summedDims:a,idDims:c}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,c,s);let{path:l,steps:u}=S.getEinsumComputePath(a,c),p=u.length,d=null,f=i.length,m=[];for(let h=0;h<p;++h){for(let g of u[h]){let{permutationIndices:x,expandDims:v}=S.getEinsumPermutation(f,c[g]),w;S.isIdentityPermutation(x)?w=s[g]:(w=at({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),m.push(w));let I=w.shape.slice();for(let _=0;_<v.length;++_)I.splice(v[_],0,1);y.arraysEqual(w.shape,I)||(w=J({inputs:{x:w},backend:t,attrs:{shape:I}}),m.push(w)),d===null?d=w:(d=xh({inputs:{a:w,b:d},backend:t}),m.push(d))}h<p-1&&(l[h]>=0&&(d=ku({inputs:{x:d},backend:t,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),m.push(d)),f--)}for(let h of m)h!==d&&t.disposeIntermediateTensorInfo(h);return d}var Fz={kernelName:_c,backendName:"webgl",kernelFunc:xae};T();var yae="return (x >= 0.0) ? x : (exp(x) - 1.0);",vae=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,bae=pe({opSnippet:yae,packedOpSnippet:vae}),Mz={kernelName:"Elu",backendName:"webgl",kernelFunc:bae};T();var Cae="return (b >= 0.0) ? a : a * (b + 1.0);",wae=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Iae=n=>{let{inputs:e,backend:t}=n,{dy:r,y:o}=e,s=O().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zn(wae,r.shape,o.shape):new Ln(Cae,r.shape,o.shape);return t.runWebGLProgram(s,[r,o],r.dtype)},Oz={kernelName:Lf,backendName:"webgl",kernelFunc:Iae};T();var Eae=`
  return vec4(equal(a, b));
`,Tae="return float(a == b);",Sae=Ke({opSnippet:Tae,packedOpSnippet:Eae,dtype:"bool",cpuKernelImpl:mU}),$z={kernelName:ai,backendName:"webgl",kernelFunc:Sae};T();var Nae=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${S.ERF_P};
  float a1 = ${S.ERF_A1};
  float a2 = ${S.ERF_A2};
  float a3 = ${S.ERF_A3};
  float a4 = ${S.ERF_A4};
  float a5 = ${S.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Dae=pe({opSnippet:Nae}),Pz={kernelName:"Erf",backendName:"webgl",kernelFunc:Dae};T();var kae=_r+`
  return exp(x);
`,_ae=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,yD=pe({opSnippet:kae,packedOpSnippet:_ae,cpuKernelImpl:hU,dtype:"float32"}),Lz={kernelName:"Exp",backendName:"webgl",kernelFunc:yD};T();function Hv(n){let{inputs:e,attrs:t,backend:r}=n,{dim:o}=t,{input:s}=e,i=s.shape.length,a=s.shape.slice(),c=o;return o<0&&(y.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),c=i+o+1),a.splice(c,0,1),J({inputs:{x:s},backend:r,attrs:{shape:a}})}var Bz={kernelName:Mc,backendName:"webgl",kernelFunc:Hv};T();var Vz="return exp(x) - 1.0;",Aae=pe({opSnippet:Vz,packedOpSnippet:Vz,cpuKernelImpl:gU}),Uz={kernelName:ci,backendName:"webgl",kernelFunc:Aae};T();T();var bh=class{constructor(e,t,r){this.variableNames=["real","imag"];let o=t[1];this.outputShape=t;let s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${o}.0`:"1.0",a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function Gv(n,e,t){let r=t.texData.get(n.dataId),o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=J({inputs:{x:n},backend:t,attrs:{shape:[i,s]}}),c=a.shape,l=new bh("real",c,e),u=new bh("imag",c,e),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],d=t.runWebGLProgram(l,p,"float32"),f=t.runWebGLProgram(u,p,"float32"),m=Bn({inputs:{real:d,imag:f},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f);let h=J({inputs:{x:m},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(m),h}function Rae(n){let{inputs:e,backend:t}=n,{input:r}=e;return Gv(r,!1,t)}var zz={kernelName:"FFT",backendName:"webgl",kernelFunc:Rae};T();var Wv=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function As(n){let{backend:e,attrs:t}=n,{shape:r,value:o}=t,{dtype:s}=t;if(s=s||y.inferDtype(o),s==="string"){let i=y.getArrayFromDType(s,y.sizeFromShape(r));return i.fill(o),e.makeTensorInfo(r,s,i)}else{let i=new Wv(r,o),a=[[o]];return e.runWebGLProgram(i,[],s,a)}}var Hz={kernelName:Oc,backendName:"webgl",kernelFunc:As};T();var jv=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var Gz={kernelName:$c,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{let{image:t}=n,r=e,o=new jv(t.shape);return r.runWebGLProgram(o,[t],t.dtype)}};T();var Wz="return floor(x);",Fae=pe({opSnippet:Wz,packedOpSnippet:Wz,cpuKernelImpl:xU}),jz={kernelName:li,backendName:"webgl",kernelFunc:Fae};T();var Mae=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Oae=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,$ae=Ke({opSnippet:Mae,packedOpSnippet:Oae,dtype:"int32"}),qz={kernelName:ui,backendName:"webgl",kernelFunc:$ae};T();T();var qv=class{constructor(e){this.variableNames=["A"];let t=xt(),[r,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var Kv=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=xt(),[r,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};var Kz={kernelName:Sp,backendName:"webgl",kernelFunc:Pae},Nd,vD=O().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Pae(n){let{inputs:e,backend:t,attrs:r}=n,{pixels:o}=e,{numChannels:s}=r,i=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[c,l]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],u=[l,c],p=[l,c,s];if(a||i){let h=O().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Nd==null||h!==vD)&&(vD=h,Nd=document.createElement("canvas").getContext("2d",{willReadFrequently:vD})),Nd.canvas.width=c,Nd.canvas.height=l,Nd.drawImage(o,0,0,c,l),o=Nd.canvas}let d=t.makeTensorInfo(u,"int32");t.texData.get(d.dataId).usage=vn.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),o);let f=O().getBool("WEBGL_PACK")?new Kv(p):new qv(p),m=t.runWebGLProgram(f,[d],"int32");return t.disposeData(d.dataId),m}T();function Lae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:c,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,h=S.convertConv2DDataFormat(u),g=S.computeConv2DInfo(o.shape,s.shape,c,p,l,d,!1,h),x,v=[],w=i!=null,I=a!=null,_=f==="leakyrelu",A=()=>{let F=[o,s],P=(L,V)=>{if(V==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){let z=J({inputs:{x:L},backend:t,attrs:{shape:[L.shape[0],1,1]}});return v.push(z),z}return L};if(w&&F.push(P(i,u)),I&&F.push(P(a,u)),_){let L=t.makeTensorInfo([],"float32",y.createScalarValue(m,"float32"));F.push(L),v.push(L)}return F};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))x=kv({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:m});else if(g.strideWidth<=2&&h==="channelsLast"&&O().getBool("WEBGL_EXP_CONV")){let F=f?ks(f,!0):null,P=new Id(g,w,F,I,_),L=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],V=A();x=t.runWebGLProgram(P,V,"float32",L)}else if(O().getBool("WEBGL_CONV_IM2COL"))x=_v({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:m});else{let F=f?ks(f,!1):null,P=new wd(g,w,F,I,_),L=A();x=t.runWebGLProgram(P,L,"float32")}let R=J({inputs:{x},backend:t,attrs:{shape:g.outShape}});return v.push(x),v.forEach(F=>t.disposeIntermediateTensorInfo(F)),R}var Xz={kernelName:zi,backendName:"webgl",kernelFunc:Lae};T();function Bae(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:c,pad:l,dilations:u,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r,m=[],h=u;h==null&&(h=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(c,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${h}'`);let g=S.computeConv2DInfo(o.shape,s.shape,c,h,l,p,!0),x=O().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,v=d?ks(d,x):null,w=[o,s],I=i!=null,_=a!=null,A=d==="leakyrelu";if(I&&w.push(i),_&&w.push(a),A){let L=t.makeTensorInfo([],"float32",y.createScalarValue(f,"float32"));w.push(L),m.push(L)}let R;x?R=new Sd(g,I,v,_,A):R=new Td(g,I,v,_,A);let F=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],P=t.runWebGLProgram(R,w,"float32",F);return m.forEach(L=>t.disposeIntermediateTensorInfo(L)),P}var Yz={kernelName:Hi,backendName:"webgl",kernelFunc:Bae};T();var Xv=class{constructor(e,t,r,o){this.sliceDim=e,this.strides=t,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=r;let s=ve(r.length),i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function Vae(n){let{inputs:e,backend:t}=n,{params:r,indices:o}=e,s=o.shape,i=s[s.length-1],a=y.sizeFromShape(r.shape),[c,l,u,p]=S.prepareAndValidate(r,o),d=J({inputs:{x:o},backend:t,attrs:{shape:[l,i]}}),f=J({inputs:{x:r},backend:t,attrs:{shape:[y.sizeFromShape(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,o])||r.dtype==="string"){let x=t.readSync(o.dataId),v=t.bufferSync(r),w=yU(x,v,r.dtype,l,i,u,p,r.shape,a);return t.makeTensorInfo(c,r.dtype,w.values)}let m=new Xv(i,p,[l,u],r.shape),h=t.runWebGLProgram(m,[f,d],f.dtype),g=J({inputs:{x:h},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var Zz={kernelName:Bc,backendName:"webgl",kernelFunc:Vae};T();var Yv=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let r=ve(this.rank),o=Uae(e,2);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function Uae(n,e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let o=0;o<n.length;o++)o===2?r.push("index"):r.push(`${t[o]}`);return r.join()}function bD(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,indices:s}=e,{axis:i,batchDims:a}=r,c=y.parseAxisParam(i,o.shape)[0];if(O().get("DEBUG")){let v=t.readSync(s.dataId),w=o.shape[c];for(let I=0;I<v.length;++I){let _=v[I];y.assert(_<=w-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${w-1}]`)}}let l=S.segment_util.collectGatherOpShapeInfo(o,s,c,a),u=y.sizeFromShape(s.shape),p=[],d=J({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=J({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,u/l.batchSize]}});p.push(d),p.push(f);let m=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let v=t.bufferSync(f),w=t.bufferSync(d),I=vU(w,v,m);return p.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.makeTensorInfo(l.outputShape,I.dtype,I.values)}let h=new Yv(d.shape,m),g=t.runWebGLProgram(h,[d,f],d.dtype);p.push(g);let x=J({inputs:{x:g},backend:t,attrs:{shape:l.outputShape}});return p.forEach(v=>t.disposeIntermediateTensorInfo(v)),x}var Qz={kernelName:Lc,backendName:"webgl",kernelFunc:bD};T();var zae="return float(a > b);",Hae=`
  return vec4(greaterThan(a, b));
`,Gae=Ke({opSnippet:zae,packedOpSnippet:Hae,cpuKernelImpl:bU,dtype:"bool"}),Jz={kernelName:pi,backendName:"webgl",kernelFunc:Gae};T();var Wae="return float(a >= b);",jae=`
  return vec4(greaterThanEqual(a, b));
`,qae=Ke({opSnippet:Wae,packedOpSnippet:jae,dtype:"bool",cpuKernelImpl:CU}),eH={kernelName:di,backendName:"webgl",kernelFunc:qae};T();function Kae(n){let{inputs:e,backend:t}=n,{input:r}=e;return Gv(r,!0,t)}var tH={kernelName:Vc,backendName:"webgl",kernelFunc:Kae};T();var Xae="return float(!isnan(x) && !isinf(x));",Yae=pe({opSnippet:Xae,dtype:"bool"}),nH={kernelName:fi,backendName:"webgl",kernelFunc:Yae};T();var Zae="return float(isinf(x));",Qae=pe({opSnippet:Zae,dtype:"bool"}),rH={kernelName:mi,backendName:"webgl",kernelFunc:Qae};T();var Jae="return float(isnan(x));",ece=pe({opSnippet:Jae,dtype:"bool"}),oH={kernelName:hi,backendName:"webgl",kernelFunc:ece};T();var tce="return float(a < b);",nce=`
  return vec4(lessThan(a, b));
`,rce=Ke({opSnippet:tce,packedOpSnippet:nce,cpuKernelImpl:wU,dtype:"bool"}),sH={kernelName:gi,backendName:"webgl",kernelFunc:rce};T();var oce="return float(a <= b);",sce=`
  return vec4(lessThanEqual(a, b));
`,ice=Ke({opSnippet:oce,packedOpSnippet:sce,cpuKernelImpl:IU,dtype:"bool"}),iH={kernelName:xi,backendName:"webgl",kernelFunc:ice};T();function ace(n){let{backend:e,attrs:t}=n,{start:r,stop:o,num:s}=t,i=EU(r,o,s);return e.makeTensorInfo([i.length],"float32",i)}var aH={kernelName:Hc,backendName:"webgl",kernelFunc:ace};T();var cce=_r+`
  return x < 0.0 ? 0./0. : log(x);
`,lce=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,uce=pe({opSnippet:cce,packedOpSnippet:lce,cpuKernelImpl:TU}),cH={kernelName:"Log",backendName:"webgl",kernelFunc:uce};T();var pce=_r+`
  return log(1.0 + x);
`,dce=pe({opSnippet:pce}),lH={kernelName:yi,backendName:"webgl",kernelFunc:dce};T();var fce="return float(a >= 1.0 && b >= 1.0);",mce=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,hce=Ke({opSnippet:fce,packedOpSnippet:mce,dtype:"bool"}),uH={kernelName:vi,backendName:"webgl",kernelFunc:hce};T();var gce="return float(!(x >= 1.0));",xce=pe({opSnippet:gce}),pH={kernelName:bi,backendName:"webgl",kernelFunc:xce};T();var yce="return float(a >= 1.0 || b >= 1.0);",vce=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,bce=Ke({opSnippet:yce,packedOpSnippet:vce,dtype:"bool"}),dH={kernelName:Ci,backendName:"webgl",kernelFunc:bce};T();var Zv=class{constructor(e,t,r,o,s){this.variableNames=["x"],this.outputShape=[];let i=t,a=e[3]-1;this.outputShape=e;let c,l=`float(${r}) + float(${o}) * sum`;s===.5?c=`inversesqrt(${l})`:s===1?c=`1.0/(${l})`:c=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}};var Qv=class{constructor(e,t,r,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=t,a=e[3]-1;this.outputShape=e;let c,l=`float(${r}) + float(${o}) * sum`;s===.5?c=`inversesqrt(${l})`:s===1?c=`1.0/(${l})`:c=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}};var Cce=n=>{let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{depthRadius:s,bias:i,alpha:a,beta:c}=r,l=O().getBool("WEBGL_PACK_NORMALIZATION")?new Qv(o.shape,s,i,a,c):new Zv(o.shape,s,i,a,c);return t.runWebGLProgram(l,[o],o.dtype)},fH={kernelName:"LRN",backendName:"webgl",kernelFunc:Cce};T();var Jv=class{constructor(e,t,r,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var wce=n=>{let{inputs:e,backend:t,attrs:r}=n,{x:o,y:s,dy:i}=e,{depthRadius:a,bias:c,alpha:l,beta:u}=r,p=new Jv(o.shape,a,c,l,u);return t.runWebGLProgram(p,[o,s,i],o.dtype)},mH={kernelName:Bf,backendName:"webgl",kernelFunc:wce};T();T();T();function hH(n,e,t,r){let o=y.sizeFromShape(e),i=y.sizeFromShape(n.shape)/o,a=J({inputs:{x:n},attrs:{shape:[i,o]},backend:r}),c=Jn(a,n.dtype,"max",r),l=J({inputs:{x:c},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(c),l}function CD(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{reductionIndices:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),l=c,u=S.getAxesPermutation(l,a),p=u!=null,d=t.shouldExecuteOnCPU([o]),f=o;if(p){if(d){let w=t.texData.get(f.dataId).values,I=new Array(a);for(let R=0;R<I.length;R++)I[R]=o.shape[u[R]];let _=Du(w,o.shape,o.dtype,u,I);f=t.makeTensorInfo(I,o.dtype);let A=t.texData.get(f.dataId);A.values=_}else f=ha(o,u,t);l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("max",l,a);let[m,h]=S.computeOutAndReduceShapes(f.shape,l),g=m;i&&(g=S.expandShapeToKeepDim(m,c));let x;if(d){let w=t.texData.get(f.dataId).values,I=SU(w,y.sizeFromShape(h),g,o.dtype);x=t.makeTensorInfo(g,o.dtype);let _=t.texData.get(x.dataId);_.values=I}else x=hH(f,h,g,t);return p&&t.disposeIntermediateTensorInfo(f),x}var gH={kernelName:"Max",backendName:"webgl",kernelFunc:CD};T();var Ice=vd+`
  return max(a, b);
`,Ece=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Qn+`
  return result;
`,Tce=Ke({opSnippet:Ice,packedOpSnippet:Ece,cpuKernelImpl:NU}),xH={kernelName:wi,backendName:"webgl",kernelFunc:Tce};T();function Sce(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e;Ho(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let u=S.computePool2DInfo(o.shape,s,i,l,a,c);if(u.filterWidth===1&&u.filterHeight===1&&y.arraysEqual(u.inShape,u.outShape))return Et({inputs:{x:o},backend:t});let p=new ao(u,"max",!1);return t.runWebGLProgram(p,[o],o.dtype)}var yH={kernelName:Wc,backendName:"webgl",kernelFunc:Sce};T();function Nce(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{filterSize:s,strides:i,pad:a,dataFormat:c,dimRoundingMode:l}=r,u=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,u,a,l,c),d=new ga(p,"max",!1);return t.runWebGLProgram(d,[o],o.dtype)}var vH={kernelName:jc,backendName:"webgl",kernelFunc:Nce};T();var eb=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,s=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=s-1-e.padInfo.top,c=i-1-e.padInfo.left,l=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},tb=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,r=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,c=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,p=c-1-e.padInfo.front,d=l-1-e.padInfo.top,f=u-1-e.padInfo.left,m=c*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Dce(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s}=e,i=s,{filterSize:a,strides:c,pad:l,dimRoundingMode:u}=r,p=[1,1,1],d=S.computePool3DInfo(i.shape,a,c,p,l,u),f=new ga(d,"max",!0),m=t.runWebGLProgram(f,[i],i.dtype),h=new tb(d),g=t.runWebGLProgram(h,[o,m],i.dtype);return t.disposeIntermediateTensorInfo(m),g}var bH={kernelName:Uf,backendName:"webgl",kernelFunc:Dce};T();function kce(n){let{inputs:e,backend:t,attrs:r}=n,{dy:o,input:s,output:i}=e,a=s;Ho([s,i],"maxPoolGrad");let{filterSize:c,strides:l,pad:u,dimRoundingMode:p}=r,d=S.computePool2DInfo(a.shape,c,l,1,u,p),f=!0,m=new ao(d,"max",f),h=t.runWebGLProgram(m,[a],a.dtype),g=new eb(d),x=t.runWebGLProgram(g,[o,h],a.dtype);return t.disposeIntermediateTensorInfo(h),x}var CH={kernelName:Vf,backendName:"webgl",kernelFunc:kce};T();T();function wH(n,e,t,r){let o=new ao(t,"max",!1),s=r.runWebGLProgram(o,[n],"float32");o=new ao(t,"max",!0,!0,e);let i=r.runWebGLProgram(o,[n],"float32");return[s,i]}var IH={kernelName:qc,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{x:r}=n,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=e,c=t;y.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let l=[1,1];y.assert(S.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let u=S.computePool2DInfo(r.shape,o,s,l,i),[p,d]=wH(r,a,u,c);return[p,d]}};T();T();function EH(n,e,t,r){let o=y.sizeFromShape(e),i=y.sizeFromShape(n.shape)/o,a=J({inputs:{x:n},attrs:{shape:[i,o]},backend:r}),c=Jn(a,"float32","mean",r),l=J({inputs:{x:c},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(c),l}var TH={kernelName:Kc,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{x:r}=n,{keepDims:o,axis:s}=e,i=t,a=r.shape.length,c=y.parseAxisParam(s,r.shape),l=c,u=S.getAxesPermutation(l,a),p=u!=null,d=i.shouldExecuteOnCPU([r]),f=[],m=r;if(p){if(d){let I=i.texData.get(m.dataId).values,_=new Array(a);for(let F=0;F<_.length;F++)_[F]=r.shape[u[F]];let A=Du(I,r.shape,r.dtype,u,_);m=i.makeTensorInfo(_,r.dtype);let R=i.texData.get(m.dataId);R.values=A}else m=ha(r,u,i);f.push(m),l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("sum",l,a);let[h,g]=S.computeOutAndReduceShapes(m.shape,l),x=h;o&&(x=S.expandShapeToKeepDim(h,c));let v=EH(m,g,x,i);for(let w of f)i.disposeIntermediateTensorInfo(w);return v}};T();function _ce(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),l=c,u=S.getAxesPermutation(l,a),p=o;u!=null&&(p=at({inputs:{x:o},backend:t,attrs:{perm:u}}),l=S.getInnerMostAxes(l.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",l,a);let[d,f]=S.computeOutAndReduceShapes(p.shape,l),m=y.sizeFromShape(f),h=J({inputs:{x:p},backend:t,attrs:{shape:[-1,m]}}),g=Jn(h,h.dtype,"min",t),x;if(i){let v=S.expandShapeToKeepDim(d,c);x=J({inputs:{x:g},backend:t,attrs:{shape:v}})}else x=J({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(p),x}var SH={kernelName:"Min",backendName:"webgl",kernelFunc:_ce};T();var Ace=vd+`
  return min(a, b);
`,Rce=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Qn+`
  return result;
`,Fce=Ke({opSnippet:Ace,packedOpSnippet:Rce,cpuKernelImpl:DU}),NH={kernelName:Ii,backendName:"webgl",kernelFunc:Fce};T();var nb=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((u,p)=>u[0]+e[p]+u[1]);let o=e.length,s=ve(o),i=t.map(u=>u[0]).join(","),a=t.map((u,p)=>u[0]+e[p]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=r==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}};var rb=class{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((m,h)=>m[0]+e[h]+m[1]);let o=e.length,s=ve(o),i=t.map(m=>m[0]).join(","),a=t.map((m,h)=>m[0]+e[h]).join(","),c=It("rc",o),l=It("source",o),u=`${c[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,d=r==="reflect"?0:1,f="";if(o===1){let m=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${c[o-1]} += 1;
        if(${u}) {
          ${m}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `}else{let m=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${c[o-1]} += 1;
        if(${u}) {
          ${m}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${c[o-2]} += 1;
        if(${c[o-2]} < ${this.outputShape[o-2]}) {
          ${m}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${c[o-1]} += 1;
          if(${u}) {
            ${m}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var Mce=({inputs:n,backend:e,attrs:t})=>{let{x:r}=n,{paddings:o,mode:s}=t,i=O().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rb(r.shape,o,s):new nb(r.shape,o,s);return e.runWebGLProgram(i,[r],r.dtype)},DH={kernelName:Xc,backendName:"webgl",kernelFunc:Mce};T();var Oce=`if (b == 0.0) return NAN;
  return mod(a, b);`,$ce=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Qn+`
  return result;
`,Pce=Ke({opSnippet:Oce,packedOpSnippet:$ce}),kH={kernelName:"Mod",backendName:"webgl",kernelFunc:Pce};T();var ob=class{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};T();T();var Lce=`
if (a == b) {
  return 1.0;
};
return a / b;`,Bce=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,wD=Ke({opSnippet:Lce,packedOpSnippet:Bce,checkOutOfBounds:!0}),_H={kernelName:ii,backendName:"webgl",kernelFunc:wD};T();var AH="return a - b;",ID=Ke({opSnippet:AH,packedOpSnippet:AH,supportsComplex:!0,cpuKernelImpl:XU}),RH={kernelName:"Sub",backendName:"webgl",kernelFunc:ID};function ED(n){let{inputs:e,backend:t,attrs:r}=n,{logits:o}=e,{dim:s}=r,i=y.parseAxisParam([s],o.shape),a=CD({inputs:{x:o},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),c=S.expandShapeToKeepDim(a.shape,i),l=J({inputs:{x:a},backend:t,attrs:{shape:c}}),u=ID({inputs:{a:o,b:l},backend:t}),p=yD({inputs:{x:u},backend:t}),d=ku({inputs:{x:p},backend:t,attrs:{axis:i,keepDims:!1}}),f=J({inputs:{x:d},backend:t,attrs:{shape:c}}),m=wD({inputs:{a:p,b:f},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),m}var FH={kernelName:Tl,backendName:"webgl",kernelFunc:ED};function Vce(n){let{inputs:e,backend:t,attrs:r}=n,{logits:o}=e,{numSamples:s,seed:i,normalized:a}=r,c=a?o:ED({inputs:{logits:o},backend:t,attrs:{dim:o.shape.length-1}}),l=c.shape[0],u=c.shape[1],p=new ob(l,u,s),d=[[i]],f=t.runWebGLProgram(p,[c],"int32",d);return a||t.disposeIntermediateTensorInfo(c),f}var MH={kernelName:Zc,backendName:"webgl",kernelFunc:Vce};T();var Uce=Mt+`
  return -x;
`,zce=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Hce(n){let{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){let s=t.texData.get(r.dataId),[i,a]=_U(s.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,i)}let o;return O().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Pn(r.shape,zce):o=new en(r.shape,Uce),t.runWebGLProgram(o,[r],r.dtype)}var OH={kernelName:"Neg",backendName:"webgl",kernelFunc:Hce};T();var Gce=Jt.nonMaxSuppressionV3Impl;function Wce(n){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c}=r,l=t.readSync(o.dataId),u=t.readSync(s.dataId),{selectedIndices:p}=Gce(l,u,i,a,c);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}var $H={kernelName:Qc,backendName:"webgl",kernelFunc:Wce};T();var jce=Jt.nonMaxSuppressionV4Impl;function qce(n){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,padToMaxOutputSize:l}=r,u=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:d,validOutputs:f}=jce(u,p,i,a,c,l);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var PH={kernelName:Jc,backendName:"webgl",kernelFunc:qce};T();var Kce=Jt.nonMaxSuppressionV5Impl;function Xce(n){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:r}=n,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,softNmsSigma:l}=r,u=t.readSync(o.dataId),p=t.readSync(s.dataId),d=i,f=a,m=c,h=l,{selectedIndices:g,selectedScores:x}=Kce(u,p,d,f,m,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var LH={kernelName:el,backendName:"webgl",kernelFunc:Xce};T();var sb=class{constructor(e,t,r,o){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${r}),
                      float(index == coords.y)));
      }
    `}};var Yce=n=>{let{inputs:e,backend:t,attrs:r}=n,{indices:o}=e,{dtype:s,depth:i,onValue:a,offValue:c}=r,l=y.sizeFromShape(o.shape),u=new sb(l,i,a,c),p=J({inputs:{x:o},backend:t,attrs:{shape:[l]}}),d=t.runWebGLProgram(u,[p],s);t.disposeIntermediateTensorInfo(p);let f=[...o.shape,i],m=J({inputs:{x:d},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(d),m},BH={kernelName:nl,backendName:"webgl",kernelFunc:Yce};T();T();function Ch(n){let{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){let o=_s({inputs:{input:r},backend:t}),s=Ch({inputs:{x:o},backend:t}),i=Au({inputs:{input:r},backend:t}),a=Ch({inputs:{x:i},backend:t}),c=Bn({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return As({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}var VH={kernelName:zl,backendName:"webgl",kernelFunc:Ch};function UH(n){let{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let o=_s({inputs:{input:r},backend:t}),s=UH({inputs:{x:o},backend:t}),i=Au({inputs:{input:r},backend:t}),a=Ch({inputs:{x:i},backend:t}),c=Bn({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return As({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}var zH={kernelName:tl,backendName:"webgl",kernelFunc:UH};T();function Zce(n){let{inputs:e,backend:t,attrs:r}=n,{axis:o}=r;if(e.length===1)return Hv({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,i=e[0].dtype;e.forEach(u=>{y.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],c=e.map(u=>{let p=Hv({inputs:{input:u},backend:t,attrs:{dim:o}});return a.push(p),p}),l=xD({inputs:c,backend:t,attrs:{axis:o}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),l}var HH={kernelName:rl,backendName:"webgl",kernelFunc:Zce};T();var ib=class{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);let o=e.length,s=ve(o),i=t.map(l=>l[0]).join(","),a=t.map((l,u)=>l[0]+e[u]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}};var ab=class{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((h,g)=>h[0]+e[g]+h[1]);let o=e.length,s=ve(o),i=t.map(h=>h[0]).join(","),a=t.map((h,g)=>h[0]+e[g]).join(","),c=It("rc",o),l=It("source",o),u=`${c[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${c[o-1]} += 1;
       if(${u}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${c[o-2]} += 1;
       if(${c[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${c[o-1]} += 1;
         if(${u}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",m="";for(let h=0,g=o===1?2:4;h<g;h++)m+=`
        ${d[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${p});
        }
      `;m+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}};var TD=n=>{let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{paddings:s,constantValue:i}=r;if(y.sizeFromShape(o.shape)===0){let l=s.map((u,p)=>u[0]+o.shape[p]+u[1]);return As({backend:t,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=O().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ab(o.shape,s,i):new ib(o.shape,s,i),c=[[i]];return t.runWebGLProgram(a,[o],o.dtype,c)},GH={kernelName:ol,backendName:"webgl",kernelFunc:TD};T();var Qce=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Jce=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Qn+`
  return result;
`,ele=Ke({opSnippet:Qce,packedOpSnippet:Jce}),WH={kernelName:"Pow",backendName:"webgl",kernelFunc:ele};T();function tle(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{axis:s,keepDims:i}=r,a=o.shape.length,c=[],l=y.parseAxisParam(s,o.shape),u=l,p=S.getAxesPermutation(u,a),d=o;p!=null&&(d=at({inputs:{x:o},backend:t,attrs:{perm:p}}),u=S.getInnerMostAxes(u.length,a),c.push(d)),S.assertAxesAreInnerMostDims("prod",u,a);let f;if(t.shouldExecuteOnCPU([d])){let m=t.texData.get(d.dataId).values,{outVals:h,outShape:g,outDtype:x}=RU(d.shape,d.dtype,m,u);f=t.makeTensorInfo(g,x,h)}else{let[m,h]=S.computeOutAndReduceShapes(d.shape,u),g=y.sizeFromShape(h),x=J({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),v=ji(o.dtype),w=Jn(x,v,"prod",t);f=J({inputs:{x:w},backend:t,attrs:{shape:m}}),c.push(x),c.push(w)}if(i){c.push(f);let m=S.expandShapeToKeepDim(f.shape,l);f=J({inputs:{x:f},backend:t,attrs:{shape:m}})}return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}var jH={kernelName:al,backendName:"webgl",kernelFunc:tle};T();function nle(n){let{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=e,{outputRaggedRank:a}=r,c=o.map(x=>t.readSync(x.dataId)),l=o.map(x=>x.shape),u=t.readSync(s.dataId),p=t.readSync(i.dataId),[d,f,m]=FU(c,l,u,s.shape,s.dtype,p,i.shape,a),h=d.map(x=>t.makeTensorInfo([x.length],"int32",x)),g=t.makeTensorInfo(m,s.dtype,f);return h.concat([g])}var qH={kernelName:cl,backendName:"webgl",kernelFunc:nle};T();function rle(n){let{inputs:e,backend:t}=n,{starts:r,limits:o,deltas:s}=e,i=t.readSync(r.dataId),a=t.readSync(o.dataId),c=t.readSync(s.dataId),[l,u]=MU(i,r.shape,r.dtype,a,o.shape,c,s.shape),p=t.makeTensorInfo([l.length],"int32",l),d=t.makeTensorInfo([u.length],r.dtype,u);return[p,d]}var KH={kernelName:ll,backendName:"webgl",kernelFunc:rle};T();function ole(n){let{inputs:e,backend:t,attrs:r}=n,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:c}=r,l=t.readSync(o.dataId),u=t.readSync(s.dataId),p=t.readSync(i.dataId),d=a.map(g=>t.readSync(g.dataId)),f=a.map(g=>g.shape),[m,h]=OU(l,o.shape,u,s.shape,s.dtype,p,i.shape,d,f,c);return t.makeTensorInfo(m,s.dtype,h)}var XH={kernelName:ul,backendName:"webgl",kernelFunc:ole};T();var SD=n=>{let{backend:e,attrs:t}=n,{start:r,stop:o,step:s,dtype:i}=t,a=$U(r,o,s,i);return e.makeTensorInfo([a.length],i,a)},YH={kernelName:pl,backendName:"webgl",kernelFunc:SD};T();var sle="return 1.0 / x;",ile=pe({opSnippet:sle}),ZH={kernelName:Si,backendName:"webgl",kernelFunc:ile};T();var ale=Mt+`
  return (x < 0.0) ? 0.0 : x;
`,cle=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lle=pe({opSnippet:ale,packedOpSnippet:cle}),QH={kernelName:Ni,backendName:"webgl",kernelFunc:lle};T();var ule=Mt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ple=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dle=pe({opSnippet:ule,packedOpSnippet:ple}),JH={kernelName:Di,backendName:"webgl",kernelFunc:dle};T();var cb=class{constructor(e,t,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,c,l]=e;this.outputShape=[i,t,r,l];let u=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/p[0]},
          ${u[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var lb=class{constructor(e,t,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,c,l]=e;this.outputShape=[i,t,r,l];let u=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/p[0]},
          ${u[1]/p[1]},
          ${u[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function fle(n){let{inputs:e,backend:t,attrs:r}=n,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=r,[c,l]=a,u=O().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new lb(o.shape,c,l,s,i):new cb(o.shape,c,l,s,i);return t.runWebGLProgram(u,[o],"float32")}var eG={kernelName:hl,backendName:"webgl",kernelFunc:fle};T();var ub=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,o,s]=t,[,i,a]=e,c=[r&&i>1?o-1:o,r&&a>1?s-1:s],l=[r&&i>1?i-1:i,r&&a>1?a-1:a],u=c[0]/l[0],p=c[1]/l[1],d=1/u,f=1/p,m=Math.ceil(d)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function mle(n){let{inputs:e,backend:t,attrs:r}=n,{images:o,dy:s}=e,{alignCorners:i}=r,a=new ub(s.shape,o.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}var tG={kernelName:Hf,backendName:"webgl",kernelFunc:mle};T();var pb=class{constructor(e,t,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,c,l]=e;this.outputShape=[i,t,r,l];let u=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/p[0]},
          ${u[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var db=class{constructor(e,t,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,c,l]=e;this.outputShape=[i,t,r,l];let u=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d=o?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/p[0]},
          ${u[1]/p[1]},
          ${u[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function hle(n){let{inputs:e,backend:t,attrs:r}=n,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=r,[c,l]=a,u=O().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new db(o.shape,c,l,s,i):new pb(o.shape,c,l,s,i);return t.runWebGLProgram(u,[o],o.dtype)}var nG={kernelName:ml,backendName:"webgl",kernelFunc:hle};T();var fb=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,o,s]=t,[,i,a]=e,c=[r&&i>1?o-1:o,r&&a>1?s-1:s],l=[r&&i>1?i-1:i,r&&a>1?a-1:a],u=c[0]/l[0],p=c[1]/l[1],d=1/u,f=1/p,m=Math.ceil(d)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function gle(n){let{inputs:e,backend:t,attrs:r}=n,{images:o,dy:s}=e,{alignCorners:i}=r,a=new fb(s.shape,o.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}var rG={kernelName:zf,backendName:"webgl",kernelFunc:gle};T();var mb=class{constructor(e,t){this.variableNames=["x"];let r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let o=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,s=e.map((a,c)=>o(c)).join(","),i=ve(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var hb=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;let o=It("rc",r),s=`${o[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${o[r-2]} + 1 < ${this.outputShape[r-2]}`,a=ve(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${i}) {
            result.b = ${u(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(m){return d(m)}function l(m){return m[r-1]="("+m[r-1]+" + 1)",d(m)}function u(m){return m[r-2]="("+m[r-2]+" + 1)",d(m)}function p(m){return m[r-1]="("+m[r-1]+" + 1)",m[r-2]="("+m[r-2]+" + 1)",d(m)}function d(m){let h=e.map((v,w)=>f(w,m)),g=h.join(","),x=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${x}))`}function f(m,h){return t.indexOf(m)!==-1&&e[m]!==1?`${e[m]} - ${h[m]} - 1`:`${h[m]}`}}};function xle(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{dims:s}=r,i=o.shape.length,a=y.parseAxisParam(s,o.shape);if(i===0)return Et({inputs:{x:o},backend:t});let c=O().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hb(o.shape,a):new mb(o.shape,a);return t.runWebGLProgram(c,[o],o.dtype)}var oG={kernelName:gl,backendName:"webgl",kernelFunc:xle};T();T();var gb=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let r=e[1],o=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var sG={kernelName:Hl,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{let{image:r}=n,{radians:o,fillValue:s,center:i}=e,a=t,c=new gb(r.shape,s),[l,u]=S.getImageCenter(i,r.shape[1],r.shape[2]),p=[[l,u,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(c,[r],r.dtype,p)}};T();var yle=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,vle=pe({opSnippet:yle}),iG={kernelName:ki,backendName:"webgl",kernelFunc:vle};T();var ble="return inversesqrt(x);",Cle=pe({opSnippet:ble,cpuKernelImpl:PU}),aG={kernelName:_i,backendName:"webgl",kernelFunc:Cle};T();var xa=class{constructor(e,t,r,o,s,i,a=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let l=ve(s.length),u=ve(i.length),p="";r===1?p="i":r===2&&(p="i, j");let d=`getIndices(${p})`,f="";o===1?f="i":o===2&&(f="i, coords[1]");let m=`getUpdates(${f})`,h="";c&&(h="coords[0], coords[1]");let g=`getDefaultValue(${h})`,x=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${x};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${m};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}};var xb=class{constructor(e,t,r,o,s,i,a=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let l=ve(s.length),u=ve(i.length),p="";r===1?p="i":r===2&&(p="i, j");let d=`getIndices(${p})`,f="";o===1?f="i":o===2&&(f="i, coords[1]");let m=`getUpdates(${f})`,h="";c&&(h="coords[0], coords[1]");let g=`getDefaultValue(${h})`,x=t>1?"strides[j]":"strides",v=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${x};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${v};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${m};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}};function wle(n){let{inputs:e,backend:t,attrs:r}=n,{indices:o,updates:s}=e,{shape:i}=r,{sliceRank:a,numUpdates:c,sliceSize:l,strides:u,outputSize:p}=S.calculateShapes(s,o,i),d=[p/l,l];if(p===0)return t.makeTensorInfo(i,o.dtype);let f=J({inputs:{x:o},backend:t,attrs:{shape:[c,a]}}),m=J({inputs:{x:s},backend:t,attrs:{shape:[c,l]}}),h=t.makeTensorInfo([],"float32",new Float32Array([0])),g;O().getBool("WEBGL_PACK")?g=new xb(c,a,f.shape.length,m.shape.length,u,d):g=new xa(c,a,f.shape.length,m.shape.length,u,d);let x=t.runWebGLProgram(g,[m,f,h],m.dtype),v=J({inputs:{x},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(h),v}var cG={kernelName:xl,backendName:"webgl",kernelFunc:wle};T();T();var yb=class{constructor(e,t,r,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=O().getNumber("WEBGL_VERSION")===2?s:i,c=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Ile(n){let{inputs:e,backend:t,attrs:r}=n,{sortedSequence:o,values:s}=e,{side:i}=r,a=new yb(o.shape[0],o.shape[1],s.shape[1],i),c=[[o.shape[1]]];return t.runWebGLProgram(a,[o,s],"int32",c)}var lG={kernelName:vl,backendName:"webgl",kernelFunc:Ile};T();var vb=class{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let o,s;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],l=[];for(let u=0;u<t.length;u++)l.push(`${a[u]}`),u<e&&c.push(`${a[u]}`);o=c.join(),s=l.join()}let i=ve(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Ele(n){let{inputs:e,backend:t}=n,{condition:r,t:o,e:s}=e,i=new vb(r.shape.length,o.shape,o.shape.length);return t.runWebGLProgram(i,[r,o,s],Dt(o.dtype,s.dtype))}var uG={kernelName:bl,backendName:"webgl",kernelFunc:Ele};T();var Tle=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${S.SELU_SCALEALPHA};
  float scale = ${S.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Sle=pe({opSnippet:Tle}),pG={kernelName:Ai,backendName:"webgl",kernelFunc:Sle};T();var Nle=_r+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Dle=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,kle=pe({opSnippet:Nle,packedOpSnippet:Dle,cpuKernelImpl:BU}),dG={kernelName:Mi,backendName:"webgl",kernelFunc:kle};T();var _le=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Ale=pe({opSnippet:_le}),fG={kernelName:Fi,backendName:"webgl",kernelFunc:Ale};T();var Rle=_r+`
  return sin(x);
`,Fle=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Qn}
  return result;
`,Mle=pe({opSnippet:Rle,packedOpSnippet:Fle}),mG={kernelName:"Sin",backendName:"webgl",kernelFunc:Mle};T();var Ole=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,$le=pe({opSnippet:Ole}),hG={kernelName:Ri,backendName:"webgl",kernelFunc:$le};T();var Ple=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Lle=pe({opSnippet:Ple}),gG={kernelName:Oi,backendName:"webgl",kernelFunc:Lle};T();var Ble=n=>{let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{blockShape:s,paddings:i}=r;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((x,v)=>x*v),c=[[0,0]];c.push(...i);for(let x=1+s.length;x<o.shape.length;++x)c.push([0,0]);let l=[],u=TD({inputs:{x:o},backend:t,attrs:{paddings:c,constantValue:0}}),p=S.getReshaped(u.shape,s,a,!1),d=S.getPermuted(p.length,s.length,!1),f=S.getReshapedPermuted(u.shape,s,a,!1),m=J({inputs:{x:u},backend:t,attrs:{shape:p}}),h=at({inputs:{x:m},backend:t,attrs:{perm:d}}),g=J({inputs:{x:h},backend:t,attrs:{shape:f}});return l.push(u),l.push(m),l.push(h),l.forEach(x=>t.disposeIntermediateTensorInfo(x)),g},xG={kernelName:Il,backendName:"webgl",kernelFunc:Ble};T();function Vle(n){let{inputs:e,backend:t}=n,{indices:r,values:o,denseShape:s,defaultValue:i}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=t.readSync(r.dataId),c=t.readSync(o.dataId),l=t.readSync(s.dataId),u=t.readSync(i.dataId)[0],[p,d,f,m,h]=UU(a,r.shape,r.dtype,c,o.dtype,l,u);return[t.makeTensorInfo(d,r.dtype,p),t.makeTensorInfo([d[0]],o.dtype,f),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}var yG={kernelName:Sl,backendName:"webgl",kernelFunc:Vle};T();function Ule(n){let{inputs:e,backend:t}=n,{inputIndices:r,inputShape:o,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(t.readSync(o.dataId)),a=t.readSync(r.dataId),c=Array.from(t.readSync(s.dataId)),[l,u,p]=zU(a,r.shape,r.dtype,i,c);return[t.makeTensorInfo(u,r.dtype,l),t.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var vG={kernelName:Nl,backendName:"webgl",kernelFunc:Ule};T();function zle(n){let{inputs:e,backend:t}=n,{data:r,indices:o,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=t.readSync(r.dataId),a=t.readSync(o.dataId),c=t.readSync(s.dataId),[l,u]=ev(i,r.shape,r.dtype,a,c,!0);return t.makeTensorInfo(u,r.dtype,l)}var bG={kernelName:Dl,backendName:"webgl",kernelFunc:zle};T();function Hle(n){let{inputs:e,backend:t}=n,{data:r,indices:o,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=t.readSync(r.dataId),a=t.readSync(o.dataId),c=t.readSync(s.dataId),[l,u]=ev(i,r.shape,r.dtype,a,c);return t.makeTensorInfo(u,r.dtype,l)}var CG={kernelName:kl,backendName:"webgl",kernelFunc:Hle};T();function Gle(n){let{inputs:e,backend:t,attrs:r}=n,{sparseIndices:o,sparseValues:s,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:c,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=S.calculateShapes(s,o,a),f=!1;if(s.dtype==="string"){let x=t.bufferSync(o),v=t.bufferSync(s),w=y.decodeString(t.readSync(i.dataId)[0]),I=LU(x,v,a,d,u,l,c,p,w,f);return t.makeTensorInfo(a,I.dtype,I.values)}let m=new xa(l,c,o.shape.length,s.shape.length,p,[d,1],f),h=t.runWebGLProgram(m,[s,o,i],s.dtype),g=J({inputs:{x:h},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(h),g}var wG={kernelName:_l,backendName:"webgl",kernelFunc:Gle};T();function Wle(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{numOrSizeSplits:s,axis:i}=r,a=y.parseAxisParam(i,o.shape)[0],c=S.prepareSplitSize(o,s,a),l=o.shape.length,u=new Array(l).fill(0),p=o.shape.slice();return c.map(d=>{let f=[...p];f[a]=d;let m=co({inputs:{x:o},backend:t,attrs:{begin:u,size:f}});return u[a]+=d,m})}var IG={kernelName:El,backendName:"webgl",kernelFunc:Wle};T();var EG="return sqrt(x);",jle=pe({opSnippet:EG,packedOpSnippet:EG,cpuKernelImpl:HU}),TG={kernelName:$i,backendName:"webgl",kernelFunc:jle};T();var qle="return x * x;",Kle=pe({opSnippet:qle}),SG={kernelName:Gf,backendName:"webgl",kernelFunc:Kle};T();var NG="return (a - b) * (a - b);",Xle=Ke({opSnippet:NG,packedOpSnippet:NG}),DG={kernelName:Pi,backendName:"webgl",kernelFunc:Xle};T();function Yle(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");let s=t.readSync(o.dataId),i=S.fromUint8ToStringArray(s),a=GU(i,"string",r);return t.makeTensorInfo(o.shape,"string",a)}var kG={kernelName:Li,backendName:"webgl",kernelFunc:Yle};T();function Zle({inputs:n,attrs:e,backend:t}){let{x:r}=n,o=Mt+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new en(r.shape,o);return t.runWebGLProgram(s,[r],r.dtype)}var _G={kernelName:Vi,backendName:"webgl",kernelFunc:Zle};T();var bb=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;let o=r.length,s=ve(r.length),i=ve(r.length),a="";if(o===1)a="coords * strides + begin";else{let c=0;a=r.map((l,u)=>(c++,r.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${c-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function Qle(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{begin:s,end:i,strides:a,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:p,shrinkAxisMask:d}=r,{finalShapeSparse:f,finalShape:m,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:v,end:w,strides:I}=$t.sliceInfo(o.shape,s,i,a,c,l,u,p,d),_;if(h)_=J({inputs:{x:o},backend:t,attrs:{shape:m}});else if(g||x){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let R=$t.computeOutShape(v,w,I),F=co({inputs:{x:o},backend:t,attrs:{begin:v,size:R}});_=J({inputs:{x:F},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(F)}else if(t.shouldExecuteOnCPU([o])){let F=t.readSync(o.dataId),P=le(o.shape,o.dtype,F),L=WU(f,P,I,v);_=t.makeTensorInfo(m,o.dtype,L.values)}else{let F=new bb(v,I,f);_=t.runWebGLProgram(F,[o],o.dtype)}let A=J({inputs:{x:_},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(_),A}var AG={kernelName:Al,backendName:"webgl",kernelFunc:Qle};T();function Jle(n){let{inputs:e,backend:t,attrs:r}=n,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:c,preserveShortSequences:l}=r,{data:u,dataSplits:p}=e,d=t.readSync(u.dataId),f=t.readSync(p.dataId),[m,h]=jU(d,f,o,s,i,a,c,l);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(p.shape,"int32",h)]}var RG={kernelName:Rl,backendName:"webgl",kernelFunc:Jle};T();function eue(n){let{inputs:e,backend:t,attrs:r}=n,{skipEmpty:o}=r,{input:s,delimiter:i}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=t.readSync(s.dataId),c=t.readSync(i.dataId)[0],[l,u,p]=qU(a,c,o),d=u.length;return[t.makeTensorInfo([d,2],"int32",l),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(p))]}var FG={kernelName:Fl,backendName:"webgl",kernelFunc:eue};T();function tue(n){let{inputs:e,backend:t,attrs:r}=n,{numBuckets:o}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=t.readSync(s.dataId),a=KU(i,o);return t.makeTensorInfo(s.shape,"int32",a)}var MG={kernelName:Ml,backendName:"webgl",kernelFunc:tue};T();var nue="return tan(x);",rue=pe({opSnippet:nue}),OG={kernelName:"Tan",backendName:"webgl",kernelFunc:rue};T();var oue=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,sue=pe({opSnippet:oue}),$G={kernelName:Bi,backendName:"webgl",kernelFunc:sue};T();function iue(n){let{inputs:e,backend:t,attrs:r}=n,{tensor:o,indices:s,updates:i}=e,{}=r,{sliceRank:a,numUpdates:c,sliceSize:l,strides:u,outputSize:p}=S.calculateShapes(i,s,o.shape),d=[p/l,l];if(p===0)return t.makeTensorInfo(o.shape,s.dtype);let f=J({inputs:{x:s},backend:t,attrs:{shape:[c,a]}}),m=J({inputs:{x:i},backend:t,attrs:{shape:[c,l]}}),h=J({inputs:{x:o},backend:t,attrs:{shape:d}}),g=new xa(c,a,f.shape.length,m.shape.length,u,d,!1,!0),x=t.runWebGLProgram(g,[m,f,h],h.dtype),v=J({inputs:{x},backend:t,attrs:{shape:o.shape}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(x),v}var PG={kernelName:yl,backendName:"webgl",kernelFunc:iue};T();var Cb=class{constructor(e,t){this.variableNames=["A"];let r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[i]*t[i];this.outputShape=r,this.rank=r.length;let o=ve(this.rank),s=aue(e);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function aue(n){let e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<n.length;o++)r.push(`imod(${t[o]}, ${n[o]})`);return r.join()}function ND(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{reps:s}=r;if(o.dtype==="string"||o.shape.length>5){let c=t.readSync(o.dataId),l=o.dtype==="string"?c.map(d=>y.decodeString(d)):c,u=le(o.shape,o.dtype,l),p=YU(u,s);return t.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new Cb(o.shape,s);return t.runWebGLProgram(i,[o],o.dtype)}var LG={kernelName:rs,backendName:"webgl",kernelFunc:ND};T();var wb=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Ib=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Ru(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function BG(n){let e=1;for(;e<n;)e*=2;return e}function cue(n){let{inputs:e,backend:t,attrs:r}=n,{x:o}=e,{k:s,sorted:i}=r,a=O().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=O().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,u=l[l.length-1];if(t.shouldExecuteOnCPU([o])||u<a||s>c){let L=t.readSync(o.dataId),[V,z]=ZU(L,l,o.dtype,s,i);return[t.makeTensorInfo(V.shape,V.dtype,V.values),t.makeTensorInfo(z.shape,z.dtype,z.values)]}if(s===0)return l[l.length-1]=0,[t.makeTensorInfo(l,o.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(u===1)return[o,As({attrs:{shape:l,dtype:"int32",value:0},backend:t})];let p=t.texData.get(o.dataId),d=p!==null&&p.isPacked,f=d?t.unpackTensor(o):o,h=y.sizeFromShape(l)/u,g=J({inputs:{x:f},attrs:{shape:[h,u]},backend:t});d&&Ru(t,f);let x=BG(s),v=BG(u),w=null,I=()=>w===null?[g,g]:[g,w],_=(L,V,z)=>{let H=I(),j=new wb(z),Y=[[u],[w===null?1:0],[Number.NEGATIVE_INFINITY],[L],[V]],Z=w;w=t.runWebGLProgram(j,H,"int32",Y),Ru(t,Z)};for(let L=1;L<x;L*=2){let V=L*2;for(let z=L;z>=1;z/=2)_(V,z,[h,v])}for(let L=v;L>x;L/=2){let V=I(),z=new Ib([h,L/2]),j=[[u],[w===null?1:0],[x]],W=w;w=t.runWebGLProgram(z,V,"int32",j),Ru(t,W);let Y=x/2,Z=Y*2;for(let K=Y;K>=1;K/=2)_(Z,K,w.shape)}let A=w;w=co({inputs:{x:w},backend:t,attrs:{begin:0,size:[h,s]}}),Ru(t,A);let R=bD({inputs:{x:g,indices:w},backend:t,attrs:{axis:1,batchDims:1}});Ru(t,g);let F=l.slice(0,-1);F.push(s),A=w,w=J({inputs:{x:w},attrs:{shape:F},backend:t}),Ru(t,A);let P=R;return R=J({inputs:{x:R},attrs:{shape:F},backend:t}),Ru(t,P),[R,w]}var VG={kernelName:Pl,backendName:"webgl",kernelFunc:cue};T();var Eb=class{constructor(e,t,r,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=r==="nearest"?1:2,c;switch(o){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function lue(n){let{inputs:e,backend:t,attrs:r}=n,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:c,outputShape:l}=r,[u,p,d,f]=o.shape,[m,h]=l??[p,d],g=[u,m,h,f],x=new Eb(p,d,i,a,c,g);return t.runWebGLProgram(x,[o,s],"float32")}var UG={kernelName:Ll,backendName:"webgl",kernelFunc:lue};T();function uue(n){let{inputs:e,attrs:t,backend:r}=n,{axis:o}=t,{x:s}=e;Ho(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:a,outputShape:c,indices:l}=QU(i,o,s.shape,s.dtype);return[r.makeTensorInfo(c,s.dtype,a),r.makeTensorInfo([l.length],"int32",l)]}var zG={kernelName:Bl,backendName:"webgl",kernelFunc:uue};T();function pue(n){let{inputs:e,backend:t,attrs:r}=n,{value:o}=e,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,c=o.shape[s],l=new Array(a-1),u=0;for(let h=0;h<a;h++)h!==s&&(l[u++]=i.shape[h]);let p=[],d=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let m=new Array(c);for(let h=0;h<m.length;h++){d[s]=h;let g=co({inputs:{x:i},backend:t,attrs:{begin:d,size:f}}),x=J({inputs:{x:g},backend:t,attrs:{shape:l}});m[h]=x,p.push(g)}return p.forEach(h=>t.disposeIntermediateTensorInfo(h)),m}var HG={kernelName:Vl,backendName:"webgl",kernelFunc:pue};T();var Tb=class{constructor(e,t){this.variableNames=["x","segmentIds"];let r=e.windowSize,o=e.batchSize,s=e.inSize,i=e.numSegments,a=i*Math.ceil(s/r);this.outputShape=[o,a];let c="0.0",l="sumValue",u=Math.floor(r/4)*4,p=r%4,d=`
        sumValue += dot(values, segFilter);
    `,f="";s%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let m="";s%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function due(n){let{inputs:e,backend:t,attrs:r}=n,{x:o,segmentIds:s}=e,{numSegments:i}=r,a=o.shape.length,c=[],l=0,u=S.getAxesPermutation([l],a),p=o;u!=null&&(p=at({inputs:{x:o},backend:t,attrs:{perm:u}}),c.push(p),l=S.getInnerMostAxes(1,a)[0]);let d=S.segment_util.computeOutShape(p.shape,l,i),f=y.sizeFromShape([p.shape[l]]),m=J({inputs:{x:p},backend:t,attrs:{shape:[-1,f]}});c.push(m);let h=ji(o.dtype),g=(I,_,A,R,F)=>{let P=I.shape[0],L=I.shape[1],V=S.segment_util.segOpComputeOptimalWindowSize(L,F),z={windowSize:V,inSize:L,batchSize:P,numSegments:F},H=new Tb(z,_),j=t.compileAndRun(H,[I,A],R);if(c.push(j),j.shape[1]===F)return j;let W=SD({backend:t,attrs:{start:0,stop:F,step:1,dtype:"float32"}}),Y=ND({inputs:{x:W},backend:t,attrs:{reps:[L/V]}});return c.push(W),c.push(Y),g(j,_,Y,R,F)},x=g(m,"unsortedSegmentSum",s,h,i),v=J({inputs:{x},backend:t,attrs:{shape:d}}),w=v;if(u!=null){c.push(v);let I=S.getUndoAxesPermutation(u);w=at({inputs:{x:w},backend:t,attrs:{perm:I}})}return c.forEach(I=>t.disposeIntermediateTensorInfo(I)),w}var GG={kernelName:Ul,backendName:"webgl",kernelFunc:due};var fue=[S4,D4,k4,_4,R4,F4,M4,O4,L4,B4,V4,U4,z4,H4,G4,W4,j4,q4,K4,X4,Y4,Q4,J4,ez,tz,sz,az,cz,g4,uz,dz,fz,mz,hz,gz,xz,yz,vz,bz,Cz,Ez,Tz,Sz,Nz,Dz,kz,_z,Az,Rz,Fz,Mz,Oz,$z,Pz,Lz,Bz,Uz,zz,Hz,Gz,jz,qz,Kz,Xz,Yz,Zz,Qz,Jz,eH,h4,tH,pz,nH,rH,oH,x4,sH,iH,aH,cH,lH,uH,pH,dH,fH,mH,gH,xH,yH,vH,bH,CH,IH,TH,SH,NH,DH,kH,MH,b4,OH,$H,PH,LH,nz,BH,zH,HH,GH,WH,y4,jH,qH,KH,XH,YH,rz,_H,ZH,QH,JH,w4,eG,tG,nG,rG,oG,sG,iG,aG,cG,lG,uG,pG,dG,fG,mG,hG,Z4,FH,gG,xG,yG,vG,bG,CG,wG,IG,TG,SG,DG,kG,_G,AG,RG,FG,MG,RH,E4,OG,$G,PG,LG,VG,UG,T4,zG,HG,GG,VH];for(let n of fue)Dp(n);var mue=["proportionChart"],Sb=class n{canvasRef;newValue=Gg(null);nearThreshold=Gg(.98);farThreshold=Gg(.88);ctx;history=[];maxPoints=50;yMin=.5;yMax=1;updateEffect=Aw(()=>{let e=this.newValue();e!==null&&!Number.isNaN(e)&&this.ctx&&this.updateChart(e)});ngAfterViewInit(){this.ctx=this.canvasRef.nativeElement.getContext("2d"),this.drawAxes()}drawAxes(){let e=this.canvasRef.nativeElement;this.ctx.clearRect(0,0,e.width,e.height);let t=[{value:this.farThreshold(),color:"orange"},{value:this.nearThreshold(),color:"red"}];console.log(`${t[0].value}, ${t[1].value}`),t.forEach(r=>{console.log(typeof r.value);let o=this.valueToY(r.value);this.ctx.beginPath(),this.ctx.strokeStyle=r.color,this.ctx.setLineDash([4,4]),this.ctx.moveTo(0,o),this.ctx.lineTo(e.width,o),this.ctx.stroke(),this.ctx.setLineDash([]),this.ctx.fillStyle=r.color,this.ctx.font="12px Arial",this.ctx.fillText(r.value.toFixed(2),5,o-5)}),this.ctx.setLineDash([])}valueToY(e){let t=this.canvasRef.nativeElement,r=this.yMax-this.yMin,o=Math.max(this.yMin,Math.min(this.yMax,e));return t.height-(o-this.yMin)/r*t.height}updateChart(e){this.history.push(e),this.history.length>this.maxPoints&&this.history.shift(),this.drawAxes(),this.ctx.beginPath(),this.ctx.strokeStyle="#0ff",this.ctx.lineWidth=2,this.history.forEach((t,r)=>{let o=r/(this.maxPoints-1)*this.canvasRef.nativeElement.width,s=this.valueToY(t);r===0?this.ctx.moveTo(o,s):this.ctx.lineTo(o,s)}),this.ctx.stroke()}static \u0275fac=function(t){return new(t||n)};static \u0275cmp=Xa({type:n,selectors:[["app-chart"]],viewQuery:function(t,r){if(t&1&&zr(mue,7),t&2){let o;Hr(o=Gr())&&(r.canvasRef=o.first)}},inputs:{newValue:[1,"newValue"],nearThreshold:[1,"nearThreshold"],farThreshold:[1,"farThreshold"]},decls:2,vars:0,consts:[["proportionChart",""],["width","400","height","120"]],template:function(t,r){t&1&&Bg(0,"canvas",1,0)},styles:["[_nghost-%COMP%]{display:block;margin:8px auto;text-align:center}canvas[_ngcontent-%COMP%]{width:100%;max-width:400px;height:auto;border:1px solid #555;border-radius:6px;background:#111}"]})};var WG="M3.90109 181.502C0.90318 168.367 1.31828 162.376 6.09542 149.831C6.71373 146.3 6.9413 143.133 6.9413 139.538C6.9413 137.5 8.25102 134.278 9.49994 132.5C11.2887 129.955 16.0694 126.71 18.8285 124.921C26.0956 120.212 35.8646 114.377 43.4999 110.5C62.1815 101.015 75.4999 96.5 94.4999 88C109.139 82.67 121.266 78.174 135.994 73.1612C142.625 70.907 154.538 67.4968 159.576 62.2266C159.328 61.1189 158.235 60.0478 158.012 59C157.82 58.103 157.964 57.2111 158.012 56.6703C158.596 55.3677 159.31 54.0703 160.218 52.9887C162.438 50.3445 166.819 49.0003 170.075 49.9519C173.207 50.8655 171.732 51.5 176.257 47.4492C196.486 29.3011 205.322 16.7591 232.084 10.2955C261.869 3.10121 295.752 1.51 326.244 2.11841C361.186 2.33421 394.589 3.97222 421.316 30.56C423.262 32.263 424.672 33.7762 426.914 35.24C431.452 38.204 435.768 38.9118 438.5 44C439.51 45.8824 441.585 49.5 442.232 51C444.605 56.5 444 60.5 442.232 65.5C442.237 68.3132 444.152 80.107 444.5 83.5C446.015 98.2317 445.27 100.477 438.5 113.5C437.241 126.786 435.5 151.779 425 155.5C420.269 157.177 414.584 158.028 409.63 157.298C404.677 156.567 402.102 154.593 400 149.5C363 173.5 333.552 195.195 295 217.519C291.388 235.803 283.375 256.184 269.5 268.5C265.441 272.103 255.5 278.042 247 279.042C239.037 279.979 235.364 280.512 227.5 278.042C221.954 276.303 218 272.5 215 268.5C212 270.359 207.934 272.44 203.916 273.888C188.598 279.397 124.523 273.466 92.4661 266.712C57.1281 259.265 31.1236 241.035 20.3212 231.423C16.4999 228.022 9.30978 222.793 8.70771 216.519C8.21013 211.327 7.72856 207.69 9.49994 203C9.49994 200.428 4.67273 193.515 4.23198 188.436C4.023 186.024 4.34394 184.048 3.90109 181.502Z";var t1=Nh(_j());var jb=class n{model=null;isLoaded=rt(!1);worker=null;constructor(){this.loadModelInBackground()}async loadModelInBackground(){typeof Worker<"u"?(this.worker=new Worker(new URL("worker-RCF4645K.js",import.meta.url),{type:"module"}),this.worker.onmessage=async({data:e})=>{e.status==="loaded"?(console.log("Woker pre-loaded the model. Loading locally..."),this.model=await t1.load(),this.isLoaded.set(!0)):e.status==="error"&&console.error("Error on worker:",e.error)},this.worker.postMessage("start")):this.directLoad()}async directLoad(){this.model=await t1.load(),this.isLoaded.set(!0)}async getModelReady(){if(this.model)return this.model;for(;!this.isLoaded();)await new Promise(e=>setTimeout(e,200));return this.model}static \u0275fac=function(t){return new(t||n)};static \u0275prov=ut({token:n,factory:n.\u0275fac,providedIn:"root"})};var mpe=["video"],hpe=["detectionCanvas"],gpe=["overlayCanvas"],xpe=["startBtn"],ype=["irregularPath"],vpe=["rectPath"],bpe=["freezeCanvas"];function Cpe(n,e){if(n&1){let t=Ya();Re(0,"div")(1,"button",63,4),Ur("click",function(){Lr(t);let o=ir();return Br(o.startCapture())}),dn(3," Start capture "),Oe()()}}function wpe(n,e){n&1&&(Re(0,"div",64),tt(1,"span")(2,"span")(3,"span"),Oe())}function Ipe(n,e){n&1&&(Re(0,"div",65),tt(1,"span")(2,"span")(3,"span"),Oe())}function Epe(n,e){n&1&&(Re(0,"div",66),tt(1,"span")(2,"span")(3,"span"),Oe())}function Tpe(n,e){n&1&&(Re(0,"div",67),tt(1,"span")(2,"span")(3,"span"),Oe())}function Spe(n,e){n&1&&(Re(0,"div",68),dn(1," \u{1F4F8} Centrado correctamente "),Oe())}function Npe(n,e){n&1&&(Re(0,"div",70),tt(1,"img",72),Re(2,"b",73),dn(3,"Image saved."),Oe()())}function Dpe(n,e){if(n&1){let t=Ya();Re(0,"div",71)(1,"button",74),Ur("click",function(){Lr(t);let o=ir(2);return Br(o.retryPhoto())}),dn(2,"\u21BB Retry"),Oe(),Re(3,"button",75),Ur("click",function(){Lr(t);let o=ir(2);return Br(o.usePhoto())}),dn(4,"\u2714 Use photo"),Oe()()}}function kpe(n,e){if(n&1&&(Re(0,"div",18),tt(1,"img",69),Hs(2,Npe,4,0,"div",70),Hs(3,Dpe,5,0,"div",71),Oe()),n&2){let t=ir();Xe(),An("src",t.capturedImage(),YC),Xe(),Gs(t.showToastOk()?2:-1),Xe(),Gs(t.showRetryConfirmMessageSignal()?3:-1)}}function _pe(n,e){if(n&1){let t=Ya();Re(0,"div",19)(1,"div",76)(2,"label",77)(3,"input",78),Ur("change",function(){Lr(t);let o=ir();return Br(o.toggleDetections())}),Oe(),tt(4,"span",79),Oe(),Re(5,"span",80),dn(6,"Show detections and proportions"),Oe()(),Re(7,"div",76)(8,"label",77)(9,"input",78),Ur("change",function(){Lr(t);let o=ir();return Br(o.toggleBoxes())}),Oe(),tt(10,"span",79),Oe(),Re(11,"span",80),dn(12,"Show bounding boxes"),Oe()()()}if(n&2){let t=ir();Xe(3),An("checked",t.showDetections()),Xe(6),An("checked",t.showBoxes())}}function Ape(n,e){if(n&1){let t=Ya();Re(0,"div",20)(1,"div",81),dn(2," Proportion: "),Re(3,"span"),dn(4),Oe(),tt(5,"app-chart",82),Oe(),Re(6,"div",83)(7,"label"),dn(8),Ug(9,"number"),Re(10,"input",84),Ur("input",function(o){Lr(t);let s=ir();return Br(s.setNearThreshold(o.target.value))}),Oe()(),Re(11,"label"),dn(12),Ug(13,"number"),Re(14,"input",85),Ur("input",function(o){Lr(t);let s=ir();return Br(s.setFarThreshold(o.target.value))}),Oe()()()()}if(n&2){let t=ir();Xe(4),wf(t.proportion()!==null?t.proportion():"N/A"),Xe(),An("newValue",t.proportion())("nearThreshold",t.nearThreshold())("farThreshold",t.farThreshold()),Xe(3),lp(" Near threshold (",zg(9,8,t.nearThreshold(),"1.2-2"),") "),Xe(2),An("value",t.nearThreshold()),Xe(2),lp(" Far threshold (",zg(13,11,t.farThreshold(),"1.2-2"),") "),Xe(2),An("value",t.farThreshold())}}function Rpe(n,e){if(n&1&&(Re(0,"div",59),dn(1),Oe()),n&2){let t=ir();Xe(),wf(t.feedback())}}var qb=class n{constructor(e,t){this.tfModelService=e;this.config=t}videoRef;detectionCanvasRef;overlayCanvasRef;startBtnRef;irregularPathRef;rectPathRef;freezeCanvasRef;feedback=rt("Press 'Start capture' button");detections=rt([]);proportion=rt(null);capturedImage=rt(null);isFrozen=rt(!1);cameraReady=rt(!0);directionMessage=rt(null);showFeedbackMessage=rt(!1);showCapturedPhotoSignal=rt(!1);showRetryConfirmMessageSignal=rt(!1);showToastOk=rt(!1);arrowDirection=rt({left:!1,right:!1,up:!1,down:!1});isCentered=rt(!1);showTogglePanel=rt(!0);showPermissionSlider=rt(!0);showDetections=rt(!1);showBoxes=rt(!1);nearThreshold=rt(.99);farThreshold=rt(.88);ctx;overlayCtx;model;detectionTimer;stream=null;isCapturingPhoto=!1;isAnimating=!1;isAnimatingFill=!1;rectPath2D;rectMetrics={offsetX:0,offsetY:0,width:0,height:0};outlinePathData=WG;svgWidth=448;svgHeight=282;ngOnInit(){let e=this.config.config();this.showTogglePanel.set(this.config.getFeature("showDetectionsPanel")),console.log("Active component configuration:",e)}ngAfterViewInit(){let e=this.irregularPathRef.nativeElement,t=e.getTotalLength();e.style.setProperty("--path-length",`${t}`)}ngOnDestroy(){this.detectionTimer&&clearInterval(this.detectionTimer),this.stream&&this.stream.getTracks().forEach(e=>e.stop())}showArrow(e){return this.arrowDirection()[e]}showCentered(){return this.isCentered()}toggleDetections(){this.showDetections.update(e=>!e)}toggleBoxes(){this.showBoxes.update(e=>!e)}setNearThreshold(e){this.nearThreshold.set(Number(e))}setFarThreshold(e){this.farThreshold.set(Number(e))}createScaledPath(e,t,r){let o=t*.05,s=r*.08,i=t-2*o,a=r-2*s,c=i/this.svgWidth,l=a/this.svgHeight,u=this.svgWidth*c,p=this.svgHeight*l,d=o+(i-u)/2,f=15,m=new Path2D;return m.addPath(e,new DOMMatrix().translate(d,f).scale(c,l)),{path:m,scaleX:c,scaleY:l,offsetX:d,offsetY:f,scaledWidth:u,scaledHeight:p}}async startCapture(){if(!this.stream)return;let e=this.startBtnRef?.nativeElement;e&&(e.style.display="none"),await this.requestFullscreenAndOrientation(),await this.initVideoAndCanvases(),this.initReferenceShapes(),await this.showGeneralInstructionsMessage(),this.config.getFeature("enableObjectDetection")&&await this.runDetectionLoop()}async showGeneralInstructionsMessage(){this.feedback.set("Frame the vehicle within the outline."),this.showFeedbackMessage.set(!0),await new Promise(e=>setTimeout(e,3e3)),this.showFeedbackMessage.set(!1)}async requestFullscreenAndOrientation(){try{await(document.documentElement.requestFullScreen?.()||document.documentElement.webkitRequestFullscreen?.()||document.documentElement.mozRequestFullScreen?.()||document.documentElement.msRequestFullscreen?.())}catch(e){console.warn("Can't force fullscreen/orientation:",e)}}async requestCameraAccess(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:{ideal:"environment"}}}),this.feedback.set("Camera ready."),this.showPermissionSlider.set(!1),this.cameraReady.set(!0)}catch{this.feedback.set("\u274C Couldn't access the camera.")}}async initVideoAndCanvases(){if(!this.stream){this.feedback.set("\u274C No camera stream.");return}let e=this.videoRef.nativeElement,t=this.detectionCanvasRef.nativeElement,r=this.overlayCanvasRef.nativeElement;e.srcObject=this.stream,await new Promise(o=>{e.onloadedmetadata=()=>{t.width=e.videoWidth,t.height=e.videoHeight,r.width=e.videoWidth,r.height=e.videoHeight,this.ctx=t.getContext("2d"),this.overlayCtx=r.getContext("2d"),o()}}),this.overlayCtx.clearRect(0,0,r.width,r.height)}initReferenceShapes(){let e=this.overlayCanvasRef.nativeElement,t=e.width,r=e.height,o=t*.1,s=20,i=t-2*o,a=r-2*s,c=o,l=s;this.rectPath2D=new Path2D,this.rectPath2D.rect(c,l,i,a),this.rectMetrics.offsetX=c,this.rectMetrics.offsetY=l,this.rectMetrics.width=i,this.rectMetrics.height=a,this.overlayCtx.clearRect(0,0,t,r),this.drawBackgroundAndRefereceCanvas(e)}drawBackgroundAndRefereceCanvas(e){this.showBoxes()?this.overlayCtx.strokeStyle="rgba(255, 255, 0, 1)":this.overlayCtx.strokeStyle="rgba(255, 255, 0, 0)",this.overlayCtx.lineWidth=0,this.overlayCtx.stroke(this.rectPath2D)}drawBoundingBoxes(e){e.forEach(t=>{let[r,o,s,i]=t.bbox;this.overlayCtx.strokeStyle="red",this.overlayCtx.lineWidth=2,this.overlayCtx.strokeRect(r,o,s,i),this.overlayCtx.fillStyle="red",this.overlayCtx.font="16px monospace";let a=o>20?o-6:o+16;this.overlayCtx.fillText(`${t.class} ${(t.score*100).toFixed(1)}%`,r,a)})}disableFramingGuides(){let e={left:!1,right:!1,up:!1,down:!1};this.arrowDirection.set(e)}enableFramingGuides(e){let[t,r,o,s]=e.bbox,i={x:t+o/2,y:r+s/2},{offsetX:a,offsetY:c,width:l,height:u}=this.rectMetrics,p={x:a+l/2,y:c+u/2},d=i.x-p.x,f=i.y-p.y,m=l*.05,h=u*.05,g={left:!1,right:!1,up:!1,down:!1},x=!0,v="";Math.abs(d)>m&&(x=!1,d>0?(g.right=!0,v="Move camera to the right"):(g.left=!0,v="Move camera to the left")),Math.abs(f)>h&&(x=!1,f>0?(g.down=!0,g.right||g.left?v+=" and downward":v="Move the camera downward"):(g.up=!0,g.right||g.left?v=" and upward":v="Move the camera upward")),this.arrowDirection.set(g),this.isCentered.set(x),this.feedback.set(v)}getMainCar(e){if(e.length===1)return e[0];let t=e.map(i=>Lt(Rt({},i),{area:i.bbox[2]*i.bbox[3]}));t.sort((i,a)=>a.area-i.area);let r=t[0],o=t[1];return(r.area-o.area)/r.area<.1?(this.feedback.set("Please frame only one vehicle in the image."),null):r}async runDetectionLoop(){let e=this.detectionCanvasRef.nativeElement,t=this.overlayCanvasRef.nativeElement,r=this.videoRef.nativeElement;this.model=await this.tfModelService.getModelReady(),this.detectionTimer=setInterval(async()=>{if(this.isCapturingPhoto)return;this.ctx.drawImage(r,0,0,e.width,e.height);let o=await this.model.detect(e);this.detections.set(o.map(a=>`${a.class} (${(a.score*100).toFixed(1)}%)`)),this.overlayCtx.clearRect(0,0,t.width,t.height),this.drawBackgroundAndRefereceCanvas(t),this.showBoxes()&&this.drawBoundingBoxes(o);let s=o.filter(a=>["car","truck","bus"].includes(a.class)),i;if(this.showFeedbackMessage.set(!0),s.length===0){this.feedback.set("I cannot detect the car, adjust the framing."),this.disableFramingGuides(),this.proportion.set(null);return}if(s.length>1?i=this.getMainCar(s):i=s[0],i){let[a,c,l,u]=i.bbox,p=[[a,c],[a+l,c],[a,c+u],[a+l,c+u]].every(([h,g])=>this.overlayCtx.isPointInPath(this.rectPath2D,h,g)),d=l,f=this.rectMetrics.width,m=d/f;this.proportion.set(+m.toFixed(3)),console.log(m),p?m>this.nearThreshold()?this.feedback.set("Step back a little. \u{1F697}\u27A1\uFE0F"):m<this.farThreshold()?this.feedback.set("You're too far \u{1F697}\u2B05\uFE0F"):(this.feedback.set("Perfect! Don't move, capturing... \u{1F4F8}"),this.isCapturingPhoto=!0,this.freezeFrame(),this.isAnimating||await this.orchestratePhotoCapturingAsync()):this.enableFramingGuides(i)}else this.disableFramingGuides(),this.proportion.set(null)},1e3)}freezeFrame(){this.isFrozen.set(!0)}unfreezeFrame(){this.isFrozen.set(!1),this.isCapturingPhoto=!1}async capturePhotoAsync(){let e=this.detectionCanvasRef.nativeElement,{offsetX:t,offsetY:r,width:o,height:s}=this.rectMetrics,i=s*.1,a=s-2*i,c=r+i,l=document.createElement("canvas");l.width=o,l.height=a,l.getContext("2d")?.drawImage(e,t,c,o,a,0,0,o,a),this.capturedImage.set(l.toDataURL("image/png")),await this.showCapturedPhoto()}async showCapturedPhoto(){this.showCapturedPhotoSignal.set(!0),this.config.getFeature("showPhotoConfirmation")?this.showRetryConfirmMessageSignal.set(!0):await this.usePhoto()}retryPhoto(){this.capturedImage.set(null),this.showCapturedPhotoSignal.set(!1),this.unfreezeFrame()}async usePhoto(){await this.showImageOkMessageAsync(),this.showCapturedPhotoSignal.set(!1),this.unfreezeFrame()}async animateFrameGlowAsync(){if(this.isAnimating)return;this.isAnimating=!0,this.showFeedbackMessage.set(!1);let e=this.irregularPathRef.nativeElement.closest("svg");e?.classList.add("glow"),await new Promise(t=>setTimeout(t,1e3)),this.isAnimating=!1,e?.classList.remove("glow")}async startFillAnimationAsync(){if(this.isAnimatingFill)return;this.isAnimatingFill=!0,this.showFeedbackMessage.set(!0),this.feedback.set("Analyzing with AI. . .");let e=this.irregularPathRef.nativeElement;e.setAttribute("fill","url(#fillGradient)"),e.classList.add("animate-fill"),await new Promise(t=>setTimeout(t,3e3)),this.isAnimatingFill=!1,this.showFeedbackMessage.set(!1),e.classList.remove("animate-fill")}async showImageOkMessageAsync(){this.showRetryConfirmMessageSignal.set(!1),this.showToastOk.set(!0),await new Promise(e=>setTimeout(e,2e3)),this.showToastOk.set(!1)}async orchestratePhotoCapturingAsync(){this.disableFramingGuides(),await this.animateFrameGlowAsync(),await this.startFillAnimationAsync(),await this.capturePhotoAsync()}static \u0275fac=function(t){return new(t||n)(wo(jb),wo(pp))};static \u0275cmp=Xa({type:n,selectors:[["app-camera"]],viewQuery:function(t,r){if(t&1&&(zr(mpe,5),zr(hpe,5),zr(gpe,5),zr(xpe,5),zr(ype,5),zr(vpe,5),zr(bpe,5)),t&2){let o;Hr(o=Gr())&&(r.videoRef=o.first),Hr(o=Gr())&&(r.detectionCanvasRef=o.first),Hr(o=Gr())&&(r.overlayCanvasRef=o.first),Hr(o=Gr())&&(r.startBtnRef=o.first),Hr(o=Gr())&&(r.irregularPathRef=o.first),Hr(o=Gr())&&(r.rectPathRef=o.first),Hr(o=Gr())&&(r.freezeCanvasRef=o.first)}},decls:69,vars:27,consts:[["detectionCanvas",""],["video",""],["overlayCanvas",""],["irregularPath",""],["startBtn",""],[1,"camera-permission-slider"],[1,"slider-content"],["id","allowBtn",3,"click"],[4,"ngIf"],[1,"frame-guide"],["class","arrow arrow-left",4,"ngIf"],["class","arrow arrow-right",4,"ngIf"],["class","arrow arrow-up",4,"ngIf"],["class","arrow arrow-down",4,"ngIf"],["class","centered-msg",4,"ngIf"],["id","detectionCanvas"],["id","video","autoplay","","playsinline","","muted",""],["id","overlayCanvas"],["id","capturedImage",1,"photo-preview"],[1,"toggle-panel"],[1,"detections-area"],["id","closeButton"],["width","24","height","24","viewBox","0 0 24 24","fill","none","xmlns","http://www.w3.org/2000/svg"],["d","M6 18L18 6M6 6L18 18","stroke","white","stroke-width","2","stroke-linecap","round","stroke-linejoin","round"],["id","main-container"],["id","header"],[1,"marco-container"],[1,"marco-svg"],["id","glowGradient","gradientTransform","rotate(90)"],["offset","0%","stop-color","#0ff"],["offset","50%","stop-color","#0f0"],["offset","100%","stop-color","#0ff"],["id","fillGradient","x1","0%","y1","50%","x2","100%","y2","50%"],["offset","0%","stop-color","rgba(31, 238, 200, 0.69)"],["attributeName","stop-color","values","rgba(31, 238, 200, 0.69);rgba(194, 255, 231, 0.30);rgba(58, 241, 144, 0.26);rgba(194, 255, 231, 0.30);rgba(31, 238, 200, 0.69)","dur","2s","repeatCount","indefinite"],["offset","100%","stop-color","rgba(31, 238, 200, 0.69)"],["attributeName","offset","values","0;.20;.40;.60;.80;.95;.80;.60;.40;.20;0;","dur","2s","repeatCount","indefinite"],["id","hole-mask"],["id","reference-frame-mask","preserveAspectRatio","xMidYMid meet"],["id","outline-hole","fill","#000"],["x","0","y","0","width","100%","height","100%","fill","#FFF"],["href","#reference-frame-mask","transform","scale(1.05)",2,"transform-origin","center","transform-box","fill-box"],["id","reference-frame","preserveAspectRatio","xMidYMid meet"],["id","top-left-corner","viewBox","0 0 17 16"],["d","M0.000137329 -1.45545e-06L0.00013593 16L2.00014 16L2.00014 2L16.6486 2L16.6486 0L0.000137329 -1.45545e-06Z","fill","white"],["id","top-right-corner","viewBox","0 0 17 16"],["d","M16.6485 -1.45545e-06L16.6485 16L14.6485 16L14.6485 2L6.121e-05 2L6.10352e-05 0L16.6485 -1.45545e-06Z","fill","white"],["id","bottom-left-corner","viewBox","0 0 17 16"],["d","M1.52588e-05 16.0001L1.386e-05 0.000123526L2.00001 0.000123351L2.00002 14.0001L16.6485 14.0001L16.6485 16.0001L1.52588e-05 16.0001Z","fill","white"],["id","bottom-right-corner","viewBox","0 0 17 16"],["d","M16.6486 16L16.6486 1.45545e-06L14.6486 1.28061e-06L14.6486 14L0.00018328 14L0.000183105 16L16.6486 16Z","fill","white"],["href","#top-left-corner","width","16px","height","16px","transform","translate(0 0)"],["href","#top-right-corner","width","16px","height","16px"],["href","#bottom-left-corner","width","16px","height","16px"],["href","#bottom-right-corner","width","16px","height","16px"],[1,"irregular-path"],["id","overlay-box","x","0","y","0"],["href","#reference-frame"],["id","footer"],["id","feedback"],[1,"orientation-warning"],[1,"orientation-content"],[1,"phone-icon"],["id","startBtn",3,"click"],[1,"arrow","arrow-left"],[1,"arrow","arrow-right"],[1,"arrow","arrow-up"],[1,"arrow","arrow-down"],[1,"centered-msg"],["alt","Captured photo",3,"src"],["id","toast-ok"],[1,"photo-actions"],["alt","","src","assets/icons/check-circle.svg",1,"iconsolidcheck-circle"],[1,"toast-ok-text"],[1,"retry",3,"click"],[1,"confirm",3,"click"],[1,"toggle-item"],[1,"switch"],["type","checkbox",3,"change","checked"],[1,"slider"],[1,"toggle-label"],["id","proportionBox"],[3,"newValue","nearThreshold","farThreshold"],[1,"slider-group"],["type","range","min","0.81","max","1","step","0.01",1,"slider-near",3,"input","value"],["type","range","min","0.5","max","0.9","step","0.01",1,"slider-far",3,"input","value"]],template:function(t,r){if(t&1){let o=Ya();Re(0,"div",5)(1,"div",6)(2,"p"),dn(3,"We need your permisson to access your camera \u{1F4F7}"),Oe(),Re(4,"button",7),Ur("click",function(){return Lr(o),Br(r.requestCameraAccess())}),dn(5,"Allow access"),Oe()()(),xf(6,Cpe,4,0,"div",8),Re(7,"div",9),xf(8,wpe,4,0,"div",10)(9,Ipe,4,0,"div",11)(10,Epe,4,0,"div",12)(11,Tpe,4,0,"div",13)(12,Spe,2,0,"div",14),Oe(),tt(13,"canvas",15,0)(15,"video",16,1)(17,"canvas",17,2),Hs(19,kpe,4,3,"div",18),Hs(20,_pe,13,2,"div",19),Hs(21,Ape,15,14,"div",20),Re(22,"div",21),tf(),Re(23,"svg",22),tt(24,"path",23),Oe()(),nf(),Re(25,"div",24),tt(26,"div",25),Re(27,"div",26),tf(),Re(28,"svg",27)(29,"defs")(30,"linearGradient",28),tt(31,"stop",29)(32,"stop",30)(33,"stop",31),Oe(),Re(34,"linearGradient",32)(35,"stop",33),tt(36,"animate",34),Oe(),Re(37,"stop",35),tt(38,"animate",34)(39,"animate",36),Oe()(),Re(40,"mask",37)(41,"symbol",38),tt(42,"path",39),Oe(),tt(43,"rect",40)(44,"use",41),Oe(),Re(45,"symbol",42)(46,"symbol",43),tt(47,"path",44),Oe(),Re(48,"symbol",45),tt(49,"path",46),Oe(),Re(50,"symbol",47),tt(51,"path",48),Oe(),Re(52,"symbol",49),tt(53,"path",50),Oe(),tt(54,"use",51)(55,"use",52)(56,"use",53)(57,"use",54)(58,"path",55,3),Oe()(),tt(60,"rect",56)(61,"use",57),Oe()(),nf(),tt(62,"div",58),Oe(),Hs(63,Rpe,2,1,"div",59),Re(64,"div",60)(65,"div",61),tt(66,"div",62),Re(67,"p"),dn(68,"Please turn your device to landscape orientation to continue."),Oe()()()}t&2&&(cp("visible",r.showPermissionSlider()),Xe(6),An("ngIf",r.cameraReady()),Xe(2),An("ngIf",r.showArrow("left")),Xe(),An("ngIf",r.showArrow("right")),Xe(),An("ngIf",r.showArrow("up")),Xe(),An("ngIf",r.showArrow("down")),Xe(),An("ngIf",r.showCentered()),Xe(),Cf("display",r.isFrozen()?"block":"none"),Xe(2),Cf("display",r.isFrozen()?"none":"block"),Xe(4),Gs(r.showCapturedPhotoSignal()?19:-1),Xe(),Gs(r.showTogglePanel()?20:-1),Xe(),Gs(r.showDetections()?21:-1),Xe(7),cp("glow",r.isAnimating),Xe(13),Io("viewBox","0 0 "+r.svgWidth+" "+r.svgHeight),Xe(),Io("d",r.outlinePathData),Xe(3),Io("viewBox","0 0 "+r.svgWidth+" "+r.svgHeight),Xe(10),Io("transform","translate("+(r.svgWidth-16)+" 0)"),Xe(),Io("transform","translate(0 "+(r.svgHeight-16)+")"),Xe(),Io("transform","translate("+(r.svgWidth-16)+" "+(r.svgHeight-16)+")"),Xe(),cp("animate-fill",r.isAnimatingFill),Io("d",r.outlinePathData),Xe(5),Gs(r.showFeedbackMessage()?63:-1))},dependencies:[qg,Lw,Sb,Bw],styles:['[_nghost-%COMP%]{display:block;background:#000;height:100vh;width:100vw;overflow:hidden;position:relative}.camera-permission-slider[_ngcontent-%COMP%]{position:fixed;left:50%;transform:translate(-50%);bottom:-200px;background:#fff;box-shadow:0 -4px 12px #0003;border-top-left-radius:16px;border-top-right-radius:16px;padding:20px;text-align:center;transition:bottom .3s ease-in-out;z-index:1000;width:50%}.camera-permission-slider.visible[_ngcontent-%COMP%]{bottom:0}.slider-content[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin-bottom:15px;font-size:16px}.camera-container[_ngcontent-%COMP%]{position:relative;width:100%;height:100%;overflow:hidden}#video[_ngcontent-%COMP%], #detectionCanvas[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100vw;height:100vh;object-fit:cover}#overlay-box[_ngcontent-%COMP%]{width:100%;height:100%;fill:#0006;mask:url(#hole-mask)}#main-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:100%;height:100%}.marco-container[_ngcontent-%COMP%]{flex-grow:1;display:flex;justify-content:center;width:100%;z-index:2}#header[_ngcontent-%COMP%], #footer[_ngcontent-%COMP%]{height:20px;width:100%;background-color:#0006;z-index:2}.marco-svg[_ngcontent-%COMP%]{width:100%;height:100%}#capturedImage[_ngcontent-%COMP%]{z-index:3}#overlayCanvas[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100vw;height:100vh;pointer-events:none}#startBtn[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:15px 30px;font-size:18px;z-index:1000;border-radius:10px;border:none;background:#32cd32;color:#fff;cursor:pointer;z-index:3}#allowBtn[_ngcontent-%COMP%]{height:32px}#feedback-box[_ngcontent-%COMP%]{display:flex;width:100%;justify-content:center;background:#0006;height:36px;z-index:2;padding:10px 20px}#feedback[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:fit-content;background:#000000b3;color:#fff;text-align:center;padding:5px 20px;font-size:18px;font-weight:500;border-radius:6px;z-index:3}#detections[_ngcontent-%COMP%]{position:absolute;top:20px;left:20px;padding:10px;background:#0009;color:#0f0;font-family:monospace;font-size:14px;border-radius:8px;max-width:50%;max-height:30%;overflow-y:auto;white-space:pre-wrap}#proportionBox[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:100%;padding:0;background:#0009;color:#0ff;font-size:14px;border-radius:8px}#proportionBox[_ngcontent-%COMP%]   canvas[_ngcontent-%COMP%]{display:block;margin-top:8px;background:#111;border:1px solid #0ff;border-radius:4px}#closeButton[_ngcontent-%COMP%]{position:absolute;top:15px;right:15px;width:32px;height:32px;padding:12px;display:flex;justify-content:center;align-items:center;gap:10px;flex-shrink:0;border-radius:50%;box-shadow:inset 0 0 6px #0003;background:#0009;z-index:4}.orientation-warning[_ngcontent-%COMP%]{display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000000e6;color:#fff;z-index:9999;display:flex;justify-content:center;align-items:center;text-align:center;padding:20px}@media only screen and (orientation: portrait){.orientation-warning[_ngcontent-%COMP%]{display:flex}}@media only screen and (orientation: landscape){.orientation-warning[_ngcontent-%COMP%]{display:none}}.orientation-content[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center}.phone-icon[_ngcontent-%COMP%]{width:60px;height:100px;border:4px solid white;border-radius:12px;position:relative;margin-bottom:20px;animation:_ngcontent-%COMP%_rotatePhone 2s infinite ease-in-out}.phone-icon[_ngcontent-%COMP%]:after{content:"";position:absolute;bottom:8px;left:50%;transform:translate(-50%);width:12px;height:12px;border:2px solid white;border-radius:50%}@keyframes _ngcontent-%COMP%_rotatePhone{0%{transform:rotate(0)}30%{transform:rotate(0)}50%{transform:rotate(-90deg)}80%{transform:rotate(-90deg)}to{transform:rotate(0)}}.orientation-warning[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:18px;font-weight:700;max-width:300px}.toggle-panel[_ngcontent-%COMP%]{position:absolute;top:15px;left:15px;display:flex;flex-direction:column;gap:10px;z-index:4}.toggle-item[_ngcontent-%COMP%]{display:flex;align-items:center;gap:8px;color:#fff}.switch[_ngcontent-%COMP%]{position:relative;display:inline-block;width:50px;height:28px}.switch[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{opacity:0;width:0;height:0}.slider[_ngcontent-%COMP%]{position:absolute;cursor:pointer;inset:0;background-color:#aaa;transition:.3s;border-radius:28px}.slider[_ngcontent-%COMP%]:before{position:absolute;content:"";height:20px;width:20px;left:4px;bottom:4px;background-color:#fff;transition:.3s;border-radius:50%}input[_ngcontent-%COMP%]:checked + .slider[_ngcontent-%COMP%]{background-color:#4caf50}input[_ngcontent-%COMP%]:checked + .slider[_ngcontent-%COMP%]:before{transform:translate(22px)}.photo-preview[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;background:#000000d9;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:5}.photo-preview[_ngcontent-%COMP%] > img[_ngcontent-%COMP%]{max-width:90%;max-height:60%;border-radius:12px;box-shadow:0 4px 12px #00000080;margin-bottom:20px}.photo-actions[_ngcontent-%COMP%]{display:flex;gap:20px}.photo-actions[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{padding:10px 20px;border:none;border-radius:8px;font-size:16px;font-weight:500;cursor:pointer}button.retry[_ngcontent-%COMP%]{background:#444;color:#fff}button.confirm[_ngcontent-%COMP%]{background:#2ecc71;color:#fff}.detections-area[_ngcontent-%COMP%]{position:absolute;width:30%;top:100px;left:8px;background:#0009;padding:10px;border-top:1px solid #444;border-right:1px solid #444;border-bottom:1px solid #444;display:flex;flex-direction:column;align-items:flex-start;gap:12px;z-index:1000}.detections-area[_ngcontent-%COMP%]   app-chart[_ngcontent-%COMP%]{width:100%}.slider-group[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:8px;width:100%;color:#0ff;font-size:14px}.slider-group[_ngcontent-%COMP%]   input[type=range][_ngcontent-%COMP%]{width:100%}.slider-near[_ngcontent-%COMP%]{background:#e74c3c66}.slider-near[_ngcontent-%COMP%]::-webkit-slider-thumb{background:#e74c3c}.slider-near[_ngcontent-%COMP%]::-moz-range-thumb{background:#e74c3c}.slider-far[_ngcontent-%COMP%]{background:#f39c1266}.slider-far[_ngcontent-%COMP%]::-webkit-slider-thumb{background:#f39c12}.slider-far[_ngcontent-%COMP%]::-moz-range-thumb{background:#f39c12}.level-container[_ngcontent-%COMP%]{position:absolute;top:50%;left:10px;transform:translateY(-50%);z-index:4}.overlay[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.rect-path[_ngcontent-%COMP%]{stroke:#fff;stroke-width:2;fill:transparent;mask:url(#corner-mask)}.irregular-path[_ngcontent-%COMP%]{fill:transparent;stroke-width:3;stroke:#fff;stroke-linejoin:round;stroke-linecap:round;transition:stroke-width .3s ease;transform:scale(.95);transform-origin:center;transform-box:fill-box}#outline-hole[_ngcontent-%COMP%]{transform:scale(.9);transform-origin:center;transform-box:fill-box}.glow[_ngcontent-%COMP%]   .irregular-path[_ngcontent-%COMP%]{stroke:url(#glowGradient);stroke-width:3;stroke-dasharray:var(--path-length);stroke-dashoffset:var(--path-length);animation:_ngcontent-%COMP%_dashGlow 1s linear forwards;filter:drop-shadow(0 0 6px #0ff) drop-shadow(0 0 12px rgba(31,238,200,.69))}@keyframes _ngcontent-%COMP%_dashGlow{to{stroke-dashoffset:0}}.animate-fill[_ngcontent-%COMP%]{fill:url(#fillGradient)}.frame-guide[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:flex;justify-content:center;align-items:center}.arrow[_ngcontent-%COMP%]{position:absolute;z-index:10;width:48px;height:48px}.arrow[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{display:block;width:1.5vw;height:1.5vw;border-bottom:5px solid white;border-right:5px solid white;transform:rotate(45deg);margin:-10px;animation:_ngcontent-%COMP%_animate 2s infinite}.arrow[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]:nth-child(2){animation-delay:-.2s}.arrow[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]:nth-child(3){animation-delay:-.4s}@keyframes _ngcontent-%COMP%_animate{0%{opacity:0;transform:rotate(45deg) translate(-20px,-20px)}50%{opacity:1}to{opacity:0;transform:rotate(45deg) translate(20px,20px)}}.arrow-left[_ngcontent-%COMP%]{left:10px;top:50%;transform:rotate(90deg)}.arrow-right[_ngcontent-%COMP%]{right:10px;top:50%;transform:rotate(270deg)}.arrow-up[_ngcontent-%COMP%]{top:10px;left:50%;transform:rotate(180deg)}.arrow-down[_ngcontent-%COMP%]{bottom:10px;left:50%}.direction-text[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:1.8rem;color:#eafff9;text-align:center;text-shadow:0 0 12px rgba(0,255,180,.7);font-weight:500;line-height:1.4;pointer-events:none;animation:_ngcontent-%COMP%_fadeInOut 1.2s ease-in-out infinite alternate;z-index:10}@keyframes _ngcontent-%COMP%_fadeInOut{0%{opacity:.4}to{opacity:1}}#toast-ok[_ngcontent-%COMP%]{width:340px;height:56px;position:relative;border-radius:8px;background-color:#82d3c466;border:1px solid #12856a;box-sizing:border-box;display:flex;align-items:center;padding:8px 16px;gap:8px;text-align:left;font-size:16px;color:#fff;margin-top:16px}.iconsolidcheck-circle[_ngcontent-%COMP%]{height:26px;width:26px;position:relative;margin-bottom:0}.toast-ok-text[_ngcontent-%COMP%]{position:relative;line-height:30px}']})};var Kb=class n{title=rt("guided-image-capture");static \u0275fac=function(t){return new(t||n)};static \u0275cmp=Xa({type:n,selectors:[["app-root"]],decls:1,vars:0,template:function(t,r){t&1&&tt(0,"app-camera")},dependencies:[qb],encapsulation:2})};Xw(Kb,WA).catch(n=>console.error(n));
