import{a as Je,b as Ft,d as D,e as mr,f as He,g as tg,h as sk}from"./chunk-YJQN4JTV.js";function er(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}var di,Mo,GI=D(()=>{"use strict";di=class{constructor(n,t){this.backend=n,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(n){return this.data.has(n)||this.dataMover.moveData(this.backend,n),this.data.get(n)}set(n,t){this.dataIdsCount++,this.data.set(n,t)}has(n){return this.data.has(n)}delete(n){return this.dataIdsCount--,this.data.delete(n)}numDataIds(){return this.dataIdsCount}},Mo=class{refCount(n){return er("refCount")}incRef(n){return er("incRef")}timerAvailable(){return!0}time(n){return er("time")}read(n){return er("read")}readSync(n){return er("readSync")}readToGPU(n,t){return er("readToGPU")}numDataIds(){return er("numDataIds")}disposeData(n,t){return er("disposeData")}write(n,t,r){return er("write")}move(n,t,r,o,s){return er("move")}createTensorFromGPUData(n,t,r){return er("createTensorFromGPUData")}memory(){return er("memory")}floatPrecision(){return er("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return er("dispose")}}});function m2(e){let n=e.length,t=0;for(;n>0;)t=Math.random()*n|0,n--,jx(e,n,t)}function hX(e,n){if(e.length!==n.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${n.length}`);let t=e.length,r=0;for(;t>0;)r=Math.random()*t|0,t--,jx(e,t,r),jx(n,t,r)}function Mp(e,n,t){return Math.max(e,Math.min(n,t))}function gX(e){return e%2===0?e:e+1}function jx(e,n,t){let r=e[n];e[n]=e[t],e[t]=r}function xX(e){let n=0;for(let t=0;t<e.length;t++)n+=e[t];return n}function yX(e,n){let t=Math.random();return n*t+(1-t)*e}function vX(e,n){let t=0;for(let r=0;r<e.length;r++){let o=Number(e[r])-Number(n[r]);t+=o*o}return t}function k(e,n){if(!e)throw new Error(typeof n=="string"?n:n())}function dt(e,n,t=""){k(kn(e,n),()=>t+` Shapes ${e} and ${n} must match`)}function Ir(e){k(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ke(e){if(e.length===0)return 1;let n=e[0];for(let t=1;t<e.length;t++)n*=e[t];return n}function bX(e){return e.length===0}function HI(e,n){if(e===n)return!0;if(e==null||n==null||e.length!==n.length)return!1;for(let t=0;t<e.length;t++)if(e[t]!==null&&n[t]!==null&&e[t]!==n[t])return!1;return!0}function kn(e,n){if(e===n)return!0;if(e==null||n==null||e.length!==n.length)return!1;for(let t=0;t<e.length;t++)if(e[t]!==n[t])return!1;return!0}function ps(e){return e%1===0}function CX(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let n=Math.exp(2*e);return(n-1)/(n+1)}}function wX(e){let n=Math.ceil(Math.sqrt(e));return[n,Math.ceil(e/n)]}function IX(e){let n=new Uint32Array(e);for(let t=0;t<e;++t)n[t]=t;return m2(n),n}function wc(e,n){return n<=e.length?e:e+" ".repeat(n-e.length)}function EX(e,n=o=>0,t,r){return new Promise((o,s)=>{let i=0,a=()=>{if(e()){o();return}i++;let c=n(i);if(t!=null&&i>=t){s();return}r!=null?r(a,c):setTimeout(a,c)};a()})}function TX(e,n){let t=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)t*=e[s];else if(e[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(r===-1){if(n>0&&n!==t)throw Error(`Size(${n}) must match the product of shape ${e}`);return e}if(t===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(n%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${n} / ${t}`);let o=e.slice();return o[r]=n/t,o}function fi(e,n){let t=n.length;return e=e==null?n.map((r,o)=>o):[].concat(e),k(e.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${e}`),k(e.every(r=>ps(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?t+r:r)}function WI(e,n){let t=[],r=[],o=n!=null&&Array.isArray(n)&&n.length===0,s=n==null||o?null:fi(n,e).sort(),i=0;for(let a=0;a<e.length;++a){if(s!=null){if(s[i]===a&&e[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${e[a]}' is not 1`);(s[i]==null||s[i]>a)&&e[a]===1&&(t.push(e[a]),r.push(a)),s[i]<=a&&i++}e[a]!==1&&(t.push(e[a]),r.push(a))}return{newShape:t,keptDims:r}}function jI(e,n){return qx(e,n)}function qx(e,n){let t=null;if(e==null||e==="float32")t=new Float32Array(n);else if(e==="int32")t=new Int32Array(n);else if(e==="bool")t=new Uint8Array(n);else if(e==="string")t=new Array(n);else throw new Error(`Unknown data type ${e}`);return t}function qI(e,n){for(let t=0;t<e.length;t++){let r=e[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${n} being uploaded contains ${r}.`)}}function KI(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function SX(e,n){return!(n==="complex64"||n==="float32"&&e!=="complex64"||n==="int32"&&e!=="float32"&&e!=="complex64"||n==="bool"&&e==="bool")}function $p(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function XI(e){if(e==null)return 0;let n=0;return e.forEach(t=>n+=t.length),n}function oo(e){return typeof e=="string"||e instanceof String}function h2(e){return typeof e=="boolean"}function g2(e){return typeof e=="number"}function mi(e){return Array.isArray(e)?mi(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":g2(e)?"float32":oo(e)?"string":h2(e)?"bool":"float32"}function $o(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Pp(e,n){for(let t=n;t<e;++t)if(e%t===0)return t;return e}function Po(e){let n=e.length;if(n<2)return[];let t=new Array(n-1);t[n-2]=e[n-1];for(let r=n-3;r>=0;--r)t[r]=t[r+1]*e[r+1];return t}function x2(e,n,t,r=!1){let o=new Array;if(n.length===1){let s=n[0]*(r?2:1);for(let i=0;i<s;i++)o[i]=t[e+i]}else{let s=n[0],i=n.slice(1),a=i.reduce((c,l)=>c*l)*(r?2:1);for(let c=0;c<s;c++)o[c]=x2(e+c*a,i,t,r)}return o}function Cc(e,n,t=!1){if(e.length===0)return n[0];let r=e.reduce((o,s)=>o*s)*(t?2:1);if(r===0)return[];if(r!==n.length)throw new Error(`[${e}] does not match the input size ${n.length}${t?" for a complex tensor":""}.`);return x2(0,e,n,t)}function NX(e,n){if(Array.isArray(e))return e;if(n==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(n==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(n==="bool"||n==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${n}`)}function rm(e,n){let t=Lp(e,n);for(let r=0;r<t.length;r++)t[r]=1;return t}function Lp(e,n){if(n==null||n==="float32"||n==="complex64")return new Float32Array(e);if(n==="int32")return new Int32Array(e);if(n==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${n}`)}function DX(e,n){let t=e.reduce((r,o)=>r*o,1);if(n==null||n==="float32")return Cc(e,new Float32Array(t));if(n==="int32")return Cc(e,new Int32Array(t));if(n==="bool")return Cc(e,new Uint8Array(t));throw new Error(`Unknown data type ${n}`)}function xt(e){e.forEach(n=>{k(Number.isInteger(n)&&n>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function kX(e,n,t){if(n===0)return 0;if(n===1)return e[0];let r=e[e.length-1];for(let o=0;o<e.length-1;++o)r+=t[o]*e[o];return r}function _X(e,n,t){if(n===0)return[];if(n===1)return[e];let r=new Array(n);for(let o=0;o<r.length-1;++o)r[o]=Math.floor(e/t[o]),e-=r[o]*t[o];return r[r.length-1]=e,r}function Ic(e){return e&&e.then&&typeof e.then=="function"}var jt=D(()=>{"use strict";});function RX(e){let n={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(FX(n,r[0],r[1]),r.join("="))),n}function FX(e,n,t){e[decodeURIComponent(n)]=decodeURIComponent(t||"")}function OX(e,n){let t=n.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:n}function M(){return Kx}function v2(e){Kx=e}var y2,Bp,Kx,nn=D(()=>{"use strict";jt();y2="tfjsflags",Bp=class{constructor(n){this.global=n,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=RX,this.populateURLFlags()}setPlatform(n,t){this.platform!=null&&(M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${n}.`)),this.platformName=n,this.platform=t}registerFlag(n,t,r){if(this.flagRegistry[n]={evaluationFn:t,setHook:r},this.urlFlags[n]!=null){let o=this.urlFlags[n];M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(`Setting feature override from URL ${n}: ${o}.`),this.set(n,o)}}async getAsync(n){return n in this.flags?this.flags[n]:(this.flags[n]=await this.evaluateFlag(n),this.flags[n])}get(n){if(n in this.flags)return this.flags[n];let t=this.evaluateFlag(n);if(Ic(t))throw new Error(`Flag ${n} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[n]=t,this.flags[n]}getNumber(n){return this.get(n)}getBool(n){return this.get(n)}getString(n){return this.get(n)}getFlags(){return this.flags}get features(){return this.flags}set(n,t){if(this.flagRegistry[n]==null)throw new Error(`Cannot set flag ${n} as it has not been registered.`);this.flags[n]=t,this.flagRegistry[n].setHook!=null&&this.flagRegistry[n].setHook(t)}evaluateFlag(n){if(this.flagRegistry[n]==null)throw new Error(`Cannot evaluate flag '${n}': no evaluation function found.`);return this.flagRegistry[n].evaluationFn()}setFlags(n){this.flags=Object.assign({},n)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let n=this.getQueryParams(this.global.location.search);y2 in n&&n[y2].split(",").forEach(r=>{let[o,s]=r.split(":");this.urlFlags[o]=OX(o,s)})}};Kx=null});function ZI(){if(YI==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");YI=e}return YI}function MX(){let e=ZI();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function om(e,n){let t=MX();if(t.has(e))return t.get(e);{let r=n();return t.set(e,r),t.get(e)}}var YI,Xx=D(()=>{"use strict";});var Ec,hi,gi,ds,Tc,Vp,Up,Sc,Nc,xi,yi,vi,bi,Ci,Dc,sm,kc,im,_c,Ac,Rc,wi,$X,Fc,fs,Ii,Ei,Oc,Mc,$c,Pc,Lc,Bc,Vc,am,Uc,zc,Ti,Gc,Hc,Wc,jc,qc,Kc,Xc,Yc,Zc,Qc,Yx,Zx,zp,Si,Jc,el,cm,tl,Ni,nl,rl,Di,Gp,ol,sl,ki,_i,il,al,cl,Ai,Ri,ms,ll,ul,Fi,Oi,Mi,pl,$i,Pi,dl,fl,Li,Bi,Vi,Ui,PX,LX,BX,Hp,lm,VX,Wp,zi,ml,um,hl,pm,gl,xl,jp,Gi,yl,vl,bl,Hi,qp,Wi,Cl,wl,Il,El,Tl,Sl,Nl,UX,Dl,kl,_l,Al,Rl,Fl,Ol,Ml,ji,qi,$l,Pl,dm,Ll,fm,Ki,Bl,Xi,Yi,Vl,Ul,zl,Gl,Zi,Hl,Wl,Qi,Ji,ea,ta,na,Kp,jl,ql,Kl,Xl,Yl,Zl,Ql,Jl,ra,mm,oa,eu,tu,nu,ru,ou,su,sa,hs,iu,au,gs,cu,lu,uu,zX,pu,ia,Xp,du,aa,ca,la,H=D(()=>{"use strict";Ec="Abs",hi="Acos",gi="Acosh",ds="Add",Tc="AddN",Vp="All",Up="Any",Sc="ArgMax",Nc="ArgMin",xi="Asin",yi="Asinh",vi="Atan",bi="Atanh",Ci="Atan2",Dc="AvgPool",sm="AvgPoolGrad",kc="AvgPool3D",im="AvgPool3DGrad",_c="BatchMatMul",Ac="BatchToSpaceND",Rc="Bincount",wi="BitwiseAnd",$X="BroadcastTo",Fc="BroadcastArgs",fs="Cast",Ii="Ceil",Ei="ClipByValue",Oc="Complex",Mc="ComplexAbs",$c="Concat",Pc="Conv2D",Lc="Conv2DBackpropFilter",Bc="Conv2DBackpropInput",Vc="Conv3D",am="Conv3DBackpropFilterV2",Uc="Conv3DBackpropInputV2",zc="Cos",Ti="Cosh",Gc="Cumprod",Hc="Cumsum",Wc="CropAndResize",jc="DenseBincount",qc="DepthToSpace",Kc="DepthwiseConv2dNative",Xc="DepthwiseConv2dNativeBackpropFilter",Yc="DepthwiseConv2dNativeBackpropInput",Zc="Diag",Qc="Dilation2D",Yx="Dilation2DBackpropInput",Zx="Dilation2DBackpropFilter",zp="Draw",Si="RealDiv",Jc="Einsum",el="Elu",cm="EluGrad",tl="Erf",Ni="Equal",nl="Exp",rl="ExpandDims",Di="Expm1",Gp="FFT",ol="Fill",sl="FlipLeftRight",ki="Floor",_i="FloorDiv",il="FusedBatchNorm",al="GatherV2",cl="GatherNd",Ai="Greater",Ri="GreaterEqual",ms="Identity",ll="IFFT",ul="Imag",Fi="IsFinite",Oi="IsInf",Mi="IsNan",pl="LeakyRelu",$i="Less",Pi="LessEqual",dl="LinSpace",fl="Log",Li="Log1p",Bi="LogicalAnd",Vi="LogicalNot",Ui="LogicalOr",PX="LogicalXor",LX="LogSoftmax",BX="LowerBound",Hp="LRN",lm="LRNGrad",VX="MatrixBandPart",Wp="Max",zi="Maximum",ml="MaxPool",um="MaxPoolGrad",hl="MaxPool3D",pm="MaxPool3DGrad",gl="MaxPoolWithArgmax",xl="Mean",jp="Min",Gi="Minimum",yl="MirrorPad",vl="Mod",bl="Multinomial",Hi="Multiply",qp="Neg",Wi="NotEqual",Cl="NonMaxSuppressionV3",wl="NonMaxSuppressionV4",Il="NonMaxSuppressionV5",El="OnesLike",Tl="OneHot",Sl="Pack",Nl="PadV2",UX="Pool",Dl="Pow",kl="Prelu",_l="Prod",Al="RaggedGather",Rl="RaggedRange",Fl="RaggedTensorToTensor",Ol="Range",Ml="Real",ji="Reciprocal",qi="Relu",$l="Reshape",Pl="ResizeNearestNeighbor",dm="ResizeNearestNeighborGrad",Ll="ResizeBilinear",fm="ResizeBilinearGrad",Ki="Relu6",Bl="Reverse",Xi="Round",Yi="Rsqrt",Vl="ScatterNd",Ul="TensorScatterUpdate",zl="SearchSorted",Gl="Select",Zi="Selu",Hl="Slice",Wl="Sin",Qi="Sinh",Ji="Sign",ea="Sigmoid",ta="Softplus",na="Sqrt",Kp="Sum",jl="SpaceToBatchND",ql="SplitV",Kl="Softmax",Xl="SparseFillEmptyRows",Yl="SparseReshape",Zl="SparseSegmentMean",Ql="SparseSegmentSum",Jl="SparseToDense",ra="SquaredDifference",mm="Square",oa="StaticRegexReplace",eu="StridedSlice",tu="StringNGrams",nu="StringSplit",ru="StringToHashBucketFast",ou="Sub",su="Tan",sa="Tanh",hs="Tile",iu="TopK",au="Transform",gs="Transpose",cu="Unique",lu="Unpack",uu="UnsortedSegmentSum",zX="UpperBound",pu="ZerosLike",ia="Step",Xp="FromPixels",du="RotateWithOffset",aa="_FusedMatMul",ca="FusedConv2D",la="FusedDepthwiseConv2D"});function Lo(...e){M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(...e)}function GX(...e){M().getBool("IS_TEST")||M().getBool("PROD")||console.log(...e)}var Qx=D(()=>{"use strict";nn();});function fu(e,n){let t=QI(e,n);return Yp.get(t)}function Jx(e){return hm.get(e)}function gm(e){let n=Yp.entries(),t=[];for(;;){let{done:r,value:o}=n.next();if(r)break;let[s,i]=o,[a]=s.split("_");a===e&&t.push(i)}return t}function Zp(e){let{kernelName:n,backendName:t}=e,r=QI(n,t);Yp.has(r)&&Lo(`The kernel '${n}' for backend '${t}' is already registered`),Yp.set(r,e)}function HX(e){let{kernelName:n}=e;hm.has(n)&&M().getBool("DEBUG")&&Lo(`Overriding the gradient for '${n}'`),hm.set(n,e)}function WX(e,n){let t=QI(e,n);if(!Yp.has(t))throw new Error(`The kernel '${e}' for backend '${n}' is not registered`);Yp.delete(t)}function jX(e){if(!hm.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);hm.delete(e)}function qX(e,n){gm(e).forEach(r=>{let o=Object.assign({},r,{backendName:n});Zp(o)})}function QI(e,n){return`${n}_${e}`}var Yp,hm,ey=D(()=>{"use strict";nn();Xx();Qx();Yp=om("kernelRegistry",()=>new Map),hm=om("gradRegistry",()=>new Map)});function ty(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var JI=D(()=>{"use strict";});var A2=mr((K1e,_2)=>{"use strict";_2.exports=It;var $r=null;try{$r=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function It(e,n,t){this.low=e|0,this.high=n|0,this.unsigned=!!t}It.prototype.__isLong__;Object.defineProperty(It.prototype,"__isLong__",{value:!0});function nr(e){return(e&&e.__isLong__)===!0}It.isLong=nr;var C2={},w2={};function hu(e,n){var t,r,o;return n?(e>>>=0,(o=0<=e&&e<256)&&(r=w2[e],r)?r:(t=Et(e,(e|0)<0?-1:0,!0),o&&(w2[e]=t),t)):(e|=0,(o=-128<=e&&e<128)&&(r=C2[e],r)?r:(t=Et(e,e<0?-1:0,!1),o&&(C2[e]=t),t))}It.fromInt=hu;function Pr(e,n){if(isNaN(e))return n?mu:Lr;if(n){if(e<0)return mu;if(e>=S2)return k2}else{if(e<=-E2)return tr;if(e+1>=E2)return D2}return e<0?Pr(-e,n).neg():Et(e%Jp|0,e/Jp|0,n)}It.fromNumber=Pr;function Et(e,n,t){return new It(e,n,t)}It.fromBits=Et;var ny=Math.pow;function tE(e,n,t){if(e.length===0)throw Error("empty string");if(e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return Lr;if(typeof n=="number"?(t=n,n=!1):n=!!n,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return tE(e.substring(1),n,t).neg();for(var o=Pr(ny(t,8)),s=Lr,i=0;i<e.length;i+=8){var a=Math.min(8,e.length-i),c=parseInt(e.substring(i,i+a),t);if(a<8){var l=Pr(ny(t,a));s=s.mul(l).add(Pr(c))}else s=s.mul(o),s=s.add(Pr(c))}return s.unsigned=n,s}It.fromString=tE;function so(e,n){return typeof e=="number"?Pr(e,n):typeof e=="string"?tE(e,n):Et(e.low,e.high,typeof n=="boolean"?n:e.unsigned)}It.fromValue=so;var I2=65536,KX=1<<24,Jp=I2*I2,S2=Jp*Jp,E2=S2/2,T2=hu(KX),Lr=hu(0);It.ZERO=Lr;var mu=hu(0,!0);It.UZERO=mu;var Qp=hu(1);It.ONE=Qp;var N2=hu(1,!0);It.UONE=N2;var eE=hu(-1);It.NEG_ONE=eE;var D2=Et(-1,2147483647,!1);It.MAX_VALUE=D2;var k2=Et(-1,-1,!0);It.MAX_UNSIGNED_VALUE=k2;var tr=Et(0,-2147483648,!1);It.MIN_VALUE=tr;var ie=It.prototype;ie.toInt=function(){return this.unsigned?this.low>>>0:this.low};ie.toNumber=function(){return this.unsigned?(this.high>>>0)*Jp+(this.low>>>0):this.high*Jp+(this.low>>>0)};ie.toString=function(n){if(n=n||10,n<2||36<n)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(tr)){var t=Pr(n),r=this.div(t),o=r.mul(t).sub(this);return r.toString(n)+o.toInt().toString(n)}else return"-"+this.neg().toString(n);for(var s=Pr(ny(n,6),this.unsigned),i=this,a="";;){var c=i.div(s),l=i.sub(c.mul(s)).toInt()>>>0,u=l.toString(n);if(i=c,i.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};ie.getHighBits=function(){return this.high};ie.getHighBitsUnsigned=function(){return this.high>>>0};ie.getLowBits=function(){return this.low};ie.getLowBitsUnsigned=function(){return this.low>>>0};ie.getNumBitsAbs=function(){if(this.isNegative())return this.eq(tr)?64:this.neg().getNumBitsAbs();for(var n=this.high!=0?this.high:this.low,t=31;t>0&&(n&1<<t)==0;t--);return this.high!=0?t+33:t+1};ie.isZero=function(){return this.high===0&&this.low===0};ie.eqz=ie.isZero;ie.isNegative=function(){return!this.unsigned&&this.high<0};ie.isPositive=function(){return this.unsigned||this.high>=0};ie.isOdd=function(){return(this.low&1)===1};ie.isEven=function(){return(this.low&1)===0};ie.equals=function(n){return nr(n)||(n=so(n)),this.unsigned!==n.unsigned&&this.high>>>31===1&&n.high>>>31===1?!1:this.high===n.high&&this.low===n.low};ie.eq=ie.equals;ie.notEquals=function(n){return!this.eq(n)};ie.neq=ie.notEquals;ie.ne=ie.notEquals;ie.lessThan=function(n){return this.comp(n)<0};ie.lt=ie.lessThan;ie.lessThanOrEqual=function(n){return this.comp(n)<=0};ie.lte=ie.lessThanOrEqual;ie.le=ie.lessThanOrEqual;ie.greaterThan=function(n){return this.comp(n)>0};ie.gt=ie.greaterThan;ie.greaterThanOrEqual=function(n){return this.comp(n)>=0};ie.gte=ie.greaterThanOrEqual;ie.ge=ie.greaterThanOrEqual;ie.compare=function(n){if(nr(n)||(n=so(n)),this.eq(n))return 0;var t=this.isNegative(),r=n.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?n.high>>>0>this.high>>>0||n.high===this.high&&n.low>>>0>this.low>>>0?-1:1:this.sub(n).isNegative()?-1:1};ie.comp=ie.compare;ie.negate=function(){return!this.unsigned&&this.eq(tr)?tr:this.not().add(Qp)};ie.neg=ie.negate;ie.add=function(n){nr(n)||(n=so(n));var t=this.high>>>16,r=this.high&65535,o=this.low>>>16,s=this.low&65535,i=n.high>>>16,a=n.high&65535,c=n.low>>>16,l=n.low&65535,u=0,p=0,d=0,f=0;return f+=s+l,d+=f>>>16,f&=65535,d+=o+c,p+=d>>>16,d&=65535,p+=r+a,u+=p>>>16,p&=65535,u+=t+i,u&=65535,Et(d<<16|f,u<<16|p,this.unsigned)};ie.subtract=function(n){return nr(n)||(n=so(n)),this.add(n.neg())};ie.sub=ie.subtract;ie.multiply=function(n){if(this.isZero())return Lr;if(nr(n)||(n=so(n)),$r){var t=$r.mul(this.low,this.high,n.low,n.high);return Et(t,$r.get_high(),this.unsigned)}if(n.isZero())return Lr;if(this.eq(tr))return n.isOdd()?tr:Lr;if(n.eq(tr))return this.isOdd()?tr:Lr;if(this.isNegative())return n.isNegative()?this.neg().mul(n.neg()):this.neg().mul(n).neg();if(n.isNegative())return this.mul(n.neg()).neg();if(this.lt(T2)&&n.lt(T2))return Pr(this.toNumber()*n.toNumber(),this.unsigned);var r=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=n.high>>>16,c=n.high&65535,l=n.low>>>16,u=n.low&65535,p=0,d=0,f=0,m=0;return m+=i*u,f+=m>>>16,m&=65535,f+=s*u,d+=f>>>16,f&=65535,f+=i*l,d+=f>>>16,f&=65535,d+=o*u,p+=d>>>16,d&=65535,d+=s*l,p+=d>>>16,d&=65535,d+=i*c,p+=d>>>16,d&=65535,p+=r*u+o*l+s*c+i*a,p&=65535,Et(f<<16|m,p<<16|d,this.unsigned)};ie.mul=ie.multiply;ie.divide=function(n){if(nr(n)||(n=so(n)),n.isZero())throw Error("division by zero");if($r){if(!this.unsigned&&this.high===-2147483648&&n.low===-1&&n.high===-1)return this;var t=(this.unsigned?$r.div_u:$r.div_s)(this.low,this.high,n.low,n.high);return Et(t,$r.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?mu:Lr;var r,o,s;if(this.unsigned){if(n.unsigned||(n=n.toUnsigned()),n.gt(this))return mu;if(n.gt(this.shru(1)))return N2;s=mu}else{if(this.eq(tr)){if(n.eq(Qp)||n.eq(eE))return tr;if(n.eq(tr))return Qp;var i=this.shr(1);return r=i.div(n).shl(1),r.eq(Lr)?n.isNegative()?Qp:eE:(o=this.sub(n.mul(r)),s=r.add(o.div(n)),s)}else if(n.eq(tr))return this.unsigned?mu:Lr;if(this.isNegative())return n.isNegative()?this.neg().div(n.neg()):this.neg().div(n).neg();if(n.isNegative())return this.div(n.neg()).neg();s=Lr}for(o=this;o.gte(n);){r=Math.max(1,Math.floor(o.toNumber()/n.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),c=a<=48?1:ny(2,a-48),l=Pr(r),u=l.mul(n);u.isNegative()||u.gt(o);)r-=c,l=Pr(r,this.unsigned),u=l.mul(n);l.isZero()&&(l=Qp),s=s.add(l),o=o.sub(u)}return s};ie.div=ie.divide;ie.modulo=function(n){if(nr(n)||(n=so(n)),$r){var t=(this.unsigned?$r.rem_u:$r.rem_s)(this.low,this.high,n.low,n.high);return Et(t,$r.get_high(),this.unsigned)}return this.sub(this.div(n).mul(n))};ie.mod=ie.modulo;ie.rem=ie.modulo;ie.not=function(){return Et(~this.low,~this.high,this.unsigned)};ie.and=function(n){return nr(n)||(n=so(n)),Et(this.low&n.low,this.high&n.high,this.unsigned)};ie.or=function(n){return nr(n)||(n=so(n)),Et(this.low|n.low,this.high|n.high,this.unsigned)};ie.xor=function(n){return nr(n)||(n=so(n)),Et(this.low^n.low,this.high^n.high,this.unsigned)};ie.shiftLeft=function(n){return nr(n)&&(n=n.toInt()),(n&=63)===0?this:n<32?Et(this.low<<n,this.high<<n|this.low>>>32-n,this.unsigned):Et(0,this.low<<n-32,this.unsigned)};ie.shl=ie.shiftLeft;ie.shiftRight=function(n){return nr(n)&&(n=n.toInt()),(n&=63)===0?this:n<32?Et(this.low>>>n|this.high<<32-n,this.high>>n,this.unsigned):Et(this.high>>n-32,this.high>=0?0:-1,this.unsigned)};ie.shr=ie.shiftRight;ie.shiftRightUnsigned=function(n){if(nr(n)&&(n=n.toInt()),n&=63,n===0)return this;var t=this.high;if(n<32){var r=this.low;return Et(r>>>n|t<<32-n,t>>>n,this.unsigned)}else return n===32?Et(t,0,this.unsigned):Et(t>>>n-32,0,this.unsigned)};ie.shru=ie.shiftRightUnsigned;ie.shr_u=ie.shiftRightUnsigned;ie.toSigned=function(){return this.unsigned?Et(this.low,this.high,!1):this};ie.toUnsigned=function(){return this.unsigned?this:Et(this.low,this.high,!0)};ie.toBytes=function(n){return n?this.toBytesLE():this.toBytesBE()};ie.toBytesLE=function(){var n=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,n&255,n>>>8&255,n>>>16&255,n>>>24]};ie.toBytesBE=function(){var n=this.high,t=this.low;return[n>>>24,n>>>16&255,n>>>8&255,n&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};It.fromBytes=function(n,t,r){return r?It.fromBytesLE(n,t):It.fromBytesBE(n,t)};It.fromBytesLE=function(n,t){return new It(n[0]|n[1]<<8|n[2]<<16|n[3]<<24,n[4]|n[5]<<8|n[6]<<16|n[7]<<24,t)};It.fromBytesBE=function(n,t){return new It(n[4]<<24|n[5]<<16|n[6]<<8|n[7],n[0]<<24|n[1]<<16|n[2]<<8|n[3],t)}});function xm(e){return xu.fromString(e,!0,16)}function nE(e){return e.xor(e.shru(47))}function O2(e,n,t){let r=e.slice(n,n+t);return xu.fromBytes(Array.from(r),!0,!0)}function yt(e,n){return O2(e,n,8)}function R2(e,n){return O2(e,n,4)}function rn(e,n){return n===0?e:e.shru(n).or(e.shl(64-n))}function ua(e,n,t=xm("9ddfea08eb382d69")){let r=e.xor(n).mul(t);r=r.xor(r.shru(47));let o=n.xor(r).mul(t);return o=o.xor(o.shru(47)),o=o.mul(t),o}function XX(e,n,t,r,o,s){o=o.add(e),s=rn(s.add(o).add(r),21);let i=o;return o=o.add(n),o=o.add(t),s=s.add(rn(o,44)),[o.add(r),s.add(i)]}function ry(e,n,t,r){return XX(yt(e,n),yt(e,n+8),yt(e,n+16),yt(e,n+24),t,r)}function YX(e,n=e.length){if(n>=8){let t=_n.add(n*2),r=yt(e,0).add(_n),o=yt(e,n-8),s=rn(o,37).mul(t).add(r),i=rn(r,25).add(o).mul(t);return ua(s,i,t)}if(n>=4){let t=_n.add(n*2),r=R2(e,0);return ua(r.shl(3).add(n),R2(e,n-4),t)}if(n>0){let t=e[0],r=e[n>>1],o=e[n-1],s=t+(r<<8),i=n+(o<<2);return nE(_n.mul(s).xor(F2.mul(i))).mul(_n)}return _n}function ZX(e,n=e.length){let t=_n.add(n*2),r=yt(e,0).mul(gu),o=yt(e,8),s=yt(e,n-8).mul(t),i=yt(e,n-16).mul(_n);return ua(rn(r.add(o),43).add(rn(s,30)).add(i),r.add(rn(o.add(_n),18)).add(s),t)}function QX(e,n=e.length){let t=_n.add(n*2),r=yt(e,0).mul(_n),o=yt(e,8),s=yt(e,n-8).mul(t),i=yt(e,n-16).mul(_n),a=rn(r.add(o),43).add(rn(s,30)).add(i),c=ua(a,r.add(rn(o.add(_n),18)).add(s),t),l=yt(e,16).mul(t),u=yt(e,24),p=a.add(yt(e,n-32)).mul(t),d=c.add(yt(e,n-24)).mul(t);return ua(rn(l.add(u),43).add(rn(p,30)).add(d),l.add(rn(u.add(r),18)).add(p),t)}function JX(e,n=e.length){let t=xu.fromNumber(81,!0);if(n<=32)return n<=16?YX(e,n):ZX(e,n);if(n<=64)return QX(e,n);let r=t,o=t.mul(gu).add(113),s=nE(o.mul(_n).add(113)).mul(_n),i=[xu.UZERO,xu.UZERO],a=[xu.UZERO,xu.UZERO];r=r.mul(_n).add(yt(e,0));let c=0,l=(n-1>>6)*64,u=l+(n-1&63)-63;do r=rn(r.add(o).add(i[0]).add(yt(e,c+8)),37).mul(gu),o=rn(o.add(i[1]).add(yt(e,c+48)),42).mul(gu),r=r.xor(a[1]),o=o.add(i[0]).add(yt(e,c+40)),s=rn(s.add(a[0]),33).mul(gu),i=ry(e,c,i[1].mul(gu),r.add(a[0])),a=ry(e,c+32,s.add(a[1]),o.add(yt(e,c+16))),[s,r]=[r,s],c+=64;while(c!==l);let p=gu.add(s.and(255).shl(1));return c=u,a[0]=a[0].add(n-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=rn(r.add(o).add(i[0]).add(yt(e,c+8)),37).mul(p),o=rn(o.add(i[1]).add(yt(e,c+48)),42).mul(p),r=r.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(yt(e,c+40))),s=rn(s.add(a[0]),33).mul(p),i=ry(e,c,i[1].mul(p),r.add(a[0])),a=ry(e,c+32,s.add(a[1]),o.add(yt(e,c+16))),[s,r]=[r,s],ua(ua(i[0],a[0],p).add(nE(o).mul(F2)).add(s),ua(i[1],a[1],p).add(r),p)}var rE,xu,F2,gu,_n,M2=D(()=>{"use strict";rE=tg(A2());xu=rE.default||rE;F2=xm("c3a5c85c97cb3127"),gu=xm("b492b66fbe98f273"),_n=xm("9ae16a3b2f90404f")});var y={};He(y,{arraysEqual:()=>kn,arraysEqualWithNull:()=>HI,assert:()=>k,assertNonNegativeIntegerDimensions:()=>xt,assertNonNull:()=>Ir,assertShapesMatch:()=>dt,bytesFromStringArray:()=>XI,bytesPerElement:()=>$p,checkConversionForErrors:()=>qI,clamp:()=>Mp,computeStrides:()=>Po,convertBackendValuesAndArrayBuffer:()=>NX,createScalarValue:()=>eY,createShuffledIndices:()=>IX,decodeString:()=>td,distSquared:()=>vX,encodeString:()=>pa,fetch:()=>nY,fingerPrint64:()=>JX,flatten:()=>io,getArrayFromDType:()=>qx,getTypedArrayFromDType:()=>jI,hasEncodingLoss:()=>SX,hexToLong:()=>xm,indexToLoc:()=>_X,inferDtype:()=>mi,inferFromImplicitShape:()=>TX,isBoolean:()=>h2,isFunction:()=>$o,isInt:()=>ps,isNumber:()=>g2,isPromise:()=>Ic,isScalarShape:()=>bX,isString:()=>oo,isTypedArray:()=>Ot,isValidDtype:()=>KI,locToIndex:()=>kX,makeOnesTypedArray:()=>rm,makeZerosNestedTypedArray:()=>DX,makeZerosTypedArray:()=>Lp,nearestDivisor:()=>Pp,nearestLargerEven:()=>gX,now:()=>yu,parseAxisParam:()=>fi,randUniform:()=>yX,repeatedTry:()=>EX,rightPad:()=>wc,shuffle:()=>m2,shuffleCombo:()=>hX,sizeFromShape:()=>ke,sizeToSquarishShape:()=>wX,squeezeShape:()=>WI,sum:()=>xX,swap:()=>jx,tanh:()=>CX,toNestedArray:()=>Cc,toTypedArray:()=>ed});function eY(e,n){return n==="string"?pa(e):ed([e],n)}function tY(e,n){return e instanceof Float32Array&&n==="float32"||e instanceof Int32Array&&n==="int32"||e instanceof Uint8Array&&n==="bool"}function ed(e,n){if(n==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=io(e)),M().getBool("DEBUG")&&qI(e,n),tY(e,n))return e;if(n==null||n==="float32"||n==="complex64")return new Float32Array(e);if(n==="int32")return new Int32Array(e);if(n==="bool"){let t=new Uint8Array(e.length);for(let r=0;r<t.length;++r)Math.round(e[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${n}`)}function yu(){return M().platform.now()}function nY(e,n){return M().platform.fetch(e,n)}function pa(e,n="utf-8"){return n=n||"utf-8",M().platform.encode(e,n)}function td(e,n="utf-8"){return n=n||"utf-8",M().platform.decode(e,n)}function Ot(e){return M().platform.isTypedArray!=null?M().platform.isTypedArray(e):ty(e)}function io(e,n=[],t=!1){if(n==null&&(n=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||Ic(e)||e==null||Ot(e)&&t)n.push(e);else if(Array.isArray(e)||Ot(e))for(let r=0;r<e.length;++r)io(e[r],n,t);else{let r=-1;for(let o of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(o)&&(r=Math.max(r,Number(o)));for(let o=0;o<=r;o++)io(e[o],n,t)}return n}var q=D(()=>{"use strict";nn();JI();jt();jt();M2();});function rY(e,n,t){if(n!=="float32")return!1;for(let r=0;r<e.length;r++){let o=e[r];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${t}'`),!0}return!1}var oy,oE,$2=D(()=>{"use strict";nn();q();oy=class{constructor(n,t){this.backendTimer=n,this.logger=t,t==null&&(this.logger=new oE)}profileKernel(n,t,r){let o,s=()=>{o=r()},i,a=yu();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();i=Promise.resolve({kernelMs:yu()-a})}if(M().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let u=o[l];u.data().then(p=>{rY(p,u.dtype,n)})}return{kernelName:n,outputs:o,inputs:t,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(n){let{kernelName:t,outputs:r,timeMs:o,inputs:s,extraInfo:i}=n;r.forEach(a=>{Promise.all([a.data(),o,i]).then(c=>{this.logger.logKernelProfile(t,a,c[0],c[1],s,c[2])})})}};oE=class{logKernelProfile(n,t,r,o,s,i){let a=typeof o=="number"?wc(`${o}ms`,9):o.error,c=wc(n,25),l=t.rank,u=t.size,p=wc(t.shape.toString(),14),d="";for(let f in s){let m=s[f];if(m!=null){let h=m.shape||t.shape,g=h.length;d+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${c}	%c${a}	%c${l}D ${p}	%c${u}	%c${d}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}});function P2(e,n,t){let r={},o={};for(let c=0;c<n.length;c++)r[n[c].id]=!0;for(let c=0;c<e.length;c++){let l=e[c],u=l.inputs;for(let p in u){let d=u[p],f=!1;for(let m=0;m<n.length;m++)if(r[d.id]){l.outputs.forEach(h=>r[h.id]=!0),f=!0,o[l.id]=!0;break}if(f)break}}let s={};s[t.id]=!0;let i={};for(let c=e.length-1;c>=0;c--){let l=e[c],u=l.inputs;for(let p=0;p<l.outputs.length;p++)if(s[l.outputs[p].id]){for(let d in u)s[u[d].id]=!0,i[l.id]=!0;break}}let a=[];for(let c=0;c<e.length;c++){let l=e[c];if(o[l.id]&&i[l.id]){let u={};for(let d in l.inputs){let f=l.inputs[d];r[f.id]&&(u[d]=f)}let p=Object.assign({},l);p.inputs=u,p.outputs=l.outputs,a.push(p)}}return a}function L2(e,n,t,r){for(let o=n.length-1;o>=0;o--){let s=n[o],i=[];if(s.outputs.forEach(c=>{let l=e[c.id];l!=null?i.push(l):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let c in s.inputs){if(!(c in a))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(a)}.`);let l=t(()=>a[c]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${l.dtype}'`);let u=s.inputs[c];if(!kn(l.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${c}' has shape '${l.shape}', which does not match the shape of the input '${u.shape}'`);if(e[u.id]==null)e[u.id]=l;else{let p=e[u.id];e[u.id]=r(p,l),p.dispose()}}}}var B2=D(()=>{"use strict";q();});function U2(e,n,t,r){let o=Po(n),s=oY(e,n,t,o),i=n.length,a=sy(e,n,t,o,s),c=["Tensor"];return r&&(c.push(`  dtype: ${t}`),c.push(`  rank: ${i}`),c.push(`  shape: [${n}]`),c.push("  values:")),c.push(a.map(l=>"    "+l).join(`
`)),c.join(`
`)}function oY(e,n,t,r){let o=ke(n),s=r[r.length-1],i=new Array(s).fill(0),a=n.length,c=t==="complex64"?bm(e):e;if(a>1)for(let l=0;l<o/s;l++){let u=l*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],vm(c[u+p],0,t).length)}return i}function vm(e,n,t){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(sE))} + ${parseFloat(e[1].toFixed(sE))}j`:oo(e)?r=`'${e}'`:t==="bool"?r=z2(e):r=parseFloat(e.toFixed(sE)).toString(),wc(r,n)}function z2(e){return e===0?"false":"true"}function sy(e,n,t,r,o,s=!0){let i=t==="complex64"?2:1,a=n[0],c=n.length;if(c===0){if(t==="complex64"){let h=bm(e);return[vm(h[0],0,t)]}return t==="bool"?[z2(e[0])]:[e[0].toString()]}if(c===1){if(a>V2){let g=ym*i,x=Array.from(e.slice(0,g)),v=Array.from(e.slice((a-ym)*i,a*i));return t==="complex64"&&(x=bm(x),v=bm(v)),["["+x.map((w,I)=>vm(w,o[I],t)).join(", ")+", ..., "+v.map((w,I)=>vm(w,o[a-ym+I],t)).join(", ")+"]"]}return["["+(t==="complex64"?bm(e):Array.from(e)).map((g,x)=>vm(g,o[x],t)).join(", ")+"]"]}let l=n.slice(1),u=r.slice(1),p=r[0]*i,d=[];if(a>V2){for(let h=0;h<ym;h++){let g=h*p,x=g+p;d.push(...sy(e.slice(g,x),l,t,u,o,!1))}d.push("...");for(let h=a-ym;h<a;h++){let g=h*p,x=g+p;d.push(...sy(e.slice(g,x),l,t,u,o,h===a-1))}}else for(let h=0;h<a;h++){let g=h*p,x=g+p;d.push(...sy(e.slice(g,x),l,t,u,o,h===a-1))}let f=c===2?",":"";d[0]="["+(a>0?d[0]+f:"");for(let h=1;h<d.length-1;h++)d[h]=" "+d[h]+f;let m=`,
`;for(let h=2;h<c;h++)m+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":m),d}function bm(e){let n=[];for(let t=0;t<e.length;t+=2)n.push([e[t],e[t+1]]);return n}var V2,ym,sE,G2=D(()=>{"use strict";q();V2=20,ym=3,sE=7});function H2(e){ao=e}function W2(e){nd=e}function j2(e){sY=e}function iE(){return om("Tensor",()=>ot)}var Ke,ao,nd,sY,ot,Bo,Er=D(()=>{"use strict";Xx();G2();q();q();Ke=class{constructor(n,t,r){if(this.dtype=t,this.shape=n.slice(),this.size=ke(n),r!=null){let o=r.length;k(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||qx(t,this.size),this.strides=Po(n)}set(n,...t){t.length===0&&(t=[0]),k(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let r=this.locToIndex(t);this.values[r]=n}get(...n){n.length===0&&(n=[0]);let t=0;for(let o of n){if(o<0||o>=this.shape[t]){let s=`Requested out of range element at ${n}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let r=n[n.length-1];for(let o=0;o<n.length-1;++o)r+=this.strides[o]*n[o];return this.values[r]}locToIndex(n){if(this.rank===0)return 0;if(this.rank===1)return n[0];let t=n[n.length-1];for(let r=0;r<n.length-1;++r)t+=this.strides[r]*n[r];return t}indexToLoc(n){if(this.rank===0)return[];if(this.rank===1)return[n];let t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(n/this.strides[r]),n-=t[r]*this.strides[r];return t[t.length-1]=n,t}get rank(){return this.shape.length}toTensor(){return ao().makeTensor(this.values,this.shape,this.dtype)}},ao=null,nd=null,sY=null;ot=class{constructor(n,t,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=n.slice(),this.dtype=t||"float32",this.size=ke(n),this.strides=Po(n),this.dataId=r,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let n=await this.data();return nd.buffer(this.shape,this.dtype,n)}bufferSync(){return nd.buffer(this.shape,this.dtype,this.dataSync())}async array(){let n=await this.data();return Cc(this.shape,n,this.dtype==="complex64")}arraySync(){return Cc(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let n=ao().read(this.dataId);if(this.dtype==="string"){let t=await n;try{return t.map(r=>td(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return n}dataToGPU(n){return this.throwIfDisposed(),ao().readToGPU(this.dataId,n)}dataSync(){this.throwIfDisposed();let n=ao().readSync(this.dataId);if(this.dtype==="string")try{return n.map(t=>td(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return n}async bytes(){this.throwIfDisposed();let n=await ao().read(this.dataId);return this.dtype==="string"?n:new Uint8Array(n.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ao().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(n=!1){return nd.print(this,n)}clone(){return this.throwIfDisposed(),nd.clone(this)}toString(n=!1){let t=this.dataSync();return U2(t,this.shape,this.dtype,n)}cast(n){return this.throwIfDisposed(),nd.cast(this,n)}variable(n=!0,t,r){return this.throwIfDisposed(),ao().makeVariable(this,n,t,r)}};Object.defineProperty(ot,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});iE();Bo=class extends ot{constructor(n,t,r,o){super(n.shape,n.dtype,n.dataId,o),this.trainable=t,this.name=r}assign(n){if(n.dtype!==this.dtype)throw new Error(`dtype of the new value (${n.dtype}) and previous value (${this.dtype}) must match`);if(!kn(n.shape,this.shape))throw new Error(`shape of the new value (${n.shape}) and previous value (${this.shape}) must match`);ao().disposeTensor(this),this.dataId=n.dataId,ao().incRef(this,null)}dispose(){ao().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Bo,Symbol.hasInstance,{value:e=>e instanceof ot&&e.assign!=null&&e.assign instanceof Function})});function Mt(e,n){if(e==="string"||n==="string"){if(e==="string"&&n==="string")return"string";throw new Error(`Can not upcast ${e} with ${n}`)}return iY[e][n]}function da(e){return Mt(e,"int32")}function iy(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function ay(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}var aE,q2,K2,X2,Y2,iY,rd=D(()=>{"use strict";aE=(function(e){return e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6",e})(aE||{}),q2=(function(e){return e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64",e})(q2||{}),K2=(function(e){return e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64",e})(K2||{}),X2=(function(e){return e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64",e})(X2||{}),Y2=(function(e){return e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64",e})(Y2||{}),iY={float32:X2,int32:q2,bool:K2,complex64:Y2}});var lE={};He(lE,{assertTypesMatch:()=>cE,getTensorsInContainer:()=>Cm,isTensorInList:()=>aY,makeTypesMatch:()=>Se});function Se(e,n){if(e.dtype===n.dtype)return[e,n];let t=Mt(e.dtype,n.dtype);return[e.cast(t),n.cast(t)]}function cE(e,n){k(e.dtype===n.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${n.dtype}) input must match`)}function aY(e,n){return n.some(t=>t.id===e.id)}function Cm(e){let n=[];return Z2(e,n,new Set),n}function Z2(e,n,t){if(e==null)return;if(e instanceof ot){n.push(e);return}if(!cY(e))return;let r=e;for(let o in r){let s=r[o];t.has(s)||(t.add(s),Z2(s,n,t))}}function cY(e){return Array.isArray(e)||typeof e=="object"}var vt=D(()=>{"use strict";Er();rd();q();});function uE(e){return e.kernelName!=null}function uY(e){let n=rm(ke(e),"float32");return N.makeTensor(n,e,"float32")}function pE(){let e=ZI();if(e._tfengine==null){let n=new Bp(e);e._tfengine=new lY(n)}return v2(e._tfengine.ENV),H2(()=>e._tfengine),e._tfengine}function pY(e,n){let t={a:e,b:n};return N.runKernel("Add",t)}var cy,lY,N,B=D(()=>{"use strict";GI();nn();Xx();H();ey();Qx();$2();B2();Er();vt();q();q();cy=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(n=>n.name)))}}}dispose(){for(let n in this.registeredVariables)this.registeredVariables[n].dispose()}},lY=(()=>{class e{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new cy}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let r=0;r<t.length;r++){let o=t[r];if(await this.initializeBackend(o).success){await this.setBackend(o);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:r}=this.initializeBackend(t);if(r)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,r,o=1){return t in this.registryFactory?(Lo(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:r,priority:o},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:r,asyncInit:o}=this.initializeBackend(t);if(!(o?await r:r))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new oy(this.backendInstance),!0}setupRegisteredKernels(){gm(this.backendName).forEach(r=>{r.setupFunc!=null&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){gm(t).forEach(o=>{o.disposeFunc!=null&&o.disposeFunc(this.registry[t])})}initializeBackend(t){let r=this.registryFactory[t];if(r==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let o=r.factory();if(o&&!(o instanceof Mo)&&typeof o.then=="function"){let s=++this.pendingBackendInitId,i=o.then(a=>s<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Lo(`Initialization of backend ${t} failed`),Lo(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=o,{success:!0,asyncInit:!1}}catch(o){return Lo(`Initialization of backend ${t} failed`),Lo(o.stack||o.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,r)=>this.registryFactory[r].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let r=0;r<t.length;r++){let o=t[r],{success:s,asyncInit:i}=this.initializeBackend(o);if(i||s)return{name:o,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,r){let o=this.state.tensorInfo.get(r),s=o.backend,i=this.readSync(r),a=s.refCount(r);s.disposeData(r,!0),o.backend=t,t.move(r,i,o.shape,o.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,r){let o=null;if(r==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");r=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof r!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=t}let s;return this.scopedRun(()=>this.startScope(o),()=>this.endScope(s),()=>(s=r(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,r,o){t();try{let s=o();return r(),s}catch(s){throw r(),s}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(t){let r=N.runKernel(ms,{x:t}),o={x:t},s=a=>({x:()=>{let c="float32",l={x:a},u={dtype:c};return N.runKernel(fs,l,u)}}),i=[];return this.addTapeNode(this.state.activeScope.name,o,[r],s,i,{}),r}runKernel(t,r,o){if(this.backendName==null&&this.backend,!(fu(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:r,attrs:o})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,r,o){let s=this.backend.numDataIds(),i=0;o.forEach(l=>{i+=l.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],c=s-r-i-a;if(c>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${c} data ids) after running '${t}'`)}runKernelFunc(t){let r,o=[],s=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let c;this.backendName==null&&this.backend;let l,u=uE(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(uE(t)){let{kernelName:h,inputs:g,attrs:x}=t;this.backendName==null&&this.backend;let v=fu(h,this.backendName);k(v!=null,()=>`Cannot find registered kernel '${h}' for backend '${this.backendName}'`),c=()=>{let w=this.backend.numDataIds();l=v.kernelFunc({inputs:g,attrs:x,backend:this.backend});let I=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,w,I);let _=I.map(A=>A.rank!=null?A:this.makeTensorFromTensorInfo(A));if(s){let A=this.getTensorsForGradient(h,g,_);o=this.saveTensorsForBackwardMode(A)}return _}}else{let{forwardFunc:h}=t,g=x=>{s&&(o=x.map(v=>this.keep(this.clone(v))))};c=()=>{let x=this.backend.numDataIds();l=this.tidy(()=>h(this.backend,g));let v=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,x,v),v}}let{inputs:p,attrs:d}=t,f=uE(t)?null:t.backwardsFunc,m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?r=c():(m=this.profiler.profileKernel(u,p,()=>c()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),r=m.outputs)}),s&&this.addTapeNode(u,p,r,f,o,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(h=>p[h]!=null?p[h].shape:null),outputShapes:r.map(h=>h.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(l)?r:r[0]}saveTensorsForBackwardMode(t){return t.map(o=>this.keep(this.clone(o)))}getTensorsForGradient(t,r,o){let s=Jx(t);if(s!=null){let i=s.inputsToSave||[],a=s.outputsToSave||[],c;s.saveAllInputs?(k(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),c=Object.keys(r).map(u=>r[u])):c=i.map(u=>r[u]);let l=o.filter((u,p)=>a[p]);return c.concat(l)}return[]}makeTensor(t,r,o,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");o=o||"float32",s=s||this.backend;let i=t;o==="string"&&oo(t[0])&&(i=t.map(l=>pa(l)));let a=s.write(i,r,o),c=new ot(r,o,a,this.nextTensorId());if(this.trackTensor(c,s),o==="string"){let l=this.state.tensorInfo.get(a),u=XI(i);this.state.numBytes+=u-l.bytes,l.bytes=u}return c}makeTensorFromDataId(t,r,o,s){o=o||"float32";let i={dataId:t,shape:r,dtype:o};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(t,r){let{dataId:o,shape:s,dtype:i}=t,a=new ot(s,i,o,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(t,r=!0,o,s){o=o||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));let i=new Bo(t,r,o,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,r){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let o=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(o=t.size*$p(t.dtype)),this.state.numBytes+=o,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:r||this.backend,dtype:t.dtype,shape:t.shape,bytes:o})),t instanceof Bo||this.track(t)}incRef(t,r){this.trackTensor(t,r),this.backend.incRef(t.dataId)}removeDataId(t,r){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===r&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let r=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let o=t.size*$p(t.dtype);this.state.numBytes-=o}r.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,r.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let r=this.state.registeredVariables[t];this.disposeVariable(r)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let r=this.state.numBytes,o=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-r,this.state.activeProfile.newTensors=this.state.numTensors-o;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,r,o,s,i,a){let c={id:this.state.nextTapeNodeId++,kernelName:t,inputs:r,outputs:o,saved:i},l=Jx(t);l!=null&&(s=l.gradFunc),s!=null&&(c.gradient=u=>(u=u.map((p,d)=>{if(p==null){let f=o[d],m=Lp(f.size,f.dtype);return this.makeTensor(m,f.shape,f.dtype)}return p}),s(u.length>1?u:u[0],i,a))),this.state.activeTape.push(c)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(r.name=t),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(t){let r=Cm(t),o=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){let a=this.state.activeScope.track[i];!a.kept&&!o.has(a.id)&&a.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(t,r,o,s=!1){if(k(r.length>0,()=>"gradients() received an empty list of xs."),o!=null&&o.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${o.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));k(i instanceof ot,()=>"The result y returned by f() must be a tensor.");let a=P2(this.state.activeTape,r,i);if(!s&&a.length===0&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let c={};c[i.id]=o??uY(i.shape),L2(c,a,u=>this.tidy(u),pY);let l=r.map(u=>c[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let p of u.saved)p.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(t){return k($o(t),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{k(r.every(c=>c instanceof ot),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let o,s={};r.forEach((c,l)=>{s[l]=c});let i=(c,l)=>(o=t(...r,l),k(o.value instanceof ot,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),k($o(o.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o.value),a=(c,l)=>{let u=o.gradFunc(c,l),p=Array.isArray(u)?u:[u];k(p.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),k(p.every(f=>f instanceof ot),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let d={};return p.forEach((f,m)=>{d[m]=()=>f}),d};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,r){return this.state.tensorInfo.get(t).backend.readToGPU(t,r)}async time(t){let r=yu(),o=await this.backend.time(t);return o.wallMs=yu()-r,o}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new cy;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return e.nextTensorId=0,e.nextVariableId=0,e})();N=pE()});var xs={};He(xs,{isBrowser:()=>fE,isMobile:()=>mY,mockIsMobile:()=>fY});function dY(){return typeof navigator<"u"&&navigator!=null}function fY(e){dE=e}function mY(e){if(dE!==void 0)return dE;if(e||dY()){if(e||(e=navigator),e.product==="ReactNative")return!0;let n=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!n){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4))}return!1}function fE(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var dE,mE=D(()=>{"use strict";});var Bn,od=D(()=>{"use strict";B();mE();nn();Bn=M();Bn.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Bn.registerFlag("IS_BROWSER",()=>fE());Bn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Bn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Bn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Bn.registerFlag("PROD",()=>!1);Bn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Bn.getBool("DEBUG"));Bn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Bn.registerFlag("IS_TEST",()=>!1);Bn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Bn.getBool("DEBUG"));Bn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Bn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Bn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1)});function un(e,n){let t=e;if(Ot(e))return n==="string"?[]:[e.length];if(iy(e)){let o=e.channels||"RGBA";return[e.height,e.width*o.length]}else if(ay(e))return[e.buffer.size/(n==null?4:$p(n))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(t)||Ot(t)&&n!=="string";)r.push(t.length),t=t[0];return Array.isArray(e)&&M().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&J2(e,r,[]),r}function J2(e,n,t){if(t=t||[],!Array.isArray(e)&&!Ot(e)){k(n.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);return}k(n.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${e.length} elements`),k(e.length===n[0],()=>`Element arr[${t.join("][")}] should have ${n[0]} elements, but has ${e.length} elements`);let r=n.slice(1);for(let o=0;o<e.length;++o)J2(e[o],r,t.concat(o))}function Q2(e,n,t,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==n||e==="numeric"&&n==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${e} tensor, but got ${n} tensor`)}}function C(e,n,t,r="numeric"){if(e instanceof iE())return Q2(r,e.dtype,n,t),e;let o=mi(e);if(o!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),Q2(r,o,n,t),e==null||!Ot(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let c=e==null?"null":e.constructor.name;throw new Error(`Argument '${n}' passed to '${t}' must be a Tensor or TensorLike, but got '${c}'`)}let s=un(e,o);!Ot(e)&&!Array.isArray(e)&&(e=[e]);let a=o!=="string"?ed(e,o):io(e,[],!0);return N.makeTensor(a,s,o)}function ys(e,n,t,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${n} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((s,i)=>C(s,`${n}[${i}]`,t,r))}var $=D(()=>{"use strict";B();nn();Er();rd();q();jt();});function E(e){let n=Object.keys(e);if(n.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${n.length} keys.`);let t=n[0],r=e[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+ly;let o=(...s)=>{N.startScope(t);try{let i=r(...s);return Ic(i)&&console.error("Cannot return a Promise inside of tidy."),N.endScope(i),i}catch(i){throw N.endScope(null),i}};return Object.defineProperty(o,"name",{value:t,configurable:!0}),o}var ly,O=D(()=>{"use strict";B();q();ly="__op"});function hY(e,n){let t=C(e,"real","complex"),r=C(n,"imag","complex");dt(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);let o={real:t,imag:r};return N.runKernel(Oc,o)}var An,fa=D(()=>{"use strict";B();H();$();q();O();An=E({complex_:hY})});function Rn(e,n,t,r){if(r==null)r=mi(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(ay(e)||iy(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return N.backend.createTensorFromGPUData(e,n||t,r)}if(!Ot(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(n!=null){xt(n);let o=ke(n),s=ke(t);k(o===s,()=>`Based on the provided shape, [${n}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<t.length;++i){let a=t[i],c=i===t.length-1?a!==ke(n.slice(i)):!0;k(t[i]===n[i]||!c,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${n}). `)}}return!Ot(e)&&!Array.isArray(e)&&(e=[e]),n=n||t,e=r!=="string"?ed(e,r):io(e,[],!0),N.makeTensor(e,n,r)}var vs=D(()=>{"use strict";B();rd();q();});function xn(e,n,t){let r=un(e,t);return Rn(e,n,r,t)}var wm=D(()=>{"use strict";$();vs();});var bs,hE=D(()=>{"use strict";bs={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}});function gY(e,n){let t=0,r=e.length;for(;t<=r;){let o=Math.floor((r-t)/2)+t,s=n(e[o]);if(s===0)return o;s<0?r=o:t=o+1}return-1}var pn,ma=D(()=>{"use strict";q();pn=class e{static join(n){return new e(n).slice()}constructor(n){if(this.shards=[],this.previousShardIndex=0,n==null||(n instanceof Array||(n=[n]),n=n.map(r=>Ot(r)?r.buffer:r),n.length===0))return;this.bufferUniformSize=n[0].byteLength;let t=0;for(let r=0;r<n.length;r++){let o=n[r];r!==n.length-1&&o.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=t+o.byteLength;this.shards.push({buffer:o,start:t,end:s}),t=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(n=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(n=isNaN(Number(n))?0:n,t=isNaN(Number(t))?0:t,n=Math.max(0,n),t=Math.min(this.byteLength,t),t<=n)return new ArrayBuffer(0);let r=this.findShardForByte(n);if(r===-1)throw new Error(`Could not find start shard for byte ${n}`);let o=t-n,s=new ArrayBuffer(o),i=new Uint8Array(s),a=0;for(let c=r;c<this.shards.length;c++){let l=this.shards[c],p=n+a-l.start,d=a,m=Math.min(t,l.end)-l.start,h=new Uint8Array(l.buffer,p,m-p);if(i.set(h,d),a+=h.length,t<l.end)break}return s}findShardForByte(n){if(this.shards.length===0||n<0||n>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(n/this.bufferUniformSize),this.previousShardIndex;function t(o){return n<o.start?-1:n>=o.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=gY(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}});function xY(){M().set("PROD",!0)}function yY(){M().set("DEBUG",!0)}function vY(){M().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function eF(e){M().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function bY(){N.disposeVariables()}function Tr(){return N}function CY(){return N.memory()}function wY(e){return N.profile(e)}function Ce(e,n){return N.tidy(e,n)}function Nt(e){Cm(e).forEach(t=>t.dispose())}function Fn(e){return N.keep(e)}function IY(e){return N.time(e)}function EY(e){return N.setBackend(e)}function TY(){return N.ready()}function gE(){return N.backendName}function SY(e){N.removeBackend(e)}function NY(e){return N.findBackend(e)}function DY(e){return N.findBackendFactory(e)}function Im(e,n,t=1){return N.registerBackend(e,n,t)}function xE(){return N.backend}function kY(e,n){M().setPlatform(e,n)}var rr=D(()=>{"use strict";B();nn();Er();vt();j2(eF)});async function rF(e,n){let t=[],r=[],o=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<o.length;++i){let a=o[i],c=Array.isArray(e)?e[i].tensor:e[a];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${c.dtype}`);let l={name:a,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){let u=new Promise(async p=>{let d=await c.bytes(),f=d.reduce((g,x)=>g+x.length,0)+ha*d.length,m=new Uint8Array(f),h=0;for(let g=0;g<d.length;g++){let x=d[g],v=new Uint8Array(new Uint32Array([x.length]).buffer);m.set(v,h),h+=ha,m.set(x,h),h+=x.length}p(m)});r.push(u)}else r.push(c.data());n!=null&&(l.group=n),t.push(l)}let s=await Promise.all(r);return{data:RY(s),specs:t}}function uy(e,n){let t=new pn(e),r={},o=0;for(let s of n){let i=_Y(s,(a,c)=>t.slice(o+a,o+c));r[s.name]=oF(s,t.slice(o,o+i)),o+=i}return r}function _Y(e,n){let t=ke(e.shape),r;if("quantization"in e){let o=e.quantization;r=bs[o.dtype]}else if(e.dtype==="string"){let o=0;for(let s=0;s<t;s++)o+=ha+new Uint32Array(n(o,o+ha))[0];return o}else r=bs[e.dtype];return t*r}async function AY(e,n){let t=ke(e.shape),r;if("quantization"in e){let o=e.quantization;r=bs[o.dtype]}else if(e.dtype==="string"){let o=0;for(let s=0;s<t;s++)o+=ha+new Uint32Array(await n(o,o+ha))[0];return o}else r=bs[e.dtype];return t*r}function oF(e,n){let t=e.name,r=e.dtype,o=e.shape,s=ke(o),i,a=0;if("quantization"in e){let c=e.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${e.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${e.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let l=bs[c.dtype],u=c.dtype==="uint8"?new Uint8Array(n):new Uint16Array(n);if(r==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){i=new Float32Array(u.length);for(let p=0;p<u.length;p++){let d=u[p];i[p]=d*c.scale+c.min}}else if(c.dtype==="float16")i=$Y()(u);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(r==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let p=0;p<u.length;p++){let d=u[p];i[p]=Math.round(d*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);a+=s*l}else if(r==="string"){let c=ke(e.shape);i=[];for(let l=0;l<c;l++){let u=new Uint32Array(n.slice(a,a+ha))[0];a+=ha;let p=new Uint8Array(n.slice(a,a+u));i.push(p),a+=u}}else{let c=bs[r];if(r==="float32")i=new Float32Array(n);else if(r==="int32")i=new Int32Array(n);else if(r==="bool")i=new Uint8Array(n);else if(r==="complex64"){i=new Float32Array(n);let l=new Float32Array(i.length/2),u=new Float32Array(i.length/2);for(let m=0;m<l.length;m++)l[m]=i[m*2],u[m]=i[m*2+1];let p=xn(l,o,"float32"),d=xn(u,o,"float32"),f=An(p,d);return p.dispose(),d.dispose(),f}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);a+=s*c}return xn(i,o,r)}async function tF(e,n,t){let r=new Uint8Array(n);for(;r.byteLength<t;){let{done:o,value:s}=await e.read();if(o&&s==null){let a=t-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}let i=new Uint8Array(r.length+s.byteLength);i.set(r,0),i.set(new Uint8Array(s),r.length),r=i}return r.buffer}async function py(e,n){let t={},r=e.getReader(),o=new ArrayBuffer(0);for(let s of n){let i=await AY(s,async(l,u)=>(o=await tF(r,o,u),o.slice(l,u)));o=await tF(r,o,i);let a=o.slice(0,i);o=o.slice(i);let c=oF(s,a);if(t[s.name]=c,gE()==="webgpu"){let l=xE();"uploadToGPU"in l&&ke(c.shape)>=M().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&l.uploadToGPU(c.dataId)}}return t}function RY(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let n=0,t=[];e.forEach(s=>{if(n+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(n),o=0;return t.forEach(s=>{r.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),r.buffer}function nF(e){return yE?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function sF(e){if(yE)return Buffer.from(e).toString("base64");let n=new Uint8Array(e),t="";for(let r=0,o=n.length;r<o;r++)t+=String.fromCharCode(n[r]);return btoa(t)}function iF(e){if(yE){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let n=atob(e),t=new Uint8Array(n.length);for(let r=0;r<n.length;++r)t.set([n.charCodeAt(r)],r);return t.buffer}function aF(e){return pn.join(e)}function vE(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function dy(e,n){let t={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};return e.signature!=null&&(t.signature=e.signature),e.userDefinedMetadata!=null&&(t.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(t.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(t.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(t.trainingConfig=e.trainingConfig),t}function bE(e,n,t){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!n)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=n,r.weightData=t}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function sd(e,n){let t,r;return e.weightsManifest!=null&&([t,r]=await n(e.weightsManifest)),bE(e,t,r)}function Vo(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:nF(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:nF(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new pn(e.weightData).byteLength}}function Em(e){let n=[];for(let t of e)n.push(...t.weights);return n}function FY(){let e=t=>{let r=t<<13,o=0;for(;(r&8388608)===0;)o-=8388608,r<<=1;return r&=-8388609,o+=947912704,r|o},n=new Uint32Array(2048);n[0]=0;for(let t=1;t<1024;t++)n[t]=e(t);for(let t=1024;t<2048;t++)n[t]=939524096+(t-1024<<13);return n}function OY(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let n=1;n<31;n++)e[n]=n<<23;for(let n=33;n<63;n++)e[n]=2147483648+(n-32<<23);return e}function MY(){let e=new Uint32Array(64);for(let n=0;n<64;n++)e[n]=1024;return e[0]=e[32]=0,e}function $Y(){let e=FY(),n=OY(),t=MY();return r=>{let o=new ArrayBuffer(4*r.length),s=new Uint32Array(o);for(let i=0;i<r.length;i++){let a=r[i],c=e[t[a>>10]+(a&1023)]+n[a>>10];s[i]=c}return new Float32Array(o)}}var ha,yE,ga=D(()=>{"use strict";fa();wm();q();hE();ma();rr();nn();rr();ha=4;yE=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u")});var qt,cF,lF,uF,pF,vu=D(()=>{"use strict";qt=class e{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return e.instance==null&&(e.instance=new e),e.instance}static registerSaveRouter(n){e.getInstance().saveRouters.push(n)}static registerLoadRouter(n){e.getInstance().loadRouters.push(n)}static getSaveHandlers(n){return e.getHandlers(n,"save")}static getLoadHandlers(n,t){return e.getHandlers(n,"load",t)}static getHandlers(n,t,r){let o=[];return(t==="load"?e.getInstance().loadRouters:e.getInstance().saveRouters).forEach(i=>{let a=i(n,r);a!==null&&o.push(a)}),o}},cF=e=>qt.registerSaveRouter(e),lF=e=>qt.registerLoadRouter(e),uF=e=>qt.getSaveHandlers(e),pF=(e,n)=>qt.getLoadHandlers(e,n)});function dF(){if(!M().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,n=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(n==null)throw new Error("The current browser does not appear to support IndexedDB.");return n}function IE(e){let n=e.result;n.createObjectStore(bu,{keyPath:"modelPath"}),n.createObjectStore(xa,{keyPath:"modelPath"})}function PY(e){return new Cu(e)}function LY(e){return e.startsWith(Cu.URL_SCHEME)?e.slice(Cu.URL_SCHEME.length):e}var CE,wE,bu,xa,Cu,fF,fy,EE=D(()=>{"use strict";od();nn();ga();vu();ma();CE="tensorflowjs",wE=1,bu="models_store",xa="model_info_store";Cu=(()=>{class e{constructor(t){if(this.indexedDB=dF(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,r){return new Promise((o,s)=>{let i=this.indexedDB.open(CE,wE);i.onupgradeneeded=()=>IE(i),i.onsuccess=()=>{let a=i.result;if(r==null){let c=a.transaction(bu,"readonly"),u=c.objectStore(bu).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));o(u.result.modelArtifacts)},u.onerror=p=>(a.close(),s(u.error)),c.oncomplete=()=>a.close()}else{r.weightData=pn.join(r.weightData);let c=Vo(r),l=a.transaction(xa,"readwrite"),u=l.objectStore(xa),p;try{p=u.put({modelPath:this.modelPath,modelArtifactsInfo:c})}catch(f){return s(f)}let d;p.onsuccess=()=>{d=a.transaction(bu,"readwrite");let f=d.objectStore(bu),m;try{m=f.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:c})}catch(h){return s(h)}m.onsuccess=()=>o({modelArtifactsInfo:c}),m.onerror=h=>{u=l.objectStore(xa);let g=u.delete(this.modelPath);g.onsuccess=()=>(a.close(),s(m.error)),g.onerror=x=>(a.close(),s(m.error))}},p.onerror=f=>(a.close(),s(p.error)),l.oncomplete=()=>{d==null?a.close():d.oncomplete=()=>a.close()}}},i.onerror=a=>s(i.error)})}}return e.URL_SCHEME="indexeddb://",e})(),fF=e=>M().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Cu.URL_SCHEME)?PY(e.slice(Cu.URL_SCHEME.length)):null;qt.registerSaveRouter(fF);qt.registerLoadRouter(fF);fy=class{constructor(){this.indexedDB=dF()}async listModels(){return new Promise((n,t)=>{let r=this.indexedDB.open(CE,wE);r.onupgradeneeded=()=>IE(r),r.onsuccess=()=>{let o=r.result,s=o.transaction(xa,"readonly"),a=s.objectStore(xa).getAll();a.onsuccess=()=>{let c={};for(let l of a.result)c[l.modelPath]=l.modelArtifactsInfo;n(c)},a.onerror=c=>(o.close(),t(a.error)),s.oncomplete=()=>o.close()},r.onerror=o=>t(r.error)})}async removeModel(n){return n=LY(n),new Promise((t,r)=>{let o=this.indexedDB.open(CE,wE);o.onupgradeneeded=()=>IE(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(xa,"readwrite"),a=i.objectStore(xa),c=a.get(n),l;c.onsuccess=()=>{if(c.result==null)return s.close(),r(new Error(`Cannot find model with path '${n}' in IndexedDB.`));{let u=a.delete(n),p=()=>{l=s.transaction(bu,"readwrite");let f=l.objectStore(bu).delete(n);f.onsuccess=()=>t(c.result.modelArtifactsInfo),f.onerror=m=>r(c.error)};u.onsuccess=p,u.onerror=d=>(p(),s.close(),r(c.error))}},c.onerror=u=>(s.close(),r(c.error)),i.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>r(o.error)})}}});function hF(e){return{info:[id,e,mF].join(Cs),topology:[id,e,BY].join(Cs),weightSpecs:[id,e,VY].join(Cs),weightData:[id,e,UY].join(Cs),modelMetadata:[id,e,zY].join(Cs)}}function gF(e){for(let n of Object.values(e))window.localStorage.removeItem(n)}function GY(e){let n=e.split(Cs);if(n.length<3)throw new Error(`Invalid key format: ${e}`);return n.slice(1,n.length-1).join(Cs)}function HY(e){return e.startsWith(wu.URL_SCHEME)?e.slice(wu.URL_SCHEME.length):e}function WY(e){return new wu(e)}var Cs,id,mF,BY,VY,UY,zY,wu,xF,my,TE=D(()=>{"use strict";od();nn();q();ga();ma();vu();Cs="/",id="tensorflowjs_models",mF="info",BY="model_topology",VY="weight_specs",UY="weight_data",zY="model_metadata";wu=(()=>{class e{constructor(t){if(!M().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=hF(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let r=JSON.stringify(t.modelTopology),o=JSON.stringify(t.weightSpecs),s=Vo(t),i=pn.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,r),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,sF(i));let a={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw gF(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let r={},o=JSON.parse(this.LS.getItem(this.keys.topology));if(o==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);r.modelTopology=o;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);r.weightSpecs=s;let i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){let c=JSON.parse(i);r.format=c.format,r.generatedBy=c.generatedBy,r.convertedBy=c.convertedBy,c.signature!=null&&(r.signature=c.signature),c.userDefinedMetadata!=null&&(r.userDefinedMetadata=c.userDefinedMetadata),c.modelInitializer!=null&&(r.modelInitializer=c.modelInitializer),c.initializerSignature!=null&&(r.initializerSignature=c.initializerSignature),c.trainingConfig!=null&&(r.trainingConfig=c.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return r.weightData=iF(a),r}}return e.URL_SCHEME="localstorage://",e})(),xF=e=>M().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(wu.URL_SCHEME)?WY(e.slice(wu.URL_SCHEME.length)):null;qt.registerSaveRouter(xF);qt.registerLoadRouter(xF);my=class{constructor(){k(M().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),k(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let n={},t=id+Cs,r=Cs+mF;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(t)&&s.endsWith(r)){let i=GY(s);n[i]=JSON.parse(this.LS.getItem(s))}}return n}async removeModel(n){n=HY(n);let t=hF(n);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${n}'`);let r=JSON.parse(this.LS.getItem(t.info));return gF(t),r}}});function hy(e){if(e.indexOf(ad)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${co.getSchemes().join(",")}`);return{scheme:e.split(ad)[0],path:e.split(ad)[1]}}async function yF(e,n,t=!1){k(e!==n,()=>`Old path and new path are the same: '${e}'`);let r=qt.getLoadHandlers(e);k(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),k(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let o=r[0],s=qt.getSaveHandlers(n);k(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${n}.`),k(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${n}.`);let i=s[0],a=hy(e).scheme,c=hy(e).path,l=a===hy(e).scheme,u=await o.load();t&&l&&await co.getManager(a).removeModel(c);let p=await i.save(u);return t&&!l&&await co.getManager(a).removeModel(c),p.modelArtifactsInfo}async function vF(){let e=co.getSchemes(),n={};for(let t of e){let r=await co.getManager(t).listModels();for(let o in r){let s=t+ad+o;n[s]=r[o]}}return n}async function bF(e){let n=hy(e);return co.getManager(n.scheme).removeModel(n.path)}async function CF(e,n){return yF(e,n,!1)}async function wF(e,n){return yF(e,n,!0)}var ad,co,SE=D(()=>{"use strict";q();vu();ad="://",co=class e{constructor(){this.managers={}}static getInstance(){return e.instance==null&&(e.instance=new e),e.instance}static registerManager(n,t){k(n!=null,()=>"scheme must not be undefined or null."),n.endsWith(ad)&&(n=n.slice(0,n.indexOf(ad))),k(n.length>0,()=>"scheme must not be an empty string.");let r=e.getInstance();k(r.managers[n]==null,()=>`A model store manager is already registered for scheme '${n}'.`),r.managers[n]=t}static getManager(n){let t=e.getInstance().managers[n];if(t==null)throw new Error(`Cannot find model manager for scheme '${n}'`);return t}static getSchemes(){return Object.keys(e.getInstance().managers)}}});var NE,IF=D(()=>{"use strict";od();nn();EE();TE();SE();JI();NE=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(n,t){return fetch(n,t)}now(){return performance.now()}encode(n,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(n)}decode(n,t){return new TextDecoder(t).decode(n)}setTimeoutCustom(n,t){if(typeof window>"u"||!M().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(n,t);return}this.functionRefs.push(n),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();let o=this.functionRefs[r.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(n){return ty(n)}};if(M().get("IS_BROWSER")){M().setPlatform("browser",new NE);try{co.registerManager(wu.URL_SCHEME,new my)}catch{}try{co.registerManager(Cu.URL_SCHEME,new fy)}catch{}}});var TF=mr((cd,EF)=>{"use strict";var jY=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("unable to locate global object")},Iu=jY();EF.exports=cd=Iu.fetch;Iu.fetch&&(cd.default=Iu.fetch.bind(Iu));cd.Headers=Iu.Headers;cd.Request=Iu.Request;cd.Response=Iu.Response});var SF=mr(()=>{"use strict"});var qY,DE,kE,NF=D(()=>{"use strict";nn();qY={importFetch:()=>TF()},kE=class{constructor(){this.util=SF(),this.textEncoder=new this.util.TextEncoder}fetch(n,t){return M().global.fetch!=null?M().global.fetch(n,t):(DE==null&&(DE=qY.importFetch()),DE(n,t))}now(){let n=process.hrtime();return n[0]*1e3+n[1]/1e6}encode(n,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(n)}decode(n,t){return n.length===0?"":new this.util.TextDecoder(t).decode(n)}isTypedArray(n){return this.util.types.isFloat32Array(n)||this.util.types.isInt32Array(n)||this.util.types.isUint8Array(n)||this.util.types.isUint8ClampedArray(n)}};M().get("IS_NODE")&&!M().get("IS_BROWSER")&&M().setPlatform("node",new kE)});function le(e,n="float32",t){return n=n||"float32",xt(e),new Ke(e,n,t)}var ws=D(()=>{"use strict";Er();q();});function KY(e,n){let t=C(e,"x","cast");if(!KI(n))throw new Error(`Failed to cast to unknown dtype ${n}`);if(n==="string"&&t.dtype!=="string"||n!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:t},o={dtype:n};return N.runKernel(fs,r,o)}var _e,dn=D(()=>{"use strict";B();H();$();q();O();_e=E({cast_:KY})});function XY(e){let t={x:C(e,"x","clone","string_or_numeric")};return N.runKernel(ms,t)}var Vn,ld=D(()=>{"use strict";B();H();$();O();Vn=E({clone_:XY})});function Tm(e,n=!1){console.log(e.toString(n))}var _E=D(()=>{"use strict";});var YY,DF=D(()=>{"use strict";B();od();IF();NF();ws();dn();ld();_E();Er();pE();YY={buffer:le,cast:_e,clone:Vn,print:Tm};W2(YY)});function ZY(e,n){let t=C(e,"a","add"),r=C(n,"b","add");[t,r]=Se(t,r);let o={a:t,b:r};return N.runKernel("Add",o)}var de,Ut=D(()=>{"use strict";B();vt();$();O();de=E({add_:ZY})});function QY(e,n){let t=C(e,"a","floorDiv"),r=C(n,"b","floorDiv");[t,r]=Se(t,r);let o={a:t,b:r};return N.runKernel(_i,o)}var Sm,AE=D(()=>{"use strict";B();H();vt();$();O();Sm=E({floorDiv_:QY})});function JY(e,n){let t=C(e,"a","div"),r=C(n,"b","div");if([t,r]=Se(t,r),t.dtype==="int32"&&r.dtype==="int32")return Sm(t,r);let o={a:t,b:r},s={};return N.runKernel(Si,o,s)}var Ve,Un=D(()=>{"use strict";B();H();vt();$();AE();O();Ve=E({div_:JY})});function eZ(e,n){let t=C(e,"a","mul"),r=C(n,"b","mul");[t,r]=Se(t,r);let o={a:t,b:r};return N.runKernel(Hi,o)}var ee,bt=D(()=>{"use strict";B();H();vt();$();O();ee=E({mul_:eZ})});function tZ(e){let n=C(e,"x","abs");if(n.dtype==="complex64"){let t={x:n};return N.runKernel(Mc,t)}else{let t={x:n};return N.runKernel("Abs",t)}}var Kt,Eu=D(()=>{"use strict";B();H();$();O();Kt=E({abs_:tZ})});function nZ(e){let t={x:C(e,"x","acos")};return N.runKernel(hi,t)}var RE,kF=D(()=>{"use strict";B();H();$();O();RE=E({acos_:nZ})});function rZ(e){let t={x:C(e,"x","acosh")};return N.runKernel(gi,t)}var FE,_F=D(()=>{"use strict";B();H();$();O();FE=E({acosh_:rZ})});function oZ(e){k(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),k(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let n=e.map((o,s)=>C(o,`tensors${s}`,"addN")),t=n[0];n.forEach(o=>{if(o.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),n.forEach(o=>{if(!kn(o.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=n;return N.runKernel(Tc,r)}var OE,AF=D(()=>{"use strict";B();H();$();q();O();OE=E({addN_:oZ})});function sZ(e,n=null,t=!1){let o={x:C(e,"x","all","bool")},s={axis:n,keepDims:t};return N.runKernel("All",o,s)}var ME,RF=D(()=>{"use strict";B();$();O();ME=E({all_:sZ})});function iZ(e,n=null,t=!1){let o={x:C(e,"x","any","bool")},s={axis:n,keepDims:t};return N.runKernel("Any",o,s)}var $E,FF=D(()=>{"use strict";B();$();O();$E=E({any_:iZ})});function aZ(e,n=0){let r={x:C(e,"x","argMax")},o={axis:n};return N.runKernel(Sc,r,o)}var PE,OF=D(()=>{"use strict";B();H();$();O();PE=E({argMax_:aZ})});function cZ(e,n=0){let r={x:C(e,"x","argMin")},o={axis:n};return N.runKernel(Nc,r,o)}var LE,MF=D(()=>{"use strict";B();H();$();O();LE=E({argMin_:cZ})});function lZ(e){let t={x:C(e,"x","asin")};return N.runKernel(xi,t)}var BE,$F=D(()=>{"use strict";B();H();$();O();BE=E({asin_:lZ})});function uZ(e){let t={x:C(e,"x","asinh")};return N.runKernel(yi,t)}var VE,PF=D(()=>{"use strict";B();H();$();O();VE=E({asinh_:uZ})});function pZ(e){let t={x:C(e,"x","atan")};return N.runKernel(vi,t)}var UE,LF=D(()=>{"use strict";B();H();$();O();UE=E({atan_:pZ})});function dZ(e,n){let t=C(e,"a","atan2"),r=C(n,"b","atan2");[t,r]=Se(t,r);let o={a:t,b:r};return N.runKernel(Ci,o)}var zE,BF=D(()=>{"use strict";B();H();vt();$();O();zE=E({atan2_:dZ})});function fZ(e){let t={x:C(e,"x","atanh")};return N.runKernel(bi,t)}var GE,VF=D(()=>{"use strict";B();H();$();O();GE=E({atanh_:fZ})});function mZ(e,n,t,r,o="NHWC",s){let i=e[3],a=[...n,i],c=zF(o);return Su(e,a,t,s,r,null,null,c)}function WE(e,n,t,r,o,s,i="channelsLast"){let[a,c]=Nm(n),l;if(i==="channelsLast")l=[a,c,e[3],e[3]];else if(i==="channelsFirst")l=[a,c,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Su(e,l,t,r,o,s,!1,i)}function hZ(e,n,t,r,o,s,i="NDHWC"){let[a,c,l]=HE(n),u,p;if(i==="NDHWC")p="channelsLast",u=[a,c,l,e[4],e[4]];else if(i==="NCDHW")p="channelsFirst",u=[a,c,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return UF(e,u,t,r,o,!1,p,s)}function Su(e,n,t,r,o,s,i=!1,a="channelsLast"){let[c,l,u,p]=[-1,-1,-1,-1];if(a==="channelsLast")[c,l,u,p]=e;else if(a==="channelsFirst")[c,p,l,u]=e;else throw new Error(`Unknown dataFormat ${a}`);let[d,f,,m]=n,[h,g]=Nm(t),[x,v]=Nm(r),w=ud(d,x),I=ud(f,v),{padInfo:_,outHeight:A,outWidth:R}=yZ(o,l,u,h,g,w,I,s,a),F=i?m*p:m,P;return a==="channelsFirst"?P=[c,F,A,R]:a==="channelsLast"&&(P=[c,A,R,F]),{batchSize:c,dataFormat:a,inHeight:l,inWidth:u,inChannels:p,outHeight:A,outWidth:R,outChannels:F,padInfo:_,strideHeight:h,strideWidth:g,filterHeight:d,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:I,dilationHeight:x,dilationWidth:v,inShape:e,outShape:P,filterShape:n}}function UF(e,n,t,r,o,s=!1,i="channelsLast",a){let[c,l,u,p,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[c,l,u,p,d]=e;else if(i==="channelsFirst")[c,d,l,u,p]=e;else throw new Error(`Unknown dataFormat ${i}`);let[f,m,h,,g]=n,[x,v,w]=HE(t),[I,_,A]=HE(r),R=ud(f,I),F=ud(m,_),P=ud(h,A),{padInfo:L,outDepth:V,outHeight:z,outWidth:G}=vZ(o,l,u,p,x,v,w,R,F,P,a),j=s?g*d:g,W;return i==="channelsFirst"?W=[c,j,V,z,G]:i==="channelsLast"&&(W=[c,V,z,G,j]),{batchSize:c,dataFormat:i,inDepth:l,inHeight:u,inWidth:p,inChannels:d,outDepth:V,outHeight:z,outWidth:G,outChannels:j,padInfo:L,strideDepth:x,strideHeight:v,strideWidth:w,filterDepth:f,filterHeight:m,filterWidth:h,effectiveFilterDepth:R,effectiveFilterHeight:F,effectiveFilterWidth:P,dilationDepth:I,dilationHeight:_,dilationWidth:A,inShape:e,outShape:W,filterShape:n}}function gZ(e,n,t,r,o){r==null&&(r=jE(e,n,t));let s=e[0],i=e[1],a=Dm((s-n+2*r)/t+1,o),c=Dm((i-n+2*r)/t+1,o);return[a,c]}function xZ(e,n,t,r,o,s){o==null&&(o=jE(e,n[0],r[0]));let i=[0,0,0,t];for(let a=0;a<3;a++)e[a]+2*o>=n[a]&&(i[a]=Dm((e[a]-n[a]+2*o)/r[a]+1,s));return i}function jE(e,n,t,r=1){let o=ud(n,r);return Math.floor((e[0]*(t-1)-t+o)/2)}function Nm(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function HE(e){return typeof e=="number"?[e,e,e]:e}function ud(e,n){return n<=1?e:e+(e-1)*(n-1)}function yZ(e,n,t,r,o,s,i,a,c){let l,u,p;if(typeof e=="number"){l={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let f=gZ([n,t],s,r,e,a);u=f[0],p=f[1]}else if(e==="same"){u=Math.ceil(n/r),p=Math.ceil(t/o);let d=Math.max(0,(u-1)*r+s-n),f=Math.max(0,(p-1)*o+i-t),m=Math.floor(d/2),h=d-m,g=Math.floor(f/2),x=f-g;l={top:m,bottom:h,left:g,right:x,type:"SAME"}}else if(e==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((n-s+1)/r),p=Math.ceil((t-i+1)/o);else if(typeof e=="object"){let d=c==="channelsLast"?e[1][0]:e[2][0],f=c==="channelsLast"?e[1][1]:e[2][1],m=c==="channelsLast"?e[2][0]:e[3][0],h=c==="channelsLast"?e[2][1]:e[3][1];l={top:d,bottom:f,left:m,right:h,type:d===0&&f===0&&m===0&&h===0?"VALID":"EXPLICIT"},u=Dm((n-s+d+f)/r+1,a),p=Dm((t-i+m+h)/o+1,a)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:l,outHeight:u,outWidth:p}}function vZ(e,n,t,r,o,s,i,a,c,l,u){let p,d,f,m;if(e==="valid"&&(e=0),typeof e=="number"){p={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let g=xZ([n,t,r,1],[a,c,l],1,[o,s,i],e,u);d=g[0],f=g[1],m=g[2]}else if(e==="same"){d=Math.ceil(n/o),f=Math.ceil(t/s),m=Math.ceil(r/i);let h=(d-1)*o+a-n,g=(f-1)*s+c-t,x=(m-1)*i+l-r,v=Math.floor(h/2),w=h-v,I=Math.floor(g/2),_=g-I,A=Math.floor(x/2),R=x-A;p={top:I,bottom:_,left:A,right:R,front:v,back:w,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outDepth:d,outHeight:f,outWidth:m}}function Dm(e,n){if(!n)return Math.trunc(e);switch(n){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${n}`)}}function Tu(e){let[n,t,r]=Nm(e);return n===1&&t===1&&r===1}function yn(e,n){return Tu(e)||Tu(n)}function Uo(e){return Nm(e).every(n=>n>0)}function zF(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Pt(e,n,t){if(t!=null){if(typeof n=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${t} but got pad ${n}.`);if(typeof n=="number")k(ps(n),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${t} but got pad ${n}.`);else if(typeof n=="object")n.forEach(r=>{r.forEach(o=>{k(ps(o),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${t} but got pad ${o}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${n}`)}}var zn=D(()=>{"use strict";q();});function bZ(e,n){let r={x:C(e,"x","reshape","string_or_numeric")},o={shape:n};return N.runKernel($l,r,o)}var U,Ne=D(()=>{"use strict";B();H();$();O();U=E({reshape_:bZ})});function CZ(e,n,t,r,o){let s=C(e,"x","avgPool","float32"),i=1;k(yn(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=s,c=!1;s.rank===3&&(c=!0,a=U(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Pt("avgPool",r,o);let l={x:a},u={filterSize:n,strides:t,pad:r,dimRoundingMode:o},p=N.runKernel(Dc,l,u);return p=_e(p,s.dtype),c?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var km,qE=D(()=>{"use strict";B();H();$();q();dn();zn();O();Ne();km=E({avgPool_:CZ})});function wZ(e,n,t,r,o,s="NDHWC"){let i=C(e,"x","avgPool3d","float32"),a=i,c=!1;i.rank===4&&(c=!0,a=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),k(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),k(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Pt("avgPool3d",r,o);let l={x:a},u={filterSize:n,strides:t,pad:r,dimRoundingMode:o,dataFormat:s},p=N.runKernel(kc,l,u);return p=_e(p,a.dtype),c?U(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var KE,GF=D(()=>{"use strict";B();H();$();q();dn();zn();O();Ne();KE=E({avgPool3d_:wZ})});function IZ(e,n=0){k(e.length>=1,()=>"Pass at least one tensor to concat");let t=ys(e,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return Vn(t[0]);let r=t,o={axis:n};return N.runKernel($c,r,o)}var ut,lo=D(()=>{"use strict";B();H();$();q();ld();O();ut=E({concat_:IZ})});function EZ(e,n,t=!1,r=!1){let o=C(e,"a","matMul"),s=C(n,"b","matMul");[o,s]=Se(o,s);let i={a:o,b:s},a={transposeA:t,transposeB:r};return N.runKernel(_c,i,a)}var je,Is=D(()=>{"use strict";B();H();vt();$();O();je=E({matMul_:EZ})});function TZ(e){let t={x:C(e,"x","sigmoid","float32")};return N.runKernel(ea,t)}var uo,_m=D(()=>{"use strict";B();H();$();O();uo=E({sigmoid_:TZ})});function SZ(e,n,t){let r=C(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let o={x:r},s={begin:n,size:t};return N.runKernel(Hl,o,s)}var Ue,Br=D(()=>{"use strict";B();H();$();O();Ue=E({slice_:SZ})});function NZ(e){let t={x:C(e,"x","tanh","float32")};return N.runKernel(sa,t)}var pd,XE=D(()=>{"use strict";B();H();$();O();pd=E({tanh_:NZ})});function DZ(e,n,t,r,o,s){let i=C(e,"forgetBias","basicLSTMCell"),a=C(n,"lstmKernel","basicLSTMCell"),c=C(t,"lstmBias","basicLSTMCell"),l=C(r,"data","basicLSTMCell"),u=C(o,"c","basicLSTMCell"),p=C(s,"h","basicLSTMCell"),d=ut([l,p],1),f=je(d,a),m=de(f,c),h=m.shape[0],g=m.shape[1]/4,x=[h,g],v=Ue(m,[0,0],x),w=Ue(m,[0,g],x),I=Ue(m,[0,g*2],x),_=Ue(m,[0,g*3],x),A=de(ee(uo(v),pd(w)),ee(u,uo(de(i,I)))),R=ee(pd(A),uo(_));return[A,R]}var YE,HF=D(()=>{"use strict";$();Ut();lo();Is();bt();O();_m();Br();XE();YE=E({basicLSTMCell_:DZ})});function kZ(e,n,t){let r=C(e,"x","batchToSpaceND"),o=n.reduce((a,c)=>a*c);k(r.rank>=1+n.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${n.length}`),k(t.length===n.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${n.length}`),k(r.shape[0]%o===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${n.join(" * ")} === ${o}`);let s={x:r},i={blockShape:n,crops:t};return N.runKernel(Ac,s,i)}var Am,ZE=D(()=>{"use strict";B();H();$();q();O();Am=E({batchToSpaceND_:kZ})});function WF(e){let n;return e.rank===0||e.rank===1?n=U(e,[1,1,1,e.size]):e.rank===2?n=U(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?n=U(e,[1,e.shape[0],e.shape[1],e.shape[2]]):n=e,n}var jF=D(()=>{"use strict";Ne()});function _Z(e,n,t,r,o,s){s==null&&(s=.001);let i=C(e,"x","batchNorm"),a=C(n,"mean","batchNorm"),c=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let u;r!=null&&(u=C(r,"offset","batchNorm")),k(a.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:WF(i),scale:l,offset:u,mean:a,variance:c},f={varianceEpsilon:s},m=N.runKernel(il,d,f);return U(m,i.shape)}var Es,Rm=D(()=>{"use strict";B();H();$();q();jF();O();Ne();Es=E({batchNorm_:_Z})});function AZ(e,n,t,r,o,s){let i=C(e,"x","batchNorm"),a=C(n,"mean","batchNorm"),c=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let u;return r!=null&&(u=C(r,"offset","batchNorm")),k(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),k(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),k(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&k(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&k(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),Es(i,a,c,u,l,s)}var QE,qF=D(()=>{"use strict";$();q();Rm();O();QE=E({batchNorm2d_:AZ})});function RZ(e,n,t,r,o,s){let i=C(e,"x","batchNorm"),a=C(n,"mean","batchNorm"),c=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let u;return r!=null&&(u=C(r,"offset","batchNorm")),k(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),k(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),k(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&k(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&k(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),Es(i,a,c,u,l,s)}var JE,KF=D(()=>{"use strict";$();q();Rm();O();JE=E({batchNorm3d_:RZ})});function FZ(e,n,t,r,o,s){let i=C(e,"x","batchNorm"),a=C(n,"mean","batchNorm"),c=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let u;return r!=null&&(u=C(r,"offset","batchNorm")),k(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),k(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),k(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&k(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&k(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),Es(i,a,c,u,l,s)}var eT,XF=D(()=>{"use strict";$();q();Rm();O();eT=E({batchNorm4d_:FZ})});function OZ(e,n,t){let r=C(e,"x","bincount"),o=C(n,"weights","bincount");k(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),k(t>=0,()=>`size must be non-negative, but got ${t}.`),k(o.size===r.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${o.shape}.`);let s={x:r,weights:o},i={size:t};return N.runKernel(Rc,s,i)}var Fm,tT=D(()=>{"use strict";B();H();$();q();O();Fm=E({bincount_:OZ})});function MZ(e,n){let t=C(e,"x","bitwiseAnd"),r=C(n,"y","bitwiseAnd");if(!kn(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if(t.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);let o={a:t,b:r};return N.runKernel(wi,o)}var nT,YF=D(()=>{"use strict";B();H();$();jt();O();nT=E({bitwiseAnd_:MZ})});function $Z(e,n){let t=C(e,"s0","broadcastArgs","int32"),r=C(n,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let o={s0:t,s1:r};return N.runKernel(Fc,o)}var rT,ZF=D(()=>{"use strict";B();H();$();O();rT=E({broadcastArgs_:$Z})});function PZ(e,n){let t=C(e,"broadcastTo","x"),r=t.shape;if(xt(n),n.length<t.rank)throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${t.rank}.`);if(n.length>t.rank){let l=t.shape.slice();for(;l.length<n.length;)l.unshift(1);t=U(t,l)}let o=t.shape,s=Array.from(n);for(let l=n.length-1;l>=0;l--)if(o[l]===n[l])s[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${n}].`);if(s.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return Vn(t);let a={x:t},c={reps:s};return N.runKernel(hs,a,c)}var Ts,oT=D(()=>{"use strict";B();H();$();jt();ld();O();Ne();Ts=E({broadcastTo_:PZ})});function LZ(e){let t={x:C(e,"x","ceil","float32")};return N.runKernel(Ii,t)}var sT,QF=D(()=>{"use strict";B();H();$();O();sT=E({ceil_:LZ})});function po(e,n,t){xt(e),t=t||mi(n);let r={shape:e,value:n,dtype:t};return N.runKernel(ol,{},r)}var dd=D(()=>{"use strict";B();H();q();jt();});function BZ(e,n,t){let r=C(e,"x","clipByValue");if(k(n<=t,()=>`Error in clip: min (${n}) must be less than or equal to max (${t}).`),n===t)return po(r.shape,n,r.dtype);let o={x:r},s={clipValueMin:n,clipValueMax:t};return N.runKernel(Ei,o,s)}var iT,JF=D(()=>{"use strict";B();H();$();q();dd();O();iT=E({clipByValue_:BZ})});function VZ(e){return ut(e,0)}var aT,eO=D(()=>{"use strict";lo();O();aT=E({concat1d_:VZ})});function UZ(e,n){return ut(e,n)}var cT,tO=D(()=>{"use strict";lo();O();cT=E({concat2d_:UZ})});function zZ(e,n){return ut(e,n)}var lT,nO=D(()=>{"use strict";lo();O();lT=E({concat3d_:zZ})});function GZ(e,n){return ut(e,n)}var uT,rO=D(()=>{"use strict";lo();O();uT=E({concat4d_:GZ})});function HZ(e,n,t,r,o="NHWC",s=[1,1],i){let a=C(e,"x","conv2d","float32"),c=C(n,"filter","conv2d","float32"),l=a,u=!1;a.rank===3&&(u=!0,l=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),k(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),Pt("conv2d",r,i);let p=o==="NHWC"?l.shape[3]:l.shape[1];k(p===c.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${c.shape[2]}.`),k(yn(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),k(Uo(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),k(Uo(t),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:l,filter:c},f={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},m=N.runKernel(Pc,d,f);return u?U(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Ss,Om=D(()=>{"use strict";B();H();$();q();zn();O();Ne();Ss=E({conv2d_:HZ})});function WZ(e,n,t,r,o="NWC",s=1,i){let a=C(e,"x","conv1d"),c=C(n,"filter","conv1d"),l=a,u=!1;a.rank===2&&(u=!0,l=U(a,[1,a.shape[0],a.shape[1]])),k(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),k(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),Pt("conv1d",r,i),k(l.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${c.shape[1]}.`),k(yn(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),k(Uo(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),k(Uo(t),()=>"Error in conv1D: Stride should be larger than 0."),k(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=U(c,[1,c.shape[0],c.shape[1],c.shape[2]]),d=U(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=Ss(d,p,[1,t],r,"NHWC",[1,s],i);return u?U(g,[g.shape[2],g.shape[3]]):U(g,[g.shape[0],g.shape[2],g.shape[3]])}var pT,oO=D(()=>{"use strict";$();q();Om();zn();O();Ne();pT=E({conv1d_:WZ})});function jZ(e,n,t,r,o,s="NHWC",i){k(e.length===n.rank,()=>`Length of inShape (${e.length}) and rank of dy (${n.rank}) must match`);let a=e,c=n,l=!1;n.rank===3&&(l=!0,c=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]),a=[1,e[0],e[1],e[2]]),k(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),k(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),k(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);let u=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?c.shape[3]:c.shape[1];k(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),k(p===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${t.shape[3]}.`),Pt("conv2dDerInput",o,i);let d={dy:c,filter:t},f={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},m=N.runKernel(Bc,d,f);return l?U(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var gy,dT=D(()=>{"use strict";B();H();q();zn();O();Ne();gy=E({conv2DBackpropInput_:jZ})});function qZ(e,n,t,r,o,s){let i=C(e,"x","conv2dTranspose"),a=C(n,"filter","conv2dTranspose");return gy(t,i,a,r,o,"NHWC",s)}var fT,sO=D(()=>{"use strict";$();dT();O();fT=E({conv2dTranspose_:qZ})});function KZ(e,n,t,r,o="NDHWC",s=[1,1,1]){let i=C(e,"x","conv3d"),a=C(n,"filter","conv3d"),c=i,l=!1;i.rank===4&&(l=!0,c=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),k(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),k(c.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${a.shape[3]}.`),k(yn(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),k(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`),k(Uo(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),k(Uo(t),()=>"Error in conv3D: Strides should be larger than 0.");let u={x:c,filter:a},p={strides:t,pad:r,dataFormat:o,dilations:s},d=N.runKernel(Vc,u,p);return l?U(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var mT,iO=D(()=>{"use strict";B();H();$();q();zn();O();Ne();mT=E({conv3d_:KZ})});function XZ(e,n,t,r,o){k(e.length===n.rank,()=>`Length of inShape (${e.length}) and rank of dy (${n.rank}) must match`);let s=e,i=n,a=!1;n.rank===4&&(a=!0,i=U(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let c=s[4],l=i.shape[4];k(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),k(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),k(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),k(c===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[3]}.`),k(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);let u={dy:i,filter:t},p={pad:o,strides:r,inputShape:s},d=N.runKernel(Uc,u,p);return a?U(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var aO,cO=D(()=>{"use strict";B();H();q();O();Ne();aO=E({conv3DBackpropInput_:XZ})});function YZ(e,n,t,r,o){let s=C(e,"x","conv3dTranspose"),i=C(n,"filter","conv3dTranspose");return aO(t,s,i,r,o)}var hT,lO=D(()=>{"use strict";$();cO();O();hT=E({conv3dTranspose_:YZ})});function ZZ(e){let t={x:C(e,"x","cos","float32")};return N.runKernel("Cos",t)}var gT,uO=D(()=>{"use strict";B();$();O();gT=E({cos_:ZZ})});function QZ(e){let t={x:C(e,"x","cosh","float32")};return N.runKernel(Ti,t)}var xT,pO=D(()=>{"use strict";B();H();$();O();xT=E({cosh_:QZ})});function JZ(e,n=0,t=!1,r=!1){let s={x:C(e,"x","cumprod")},i={axis:n,exclusive:t,reverse:r};return N.runKernel(Gc,s,i)}var yT,dO=D(()=>{"use strict";B();H();$();O();yT=E({cumprod_:JZ})});function eQ(e,n=0,t=!1,r=!1){let s={x:C(e,"x","cumsum")},i={axis:n,exclusive:t,reverse:r};return N.runKernel(Hc,s,i)}var vT,fO=D(()=>{"use strict";B();H();$();O();vT=E({cumsum_:eQ})});function tQ(e,n,t,r=!1){let o=C(e,"x","denseBincount"),s=C(n,"weights","denseBincount");k(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),k(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),k(t>=0,()=>`size must be non-negative, but got ${t}.`),k(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:t,binaryOutput:r};return N.runKernel(jc,i,a)}var bT,mO=D(()=>{"use strict";B();H();$();q();O();bT=E({denseBincount_:tQ})});function nQ(e,n,t="NHWC"){let r=C(e,"x","depthToSpace","float32"),o=t==="NHWC"?r.shape[1]:r.shape[2],s=t==="NHWC"?r.shape[2]:r.shape[3],i=t==="NHWC"?r.shape[3]:r.shape[1];k(n>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`),k(o*n>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${n}  for depthToSpace with input shape
    ${r.shape}`),k(s*n>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${n} for depthToSpace with input shape
        ${r.shape}`),k(i%(n*n)===0,()=>`Dimension size must be evenly divisible by ${n*n} but is ${i} for depthToSpace with input shape ${r.shape}`);let a={x:r},c={blockSize:n,dataFormat:t};return N.runKernel(qc,a,c)}var CT,hO=D(()=>{"use strict";B();H();$();q();O();CT=E({depthToSpace_:nQ})});function rQ(e,n,t,r,o="NHWC",s=[1,1],i){let a=C(e,"x","depthwiseConv2d","float32"),c=C(n,"filter","depthwiseConv2d","float32"),l=a,u=!1;a.rank===3&&(u=!0,l=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),k(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);let p=o==="NHWC"?l.shape[3]:l.shape[1];k(p===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${c.shape[2]}.`),Pt("depthwiseConv2d",r,i);let d={x:l,filter:c},f={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},m=N.runKernel(Kc,d,f);return u?U(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Nu,xy=D(()=>{"use strict";B();H();$();q();zn();O();Ne();Nu=E({depthwiseConv2d_:rQ})});function oQ(e){let t={x:C(e,"x","diag")};return N.runKernel(Zc,t)}var wT,gO=D(()=>{"use strict";B();H();$();O();wT=E({diag_:oQ})});function sQ(e,n,t,r,o=[1,1],s="NHWC"){let i=C(e,"x","dilation2d"),a=C(n,"filter","dilation2d");k(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),k(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),k(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let c=i,l=!1;i.rank===3&&(c=U(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),k(c.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${a.shape[2]}`);let u={x:c,filter:a},p={strides:t,pad:r,dilations:o},d=N.runKernel(Qc,u,p);return l?U(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var IT,xO=D(()=>{"use strict";B();H();$();q();O();Ne();IT=E({dilation2d_:sQ})});var fo={};He(fo,{assertAndGetBroadcastShape:()=>Ye,getBroadcastDims:()=>yO,getReductionAxes:()=>yy});function yO(e,n){let t=e.length,r=[];for(let o=0;o<t;o++){let s=t-1-o,i=e[s]||1;(n[n.length-1-o]||1)>1&&i===1&&r.unshift(s)}return r}function yy(e,n){let t=[];for(let r=0;r<n.length;r++){let o=e[e.length-r-1],s=n.length-r-1,i=n[s];(o==null||o===1&&i>1)&&t.unshift(s)}return t}function Ye(e,n){let t=Math.max(e.length,n.length),r=new Array(t);for(let o=0;o<t;o++){let s=e[e.length-o-1];s==null&&(s=1);let i=n[n.length-o-1];if(i==null&&(i=1),s===1)r[t-o-1]=i;else if(i===1)r[t-o-1]=s;else if(s!==i){let a=`Operands could not be broadcast together with shapes ${e} and ${n}.`;throw Error(a)}else r[t-o-1]=s}return r}var Xt=D(()=>{"use strict";});function iQ(e,n){let t=C(e,"a","equal","string_or_numeric"),r=C(n,"b","equal","string_or_numeric");[t,r]=Se(t,r),Ye(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Ni,o)}var Mm,ET=D(()=>{"use strict";B();H();vt();$();Xt();O();Mm=E({equal_:iQ})});function aQ(e,n,t){let r=C(n,"a","where"),o=C(t,"b","where"),s=C(e,"condition","where","bool"),i=Ye(Ye(s.shape,r.shape),o.shape),a=Ts(s,i),c=Ts(r,i),l=Ts(o,i),u={condition:a,t:c,e:l};return N.runKernel(Gl,u)}var or,fd=D(()=>{"use strict";B();H();$();oT();Xt();O();or=E({where_:aQ})});function cQ(e){let t={x:C(e,"x","zerosLike")};return N.runKernel(pu,t)}var Bt,Ns=D(()=>{"use strict";B();H();$();O();Bt=E({zerosLike_:cQ})});function lQ(e,n){let t=C(e,"a","div"),r=C(n,"b","div");[t,r]=Se(t,r);let o=Ve(t,r),s=Bt(o),i=Mm(r,s);return or(i,s,o)}var TT,vO=D(()=>{"use strict";vt();$();Un();ET();O();fd();Ns();TT=E({divNoNan_:lQ})});function uQ(e,n){let t=C(e,"t1","dot"),r=C(n,"t2","dot");k((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);let o=t.rank===1?t.size:t.shape[1],s=r.rank===1?r.size:r.shape[0];if(k(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),t.rank===1&&r.rank===1){let i=U(t,[1,-1]),a=U(r,[-1,1]),c=je(i,a);return U(c,[])}else if(t.rank===1&&r.rank===2){let i=U(t,[1,-1]),a=U(r,[r.shape[0],r.shape[1]]),c=je(i,a);return U(c,[c.size])}else if(t.rank===2&&r.rank===1){let i=U(r,[-1,1]),a=je(t,i);return U(a,[a.size])}else{let i=U(r,[r.shape[0],r.shape[1]]);return je(t,i)}}var ST,bO=D(()=>{"use strict";$();q();Is();O();Ne();ST=E({dot_:uQ})});function pQ(e,...n){let t=n.map((o,s)=>C(o,`tensors${s}`,"einsum")),r={equation:e};return N.runKernel(Jc,t,r)}var Ds,NT=D(()=>{"use strict";B();H();$();O();Ds=E({einsum_:pQ})});function dQ(e){let t={x:C(e,"x","elu","float32")};return N.runKernel("Elu",t)}var $m,DT=D(()=>{"use strict";B();$();O();$m=E({elu_:dQ})});function fQ(e,n){let t=C(e,"x","ensureShape","string_or_numeric");if(!HI(t.shape,n))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${n}`);return e}var kT,CO=D(()=>{"use strict";$();jt();O();kT=E({ensureShape_:fQ})});function mQ(e){let n=C(e,"x","erf");k(n.dtype==="int32"||n.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),n.dtype==="int32"&&(n=_e(n,"float32"));let t={x:n};return N.runKernel("Erf",t)}var _T,wO=D(()=>{"use strict";B();$();q();dn();O();_T=E({erf_:mQ})});function AT(e,n){for(let t=0;t<e.length;++t)if(e[e.length-t-1]!==n-1-t)return!1;return!0}function IO(e,n,t){let r=e.length+n.length,o=[],s=0,i=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?o.push(e[s++]):o.push(n[i++]);return o}function hQ(e,n){let t=[],r=e.length;for(let s=0;s<r;s++)n.indexOf(s)===-1&&t.push(e[s]);let o=n.map(s=>e[s]);return[t,o]}function ks(e,n){let t=n.map(r=>1);return IO(e,t,n)}function gQ(e,n,t){k(AT(n,t),()=>`${e} supports only inner-most axes for now. Got axes ${n} and rank-${t} input.`)}function xQ(e,n){if(AT(e,n))return null;let t=[];for(let r=0;r<n;++r)e.indexOf(r)===-1&&t.push(r);return e.forEach(r=>t.push(r)),t}function yQ(e){return e.map((n,t)=>[t,n]).sort((n,t)=>n[1]-t[1]).map(n=>n[0])}function vQ(e,n){let t=[];for(let r=n-e;r<n;++r)t.push(r);return t}var md=D(()=>{"use strict";q();});function CQ(e,n=null,t=!1){let o={x:C(e,"x","max")},s={reductionIndices:n,keepDims:t};return N.runKernel("Max",o,s)}var mo,Pm=D(()=>{"use strict";B();$();O();mo=E({max_:CQ})});function wQ(e,n=null,t=!1){let o={x:C(e,"x","min")},s={axis:n,keepDims:t};return N.runKernel("Min",o,s)}var hd,RT=D(()=>{"use strict";B();$();O();hd=E({min_:wQ})});function IQ(e,n){let t=C(e,"base","pow"),r=C(n,"exp","pow");[t,r]=Se(t,r);let o={a:t,b:r};return N.runKernel("Pow",o)}var Go,Lm=D(()=>{"use strict";B();vt();$();O();Go=E({pow_:IQ})});function me(e,n){if((Ot(e)&&n!=="string"||Array.isArray(e))&&n!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(n==="string"&&Ot(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Rn(e,[],[],n)}var vn=D(()=>{"use strict";q();vs();});function EQ(e){let t={x:C(e,"x","sqrt","float32")};return N.runKernel(na,t)}var On,gd=D(()=>{"use strict";B();H();$();O();On=E({sqrt_:EQ})});function TQ(e){let n=C(e,"x","square"),t={};return N.runKernel("Square",{x:n},t)}var Yt,_s=D(()=>{"use strict";B();$();O();Yt=E({square_:TQ})});function SQ(e,n=null,t=!1){let r=C(e,"x","sum");r.dtype==="bool"&&(r=_e(r,"int32"));let o={x:r},s={axis:n,keepDims:t};return N.runKernel("Sum",o,s)}var Ze,ho=D(()=>{"use strict";B();$();dn();O();Ze=E({sum_:SQ})});function NQ(e,n="euclidean",t=null,r=!1){e=C(e,"x","norm");let o=EO(e,n,t),s=o.shape;if(r){let i=fi(t,e.shape);s=ks(o.shape,i)}return U(o,s)}function EO(e,n,t=null){if(e.rank===0)return Kt(e);if(e.rank!==1&&t===null)return EO(U(e,[-1]),n,t);if(e.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(n===1)return Ze(Kt(e),t);if(n===1/0)return mo(Kt(e),t);if(n===-1/0)return hd(Kt(e),t);if(n==="euclidean"||n===2)return On(Ze(Go(Kt(e),me(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(t)&&t.length===2){if(n===1)return mo(Ze(Kt(e),t[0]),t[1]-1);if(n===1/0)return mo(Ze(Kt(e),t[1]),t[0]);if(n===-1/0)return hd(Ze(Kt(e),t[1]),t[0]);if(n==="fro"||n==="euclidean")return On(Ze(Yt(e),t));throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}var ya,Bm=D(()=>{"use strict";$();q();Eu();md();Pm();RT();O();Lm();Ne();vn();gd();_s();ho();ya=E({norm_:NQ})});function DQ(e,n=null,t=!1){return ya(e,"euclidean",n,t)}var FT,TO=D(()=>{"use strict";Bm();O();FT=E({euclideanNorm_:DQ})});function kQ(e){let t={x:C(e,"x","exp")};return N.runKernel("Exp",t)}var Sr,xd=D(()=>{"use strict";B();$();O();Sr=E({exp_:kQ})});function _Q(e,n=0){let t=C(e,"x","expandDims","string_or_numeric");k(n<=t.rank,()=>"Axis must be <= rank of the tensor");let r={input:t},o={dim:n};return N.runKernel(rl,r,o)}var Vr,vy=D(()=>{"use strict";B();H();$();q();O();Vr=E({expandDims_:_Q})});function AQ(e){let t={x:C(e,"x","expm1")};return N.runKernel(Di,t)}var OT,SO=D(()=>{"use strict";B();H();$();O();OT=E({expm1_:AQ})});function RQ(e,n){let t=C(e,"x","tile","string_or_numeric");k(t.rank===n.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${n}.`);let r={x:t},o={reps:n};return N.runKernel(hs,r,o)}var As,by=D(()=>{"use strict";B();H();$();q();O();As=E({tile_:RQ})});function FQ(e,n,t,r="float32"){n==null&&(n=e);let o=le([e,n],r),s=e<=n?e:n;for(let a=0;a<s;++a)o.set(1,a,a);let i=U(o.toTensor(),[e,n]);if(t==null)return i;if(t.length===1)return As(Vr(i,0),[t[0],1,1]);if(t.length===2)return As(Vr(Vr(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return As(Vr(Vr(Vr(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}var Vm,MT=D(()=>{"use strict";ws();vy();O();Ne();by();Vm=E({eye_:FQ})});function OQ(e){let t={x:C(e,"x","floor","float32")};return N.runKernel(ki,t)}var Um,$T=D(()=>{"use strict";B();H();$();O();Um=E({floor_:OQ})});function MQ(e,n,t=0,r=0){let o=C(e,"x","gather"),s=C(n,"indices","gather","int32"),i={x:o,indices:s},a={axis:t,batchDims:r};return N.runKernel(al,i,a)}var zm,PT=D(()=>{"use strict";B();H();$();O();zm=E({gather_:MQ})});function $Q(e,n){let t=C(e,"a","greater","string_or_numeric"),r=C(n,"b","greater","string_or_numeric");[t,r]=Se(t,r),Ye(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Ai,o)}var va,Cy=D(()=>{"use strict";B();H();vt();$();Xt();O();va=E({greater_:$Q})});function PQ(e,n){let t=C(e,"a","greaterEqual","string_or_numeric"),r=C(n,"b","greaterEqual","string_or_numeric");[t,r]=Se(t,r),Ye(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Ri,o)}var Gm,LT=D(()=>{"use strict";B();H();vt();$();Xt();O();Gm=E({greaterEqual_:PQ})});function LQ(e){let t={input:C(e,"input","imag")};return N.runKernel(ul,t)}var Rs,Hm=D(()=>{"use strict";B();H();$();O();Rs=E({imag_:LQ})});function BQ(e){let t={x:C(e,"x","isFinite")};return N.runKernel(Fi,t)}var BT,NO=D(()=>{"use strict";B();H();$();O();BT=E({isFinite_:BQ})});function VQ(e){let t={x:C(e,"x","isInf")};return N.runKernel(Oi,t)}var VT,DO=D(()=>{"use strict";B();H();$();O();VT=E({isInf_:VQ})});function UQ(e){let t={x:C(e,"x","isNaN")};return N.runKernel(Mi,t)}var UT,kO=D(()=>{"use strict";B();H();$();O();UT=E({isNaN_:UQ})});function zQ(e,n=.2){let r={x:C(e,"x","leakyRelu")},o={alpha:n};return N.runKernel(pl,r,o)}var Wm,zT=D(()=>{"use strict";B();H();$();O();Wm=E({leakyRelu_:zQ})});function GQ(e,n){let t=C(e,"a","less","string_or_numeric"),r=C(n,"b","less","string_or_numeric");[t,r]=Se(t,r),Ye(t.shape,r.shape);let o={a:t,b:r};return N.runKernel($i,o)}var yd,GT=D(()=>{"use strict";B();H();vt();$();Xt();O();yd=E({less_:GQ})});function HQ(e,n){let t=C(e,"a","lessEqual","string_or_numeric"),r=C(n,"b","lessEqual","string_or_numeric");[t,r]=Se(t,r),Ye(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Pi,o)}var Du,wy=D(()=>{"use strict";B();H();vt();$();Xt();O();Du=E({lessEqual_:HQ})});function HT(e,n,t){if(t<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:n,num:t};return N.runKernel(dl,{},r)}var _O=D(()=>{"use strict";B();H();});function WQ(e,n=5,t=1,r=1,o=.5){let s=C(e,"x","localResponseNormalization");k(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),k(ps(n),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${n}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=U(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let c={x:i},l={depthRadius:n,bias:t,alpha:r,beta:o},u=N.runKernel("LRN",c,l);return a?U(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var WT,AO=D(()=>{"use strict";B();$();q();O();Ne();WT=E({localResponseNormalization_:WQ})});function jQ(e){let t={x:C(e,"x","log","float32")};return N.runKernel("Log",t)}var Ho,jm=D(()=>{"use strict";B();$();O();Ho=E({log_:jQ})});function qQ(e){let t={x:C(e,"x","log1p")};return N.runKernel(Li,t)}var qm,jT=D(()=>{"use strict";B();H();$();O();qm=E({log1p_:qQ})});function RO(e){return k($o(e),()=>"The f passed in grad(f) must be a function"),(n,t)=>{let r=C(n,"x","tf.grad","string_or_numeric"),o=t!=null?C(t,"dy","tf.grad"):null;return N.tidy(()=>{let{value:s,grads:i}=N.gradients(()=>e(r),[r],o);return o!=null&&dt(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Ey(i),i[0]})}}function FO(e){return k($o(e),()=>"The f passed in grads(f) must be a function"),(n,t)=>{k(Array.isArray(n),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=ys(n,"args","tf.grads","string_or_numeric"),o=t!=null?C(t,"dy","tf.grads"):null;return N.tidy(()=>{let{value:s,grads:i}=N.gradients(()=>e(...r),r,o);return o!=null&&dt(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ey(i),i})}}function OO(e){return k($o(e),()=>"The f passed in valueAndGrad(f) must be a function"),(n,t)=>{k(n instanceof ot,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),k(t==null||t instanceof ot,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:o}=N.gradients(()=>e(n),[n],t);return Ey(r),{grad:r[0],value:o}}}function MO(e){return k($o(e),()=>"The f passed in valueAndGrads(f) must be a function"),(n,t)=>{k(Array.isArray(n)&&n.every(o=>o instanceof ot),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),k(t==null||t instanceof ot,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=N.gradients(()=>e(...n),n,t);return t!=null&&dt(r.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ey(r.grads),r}}function Iy(e,n){k($o(e),()=>"The f passed in variableGrads(f) must be a function"),k(n==null||Array.isArray(n)&&n.every(l=>l instanceof Bo),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let t=n!=null;if(!t){n=[];for(let l in N.registeredVariables)n.push(N.registeredVariables[l])}let r=t?n.filter(l=>!l.trainable):null,o=n.length;n=n.filter(l=>l.trainable),k(n.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=N.gradients(e,n,null,s);k(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),k(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let c={};return n.forEach((l,u)=>{a[u]!=null&&(c[l.name]=a[u])}),r?.forEach(l=>c[l.name]=null),{value:i,grads:c}}function bn(e){return N.customGrad(e)}function Ey(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}var Fs=D(()=>{"use strict";B();Er();$();q();});function KQ(e){let t={x:C(e,"x","neg")};return N.runKernel("Neg",t)}var on,Os=D(()=>{"use strict";B();$();O();on=E({neg_:KQ})});function XQ(e){let t={x:C(e,"x","softplus")};return N.runKernel(ta,t)}var Km,qT=D(()=>{"use strict";B();H();$();O();Km=E({softplus_:XQ})});function YQ(e){let n=C(e,"x","logSigmoid");return bn(r=>({value:on(Km(on(r))),gradFunc:i=>ee(i,uo(on(r)))}))(n)}var KT,$O=D(()=>{"use strict";Fs();$();bt();Os();O();_m();qT();KT=E({logSigmoid_:YQ})});function ZQ(e,n){let t=C(e,"a","sub"),r=C(n,"b","sub");[t,r]=Se(t,r);let o={a:t,b:r};return N.runKernel("Sub",o)}var ge,Zt=D(()=>{"use strict";B();vt();$();O();ge=E({sub_:ZQ})});function QQ(e,n=-1){let t=C(e,"logits","logSoftmax");if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${n}`);return bn((o,s)=>{let a=mo(o,n,!0),c=ge(o,a),l=ge(_e(c,"float32"),Ho(Ze(Sr(c),n,!0)));return s([l]),{value:l,gradFunc:(p,d)=>{let[f]=d,m=!0,h=Sr(f);return ge(p,ee(Ze(p,n,m),h))}}})(t)}var XT,PO=D(()=>{"use strict";Fs();$();dn();xd();jm();Pm();bt();O();Zt();ho();XT=E({logSoftmax_:QQ})});function JQ(e,n=null,t=!1){let r=C(e,"x","logSumExp"),o=fi(n,r.shape),s=mo(r,o,!0),i=ge(r,s),a=Sr(i),c=Ze(a,o),l=Ho(c),u=de(U(s,l.shape),l);if(t){let p=ks(u.shape,o);return U(u,p)}return u}var Xm,YT=D(()=>{"use strict";$();q();Ut();md();xd();jm();Pm();O();Ne();Zt();ho();Xm=E({logSumExp_:JQ})});function eJ(e,n){let t=C(e,"a","logicalAnd","bool"),r=C(n,"b","logicalAnd","bool");Ye(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Bi,o)}var ba,Ty=D(()=>{"use strict";B();H();$();Xt();O();ba=E({logicalAnd_:eJ})});function tJ(e){let t={x:C(e,"x","logicalNot","bool")};return N.runKernel(Vi,t)}var Ym,ZT=D(()=>{"use strict";B();H();$();O();Ym=E({logicalNot_:tJ})});function nJ(e,n){let t=C(e,"a","logicalOr","bool"),r=C(n,"b","logicalOr","bool");Ye(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Ui,o)}var Zm,QT=D(()=>{"use strict";B();H();$();Xt();O();Zm=E({logicalOr_:nJ})});function rJ(e,n){let t=C(e,"a","logicalXor","bool"),r=C(n,"b","logicalXor","bool");return Ye(t.shape,r.shape),ba(Zm(e,n),Ym(ba(e,n)))}var JT,LO=D(()=>{"use strict";$();Xt();Ty();ZT();QT();O();JT=E({logicalXor_:rJ})});function oJ(e,n,t="left"){let r=C(e,"sortedSequence","searchSorted"),o=C(n,"values","searchSorted"),s=r.shape[r.shape.length-1],i=o.shape[o.shape.length-1],a=U(r,[-1,s]),c=U(o,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ke(c.shape)>=Sy)throw new Error(`values tensor size must less than ${Sy}`);if(a.shape[1]>=Sy)throw new Error(`trailing dim_size must less than ${Sy} for int32 output type, was ${a.shape[1]}`);let l={sortedSequence:a,values:c},u={side:t};return N.runKernel(zl,l,u)}var Sy,vd,Ny=D(()=>{"use strict";B();H();$();jt();O();Ne();Sy=2147483648;vd=E({searchSorted_:oJ})});function eS(e,n){return vd(e,n,"left")}var BO=D(()=>{"use strict";Ny();});function sJ(e,n,t,r,o){let s=C(e,"x","maxPool"),i=1,a=s,c=!1;s.rank===3&&(c=!0,a=U(s,[1,s.shape[0],s.shape[1],s.shape[2]])),k(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),k(yn(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),Pt("maxPool",r,o);let l={x:a},u={filterSize:n,strides:t,pad:r,dimRoundingMode:o},p=N.runKernel(ml,l,u);return c?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Qm,tS=D(()=>{"use strict";B();H();$();q();zn();O();Ne();Qm=E({maxPool_:sJ})});function iJ(e,n=[1,1,1],t,r,o,s="NDHWC"){let i=C(e,"x","maxPool3d"),a=i,c=!1;i.rank===4&&(c=!0,a=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),k(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),k(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Pt("maxPool3d",r,o);let l={x:a},u={filterSize:n,strides:t,pad:r,dimRoundingMode:o,dataFormat:s},p=N.runKernel(hl,l,u);return c?U(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var nS,VO=D(()=>{"use strict";B();H();$();q();zn();O();Ne();nS=E({maxPool3d_:iJ})});function aJ(e,n,t,r,o=!1){let i={x:C(e,"x","maxPoolWithArgmax")},a={filterSize:n,strides:t,pad:r,includeBatchInIndex:o},c=N.runKernel(gl,i,a);return{result:c[0],indexes:c[1]}}var rS,UO=D(()=>{"use strict";B();H();$();O();rS=E({maxPoolWithArgmax_:aJ})});function cJ(e,n){let t=C(e,"a","maximum"),r=C(n,"b","maximum");[t,r]=Se(t,r),t.dtype==="bool"&&(t=_e(t,"int32"),r=_e(r,"int32")),Ye(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(zi,o)}var Jm,oS=D(()=>{"use strict";B();H();vt();$();Xt();dn();O();Jm=E({maximum_:cJ})});function lJ(e,n=null,t=!1){let o={x:C(e,"x","mean")},s={axis:n,keepDims:t};return N.runKernel(xl,o,s)}var Ca,Dy=D(()=>{"use strict";B();H();$();O();Ca=E({mean_:lJ})});function Nr(e,n="float32"){if(xt(e),n==="complex64"){let r=Nr(e,"float32"),o=Nr(e,"float32");return An(r,o)}let t=Lp(ke(e),n);return N.makeTensor(t,e,n)}var eh=D(()=>{"use strict";B();q();fa();});function go(e,n="float32"){if(xt(e),n==="complex64"){let r=go(e,"float32"),o=Nr(e,"float32");return An(r,o)}let t=rm(ke(e),n);return N.makeTensor(t,e,n)}var ky=D(()=>{"use strict";B();q();jt();fa();eh();});function sS(e,n,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=C(e,"x","meshgrid",e instanceof ot?e.dtype:"float32");if(n===void 0)return[r];let o=C(n,"y","meshgrid",n instanceof ot?n.dtype:"float32"),s=ke(r.shape),i=ke(o.shape);return t==="xy"?(r=U(r,[1,-1]),o=U(o,[-1,1]),[je(go([i,1],r.dtype),r),je(o,go([1,s],o.dtype))]):(r=U(r,[-1,1]),o=U(o,[1,-1]),[je(r,go([1,i],r.dtype)),je(go([s,1],o.dtype),o)])}var zO=D(()=>{"use strict";Is();ky();Ne();Er();$();jt();});function uJ(e,n){let t=C(e,"a","minimum"),r=C(n,"b","minimum");[t,r]=Se(t,r),t.dtype==="bool"&&(t=_e(t,"int32"),r=_e(r,"int32")),Ye(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Gi,o)}var wa,_y=D(()=>{"use strict";B();H();vt();$();Xt();dn();O();wa=E({minimum_:uJ})});function pJ(e,n,t){k(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);let r=C(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");k(n.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${n.length}.`);let o=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)k(n[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),k(n[a][0]>=0&&n[a][0]<=r.shape[a]-o&&n[a][1]>=0&&n[a][1]<=r.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-o} or less than 0 for input of shape ${r.shape}`);let s={paddings:n,mode:t},i={x:r};return N.runKernel(yl,i,s)}var iS,GO=D(()=>{"use strict";B();H();$();q();O();iS=E({mirrorPad_:pJ})});function dJ(e,n){let t=C(e,"a","mod"),r=C(n,"b","mod");[t,r]=Se(t,r);let o={a:t,b:r};return N.runKernel("Mod",o)}var aS,HO=D(()=>{"use strict";B();vt();$();O();aS=E({mod_:dJ})});function fJ(e,n=null,t=!1){e=C(e,"x","moments");let r=fi(n,e.shape),o=Ca(e,r,t),s=o.shape;t||(s=ks(o.shape,r));let i=Yt(ge(_e(e,"float32"),U(o,s))),a=Ca(i,r,t);return{mean:o,variance:a}}var cS,WO=D(()=>{"use strict";$();q();md();dn();Dy();O();Ne();_s();Zt();cS=E({moments_:fJ})});function mJ(e,n,t,r){let o=C(n,"data","multiRNNCell"),s=ys(t,"c","multiRNNCell"),i=ys(r,"h","multiRNNCell"),a=o,c=[];for(let p=0;p<e.length;p++){let d=e[p](a,s[p],i[p]);c.push(d[0]),c.push(d[1]),a=d[1]}let l=[],u=[];for(let p=0;p<c.length;p+=2)l.push(c[p]),u.push(c[p+1]);return[l,u]}var lS,jO=D(()=>{"use strict";$();O();lS=E({multiRNNCell_:mJ})});function hJ(e,n,t,r=!1){let o=C(e,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();let c={logits:i===1?U(o,[1,-1]):o},l={numSamples:n,seed:t,normalized:r},u=N.runKernel(bl,c,l);return i===1?U(u,[u.size]):u}var uS,qO=D(()=>{"use strict";B();H();$();O();Ne();uS=E({multinomial_:hJ})});function gJ(e,n){let t=C(e,"a","notEqual","string_or_numeric"),r=C(n,"b","notEqual","string_or_numeric");[t,r]=Se(t,r),Ye(t.shape,r.shape);let o={a:t,b:r};return N.runKernel(Wi,o)}var th,pS=D(()=>{"use strict";B();H();vt();$();Xt();O();th=E({notEqual_:gJ})});function xJ(e,n,t=1,r=0,o="int32"){if(n<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`);let i={indices:C(e,"indices","oneHot","int32")},a={dtype:o,depth:n,onValue:t,offValue:r};return N.runKernel(Tl,i,a)}var bd,dS=D(()=>{"use strict";B();H();$();O();bd=E({oneHot_:xJ})});function yJ(e){let t={x:C(e,"x","onesLike")};return N.runKernel(El,t)}var fS,KO=D(()=>{"use strict";B();H();$();O();fS=E({onesLike_:yJ})});function vJ(e,n){let t=C(e,"v1","outerProduct"),r=C(n,"v2","outerProduct");k(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);let o=U(t,[-1,1]),s=U(r,[1,-1]);return je(o,s)}var mS,XO=D(()=>{"use strict";$();q();Is();O();Ne();mS=E({outerProduct_:vJ})});function bJ(e,n,t=0){let r=C(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:n,constantValue:t},s={x:r};return N.runKernel(Nl,s,o)}var xo,Cd=D(()=>{"use strict";B();H();$();O();xo=E({pad_:bJ})});function CJ(e,n,t=0){return k(n.length===2,()=>"Invalid number of paddings. Must be length of 2."),xo(e,[n],t)}var hS,YO=D(()=>{"use strict";q();O();Cd();hS=E({pad1d_:CJ})});function wJ(e,n,t=0){return k(n.length===2&&n[0].length===2&&n[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),xo(e,n,t)}var gS,ZO=D(()=>{"use strict";q();O();Cd();gS=E({pad2d_:wJ})});function IJ(e,n,t=0){return k(n.length===3&&n[0].length===2&&n[1].length===2&&n[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),xo(e,n,t)}var xS,QO=D(()=>{"use strict";q();O();Cd();xS=E({pad3d_:IJ})});function EJ(e,n,t=0){return k(n.length===4&&n[0].length===2&&n[1].length===2&&n[2].length===2&&n[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),xo(e,n,t)}var yS,JO=D(()=>{"use strict";q();O();Cd();yS=E({pad4d_:EJ})});function TJ(e,n,t){let r=C(e,"x","spaceToBatchND");k(r.rank>=1+n.length,()=>`input rank ${r.rank} should be > than [blockShape] ${n.length}`),k(t.length===n.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${n.length}`),k(r.shape.reduce((i,a,c)=>c>0&&c<=n.length?i&&(a+t[c-1][0]+t[c-1][1])%n[c-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${n.toString()}`);let o={x:r},s={blockShape:n,paddings:t};return N.runKernel(jl,o,s)}var nh,vS=D(()=>{"use strict";B();H();$();q();O();nh=E({spaceToBatchND_:TJ})});function SJ(e,n,t,r,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),r===0&&(r="valid");let a=C(e,"x","maxPool"),c=a,l=!1;a.rank===3&&(l=!0,c=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),k(yn(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let u=WE(c.shape,n,s,o,r),p=[u.dilationHeight,u.dilationWidth],d;r==="same"?d=DJ([u.filterHeight,u.filterWidth],p):d=[[0,0],[0,0]];let f=p[0]===1&&p[1]===1,[m,h]=NJ([u.inHeight,u.inWidth],p,d),g=f?r:"valid",x=f?c:nh(c,p,m),w=(t==="avg"?()=>km(x,n,s,g,i):()=>Qm(x,n,s,g,i))(),I=f?w:Am(w,p,h);return l?U(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function NJ(e,n,t){let r=t.map(u=>u[0]),o=t.map(u=>u[1]),s=e.concat(r,o),i=n.map((u,p)=>(u-s[p]%u)%u),a=o.map((u,p)=>u+i[p]),c=n.map((u,p)=>[r[p],a[p]]),l=n.map((u,p)=>[0,i[p]]);return[c,l]}function DJ(e,n){let r=e.map((i,a)=>i+(i-1)*(n[a]-1)).map(i=>i-1),o=r.map(i=>Math.floor(i/2)),s=r.map((i,a)=>i-o[a]);return r.map((i,a)=>[o[a],s[a]])}var bS,eM=D(()=>{"use strict";$();q();qE();ZE();zn();tS();O();Ne();vS();bS=E({pool_:SJ})});function kJ(e,n){let t=C(e,"x","prelu"),r=C(n,"alpha","prelu"),o={x:t,alpha:r};return N.runKernel(kl,o)}var rh,CS=D(()=>{"use strict";B();H();$();O();rh=E({prelu_:kJ})});function _J(e,n=null,t=!1){let r=C(e,"x","prod");r.dtype==="bool"&&(r=_e(r,"int32"));let o={x:r},s={axis:n,keepDims:t};return N.runKernel(_l,o,s)}var wS,tM=D(()=>{"use strict";B();H();$();dn();O();wS=E({prod_:_J})});function AJ(e,n,t,r){let o=e.map((u,p)=>C(u,`tensors${p}`,"raggedGather","int32")),s=C(n,"paramsDenseValues","raggedGather"),i=C(t,"indices","raggedGather","int32"),a={paramsNestedSplits:o,paramsDenseValues:s,indices:i},c={outputRaggedRank:r},l=N.runKernel(Al,a,c);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}var IS,nM=D(()=>{"use strict";B();H();$();O();IS=E({raggedGather_:AJ})});function RJ(e,n,t){let r=C(e,"starts","raggedRange"),o=C(n,"limits","raggedRange",r.dtype),s=C(t,"deltas","raggedRange",r.dtype),i={starts:r,limits:o,deltas:s},a=N.runKernel(Rl,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}var ES,rM=D(()=>{"use strict";B();H();$();O();ES=E({raggedRange_:RJ})});function FJ(e,n,t,r,o){let s=C(e,"shape","raggedTensorToTensor","int32"),i=C(n,"values","raggedTensorToTensor"),a=C(t,"defaultValue","raggedTensorToTensor",i.dtype),c=r.map((p,d)=>C(p,`tensors${d}`,"raggedTensorToTensor","int32")),l={shape:s,values:i,defaultValue:a,rowPartitionTensors:c},u={rowPartitionTypes:o};return N.runKernel(Fl,l,u)}var TS,oM=D(()=>{"use strict";B();H();$();O();TS=E({raggedTensorToTensor_:FJ})});function OJ(e,n,t){xt(e);let r=ke(e),o=null;if(t==null||t==="float32")o=new Float32Array(r);else if(t==="int32")o=new Int32Array(r);else if(t==="bool")o=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<r;s++)o[s]=n();return N.makeTensor(o,e,t)}var SS,sM=D(()=>{"use strict";B();q();jt();O();SS=E({rand_:OJ})});var aM=mr((iM,NS)=>{"use strict";(function(e,n,t){function r(a){var c=this,l=i();c.next=function(){var u=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=u-(c.c=u|0)},c.c=1,c.s0=l(" "),c.s1=l(" "),c.s2=l(" "),c.s0-=l(a),c.s0<0&&(c.s0+=1),c.s1-=l(a),c.s1<0&&(c.s1+=1),c.s2-=l(a),c.s2<0&&(c.s2+=1),l=null}function o(a,c){return c.c=a.c,c.s0=a.s0,c.s1=a.s1,c.s2=a.s2,c}function s(a,c){var l=new r(a),u=c&&c.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,u&&(typeof u=="object"&&o(u,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,c=function(l){l=String(l);for(var u=0;u<l.length;u++){a+=l.charCodeAt(u);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(iM,typeof NS=="object"&&NS,typeof define=="function"&&define)});var lM=mr((cM,DS)=>{"use strict";(function(e,n,t){function r(i){var a=this,c="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var u=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^u^u>>>8},i===(i|0)?a.x=i:c+=i;for(var l=0;l<c.length+64;l++)a.x^=c.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var c=new r(i),l=a&&a.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,l&&(typeof l=="object"&&o(l,c),u.state=function(){return o(c,{})}),u}n&&n.exports?n.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(cM,typeof DS=="object"&&DS,typeof define=="function"&&define)});var pM=mr((uM,kS)=>{"use strict";(function(e,n,t){function r(i){var a=this,c="";a.next=function(){var u=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(u^u<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:c+=i;for(var l=0;l<c.length+64;l++)a.x^=c.charCodeAt(l)|0,l==c.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var c=new r(i),l=a&&a.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,l&&(typeof l=="object"&&o(l,c),u.state=function(){return o(c,{})}),u}n&&n.exports?n.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(uM,typeof kS=="object"&&kS,typeof define=="function"&&define)});var fM=mr((dM,_S)=>{"use strict";(function(e,n,t){function r(i){var a=this;a.next=function(){var l=a.x,u=a.i,p,d,f;return p=l[u],p^=p>>>7,d=p^p<<24,p=l[u+1&7],d^=p^p>>>10,p=l[u+3&7],d^=p^p>>>3,p=l[u+4&7],d^=p^p<<7,p=l[u+7&7],p=p^p<<13,d^=p^p<<9,l[u]=d,a.i=u+1&7,d};function c(l,u){var p,d,f=[];if(u===(u|0))d=f[0]=u;else for(u=""+u,p=0;p<u.length;++p)f[p&7]=f[p&7]<<15^u.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?d=f[7]=-1:d=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}c(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var c=new r(i),l=a&&a.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,l&&(l.x&&o(l,c),u.state=function(){return o(c,{})}),u}n&&n.exports?n.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(dM,typeof _S=="object"&&_S,typeof define=="function"&&define)});var hM=mr((mM,AS)=>{"use strict";(function(e,n,t){function r(i){var a=this;a.next=function(){var l=a.w,u=a.X,p=a.i,d,f;return a.w=l=l+1640531527|0,f=u[p+34&127],d=u[p=p+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,f=u[p]=f^d,a.i=p,f+(l^l>>>16)|0};function c(l,u){var p,d,f,m,h,g=[],x=128;for(u===(u|0)?(d=u,u=null):(u=u+"\0",d=0,x=Math.max(x,u.length)),f=0,m=-32;m<x;++m)u&&(d^=u.charCodeAt((m+32)%u.length)),m===0&&(h=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,m>=0&&(h=h+1640531527|0,p=g[m&127]^=d+h,f=p==0?f+1:0);for(f>=128&&(g[(u&&u.length||0)&127]=-1),f=127,m=512;m>0;--m)d=g[f+34&127],p=g[f=f+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,g[f]=d^p;l.w=h,l.X=g,l.i=f}c(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var c=new r(i),l=a&&a.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,l&&(l.X&&o(l,c),u.state=function(){return o(c,{})}),u}n&&n.exports?n.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})(mM,typeof AS=="object"&&AS,typeof define=="function"&&define)});var xM=mr((gM,RS)=>{"use strict";(function(e,n,t){function r(i){var a=this,c="";a.next=function(){var u=a.b,p=a.c,d=a.d,f=a.a;return u=u<<25^u>>>7^p,p=p-d|0,d=d<<24^d>>>8^f,f=f-u|0,a.b=u=u<<20^u>>>12^p,a.c=p=p-d|0,a.d=d<<16^p>>>16^f,a.a=f-u|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):c+=i;for(var l=0;l<c.length+20;l++)a.b^=c.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var c=new r(i),l=a&&a.state,u=function(){return(c.next()>>>0)/4294967296};return u.double=function(){do var p=c.next()>>>11,d=(c.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},u.int32=c.next,u.quick=u,l&&(typeof l=="object"&&o(l,c),u.state=function(){return o(c,{})}),u}n&&n.exports?n.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(gM,typeof RS=="object"&&RS,typeof define=="function"&&define)});var yM=mr(()=>{"use strict"});var bM=mr((vM,Ay)=>{"use strict";(function(e,n,t){var r=256,o=6,s=52,i="random",a=t.pow(r,o),c=t.pow(2,s),l=c*2,u=r-1,p;function d(w,I,_){var A=[];I=I==!0?{entropy:!0}:I||{};var R=g(h(I.entropy?[w,v(n)]:w??x(),3),A),F=new f(A),P=function(){for(var L=F.g(o),V=a,z=0;L<c;)L=(L+z)*r,V*=r,z=F.g(1);for(;L>=l;)L/=2,V/=2,z>>>=1;return(L+z)/V};return P.int32=function(){return F.g(4)|0},P.quick=function(){return F.g(4)/4294967296},P.double=P,g(v(F.S),n),(I.pass||_||function(L,V,z,G){return G&&(G.S&&m(G,F),L.state=function(){return m(F,{})}),z?(t[i]=L,V):L})(P,R,"global"in I?I.global:this==t,I.state)}function f(w){var I,_=w.length,A=this,R=0,F=A.i=A.j=0,P=A.S=[];for(_||(w=[_++]);R<r;)P[R]=R++;for(R=0;R<r;R++)P[R]=P[F=u&F+w[R%_]+(I=P[R])],P[F]=I;(A.g=function(L){for(var V,z=0,G=A.i,j=A.j,W=A.S;L--;)V=W[G=u&G+1],z=z*r+W[u&(W[G]=W[j=u&j+V])+(W[j]=V)];return A.i=G,A.j=j,z})(r)}function m(w,I){return I.i=w.i,I.j=w.j,I.S=w.S.slice(),I}function h(w,I){var _=[],A=typeof w,R;if(I&&A=="object")for(R in w)try{_.push(h(w[R],I-1))}catch{}return _.length?_:A=="string"?w:w+"\0"}function g(w,I){for(var _=w+"",A,R=0;R<_.length;)I[u&R]=u&(A^=I[u&R]*19)+_.charCodeAt(R++);return v(I)}function x(){try{var w;return p&&(w=p.randomBytes)?w=w(r):(w=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(w)),v(w)}catch{var I=e.navigator,_=I&&I.plugins;return[+new Date,e,_,e.screen,v(n)]}}function v(w){return String.fromCharCode.apply(0,w)}if(g(t.random(),n),typeof Ay=="object"&&Ay.exports){Ay.exports=d;try{p=yM()}catch{}}else typeof define=="function"&&define.amd?define(function(){return d}):t["seed"+i]=d})(typeof self<"u"?self:vM,[],Math)});var FS=mr((fze,CM)=>{"use strict";var MJ=aM(),$J=lM(),PJ=pM(),LJ=fM(),BJ=hM(),VJ=xM(),ku=bM();ku.alea=MJ;ku.xor128=$J;ku.xorwow=PJ;ku.xorshift7=LJ;ku.xor4096=BJ;ku.tychei=VJ;CM.exports=ku});var PS={};He(PS,{TEST_EPSILON_FLOAT16:()=>wM,createVideoElement:()=>KJ,encodeStrings:()=>IM,expectArrayBuffersEqual:()=>qJ,expectArraysClose:()=>zJ,expectArraysEqual:()=>HJ,expectNumbersClose:()=>WJ,expectPromiseToFail:()=>GJ,expectValuesInRange:()=>jJ,play:()=>XJ,testEpsilon:()=>MS});function zJ(e,n,t){return t==null&&(t=MS()),OS(e,n,(r,o)=>$S(r,o,t))}function MS(){return N.backend.floatPrecision()===32?UJ:wM}function OS(e,n,t){let r=!0;if((Ot(e)||Ot(n))&&(r=!1),Ot(e)&&Ot(n)&&(r=!0),r){let i=e.constructor.name,a=n.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(e)&&Array.isArray(n)){let i=un(e),a=un(n);if(!kn(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}let o=Ot(e)?e:io(e),s=Ot(n)?n:io(n);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let a=o[i],c=s[i];if(!t(a,c))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${c}.
Actual:   ${o}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function GJ(e,n){e().then(()=>n.fail(),()=>n()),typeof expect<"u"&&expect().nothing()}function HJ(e,n){let t=typeof n=="string"||typeof n=="number"||typeof n=="boolean"?[n]:n;return oo(e)||oo(e[0])||oo(n)||oo(n[0])?OS(e,t,(r,o)=>r==o):OS(e,n,(r,o)=>$S(r,o,0))}function WJ(e,n,t){if(t==null&&(t=MS()),!$S(e,n,t))throw new Error(`Numbers differ: actual === ${e}, expected === ${n}`);typeof expect<"u"&&expect().nothing()}function $S(e,n,t){return!isFinite(e)&&!isFinite(n)?!0:!(isNaN(e)||isNaN(n)||Math.abs(e-n)>t)}function jJ(e,n,t){for(let r=0;r<e.length;r++)if(e[r]<n||e[r]>t)throw new Error(`Value out of range:${e[r]} low: ${n}, high: ${t}`)}function qJ(e,n){let t=new Float32Array(e),r=new Float32Array(n);if(t.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${t.length}`);for(let o=0;o<r.length;o++)if(t[o]!==r[o])throw new Error(`Expected ArrayBuffer value at ${o} to be ${r[o]} but got ${t[o]} instead`)}function IM(e){for(let n=0;n<e.length;n++){let t=e[n];Array.isArray(t)?IM(t):e[n]=pa(t)}return e}function KJ(e){let n=document.createElement("video");return"playsInline"in n&&(n.playsInline=!0),n.muted=!0,n.loop=!0,n.style.position="fixed",n.style.left="0px",n.style.top="0px",n.preload="auto",n.appendChild(e),new Promise(t=>{n.addEventListener("loadeddata",r=>t(n)),n.load()})}async function XJ(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(n=>{e.requestVideoFrameCallback(n)})}var UJ,wM,EM=D(()=>{"use strict";B();$();q();UJ=.001,wM=.1});var Oy,_u,Ry,Fy,oh=D(()=>{"use strict";Oy=tg(FS());_u=class{constructor(n,t,r,o,s){this.mean=n,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=Oy.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let n,t,r=!1;for(;!r;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);n=this.mean+this.stdDev*o*a,t=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(n))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(n)}convertValue(n){return this.dtype==null||this.dtype==="float32"?n:Math.round(n)}isValidTruncated(n){return n<=this.upper&&n>=this.lower}},Ry=class{constructor(n,t,r,o){this.alpha=n,this.beta=1/t,this.dtype=r;let s=o||Math.random();this.randu=Oy.alea(s.toString()),this.randn=new _u(0,1,r,!1,this.randu()),n<1?this.d=n+2/3:this.d=n-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let n,t,r,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,n=o*o,t=1-.331*n*n,r=.5*n+this.d*(1-i+Math.log(i)),s=this.randu(),s<t||Math.log(s)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(n){return this.dtype==="float32"?n:Math.round(n)}},Fy=class{constructor(n=0,t=1,r,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=n,this.range=t-n,this.dtype=r,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${n} - ${t} <= 1 and dtype is not float`);this.random=Oy.alea(o)}convertValue(n){return this.canReturnFloat()?n:Math.round(n)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}});function YJ(e,n,t=1,r="float32",o){if(xt(e),t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new Ry(n,t,r,o),i=le(e,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var LS,TM=D(()=>{"use strict";jt();ws();O();oh();LS=E({randomGamma_:YJ})});function ZJ(e,n=0,t=1,r,o){if(xt(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new _u(n,t,r,!1,o),i=le(e,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var sh,BS=D(()=>{"use strict";jt();ws();O();oh();sh=E({randomNormal_:ZJ})});function QJ(e,n,t){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);return sh(e,0,1,n,t)}var VS,SM=D(()=>{"use strict";O();BS();VS=E({randomStandardNormal_:QJ})});function JJ(e,n=0,t=1,r="float32",o){xt(e);let s=le(e,r),i=new Fy(n,t,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var Au,My=D(()=>{"use strict";jt();ws();O();oh();Au=E({randomUniform_:JJ})});function eee(e,n,t,r){return Au(e,n,t,"int32",r)}var US,NM=D(()=>{"use strict";O();My();US=E({randomUniformInt_:eee})});function Ms(e,n,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");let o={start:e,stop:n,step:t,dtype:r};return N.runKernel(Ol,{},o)}var $y=D(()=>{"use strict";B();H();});function tee(e){let t={input:C(e,"input","real")};return N.runKernel(Ml,t)}var Wo,ih=D(()=>{"use strict";B();H();$();O();Wo=E({real_:tee})});function nee(e){let t={x:C(e,"x","reciprocal")};return N.runKernel(ji,t)}var zS,DM=D(()=>{"use strict";B();H();$();O();zS=E({reciprocal_:nee})});function ree(e){let t={x:C(e,"x","relu")};return N.runKernel(qi,t)}var $s,ah=D(()=>{"use strict";B();H();$();O();$s=E({relu_:ree})});function oee(e){let t={x:C(e,"x","relu6")};return N.runKernel(Ki,t)}var ch,GS=D(()=>{"use strict";B();H();$();O();ch=E({relu6_:oee})});function see(e,n){let r={x:C(e,"x","reverse")},o={dims:n};return N.runKernel(Bl,r,o)}var sr,Ru=D(()=>{"use strict";B();H();$();O();sr=E({reverse_:see})});function iee(e){let n=C(e,"x","reverse");return k(n.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${n.rank}.`),sr(n,0)}var HS,kM=D(()=>{"use strict";$();q();O();Ru();HS=E({reverse1d_:iee})});function aee(e,n){let t=C(e,"x","reverse");return k(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),sr(t,n)}var WS,_M=D(()=>{"use strict";$();q();O();Ru();WS=E({reverse2d_:aee})});function cee(e,n){let t=C(e,"x","reverse");return k(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),sr(t,n)}var jS,AM=D(()=>{"use strict";$();q();O();Ru();jS=E({reverse3d_:cee})});function lee(e,n){let t=C(e,"x","reverse");return k(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),sr(t,n)}var qS,RM=D(()=>{"use strict";$();q();O();Ru();qS=E({reverse4d_:lee})});function uee(e){let t={x:C(e,"x","round")};return N.runKernel(Xi,t)}var lh,KS=D(()=>{"use strict";B();H();$();O();lh=E({round_:uee})});function pee(e){let t={x:C(e,"x","rsqrt","float32")};return N.runKernel(Yi,t)}var XS,FM=D(()=>{"use strict";B();H();$();O();XS=E({rsqrt_:pee})});function dee(e){let t={x:C(e,"x","selu")};return N.runKernel(Zi,t)}var YS,OM=D(()=>{"use strict";B();H();$();O();YS=E({selu_:dee})});function fee(e,n,t,r,o,s=[1,1],i="NHWC"){let a=C(e,"x","separableConv2d"),c=C(n,"depthwiseFilter","separableConv2d"),l=C(t,"pointwiseFilter","separableConv2d"),u=a,p=!1;if(a.rank===3&&(p=!0,u=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");k(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),k(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),k(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),k(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),k(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let d=c.shape[2],f=c.shape[3];k(l.shape[2]===d*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*f}, but got ${l.shape[2]}.`);let m=Nu(u,c,r,o,i,s),g=Ss(m,l,1,"valid",i);return p?U(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var ZS,MM=D(()=>{"use strict";$();q();Om();xy();O();Ne();ZS=E({separableConv2d_:fee})});async function mee(e,n){let t=C(e,"x","setdiff1d"),r=C(n,"y","setdiff1d");k(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),k(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),k(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let o=await t.data(),s=await r.data(),i=new Set(s),a=0;for(let u=0;u<o.length;u++)i.has(o[u])||a++;let c=new Ke([a],t.dtype),l=new Ke([a],"int32");for(let u=0,p=0;u<o.length;u++)i.has(o[u])||(c.values[p]=o[u],l.values[p]=u,p++);return[c.toTensor(),l.toTensor()]}var QS,$M=D(()=>{"use strict";Er();$();q();QS=mee});function hee(e){let t={x:C(e,"x","sign")};return N.runKernel(Ji,t)}var JS,PM=D(()=>{"use strict";B();H();$();O();JS=E({sign_:hee})});function gee(e){let t={x:C(e,"x","sin","float32")};return N.runKernel("Sin",t)}var eN,LM=D(()=>{"use strict";B();$();O();eN=E({sin_:gee})});function xee(e){let t={x:C(e,"x","sinh")};return N.runKernel(Qi,t)}var tN,BM=D(()=>{"use strict";B();H();$();O();tN=E({sinh_:xee})});function yee(e,n,t){let r=C(e,"x","slice1d");return k(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ue(r,[n],[t])}var nN,VM=D(()=>{"use strict";$();q();O();Br();nN=E({slice1d_:yee})});function vee(e,n,t){let r=C(e,"x","slice2d");return k(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ue(r,n,t)}var rN,UM=D(()=>{"use strict";$();q();O();Br();rN=E({slice2d_:vee})});function bee(e,n,t){let r=C(e,"x","slice3d");return k(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ue(r,n,t)}var oN,zM=D(()=>{"use strict";$();q();O();Br();oN=E({slice3d_:bee})});function Cee(e,n,t){let r=C(e,"x","slice4d");return k(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ue(r,n,t)}var sN,GM=D(()=>{"use strict";$();q();O();Br();sN=E({slice4d_:Cee})});function wee(e,n=-1){let t=C(e,"logits","softmax","float32");if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${n}`);let r={logits:t},o={dim:n};return N.runKernel(Kl,r,o)}var iN,HM=D(()=>{"use strict";B();H();$();O();iN=E({softmax_:wee})});function Iee(e){k(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let n={input:e};return N.runKernel("FFT",n)}var Fu,Py=D(()=>{"use strict";B();q();O();Fu=E({fft_:Iee})});function Eee(e){k(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let n={input:e};return N.runKernel(ll,n)}var Ia,Ly=D(()=>{"use strict";B();H();q();O();Ia=E({ifft_:Eee})});function Tee(e){let n=e.shape[e.shape.length-1],t=e.size/n,r;if(n<=2){let o=U(e,[t,n]);r=Ia(o)}else{let o=[t,2*(n-1)],s=U(Wo(e),[t,n]),i=U(Rs(e),[t,n]),a=sr(Ue(s,[0,1],[t,n-2]),1),c=ee(sr(Ue(i,[0,1],[t,n-2]),1),me(-1)),l=ut([s,a],1),u=ut([i,c],1),p=U(An(l,u),[o[0],o[1]]);r=Ia(p)}if(r=Wo(r),e.rank===3&&e.shape[0]!==0){let o=r,s=e.shape[0];r=U(r,[s,r.shape[0]/s,r.shape[1]]),o.dispose()}return r}var uh,aN=D(()=>{"use strict";fa();lo();Hm();bt();O();ih();Ne();Ru();vn();Br();Ly();uh=E({irfft_:Tee})});function See(e,n,t=0){let o={x:C(e,"x","split")},s={numOrSizeSplits:n,axis:t};return N.runKernel(ql,o,s)}var jo,ph=D(()=>{"use strict";B();H();$();O();jo=E({split_:See})});function Nee(e,n){k(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let t=e.shape[e.shape.length-1],r=e.size/t,o;if(n!=null&&n<t){let m=e.shape.map(g=>0),h=e.shape.map(g=>g);h[e.shape.length-1]=n,o=Ue(e,m,h),t=n}else if(n!=null&&n>t){let m=e.shape.map(h=>h);m[e.shape.length-1]=n-t,o=ut([e,Nr(m)],e.shape.length-1),t=n}else o=e;let s=Bt(o),i=U(An(o,s),[r,t]),a=Fu(i),c=Math.floor(t/2)+1,l=Wo(a),u=Rs(a),p=jo(l,[c,t-c],l.shape.length-1),d=jo(u,[c,t-c],u.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=c,U(An(p[0],d[0]),f)}var Ou,By=D(()=>{"use strict";q();fa();lo();Hm();O();ih();Ne();Br();ph();eh();Ns();Py();Ou=E({rfft_:Nee})});function Dee(e,n){let t=C(e,"a","squaredDifference"),r=C(n,"b","squaredDifference");[t,r]=Se(t,r),Ye(t.shape,r.shape);let o={a:t,b:r},s={};return N.runKernel(ra,o,s)}var dh,cN=D(()=>{"use strict";B();H();vt();$();Xt();O();dh=E({squaredDifference_:Dee})});function kee(e,n){let t=C(e,"x","squeeze","string_or_numeric");return U(t,WI(t.shape,n).newShape)}var Mu,Vy=D(()=>{"use strict";$();q();O();Ne();Mu=E({squeeze_:kee})});function _ee(e,n=0){let t=ys(e,"tensors","stack","string_or_numeric");k(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&k(n<=t[0].rank,()=>"Axis must be <= rank of the tensor");let r=t,o={axis:n};return N.runKernel(Sl,r,o)}var Cn,fh=D(()=>{"use strict";B();H();$();q();O();Cn=E({stack_:_ee})});function Aee(e,n=0){let r={x:C(e,"x","step")},o={alpha:n};return N.runKernel(ia,r,o)}var mh,lN=D(()=>{"use strict";B();H();$();O();mh=E({step_:Aee})});function Ree(e,n,t,r,o=0,s=0,i=0,a=0,c=0){let u={x:C(e,"x","stridedSlice","string_or_numeric")},p={begin:n,end:t,strides:r,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:c};return N.runKernel(eu,u,p)}var uN,WM=D(()=>{"use strict";B();H();$();O();uN=E({stridedSlice_:Ree})});function Fee(e){let t={x:C(e,"x","tan","float32")};return N.runKernel("Tan",t)}var pN,jM=D(()=>{"use strict";B();$();O();pN=E({tan_:Fee})});function Qt(e,n){Ir(e);let t=un(e,n);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Rn(e,null,t,n)}var Ea=D(()=>{"use strict";$();q();vs();});function Ps(e,n,t){if(Ir(e),n!=null&&n.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=un(e,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Rn(e,n,r,t)}var Uy=D(()=>{"use strict";$();q();vs();});function hh(e,n,t){if(Ir(e),n!=null&&n.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=un(e,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Rn(e,n,r,t)}var dN=D(()=>{"use strict";$();q();vs();});function fN(e,n,t){if(Ir(e),n!=null&&n.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=un(e,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Rn(e,n,r,t)}var qM=D(()=>{"use strict";$();q();vs();});function mN(e,n,t){if(Ir(e),n!=null&&n.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=un(e,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Rn(e,n,r,t)}var KM=D(()=>{"use strict";$();q();vs();});function hN(e,n,t){if(Ir(e),n!=null&&n.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=un(e,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return n=n||r,Rn(e,n,r,t)}var XM=D(()=>{"use strict";$();q();vs();});var gh={};He(gh,{calculateShapes:()=>YM,validateInput:()=>wd,validateUpdateShape:()=>gN});function gN(e,n,t){let r=n.rank>1?n.shape[n.rank-1]:1,o=n.rank>1?n.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${n.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${o}.`;if(t.rank<o)throw new Error(s+` update.rank < ${o}. `);if(e.length<r+(t.rank-o))throw new Error(s+` Output shape length < ${r+(t.rank-o)}`);if(t.rank!==o+e.length-r)throw new Error(s+` update.rank != ${o+e.length-r}`);for(let i=0;i<o;++i)if(t.shape[i]!==n.shape[i])throw new Error(s+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${n.shape[i]}).`);for(let i=0;i<t.rank-o;++i)if(t.shape[i+o]!==e[i+r])throw new Error(s+` updates.shape[${i+o}] (${t.shape[i+o]}) != shape[${i+o}] (${e[i+o]})`)}function wd(e,n,t){if(n.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${n.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(n.size===0)throw new Error(`Indices specified for empty output. indices shape: ${n.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}gN(t,n,e)}function YM(e,n,t){let r=n.shape.length,o=r>1?n.shape[r-1]:1,s=t.length,i=1;for(let p=o;p<s;++p)i*=t[p];let a=o<1?1:o,c=ke(n.shape)/a,l=[...Po(t.slice(0,o)),1],u=ke(t);return{sliceRank:o,numUpdates:c,sliceSize:i,strides:l,outputSize:u}}var xh=D(()=>{"use strict";q()});function Oee(e,n,t){let r=C(e,"tensor","tensorScatterupdate"),o=C(n,"indices","tensorScatterupdate","int32"),s=C(t,"updates","tensorScatterupdate");if(wd(s,o,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:o,updates:s},a={};return N.runKernel(Ul,i,a)}var xN,ZM=D(()=>{"use strict";B();H();$();O();xh();xN=E({tensorScatterUpdate_:Oee})});function Mee(e,n=1,t=!0){let r=C(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=r.shape[r.shape.length-1];if(n<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${n}`);if(n>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${n}`);let s={x:r},i={k:n,sorted:t},[a,c]=N.runKernel(iu,s,i);return{values:a,indices:c}}var yN,QM=D(()=>{"use strict";B();H();$();O();yN=E({topk_:Mee})});function $ee(e,n=0,t=1,r,o){if(xt(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new _u(n,t,r,!0,o),i=le(e,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var vN,JM=D(()=>{"use strict";jt();ws();O();oh();vN=E({truncatedNormal_:$ee})});function Pee(e,n=0){let t=C(e,"x","unique","string_or_numeric");k(t.rank>0,()=>"The input tensor must be at least 1D");let r={x:t},o={axis:n},[s,i]=N.runKernel(cu,r,o);return{values:s,indices:i}}var bN,e$=D(()=>{"use strict";B();H();$();q();O();bN=E({unique_:Pee})});function Lee(e,n,t){let r=C(e,"x","unsortedSegmentSum"),o=C(n,"segmentIds","unsortedSegmentSum","int32");k(ps(t),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:o},i={numSegments:t};return N.runKernel(uu,s,i)}var CN,t$=D(()=>{"use strict";B();H();$();q();O();CN=E({unsortedSegmentSum_:Lee})});function Bee(e,n=0){let t=C(e,"x","unstack","string_or_numeric");k(n>=-t.shape.length&&n<t.shape.length,()=>`Axis = ${n} is not in [-${t.shape.length}, ${t.shape.length})`);let r={value:t},o={axis:n};return N.runKernel(lu,r,o)}var ir,zy=D(()=>{"use strict";B();H();$();q();O();ir=E({unstack_:Bee})});function wN(e,n){return vd(e,n,"right")}var n$=D(()=>{"use strict";Ny();});function IN(e,n=!0,t,r){return N.makeVariable(e,n,t,r)}var r$=D(()=>{"use strict";B();});function Gy(e,n){let t=[];for(let s=0;s<n.length;s++)n[s]&&t.push(s);let r=le(e,"int32"),o=le([t.length,e.length],"int32");for(let s=0;s<t.length;s++){let i=r.indexToLoc(t[s]),a=s*e.length;o.values.set(i,a)}return o.toTensor()}var EN=D(()=>{"use strict";ws();});async function Vee(e){let n=C(e,"condition","whereAsync","bool"),t=await n.data(),r=Gy(n.shape,t);return e!==n&&n.dispose(),r}var yh,TN=D(()=>{"use strict";EN();$();yh=Vee});async function Uee(e,n,t){let r=C(e,"tensor","boolMask"),o=C(n,"mask","boolMask","bool"),s=t??0,i=o.rank,a=r.shape;k(i>0,()=>"mask cannot be scalar"),dt(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let h=s;h<s+i;h++)c*=a[h];let l=a.slice(0,s).concat([c],a.slice(s+i)),u=U(r,l),p=U(o,[-1]),d=await yh(p),f=Mu(d,[1]),m=zm(u,f,s);return e!==r&&r.dispose(),n!==o&&o.dispose(),f.dispose(),u.dispose(),p.dispose(),d.dispose(),m}var o$,s$=D(()=>{"use strict";$();q();PT();Ne();Vy();TN();o$=Uee});function zee(e,n,t){let r=C(e,"x","transpose");if(n==null&&(n=r.shape.map((i,a)=>a).reverse()),k(r.rank===n.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${n}.`),n.forEach(i=>{k(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${n}`)}),r.rank<=1)return r.clone();let o={x:r},s={perm:n};return r.dtype==="complex64"?Ce(()=>{let i=Wo(r),a=Rs(r);return i=N.runKernel(gs,{x:i},s),a=N.runKernel(gs,{x:a},s),t&&(a=on(a)),An(i,a)}):N.runKernel(gs,o,s)}var $u,Hy=D(()=>{"use strict";B();rr();H();$();q();fa();Hm();Os();O();ih();$u=E({transpose_:zee})});function Gee(e,n,t,r,o=!0){let s=C(e,"v","movingAverage"),i=C(n,"x","movingAverage"),a=C(t,"decay","movingAverage");cE(s,i),k(kn(s.shape,i.shape),()=>"Shape mismatch in v and x");let c=me(1),l=ge(c,a),u=ee(ge(i,s),l);if(o){k(r!=null,()=>"When using zeroDebias: true, step is required.");let p=C(r,"step","movingAverage");u=Ve(u,ge(c,Go(a,p)))}return de(s,u)}var i$,a$=D(()=>{"use strict";vt();$();q();Ut();Un();bt();O();Lm();vn();Zt();i$=E({movingAverage_:Gee})});function Hee(e,n,t){xt(t);let r=C(e,"indices","scatterND","int32"),o=C(n,"updates","scatterND");wd(o,r,t);let s={indices:r,updates:o},i={shape:t};return N.runKernel(Vl,s,i)}var c$,l$=D(()=>{"use strict";B();H();$();jt();O();xh();c$=E({scatterND_:Hee})});function u$(e,n,t,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let o=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);let i=n.size;if(!(n.rank===0||n.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${n.shape}, should be [] or [${o}]`);if(n.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}var p$=D(()=>{"use strict"});function jee(e,n,t,r=0){xt(t);let o=C(e,"sparseIndices","sparseToDense","int32"),s=C(n,"sparseValues","sparseToDense","string_or_numeric"),i=C(r,"defaultValue","sparseToDense",s.dtype);u$(o,s,t,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},c={outputShape:t};return N.runKernel(Jl,a,c)}var d$,f$=D(()=>{"use strict";B();H();p$();$();jt();O();d$=E({sparseToDense_:jee})});function qee(e,n){let t=C(n,"indices","gatherND","int32"),o={params:C(e,"x","gatherND","string_or_numeric"),indices:t};return N.runKernel(cl,o)}var m$,h$=D(()=>{"use strict";B();H();$();O();m$=E({gatherND_:qee})});function g$(e,n){if(n==null)return e.shape.slice();if(kn(e.shape,n))return n;if(e.shape.length===n.length){let t=[];for(let r=0;r<e.shape.length;r++)n[r]==null&&e.shape[r]!=null?t.push(e.shape[r]):t.push(n[r]);return t}return n}var x$=D(()=>{"use strict";q();});function Kee(e,n,t,r){let o=C(e,"x","dropout");if(k(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),k(n>=0&&n<1,()=>`rate must be a float in the range [0, 1), but got ${n}.`),n===0)return e instanceof ot?o.clone():o;let s=g$(o,t),i=1-n,a=Ve(Um(de(Au(s,0,1,"float32",r),i)),i);return ee(o,a)}var y$,v$=D(()=>{"use strict";Er();$();q();Ut();Un();x$();$T();bt();O();My();y$=E({dropout_:Kee})});function Wy(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Id(e,n,t){let r=1-e%2,o=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);o[s]=n-t*Math.cos(i)}return Qt(o,"float32")}var vh=D(()=>{"use strict";Ea();});async function Xee(e,n,t=1){let r=C(e,"predictions","inTopK"),o=C(n,"targets","inTopK");k(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),k(r.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${o.rank}`),dt(r.shape.slice(0,r.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];k(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);let i=await r.data(),a=await o.data(),[c,l]=[i.length/s,s],u=jI("bool",c);for(let p=0;p<c;p++){let d=p*l,f=i.subarray(d,d+l),m=[];for(let h=0;h<f.length;h++)m.push({value:f[h],index:h});m.sort((h,g)=>g.value-h.value),u[p]=0;for(let h=0;h<t;h++)if(m[h].index===a[p]){u[p]=1;break}}return e!==r&&r.dispose(),n!==o&&o.dispose(),xn(u,o.shape,"bool")}var b$,C$=D(()=>{"use strict";$();q();wm();b$=Xee});function Yee(e,n,t,r,o,s="NHWC",i){let a=e;e.rank===3&&(a=U(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=n;c.rank===3&&(c=U(n,[1,n.shape[0],n.shape[1],n.shape[2]])),k(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),k(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),k(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);let l=s==="NHWC"?a.shape[3]:a.shape[1],u=s==="NHWC"?c.shape[3]:c.shape[1];k(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),k(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),Pt("conv2dDerFilter",o,i);let p={x:a,dy:c},d={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:t};return N.runKernel(Lc,p,d)}var w$,I$=D(()=>{"use strict";B();H();q();zn();O();Ne();w$=E({conv2DBackpropFilter_:Yee})});function Pu(e,n,t){if(t==null||t==="linear")return e;if(t==="relu")return ee(e,mh(n));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Lu(e,n){let t=n,r=yy(e.shape,n.shape);return r.length>0&&(t=Ze(t,r)),U(t,e.shape)}function Bu(e,n,t,r){if(n==="linear")return e;if(n==="relu")return $s(e);if(n==="elu")return $m(e);if(n==="relu6")return ch(e);if(n==="prelu")return rh(e,t);if(n==="leakyrelu")return Wm(e,r);if(n==="sigmoid")return uo(e);throw new Error(`Unknown fused activation ${n}.`)}var Vu,Ed=D(()=>{"use strict";Xt();DT();zT();bt();CS();ah();GS();Ne();_m();lN();ho();Vu=(e,n)=>!(e>0)||n==="linear"});function Zee({x:e,filter:n,strides:t,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:u}){if(c=c||"linear",Vu(N.state.gradientDepth,c)===!1){k(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let A=Ss(e,n,t,r,o,s,i);return a!=null&&(A=de(A,a)),Bu(A,c,l,u)}let p=C(e,"x","conv2d","float32"),d=C(n,"filter","conv2d","float32"),f=p,m=!1;p.rank===3&&(m=!0,f=U(p,[1,p.shape[0],p.shape[1],p.shape[2]])),k(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),k(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Pt("fused conv2d",r,i);let h=o==="NHWC"?f.shape[3]:f.shape[1];k(d.shape[2]===h,()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${d.shape[2]}.`),k(yn(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let g=Su(f.shape,d.shape,t,s,r,i),x;a!=null&&(x=C(a,"bias","fused conv2d"),[x]=Se(x,p),o==="NHWC"?Ye(g.outShape,x.shape):(k(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),k(x.shape.length===0||x.shape[0]===g.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let v;if(l!=null){let A=l.shape;if(k(A.length<=1||A.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${A.length}.`),A.length===1)k(A[0]===1||A[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the number of output channels (${g.outChannels}).`);else if(A.length===3)try{Ye(A,g.outShape)}catch{let F=`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(F)}v=C(l,"prelu weights","fused conv2d")}let w=(A,R)=>{k(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[F,P,L,V]=R,z=Pu(A,L,c);k(Tu(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let G=gy(P.shape,z,F,t,r),j=w$(P,z,F.shape,t,r),W=[G,j];if(V!=null){let Y=Lu(V,z);W.push(Y)}return W},I={x:f,filter:d,bias:x,preluActivationWeights:v},_={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:c,leakyreluAlpha:u};return a==null?bn((R,F,P)=>{let L=N.runKernel(ca,I,_);return P([F,R,L]),m&&(L=U(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:w}})(f,d):bn((R,F,P,L)=>{let V=N.runKernel(ca,I,_);return L([F,R,V,P]),m&&(V=U(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:w}})(f,d,x)}var E$,T$=D(()=>{"use strict";B();Fs();H();vt();$();q();Ut();Xt();Om();I$();dT();zn();Ed();O();Ne();E$=E({fusedConv2d_:Zee})});function Qee(e,n,t,r,o,s=[1,1],i){let a=e;e.rank===3&&(a=U(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=n;c.rank===3&&(c=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l={x:a,dy:c},u={strides:r,pad:o,dimRoundingMode:i,dilations:s,filterShape:t};return N.runKernel(Xc,l,u)}var S$,N$=D(()=>{"use strict";B();H();O();Ne();S$=E({depthwiseConv2dNativeBackpropFilter_:Qee})});function Jee(e,n,t,r,o,s=[1,1],i){let a=n,c=!1;n.rank===3&&(c=!0,a=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l={dy:a,filter:t},u={strides:r,pad:o,dimRoundingMode:i,dilations:s,inputShape:e},p=N.runKernel(Yc,l,u);return c?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var D$,k$=D(()=>{"use strict";B();H();O();Ne();D$=E({depthwiseConv2dNativeBackpropInput_:Jee})});function ete({x:e,filter:n,strides:t,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:u}){if(Vu(N.state.gradientDepth,c)===!1){let _=Nu(e,n,t,r,o,s,i);return a!=null&&(_=de(_,a)),Bu(_,c,l,u)}let p=C(e,"x","depthwiseConv2d","float32"),d=C(n,"filter","depthwiseConv2d","float32"),f=p,m=!1;p.rank===3&&(m=!0,f=U(p,[1,p.shape[0],p.shape[1],p.shape[2]])),k(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),k(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),k(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),s==null&&(s=[1,1]),k(yn(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),Pt("fused depthwiseConv2d",r,i);let h=Su(f.shape,d.shape,t,s,r,i,!0),g;a!=null&&(g=C(a,"bias","fused conv2d"),[g]=Se(g,p),Ye(h.outShape,g.shape));let x;l!=null&&(x=C(l,"prelu weights","fused depthwiseConv2d"));let v=(_,A)=>{k(Tu(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[R,F,P,L]=A,V=Pu(_,P,c),z=D$(F.shape,V,R,t,r,s,i),G=S$(F,V,R.shape,t,r,s,i);if(L!=null){let j=Lu(g,V);return[z,G,j]}return[z,G]},w={x:f,filter:d,bias:g,preluActivationWeights:x},I={strides:t,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:c,leakyreluAlpha:u};return a==null?bn((A,R,F)=>{let P=N.runKernel(la,w,I);return F([R,A,P]),m&&(P=U(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:v}})(f,d):bn((A,R,F,P)=>{let L=N.runKernel(la,w,I);return P([R,A,L,F]),m&&(L=U(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:v}})(f,d,g)}var _$,A$=D(()=>{"use strict";B();Fs();H();vt();$();q();Ut();Xt();zn();xy();N$();k$();Ed();O();Ne();_$=E({fusedDepthwiseConv2d_:ete})});function tte({a:e,b:n,transposeA:t=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(Vu(N.state.gradientDepth,s)===!1){let V=je(e,n,t,r);return o!=null&&(V=de(V,o)),Bu(V,s,i,a)}let c=C(e,"a","fused matMul"),l=C(n,"b","fused matMul");[c,l]=Se(c,l);let u=t?c.shape[c.rank-2]:c.shape[c.rank-1],p=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=t?c.shape[c.rank-1]:c.shape[c.rank-2],f=r?l.shape[l.rank-2]:l.shape[l.rank-1],m=c.shape.slice(0,-2),h=l.shape.slice(0,-2),g=ke(m),x=ke(h);k(u===p,()=>`Error in fused matMul: inner shapes (${u}) and (${p}) of Tensors with shapes ${c.shape} and ${l.shape} and transposeA=${t} and transposeB=${r} must match.`);let w=Ye(c.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,f]),I=t?U(c,[g,u,d]):U(c,[g,d,u]),_=r?U(l,[x,f,p]):U(l,[x,p,f]),A;o!=null&&(A=C(o,"bias","fused matMul"),[A]=Se(A,c),Ye(w,A.shape));let R;i!=null&&(R=C(i,"prelu weights","fused matMul"));let F=(V,z)=>{let[G,j,W,Y]=z,Z=Pu(U(V,W.shape),W,s),K,Q;if(!t&&!r?(K=je(Z,j,!1,!0),Q=je(G,Z,!0,!1)):!t&&r?(K=je(Z,j,!1,!1),Q=je(Z,G,!0,!1)):t&&!r?(K=je(j,Z,!1,!0),Q=je(G,Z,!1,!1)):(K=je(j,Z,!0,!0),Q=je(Z,G,!0,!0)),o!=null){let te=Lu(Y,Z);return[K,Q,te]}else return[K,Q]},P={a:I,b:_,bias:A,preluActivationWeights:R},L={transposeA:t,transposeB:r,activation:s,leakyreluAlpha:a};return o==null?bn((z,G,j)=>{let W=N.runKernel(aa,P,L);return j([z,G,W]),{value:U(W,w),gradFunc:F}})(I,_):bn((z,G,j,W)=>{let Y=N.runKernel(aa,P,L);return W([z,G,Y,j]),{value:U(Y,w),gradFunc:F}})(I,_,A)}var R$,F$=D(()=>{"use strict";B();Fs();H();vt();$();q();Ut();Xt();Ed();Is();O();Ne();R$=E({fusedMatMul_:tte})});var jy={};He(jy,{conv2d:()=>E$,depthwiseConv2d:()=>_$,matMul:()=>R$});var O$=D(()=>{"use strict";T$();A$();F$();});function nte(e){return Id(e,.54,.46)}var M$,$$=D(()=>{"use strict";O();vh();M$=E({hammingWindow_:nte})});function rte(e){return Id(e,.5,.5)}var qy,SN=D(()=>{"use strict";O();vh();qy=E({hannWindow_:rte})});function ote(e,n,t,r=!1,o=0){let s=0,i=[];for(;s+n<=e.size;)i.push(Ue(e,s,n)),s+=t;if(r)for(;s<e.size;){let a=s+n-e.size,c=ut([Ue(e,s,n-a),po([a],o)]);i.push(c),s+=t}return i.length===0?Ps([],[0,n]):U(ut(i),[i.length,n])}var Ky,NN=D(()=>{"use strict";lo();dd();O();Ne();Br();Uy();Ky=E({frame_:ote})});function ste(e,n,t,r,o=qy){r==null&&(r=Wy(n));let s=Ky(e,n,t),i=ee(s,o(n));return Ou(i,r)}var P$,L$=D(()=>{"use strict";bt();O();vh();By();NN();SN();P$=E({stft_:ste})});function ite(e,n,t,r,o="bilinear",s=0){let i=C(e,"image","cropAndResize"),a=C(n,"boxes","cropAndResize","float32"),c=C(t,"boxInd","cropAndResize","int32"),l=a.shape[0];k(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),k(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),k(c.rank===1&&c.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),k(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),k(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),k(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let u={image:i,boxes:a,boxInd:c},p={method:o,extrapolationValue:s,cropSize:r};return N.runKernel(Wc,u,p)}var B$,V$=D(()=>{"use strict";B();H();$();q();O();B$=E({cropAndResize_:ite})});function ate(e){let n=C(e,"image","flipLeftRight","float32");k(n.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${n.rank}.`);let t={image:n};return N.runKernel(sl,t,{})}var U$,z$=D(()=>{"use strict";B();H();$();q();O();U$=E({flipLeftRight_:ate})});function cte(e){let n=C(e,"image","grayscaleToRGB"),t=n.rank-1,r=n.shape[t];k(n.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${n.rank}.`),k(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let o=new Array(n.rank);return o.fill(1,0,t),o[t]=3,As(n,o)}var G$,H$=D(()=>{"use strict";$();q();O();by();G$=E({grayscaleToRGB_:cte})});function lte(e){let n=C(e,"image","RGBToGrayscale"),t=n.rank-1,r=n.shape[t];k(n.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${n.rank}.`),k(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let o=n.dtype,s=_e(n,"float32"),i=Qt([.2989,.587,.114]),a;switch(n.rank){case 2:a=Ds("ij,j->i",s,i);break;case 3:a=Ds("ijk,k->ij",s,i);break;case 4:a=Ds("ijkl,l->ijk",s,i);break;case 5:a=Ds("ijklm,m->ijkl",s,i);break;case 6:a=Ds("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return a=Vr(a,-1),_e(a,o)}var W$,j$=D(()=>{"use strict";$();q();dn();NT();vy();O();Ea();W$=E({rgbToGrayscale_:lte})});function ute(e,n,t=0,r=.5){let o=C(e,"image","rotateWithOffset","float32");k(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:n,fillValue:t,center:r};return N.runKernel(du,s,i)}var q$,K$=D(()=>{"use strict";B();H();$();q();O();q$=E({rotateWithOffset_:ute})});function Ur(e,n,t,r,o,s){r==null&&(r=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return t=Math.min(t,i),k(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),k(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),k(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),k(n.rank===1,()=>"scores must be a 1D tensor"),k(n.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${n.shape[0]}`),k(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:o,softNmsSigma:s}}var Uu=D(()=>{"use strict";q();});function pte(e,n,t,r=.5,o=Number.NEGATIVE_INFINITY){let s=C(e,"boxes","nonMaxSuppression","float32"),i=C(n,"scores","nonMaxSuppression","float32"),a=Ur(s,i,t,r,o);t=a.maxOutputSize,r=a.iouThreshold,o=a.scoreThreshold;let c={maxOutputSize:t,iouThreshold:r,scoreThreshold:o};return N.runKernel(Cl,{boxes:s,scores:i},c)}var X$,Y$=D(()=>{"use strict";B();H();$();Uu();O();X$=E({nonMaxSuppression_:pte})});function Z$(e,n,t){let r=dte(e,n,t),o=r<0?-(r+1):r;e.splice(o,0,n)}function dte(e,n,t){return mte(e,n,t||fte)}function fte(e,n){return e>n?1:e<n?-1:0}function mte(e,n,t){let r=0,o=e.length,s=0,i=!1;for(;r<o;){s=r+(o-r>>>1);let a=t(n,e[s]);a>0?r=s+1:(o=s,i=!a)}return i?r:-r-1}var Q$=D(()=>{"use strict";});function Xy(e,n,t,r,o){return DN(e,n,t,r,o,0)}function Yy(e,n,t,r,o,s){return DN(e,n,t,r,o,0,!1,s,!0)}function Zy(e,n,t,r,o,s){return DN(e,n,t,r,o,s,!0)}function DN(e,n,t,r,o,s,i=!1,a=!1,c=!1){let l=[];for(let g=0;g<n.length;g++)n[g]>o&&l.push({score:n[g],boxIndex:g,suppressBeginIndex:0});l.sort(J$);let u=s>0?-.5/s:0,p=[],d=[];for(;p.length<t&&l.length>0;){let g=l.pop(),{score:x,boxIndex:v,suppressBeginIndex:w}=g;if(x<o)break;let I=!1;for(let _=p.length-1;_>=w;--_){let A=hte(e,v,p[_]);if(A>=r){I=!0;break}if(g.score=g.score*gte(r,u,A),g.score<=o)break}g.suppressBeginIndex=p.length,I||(g.score===x?(p.push(v),d.push(g.score)):g.score>o&&Z$(l,g,J$))}let f=p.length,m=t-f;a&&m>0&&(p.push(...new Array(m).fill(0)),d.push(...new Array(m).fill(0)));let h={selectedIndices:p};return i&&(h.selectedScores=d),c&&(h.validOutputs=f),h}function hte(e,n,t){let r=e.subarray(n*4,n*4+4),o=e.subarray(t*4,t*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),l=Math.min(o[0],o[2]),u=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),d=Math.max(o[1],o[3]),f=(a-s)*(c-i),m=(p-l)*(d-u);if(f<=0||m<=0)return 0;let h=Math.max(s,l),g=Math.max(i,u),x=Math.min(a,p),v=Math.min(c,d),w=Math.max(x-h,0)*Math.max(v-g,0);return w/(f+m-w)}function gte(e,n,t){let r=Math.exp(n*t*t);return t<=e?r:0}function J$(e,n){return e.score-n.score||e.score===n.score&&n.boxIndex-e.boxIndex}var bh=D(()=>{"use strict";Q$();});async function xte(e,n,t,r=.5,o=Number.NEGATIVE_INFINITY){let s=C(e,"boxes","nonMaxSuppressionAsync"),i=C(n,"scores","nonMaxSuppressionAsync"),a=Ur(s,i,t,r,o);t=a.maxOutputSize,r=a.iouThreshold,o=a.scoreThreshold;let c=await Promise.all([s.data(),i.data()]),l=c[0],u=c[1],{selectedIndices:p}=Xy(l,u,t,r,o);return s!==e&&s.dispose(),i!==n&&i.dispose(),Qt(p,"int32")}var eP,tP=D(()=>{"use strict";bh();$();Uu();Ea();eP=xte});function yte(e,n,t,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(e,"boxes","nonMaxSuppression"),a=C(n,"scores","nonMaxSuppression"),c=Ur(i,a,t,r,o,s);t=c.maxOutputSize,r=c.iouThreshold,o=c.scoreThreshold,s=c.softNmsSigma;let l={boxes:i,scores:a},u={maxOutputSize:t,iouThreshold:r,scoreThreshold:o,softNmsSigma:s},p=N.runKernel(Il,l,u);return{selectedIndices:p[0],selectedScores:p[1]}}var nP,rP=D(()=>{"use strict";B();H();$();Uu();O();nP=E({nonMaxSuppressionWithScore_:yte})});async function vte(e,n,t,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(e,"boxes","nonMaxSuppressionAsync"),a=C(n,"scores","nonMaxSuppressionAsync"),c=Ur(i,a,t,r,o,s);t=c.maxOutputSize,r=c.iouThreshold,o=c.scoreThreshold,s=c.softNmsSigma;let l=await Promise.all([i.data(),a.data()]),u=l[0],p=l[1],{selectedIndices:d,selectedScores:f}=Zy(u,p,t,r,o,s);return i!==e&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:Qt(d,"int32"),selectedScores:Qt(f)}}var oP,sP=D(()=>{"use strict";bh();$();Uu();Ea();oP=vte});function bte(e,n,t,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(e,"boxes","nonMaxSuppression"),a=C(n,"scores","nonMaxSuppression"),c=Ur(i,a,t,r,o,null),l=c.maxOutputSize,u=c.iouThreshold,p=c.scoreThreshold,d={boxes:i,scores:a},f={maxOutputSize:l,iouThreshold:u,scoreThreshold:p,padToMaxOutputSize:s},m=N.runKernel(wl,d,f);return{selectedIndices:m[0],validOutputs:m[1]}}var iP,aP=D(()=>{"use strict";B();H();$();Uu();O();iP=E({nonMaxSuppressionPadded_:bte})});async function Cte(e,n,t,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(e,"boxes","nonMaxSuppressionAsync"),a=C(n,"scores","nonMaxSuppressionAsync"),c=Ur(i,a,t,r,o,null),l=c.maxOutputSize,u=c.iouThreshold,p=c.scoreThreshold,[d,f]=await Promise.all([i.data(),a.data()]),{selectedIndices:m,validOutputs:h}=Yy(d,f,l,u,p,s);return i!==e&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:Qt(m,"int32"),validOutputs:me(h,"int32")}}var cP,lP=D(()=>{"use strict";bh();$();Uu();vn();Ea();cP=Cte});function wte(e,n,t=!1,r=!1){let o=C(e,"images","resizeBilinear");k(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),k(n.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${n}.`),k(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=U(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=n,a={images:s},c={alignCorners:t,halfPixelCenters:r,size:n},l=N.runKernel(Ll,a,c);return i?U(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var uP,pP=D(()=>{"use strict";B();H();$();q();O();Ne();uP=E({resizeBilinear_:wte})});function Ite(e,n,t=!1,r=!1){let o=C(e,"images","resizeNearestNeighbor");k(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),k(n.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${n}.`),k(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),k(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=U(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=n,a={images:s},c={alignCorners:t,halfPixelCenters:r,size:n},l=N.runKernel(Pl,a,c);return i?U(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var dP,fP=D(()=>{"use strict";B();H();$();q();O();Ne();dP=E({resizeNearestNeighbor_:Ite})});function Ete(e,n="binary",t=!1,r=.5){let o=C(e,"image","threshold"),s=.2989,i=.587,a=.114,c=o.shape[0]*o.shape[1],l=ee(Qt([r]),255),u,p,d,f;if(k(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),k(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),k(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),k(n==="otsu"||n==="binary",()=>`Method must be binary or otsu, but was ${n}`),o.shape[2]===3){[u,p,d]=jo(o,[1,1,1],-1);let g=ee(u,s),x=ee(p,i),v=ee(d,a);f=de(de(g,x),v)}else f=e;if(n==="otsu"){let g=Fm(_e(lh(f),"int32"),xn([]),256);l=Tte(g,c)}let m=t?Du(f,l):va(f,l);return _e(ee(m,255),"int32")}function Tte(e,n){let t=Qt([-1]),r=Qt([0]),o=Qt([0]),s,i,a,c,l,u;for(let p=0;p<e.size-1;p++){s=Ue(e,0,p+1),i=Ue(e,p+1),l=Ve(Ze(s),n),u=Ve(Ze(i),n);let d=Ze(ee(s,Ms(0,s.size)));a=Ve(d,Ze(s));let f=po(i.shape,s.size),m=de(Ms(0,i.size),f),h=ee(i,m);c=Ve(Ze(h),Ze(i));let g=ge(a,c),x=ge(a,c),v=ee(l,u);o=ee(ee(v,g),x);let w=va(o,r);r=or(w,o,r),t=or(w,Qt([p]),t)}return t}var mP,hP=D(()=>{"use strict";Ea();O();dn();ph();tT();wy();Cy();ho();Ut();bt();Un();Zt();KS();fd();dd();Br();$y();wm();q();$();mP=E({threshold_:Ete})});function Ste(e,n,t="nearest",r="constant",o=0,s){let i=C(e,"image","transform","float32"),a=C(n,"transforms","transform","float32");k(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),k(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),k(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let c={image:i,transforms:a},l={interpolation:t,fillMode:r,fillValue:o,outputShape:s};return N.runKernel(au,c,l)}var gP,xP=D(()=>{"use strict";B();H();$();q();O();gP=E({transform_:Ste})});function Nte(e,n,t){let r=C(e,"a","bandPart");k(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let o=r.shape,[s,i]=r.shape.slice(-2),a,c;typeof n=="number"?(k(n%1===0,()=>`bandPart(): numLower must be an integer, got ${n}.`),k(n<=s,()=>`bandPart(): numLower (${n}) must not be greater than the number of rows (${s}).`),a=C(n<0?s:n,"numLower","bandPart")):(k(n.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=or(yd(n,0),s,wa(n,s))),typeof t=="number"?(k(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),k(t<=i,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`),c=C(t<0?i:t,"numUpper","bandPart")):(k(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),c=or(yd(t,0),i,wa(t,i)));let l=U(Ms(0,s,1,"int32"),[-1,1]),u=Ms(0,i,1,"int32"),p=ge(l,u),d=ba(Du(p,a),Gm(p,on(c))),f=Nr([s,i],r.dtype);return U(Cn(ir(U(r,[-1,s,i])).map(m=>or(d,m,f))),o)}var yP,vP=D(()=>{"use strict";$();q();LT();GT();wy();Ty();_y();Os();O();$y();Ne();fh();Zt();zy();fd();eh();yP=E({bandPart_:Nte})});function Dte(e){let n;if(Array.isArray(e)){n=!1,k(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=e[0].shape[0];for(let s=1;s<e.length;++s)k(e[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${o})`)}else n=!0,e=jo(e,e.shape[0],0).map(o=>Mu(o,[0]));k(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let t=[],r=e;for(let o=0;o<e.length;++o)t.push(N.tidy(()=>{let s=r[o];if(o>0)for(let i=0;i<o;++i){let a=ee(Ze(ee(t[i],s)),t[i]);s=ge(s,a)}return Ve(s,ya(s,"euclidean"))}));return n?Cn(t,0):t}var bP,CP=D(()=>{"use strict";B();q();Un();bt();Bm();O();ph();Vy();fh();Zt();ho();bP=E({gramSchmidt_:Dte})});function kte(e,n=!1){if(k(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return wP(e,n);{let t=e.shape.slice(0,e.shape.length-2).reduce((c,l)=>c*l),r=ir(U(e,[t,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),o=[],s=[];r.forEach(c=>{let[l,u]=wP(c,n);o.push(l),s.push(u)});let i=U(Cn(o,0),e.shape),a=U(Cn(s,0),e.shape);return[i,a]}}function wP(e,n=!1){return N.tidy(()=>{k(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let t=e.shape[0],r=e.shape[1],o=Vm(t),s=Vn(e),i=Ps([[1]],[1,1]),a=Vn(i),c=t>=r?r:t;for(let l=0;l<c;++l){let u=s,p=a,d=o;[a,s,o]=N.tidy(()=>{let f=Ue(s,[l,l],[t-l,1]),m=ya(f),h=Ue(s,[l,l],[1,1]),g=or(va(h,0),Ps([[-1]]),Ps([[1]])),x=ge(h,ee(g,m)),v=Ve(f,x);v.shape[0]===1?a=Vn(i):a=ut([i,Ue(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);let w=on(Ve(je(g,x),m)),I=Ue(s,[l,0],[t-l,r]),_=ee(w,a),A=$u(a);if(l===0)s=ge(I,je(_,je(A,I)));else{let P=ge(I,je(_,je(A,I)));s=ut([Ue(s,[0,0],[l,r]),P],0)}let R=$u(_),F=Ue(o,[0,l],[t,o.shape[1]-l]);if(l===0)o=ge(F,je(je(F,a),R));else{let P=ge(F,je(je(F,a),R));o=ut([Ue(o,[0,0],[t,l]),P],1)}return[a,s,o]}),Nt([u,p,d])}return!n&&t>r&&(o=Ue(o,[0,0],[t,r]),s=Ue(s,[0,0],[r,r])),[o,s]})}var IP,EP=D(()=>{"use strict";B();rr();q();ld();lo();Un();MT();Cy();Is();bt();Os();Bm();O();Ne();Br();fh();Zt();Uy();Hy();zy();fd();IP=E({qr_:kte})});var Dt,yo=D(()=>{"use strict";Dt=(function(e){return e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",e})(Dt||{})});function _te(e,n,t=Dt.SUM_BY_NONZERO_WEIGHTS){let r=C(e,"losses","computeWeightedLoss"),o=null;n!=null&&(o=C(n,"weights","computeWeightedLoss"));let s=o==null?r:ee(r,o);if(t===Dt.NONE)return s;if(t===Dt.SUM)return Ze(s);if(t===Dt.MEAN){if(o==null)return Ca(s);{let i=r.size/o.size,a=Ve(Ze(s),Ze(o));return i>1?Ve(a,me(i)):a}}if(t===Dt.SUM_BY_NONZERO_WEIGHTS){if(o==null)return Ve(Ze(s),me(r.size));{let i=ee(o,go(r.shape)),a=_e(Ze(th(i,me(0))),"float32");return Ve(Ze(s),a)}}throw Error(`Unknown reduction: ${t}`)}var fn,qo=D(()=>{"use strict";$();dn();Un();yo();Dy();bt();pS();ky();O();vn();ho();fn=E({computeWeightedLoss_:_te})});function Ate(e,n,t,r=Dt.SUM_BY_NONZERO_WEIGHTS){let o=C(e,"labels","absoluteDifference"),s=C(n,"predictions","absoluteDifference"),i=null;t!=null&&(i=C(t,"weights","absoluteDifference")),dt(o.shape,s.shape,"Error in absoluteDifference: ");let a=Kt(ge(o,s));return fn(a,i,r)}var TP,SP=D(()=>{"use strict";$();q();Eu();yo();O();Zt();qo();TP=E({absoluteDifference_:Ate})});function Rte(e,n,t,r,o=Dt.SUM_BY_NONZERO_WEIGHTS){let s=C(e,"labels","cosineDistance"),i=C(n,"predictions","cosineDistance"),a=null;r!=null&&(a=C(r,"weights","cosineDistance")),dt(s.shape,i.shape,"Error in cosineDistance: ");let c=me(1),l=ge(c,Ze(ee(s,i),t,!0));return fn(l,a,o)}var NP,DP=D(()=>{"use strict";$();q();yo();bt();O();vn();Zt();ho();qo();NP=E({cosineDistance_:Rte})});function Fte(e,n,t,r=Dt.SUM_BY_NONZERO_WEIGHTS){let o=C(e,"labels","hingeLoss"),s=C(n,"predictions","hingeLoss"),i=null;t!=null&&(i=C(t,"weights","hingeLoss")),dt(o.shape,s.shape,"Error in hingeLoss: ");let a=me(1);o=ge(ee(me(2),o),a);let c=$s(ge(a,ee(o,s)));return fn(c,i,r)}var kP,_P=D(()=>{"use strict";$();q();yo();bt();O();ah();vn();Zt();qo();kP=E({hingeLoss_:Fte})});function Ote(e,n,t,r=1,o=Dt.SUM_BY_NONZERO_WEIGHTS){let s=C(e,"labels","huberLoss"),i=C(n,"predictions","huberLoss"),a=null;t!=null&&(a=C(t,"weights","huberLoss")),dt(s.shape,i.shape,"Error in huberLoss: ");let c=me(r),l=Kt(ge(i,s)),u=wa(l,c),p=ge(l,u),d=de(ee(me(.5),Yt(u)),ee(c,p));return fn(d,a,o)}var AP,RP=D(()=>{"use strict";$();q();Eu();Ut();yo();_y();bt();O();vn();_s();Zt();qo();AP=E({huberLoss_:Ote})});function Mte(e,n,t,r=1e-7,o=Dt.SUM_BY_NONZERO_WEIGHTS){let s=C(e,"labels","logLoss"),i=C(n,"predictions","logLoss"),a=null;t!=null&&(a=C(t,"weights","logLoss")),dt(s.shape,i.shape,"Error in logLoss: ");let c=me(1),l=me(r),u=on(ee(s,Ho(de(i,l)))),p=ee(ge(c,s),Ho(de(ge(c,i),l))),d=ge(u,p);return fn(d,a,o)}var FP,OP=D(()=>{"use strict";$();q();Ut();jm();yo();bt();Os();O();vn();Zt();qo();FP=E({logLoss_:Mte})});function $te(e,n,t,r=Dt.SUM_BY_NONZERO_WEIGHTS){let o=C(e,"labels","meanSquaredError"),s=C(n,"predictions","meanSquaredError"),i=null;t!=null&&(i=C(t,"weights","meanSquaredError")),dt(o.shape,s.shape,"Error in meanSquaredError: ");let a=dh(o,s);return fn(a,i,r)}var MP,$P=D(()=>{"use strict";$();q();yo();O();cN();qo();MP=E({meanSquaredError_:$te})});function Pte(e,n){let t=C(e,"labels","sigmoidCrossEntropyWithLogits"),r=C(n,"logits","sigmoidCrossEntropyWithLogits");dt(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=$s(r),s=ee(r,t),i=qm(Sr(on(Kt(r))));return de(ge(o,s),i)}function Lte(e,n,t,r=0,o=Dt.SUM_BY_NONZERO_WEIGHTS){let s=C(e,"multiClassLabels","sigmoidCrossEntropy"),i=C(n,"logits","sigmoidCrossEntropy"),a=null;if(t!=null&&(a=C(t,"weights","sigmoidCrossEntropy")),dt(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let l=me(r),u=me(1),p=me(.5);s=de(ee(s,ge(u,l)),ee(p,l))}let c=Pte(s,i);return fn(c,a,o)}var PP,LP=D(()=>{"use strict";$();q();Eu();Ut();xd();jT();yo();bt();Os();O();ah();vn();Zt();qo();PP=E({sigmoidCrossEntropy_:Lte})});function Bte(e,n,t=-1){if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${n.rank} and dim was ${t}`);return bn((o,s,i)=>{let c=Xm(s,[t],!0),l=ge(_e(s,"float32"),c);i([o,l]);let u=on(ee(l,o));return{value:Ze(u,[t]),gradFunc:(f,m)=>{let[h,g]=m,x=ks(f.shape,[t]);return[ee(U(f,x),ge(_e(h,"float32"),Sr(g))),ee(U(f,x),ge(Sr(g),_e(h,"float32")))]}}})(e,n)}function Vte(e,n,t,r=0,o=Dt.SUM_BY_NONZERO_WEIGHTS){let s=C(e,"onehotLabels","softmaxCrossEntropy"),i=C(n,"logits","softmaxCrossEntropy"),a=null;if(t!=null&&(a=C(t,"weights","softmaxCrossEntropy")),dt(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let l=me(r),u=me(1),p=me(s.shape[1]);s=de(ee(s,ge(u,l)),Ve(l,p))}let c=Bte(s,i);return fn(c,a,o)}var BP,VP=D(()=>{"use strict";Fs();$();q();Ut();md();dn();Un();xd();YT();yo();bt();Os();O();Ne();vn();Zt();ho();qo();BP=E({softmaxCrossEntropy_:Vte})});function Ute(e,n,t,r){let o=C(e,"indices","sparseFillEmptyRows","int32"),s=C(n,"values","sparseFillEmptyRows"),i=C(t,"denseShape","sparseFillEmptyRows","int32"),a=C(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let c={indices:o,values:s,denseShape:i,defaultValue:a},l=N.runKernel(Xl,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var UP,zP=D(()=>{"use strict";B();H();$();O();UP=E({sparseFillEmptyRows_:Ute})});function zte(e,n,t){let r=C(e,"inputIndices","sparseReshape","int32"),o=C(n,"inputShape","sparseReshape","int32"),s=C(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:o,newShape:s},a=N.runKernel(Yl,i);return{outputIndices:a[0],outputShape:a[1]}}var GP,HP=D(()=>{"use strict";B();H();$();O();GP=E({sparseReshape_:zte})});function Gte(e,n,t){let r=C(e,"data","sparseSegmentMean"),o=C(n,"indices","sparseSegmentMean","int32"),s=C(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return N.runKernel(Zl,i)}var WP,jP=D(()=>{"use strict";B();H();$();O();WP=E({sparseSegmentMean_:Gte})});function Hte(e,n,t){let r=C(e,"data","sparseSegmentSum"),o=C(n,"indices","sparseSegmentSum","int32"),s=C(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return N.runKernel(Ql,i)}var qP,KP=D(()=>{"use strict";B();H();$();O();qP=E({sparseSegmentSum_:Hte})});function Wte(e,n,t,r,o,s,i,a){let c=C(e,"data","stringNGrams","string");if(c.dtype!=="string")throw new Error("Data must be of datatype string");if(c.shape.length!==1)throw new Error(`Data must be a vector, saw: ${c.shape}`);let l=C(n,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let u={separator:t,nGramWidths:r,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:c,dataSplits:l},d=N.runKernel(tu,p,u);return{nGrams:d[0],nGramsSplits:d[1]}}var XP,YP=D(()=>{"use strict";B();H();$();O();XP=E({stringNGrams_:Wte})});function jte(e,n,t=!0){let r=C(e,"input","stringSplit","string"),o=C(n,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:t},i={input:r,delimiter:o},a=N.runKernel(nu,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var ZP,QP=D(()=>{"use strict";B();H();$();O();ZP=E({stringSplit_:jte})});function qte(e,n){let t=C(e,"input","stringToHashBucketFast","string"),r={numBuckets:n};if(n<=0)throw new Error("Number of buckets must be at least 1");let o={input:t};return N.runKernel(ru,o,r)}var JP,eL=D(()=>{"use strict";B();H();$();O();JP=E({stringToHashBucketFast_:qte})});function Kte(e,n,t,r=!0){let o=C(e,"input","staticRegexReplace","string"),s={pattern:n,rewrite:t,replaceGlobal:r};return N.runKernel(oa,{x:o},s)}var tL,nL=D(()=>{"use strict";B();H();$();O();tL=E({staticRegexReplace_:Kte})});var rL,oL,sL,iL,aL,cL,lL,Ch=D(()=>{"use strict";Eu();kF();_F();Ut();AF();RF();FF();OF();MF();$F();PF();LF();BF();VF();qE();GF();HF();ZE();Rm();qF();KF();XF();tT();YF();ZF();oT();ws();dn();QF();JF();ld();fa();lo();eO();tO();nO();rO();oO();Om();sO();iO();lO();uO();pO();dO();fO();mO();hO();xy();gO();xO();Un();vO();bO();NT();DT();CO();ET();wO();TO();xd();vy();SO();MT();dd();$T();AE();PT();Cy();LT();Hm();NO();DO();kO();zT();GT();wy();_O();AO();jm();jT();$O();PO();YT();Ty();ZT();QT();LO();BO();Is();Pm();tS();VO();UO();oS();Dy();zO();RT();_y();GO();HO();WO();bt();jO();qO();Os();pS();dS();ky();KO();XO();Cd();YO();ZO();QO();JO();eM();Lm();CS();_E();tM();nM();rM();oM();sM();TM();BS();SM();My();NM();$y();ih();DM();ah();GS();Ne();Ru();kM();_M();AM();RM();KS();FM();vn();OM();MM();$M();_m();PM();LM();BM();Br();VM();UM();zM();GM();HM();qT();vS();Py();Ly();aN();By();ph();gd();_s();cN();Vy();fh();lN();WM();Zt();ho();jM();XE();wm();Ea();Uy();dN();qM();KM();XM();ZM();by();QM();JM();e$();t$();zy();n$();r$();fd();TN();eh();Ns();s$();Hy();Bm();a$();l$();Ny();f$();h$();v$();vh();C$();O();By();Py();Ly();aN();O$();$$();SN();NN();L$();V$();z$();H$();j$();K$();Y$();tP();rP();sP();aP();lP();pP();fP();hP();xP();vP();CP();EP();SP();qo();DP();_P();RP();OP();$P();LP();VP();zP();HP();jP();KP();YP();QP();eL();nL();rL={fft:Fu,ifft:Ia,rfft:Ou,irfft:uh},oL={hammingWindow:M$,hannWindow:qy,frame:Ky,stft:P$},sL={flipLeftRight:U$,grayscaleToRGB:G$,resizeNearestNeighbor:dP,resizeBilinear:uP,rgbToGrayscale:W$,rotateWithOffset:q$,cropAndResize:B$,nonMaxSuppression:X$,nonMaxSuppressionAsync:eP,nonMaxSuppressionWithScore:nP,nonMaxSuppressionWithScoreAsync:oP,nonMaxSuppressionPadded:iP,nonMaxSuppressionPaddedAsync:cP,threshold:mP,transform:gP},iL={bandPart:yP,gramSchmidt:bP,qr:IP},aL={absoluteDifference:TP,computeWeightedLoss:fn,cosineDistance:NP,hingeLoss:kP,huberLoss:AP,logLoss:FP,meanSquaredError:MP,sigmoidCrossEntropy:PP,softmaxCrossEntropy:BP},cL={sparseFillEmptyRows:UP,sparseReshape:GP,sparseSegmentMean:WP,sparseSegmentSum:qP},lL={stringNGrams:XP,stringSplit:ZP,stringToHashBucketFast:JP,staticRegexReplace:tL}});var AN={};He(AN,{Serializable:()=>wh,SerializationMap:()=>Qy,getRegisteredName:()=>Yte,registerClass:()=>_N});function _N(e,n,t){k(e.className!=null,()=>"Class being registered does not have the static className property defined."),k(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),k(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof n>"u"&&(n="Custom"),typeof t>"u"&&(t=e.className);let r=t,o=n+">"+r;return Qy.register(e),Xte.set(o,e),kN.set(e,o),e}function Yte(e){return kN.has(e)?kN.get(e):e.className}var Xte,kN,wh,Qy,Jy=D(()=>{"use strict";q();Xte=new Map,kN=new Map,wh=class{getClassName(){return this.constructor.className}static fromConfig(n,t){return new n(t)}},Qy=class e{constructor(){this.classNameMap={}}static getMap(){return e.instance==null&&(e.instance=new e),e.instance}static register(n){e.getMap().classNameMap[n.className]=[n,n.fromConfig]}}});var wn,Ta=D(()=>{"use strict";rr();Fs();Ch();Jy();wn=class extends wh{minimize(n,t=!1,r){let{value:o,grads:s}=this.computeGradients(n,r);if(r!=null){let i=r.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return Nt(s),t?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(n,t){return Iy(n,t)}dispose(){this.iterations_!=null&&Nt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:me(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(n){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(n){return this.iterations_=(await n[0].tensor.data())[0],n.slice(1)}};Object.defineProperty(wn,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null})});var Sa,ev=D(()=>{"use strict";B();rr();Ut();Un();bt();Ch();_s();Ns();Ta();Sa=class extends wn{static get className(){return"Adadelta"}constructor(n,t,r=null){super(),this.learningRate=n,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=N.backend.epsilon())}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=N.registeredVariables[r],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accum_grad`,variable:Ce(()=>Bt(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${r}/accum_var`,variable:Ce(()=>Bt(s).variable(i))});let a=Array.isArray(n)?n[o].tensor:n[r];if(a==null)return;let c=this.accumulatedGrads[o].variable,l=this.accumulatedUpdates[o].variable;Ce(()=>{let u=de(ee(c,this.rho),ee(Yt(a),1-this.rho)),p=ee(Ve(On(de(l,this.epsilon)),On(de(c,this.epsilon))),a),d=de(ee(l,this.rho),ee(Yt(p),1-this.rho));c.assign(u),l.assign(d);let f=de(ee(p,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Nt(this.accumulatedGrads.map(n=>n.variable)),Nt(this.accumulatedUpdates.map(n=>n.variable)))}async getWeights(){let n=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(n.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(n){n=await this.extractIterations(n);let t=n.length/2,r=!1;this.accumulatedGrads=n.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedUpdates=n.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(n,t){return new n(t.learningRate,t.rho,t.epsilon)}}});var Na,tv=D(()=>{"use strict";B();rr();Ut();Un();dd();bt();gd();_s();Ta();Na=class extends wn{static get className(){return"Adagrad"}constructor(n,t=.1){super(),this.learningRate=n,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=N.registeredVariables[r];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accumulator`,variable:Ce(()=>po(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(n)?n[o].tensor:n[r];if(i==null)return;let a=this.accumulatedGrads[o].variable;Ce(()=>{let c=de(a,Yt(i));a.assign(c);let l=de(ee(Ve(i,On(de(c,N.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Nt(this.accumulatedGrads.map(n=>n.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(n){n=await this.extractIterations(n);let t=!1;this.accumulatedGrads=n.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(n,t){return new n(t.learningRate,t.initialAccumulatorValue)}}});var Da,nv=D(()=>{"use strict";B();rr();Ut();Un();bt();Lm();vn();gd();_s();Zt();Ns();Ta();Da=class extends wn{static get className(){return"Adam"}constructor(n,t,r,o=null){super(),this.learningRate=n,this.beta1=t,this.beta2=r,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ce(()=>{this.accBeta1=me(t).variable(),this.accBeta2=me(r).variable()}),o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(n){let t=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);Ce(()=>{let r=ge(1,this.accBeta1),o=ge(1,this.accBeta2);t.forEach((s,i)=>{let a=N.registeredVariables[s],c=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:Ce(()=>Bt(a).variable(c))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:Ce(()=>Bt(a).variable(c))});let l=Array.isArray(n)?n[i].tensor:n[s];if(l==null)return;let u=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,d=de(ee(u,this.beta1),ee(l,1-this.beta1)),f=de(ee(p,this.beta2),ee(Yt(l),1-this.beta2)),m=Ve(d,r),h=Ve(f,o);u.assign(d),p.assign(f);let g=de(ee(Ve(m,de(On(h),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(ee(this.accBeta1,this.beta1)),this.accBeta2.assign(ee(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Nt(this.accumulatedFirstMoment.map(n=>n.variable)),this.accumulatedSecondMoment!=null&&Nt(this.accumulatedSecondMoment.map(n=>n.variable))}async getWeights(){let n=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(n.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(n){n=await this.extractIterations(n),Ce(()=>{this.accBeta1.assign(Go(this.beta1,this.iterations_+1)),this.accBeta2.assign(Go(this.beta2,this.iterations_+1))});let t=n.length/2,r=!1;this.accumulatedFirstMoment=n.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedSecondMoment=n.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(n,t){return new n(t.learningRate,t.beta1,t.beta2,t.epsilon)}}});var ka,rv=D(()=>{"use strict";B();rr();Eu();Ut();Un();oS();bt();vn();Zt();Ns();Ta();ka=class extends wn{static get className(){return"Adamax"}constructor(n,t,r,o=null,s=0){super(),this.learningRate=n,this.beta1=t,this.beta2=r,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ce(()=>{this.iteration=me(0).variable(),this.accBeta1=me(t).variable()}),o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(n){let t=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);Ce(()=>{let r=ge(1,this.accBeta1),o=Ve(-this.learningRate,de(ee(this.iteration,this.decay),1));t.forEach((s,i)=>{let a=N.registeredVariables[s],c=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:Bt(a).variable(c)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:Bt(a).variable(c)});let l=Array.isArray(n)?n[i].tensor:n[s];if(l==null)return;let u=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,d=de(ee(u,this.beta1),ee(l,1-this.beta1)),f=ee(p,this.beta2),m=Kt(l),h=Jm(f,m);u.assign(d),p.assign(h);let g=de(ee(Ve(o,r),Ve(d,de(h,this.epsilon))),a);a.assign(g)}),this.iteration.assign(de(this.iteration,1)),this.accBeta1.assign(ee(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Nt(this.accumulatedFirstMoment.map(n=>n.variable)),this.accumulatedWeightedInfNorm!=null&&Nt(this.accumulatedWeightedInfNorm.map(n=>n.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(n){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(n,t){return new n(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}});var Ko,Ih=D(()=>{"use strict";B();rr();Ut();bt();vn();Ta();Ko=class extends wn{static get className(){return"SGD"}constructor(n){super(),this.learningRate=n,this.setLearningRate(n)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=Array.isArray(n)?n[o].tensor:n[r];if(s==null)return;let i=N.registeredVariables[r];Ce(()=>{let a=de(ee(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(n){this.learningRate=n,this.c!=null&&this.c.dispose(),this.c=Fn(me(-n))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(n){if(n=await this.extractIterations(n),n.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(n,t){return new n(t.learningRate)}}});var _a,ov=D(()=>{"use strict";B();rr();Ut();bt();vn();Ns();Ih();_a=class extends Ko{static get className(){return"Momentum"}constructor(n,t,r=!1){super(n),this.learningRate=n,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=me(this.momentum)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=N.registeredVariables[r];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${r}/momentum`,variable:Ce(()=>Bt(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(n)?n[o].tensor:n[r];a!=null&&Ce(()=>{let c,l=de(ee(this.m,i),a);this.useNesterov?c=de(ee(this.c,de(a,ee(l,this.m))),s):c=de(ee(this.c,l),s),i.assign(l),s.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Nt(this.accumulations.map(n=>n.variable))}setMomentum(n){this.momentum=n}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(n){n=await this.extractIterations(n);let t=!1;this.accumulations=n.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(n,t){return new n(t.learningRate,t.momentum,t.useNesterov)}}});var Aa,sv=D(()=>{"use strict";B();rr();Ut();Un();bt();gd();_s();Zt();Ns();Ta();Aa=class extends wn{static get className(){return"RMSProp"}constructor(n,t=.9,r=0,o=null,s=!1){if(super(),this.learningRate=n,this.decay=t,this.momentum=r,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=N.backend.epsilon()),n==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=N.registeredVariables[r],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${r}/rms`,variable:Ce(()=>Bt(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${r}/momentum`,variable:Ce(()=>Bt(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${r}/mg`,variable:Ce(()=>Bt(s).variable(i))});let a=Array.isArray(n)?n[o].tensor:n[r];if(a==null)return;let c=this.accumulatedMeanSquares[o].variable,l=this.accumulatedMoments[o].variable;Ce(()=>{let u=de(ee(c,this.decay),ee(Yt(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,d=de(ee(p,this.decay),ee(a,1-this.decay)),f=Ve(ee(a,this.learningRate),On(ge(u,de(Yt(d),this.epsilon)))),m=de(ee(l,this.momentum),f);c.assign(u),p.assign(d),l.assign(m);let h=ge(s,m);s.assign(h)}else{let p=de(ee(c,this.decay),ee(Yt(a),1-this.decay)),d=de(ee(l,this.momentum),Ve(ee(a,this.learningRate),On(de(p,this.epsilon))));c.assign(p),l.assign(d);let f=ge(s,d);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Nt(this.accumulatedMeanSquares.map(n=>n.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Nt(this.accumulatedMeanGrads.map(n=>n.variable)),this.accumulatedMoments!=null&&Nt(this.accumulatedMoments.map(n=>n.variable))}async getWeights(){let n=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&n.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(n.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(n){n=await this.extractIterations(n);let t=this.centered?n.length/3:n.length/2,r=!1;this.accumulatedMeanSquares=n.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedMoments=n.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=n.slice(t*2,t*3).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(n,t){return new n(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}});function uL(){for(let e of Zte)_N(e)}var Zte,pL=D(()=>{"use strict";ev();tv();nv();rv();ov();sv();Ih();Jy();Zte=[Sa,Na,Da,ka,_a,Aa,Ko]});function dL(e){return new Promise(n=>setTimeout(n)).then(e)}function nne(e="model"){return new RN(e)}function fL(e){return new FN(e)}var Qte,Jte,ene,RN,FN,tne,mL=D(()=>{"use strict";od();nn();ga();vu();ma();Qte="model",Jte=".json",ene=".weights.bin";RN=(()=>{class e{constructor(t){if(!M().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),(t==null||t.length===0)&&(t=Qte),this.modelJsonFileName=t+Jte,this.weightDataFileName=t+ene}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let r=pn.join(t.weightData),o=window.URL.createObjectURL(new Blob([r],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],i=dy(t,s),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),c=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(c.download=this.modelJsonFileName,c.href=a,await dL(()=>c.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=o,await dL(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Vo(t)}}}}return e.URL_SCHEME="downloads://",e})(),FN=class{constructor(n){if(n==null||n.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${n}`);this.jsonFile=n[0],this.weightsFiles=n.slice(1)}async load(){return new Promise((n,t)=>{let r=new FileReader;r.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){n({modelTopology:i});return}let c=sd(s,l=>this.loadWeights(l));n(c)},r.onerror=o=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(n){let t=[],r=[];for(let i of n)t.push(...i.weights),r.push(...i.paths);let o=this.checkManifestAndWeightFiles(n),s=r.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[t,i])}loadWeightsFile(n,t){return new Promise((r,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;r(a)},s.onerror=i=>o(`Failed to weights data from file of path '${n}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(n){let t=[],r=this.weightsFiles.map(s=>vE(s.name)),o={};for(let s of n)s.paths.forEach(i=>{let a=vE(i);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},tne=e=>M().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(RN.URL_SCHEME)?nne(e.slice(RN.URL_SCHEME.length)):null;qt.registerSaveRouter(tne)});function ON(e,n,t,r){i(e),t=t??0,r=r??1,a(t,r);let o=0,s=c=>(c.then(l=>{let u=t+ ++o/e.length*(r-t);return n(u),l}),c);function i(c){k(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function a(c,l){k(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),k(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),k(l>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${l}`)}return Promise.all(e.map(s))}var hL=D(()=>{"use strict";q();});async function MN(e,n){n==null&&(n={});let t=n.fetchFunc==null?M().platform.fetch:n.fetchFunc,r=e.map(p=>t(p,n.requestInit,{isBinary:!0})),a=(n.onProgress==null?await Promise.all(r):await ON(r,n.onProgress,0,.5)).map(p=>p.arrayBuffer());return n.onProgress==null?await Promise.all(a):await ON(a,n.onProgress,.5,1)}function gL(e,n){var t;let r=n.fetchFunc==null?M().platform.fetch:n.fetchFunc,o=0,s;return(t=n.onProgress)===null||t===void 0||t.call(n,0),new ReadableStream({pull:async i=>{for(var a;o<e.length;){s||(s=(await r(e[o],n.requestInit,{isBinary:!0})).body.getReader());let{done:c,value:l}=await s.read();if(c){o++,s=void 0,(a=n.onProgress)===null||a===void 0||a.call(n,o/e.length);continue}i.enqueue(l);return}i.close()}})}async function xL(e,n="",t,r){return $N(i=>MN(i,{requestInit:r}))(e,n,t)}function $N(e){return async(n,t="",r)=>{let o=n.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],a=[];if(n.forEach((f,m)=>{let h=0;f.weights.forEach(g=>{let x="quantization"in g?g.quantization.dtype:g.dtype,v=bs[x]*ke(g.shape),w=()=>{o[m]=!0,s[m]==null&&(s[m]=[]),s[m].push({manifestEntry:g,groupOffset:h,sizeBytes:v})};r!=null?r.forEach((I,_)=>{I===g.name&&(w(),i[_]=!0)}):w(),a.push(g.name),h+=v})}),!i.every(f=>f)){let f=r.filter((m,h)=>!i[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let c=o.reduce((f,m,h)=>(m&&f.push(h),f),[]),l=[];c.forEach(f=>{n[f].paths.forEach(m=>{let h=t+(t.endsWith("/")?"":"/")+m;l.push(h)})});let u=await e(l),p={},d=0;return c.forEach(f=>{let m=n[f].paths.length,h=new pn(u.slice(d,d+m));s[f].forEach(x=>{let v=h.slice(x.groupOffset,x.groupOffset+x.sizeBytes),w=uy(v,[x.manifestEntry]);for(let I in w)p[I]=w[I]}),d+=m}),p}}var PN=D(()=>{"use strict";nn();q();ma();ga();hL();hE();});function sne(e){let n=e.lastIndexOf("/"),t=e.lastIndexOf("?"),r=e.substring(0,n),o=t>n?e.substring(t):"";return[r+"/",o]}function iv(e){return e.match(yL.URL_SCHEME_REGEX)!=null}function av(e,n){return new yL(e,n)}function bL(e,n){return av(e,n)}var rne,one,yL,vL,CL=D(()=>{"use strict";nn();q();ga();ma();vu();PN();rne="application/octet-stream",one="application/json",yL=(()=>{class e{constructor(t,r){if(this.DEFAULT_METHOD="POST",r==null&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,r.fetchFunc!=null?(k(typeof r.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=M().platform.fetch,k(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&k(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,r.requestInit!=null&&r.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let r=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);r.body=new FormData;let o=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],s=dy(t,o);if(r.body.append("model.json",new Blob([JSON.stringify(s)],{type:one}),"model.json"),t.weightData!=null){let a=pn.join(t.weightData);r.body.append("model.weights.bin",new Blob([a],{type:rne}),"model.weights.bin")}let i=await this.fetch(this.path,r);if(i.ok)return{modelArtifactsInfo:Vo(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let r;try{r=await t.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let o=r.modelTopology,s=r.weightsManifest;if(o==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return r}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let t=await this.loadModelJSON();return sd(t,r=>this.loadWeights(r))}async loadStream(){let t=await this.loadModelJSON(),r=await this.getWeightUrls(t.weightsManifest),o=Em(t.weightsManifest),s=()=>gL(r,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:o,getWeightStream:s})}async getWeightUrls(t){let r=Array.isArray(this.path)?this.path[1]:this.path,[o,s]=sne(r),i=this.weightPathPrefix||o,a=[],c=[];for(let l of t)for(let u of l.paths)this.weightUrlConverter!=null?c.push(this.weightUrlConverter(u)):a.push(i+u+s);return this.weightUrlConverter&&a.push(...await Promise.all(c)),a}async loadWeights(t){let r=await this.getWeightUrls(t),o=Em(t),s=await MN(r,this.loadOptions);return[o,s]}}return e.URL_SCHEME_REGEX=/^https?:\/\//,e})();vL=(e,n)=>{if(typeof fetch>"u"&&(n==null||n.fetchFunc==null))return null;{let t=!0;if(Array.isArray(e)?t=e.every(r=>iv(r)):t=iv(e),t)return av(e,n)}return null};qt.registerSaveRouter(vL);qt.registerLoadRouter(vL)});function wL(e,n,t,r){let o=arguments;return new LN(BN(...o))}function BN(e,n,t,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new Eh(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Eh({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Eh({modelTopology:e,weightSpecs:n,weightData:t,trainingConfig:r}))}function IL(e){return new cv(e)}function EL(e){return new cv(e)}var Eh,cv,LN,TL=D(()=>{"use strict";Eh=class{constructor(n){this.modelArtifacts=n}load(){return this.modelArtifacts}},cv=class{constructor(n){this.saveHandler=n}save(n){return this.saveHandler(n)}},LN=class{constructor(n){n.load&&(this.load=()=>Promise.resolve(n.load())),n.save&&(this.save=t=>Promise.resolve(n.save(t)))}}});var Xo={};He(Xo,{CompositeArrayBuffer:()=>pn,browserFiles:()=>fL,browserHTTPRequest:()=>bL,concatenateArrayBuffers:()=>aF,copyModel:()=>CF,decodeWeights:()=>uy,decodeWeightsStream:()=>py,encodeWeights:()=>rF,fromMemory:()=>wL,fromMemorySync:()=>BN,getLoadHandlers:()=>pF,getModelArtifactsForJSON:()=>sd,getModelArtifactsForJSONSync:()=>bE,getModelArtifactsInfoForJSON:()=>Vo,getSaveHandlers:()=>uF,getWeightSpecs:()=>Em,http:()=>av,isHTTPScheme:()=>iv,listModels:()=>vF,loadWeights:()=>xL,moveModel:()=>wF,registerLoadRouter:()=>lF,registerSaveRouter:()=>cF,removeModel:()=>bF,weightsLoaderFactory:()=>$N,withSaveHandler:()=>IL,withSaveHandlerSync:()=>EL});var SL=D(()=>{"use strict";EE();TE();mL();CL();ga();TL();vu();PN();ma();SE();});function ine(e,n,t){let r=C(e,"labels","confusionMatrix"),o=C(n,"predictions","confusionMatrix");k(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),k(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),k(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),k(r.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),k(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);let s=bd(_e(r,"int32"),t),i=bd(_e(o,"int32"),t),a=$u(s),c=je(a,i);return _e(c,"int32")}var NL,DL=D(()=>{"use strict";$();q();dn();Is();dS();O();Hy();NL=E({confusionMatrix_:ine})});var VN={};He(VN,{confusionMatrix:()=>NL});var kL=D(()=>{"use strict";DL();});var UN={};He(UN,{draw:()=>mne,fromPixels:()=>hne,fromPixelsAsync:()=>pne,toPixels:()=>fne});function AL(e,n=3){if(n>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,o=!1,s=!1,i=!1,a=!1;if(e.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(fu(Xp,N.backendName)!=null){let m={pixels:e},h={numChannels:n};return N.runKernel(Xp,m,h)}let[l,u]=o?[e.videoWidth,e.videoHeight]:[e.width,e.height],p;if(i)p=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||t)p=e.data;else if(s||o||a){if(zu==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")zu=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else zu=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});zu.canvas.width=l,zu.canvas.height=u,zu.drawImage(e,0,0,l,u),p=zu.getImageData(0,0,l,u).data}let d;if(n===4)d=new Int32Array(p);else{let m=l*u;d=new Int32Array(m*n);for(let h=0;h<m;h++)for(let g=0;g<n;++g)d[h*n+g]=p[h*4+g]}return hh(d,[u,l,n],"int32")}function ane(e){return e!=null&&e.data instanceof Uint8Array}function cne(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function lne(e){return e!=null&&e.width!==0&&e.height!==0}function une(e){return cne()&&!(e instanceof ImageBitmap)&&lne(e)&&!ane(e)}async function pne(e,n=3){let t=null;if(M().getBool("WRAP_TO_IMAGEBITMAP")&&une(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?t=r:t=e}else t=e;return AL(t,n)}function RL(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let n=e.rank===2?1:e.shape[2];if(n>4||n===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${n}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function dne(e){let n=e?.alpha||1;if(n>1||n<0)throw new Error(`Alpha value ${n} is suppoed to be in range [0 - 1].`)}async function fne(e,n){let t=C(e,"img","toPixels");if(!(e instanceof ot)){let l=t;t=_e(l,"int32"),l.dispose()}RL(t);let[r,o]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2],i=await t.data(),a=t.dtype==="float32"?255:1,c=new Uint8ClampedArray(o*r*4);for(let l=0;l<r*o;++l){let u=[0,0,0,255];for(let d=0;d<s;d++){let f=i[l*s+d];if(t.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(t.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(u[0]=f*a,u[1]=f*a,u[2]=f*a):u[d]=f*a}let p=l*4;c[p+0]=Math.round(u[0]),c[p+1]=Math.round(u[1]),c[p+2]=Math.round(u[2]),c[p+3]=Math.round(u[3])}if(n!=null){_L||fu(zp,N.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),_L=!0),n.width=o,n.height=r;let l=n.getContext("2d"),u=new ImageData(c,o,r);l.putImageData(u,0,0)}return t!==e&&t.dispose(),c}function mne(e,n,t){let r=C(e,"img","draw");if(!(e instanceof ot)){let i=r;r=_e(i,"int32"),i.dispose()}RL(r),dne(t?.imageOptions);let o={image:r},s={canvas:n,options:t};N.runKernel(zp,o,s)}var zu,_L,hne,FL=D(()=>{"use strict";B();nn();H();ey();Er();$();dn();O();dN();_L=!1;hne=E({fromPixels_:AL})});var zN={};He(zN,{prepareAndValidate:()=>OL});function OL(e,n){let t=e.shape.length,r=n.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(n.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${n.shape[r-1]} vs. ${t}`);if(ke(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let o=n.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=e.shape,c=o.slice();c.pop();let l=1;for(let p=s;p<t;++p)l*=a[p],c.push(a[p]);let u=[...Po(e.shape).map(p=>p/l),1].slice(0,s);return[c,i,l,u]}var GN=D(()=>{"use strict";q()});var zt={};He(zt,{assertParamsValid:()=>xne,computeFlatOffset:()=>wne,computeOutShape:()=>vne,getNormalizedAxes:()=>bne,isSliceContinous:()=>Cne,maskToAxes:()=>yne,parseSliceParams:()=>Ine,sliceInfo:()=>Ene,startForAxis:()=>zL,startIndicesWithElidedDims:()=>BL,stopForAxis:()=>GL,stopIndicesWithElidedDims:()=>VL,stridesForAxis:()=>UL,stridesWithElidedDims:()=>$L});function xne(e,n,t){let r=e.shape.length;k(r===n.length,()=>`Error in slice${r}D: Length of begin ${n} must match the rank of the array (${r}).`),k(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let o=0;o<r;++o)k(n[o]+t[o]<=e.shape[o],()=>`Error in slice${r}D: begin[${o}] + size[${o}] (${n[o]+t[o]}) would overflow input.shape[${o}] (${e.shape[o]})`)}function yne(e){let n=[],t=0;for(;e>0;)e&1&&n.push(t),e/=2,t++;return n}function vne(e,n,t){let r=[];for(let o=0;o<e.length;o++)r[o]=Math.ceil((n[o]-e[o])/t[o]);return r}function $L(e,n,t,r){let o=[...e];for(let s=o.length;s<r.length;s++)o.push(1);for(let s=0;s<t;s++)s===0?o[n]=1:(o.splice(n,0,1),o.pop());return o}function PL(e,n,t){return t<=e?t:t-(n-1)}function LL(e,n){let t=[];for(let r=0;r<e;r++)t.push(n+r);return t}function bne(e,n,t,r,o,s,i,a,c){let l=e.length,u=new Array(l),p=new Array(l),d=new Array(l);if(n.length&&t>0){let f=n[0],m=t+1;u=BL(i,f,m,r,e),p=VL(a,f,m,o,e),d=$L(s,f,m,e)}else for(let f=0;f<l;f++)u[f]=zL(i,r,s,e,f,c),p[f]=GL(a,o,s,e,f,c),d[f]=UL(s,f,c);return{begin:u,end:p,strides:d}}function BL(e,n,t,r,o){let s=[...o],i=LL(t,n);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let c=PL(n,t,a),l=r[c];e&1<<c&&(l=0),s[a]=l}return s}function VL(e,n,t,r,o){let s=[...o],i=LL(t,n);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let c=PL(n,t,a),l=r[c];e&1<<c&&(l=Number.MAX_SAFE_INTEGER),s[a]=l}for(let a=0;a<s.length;a++){let c=o[a];s[a]<0&&(s[a]+=c),s[a]=Mp(0,s[a],o[a])}return s}function UL(e,n,t){let r=e[n];return(t&1<<n||r==null)&&(r=1),r}function zL(e,n,t,r,o,s){let i=n[o],a=t[o]||1;(e&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let c=r[o];return i<0&&(i+=c),i=Mp(0,i,c-1),i}function GL(e,n,t,r,o,s){let i=n[o],a=t[o]||1;(e&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let c=r[o];return i<0&&(i+=c),a>0?i=Mp(0,i,c):i=Mp(-1,i,c-1),i}function Cne(e,n,t){let r=t.length;for(let o=0;o<t.length;o++)if(t[o]>1){r=o;break}for(let o=r+1;o<t.length;o++)if(n[o]>0||t[o]!==e[o])return!1;return!0}function wne(e,n){let t=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)t+=e[r]*n[r];return t}function Ine(e,n,t){let r,o=e.shape.length;typeof n=="number"?r=[n,...new Array(o-1).fill(0)]:n.length<o?r=n.concat(new Array(o-n.length).fill(0)):r=n.slice(),r.forEach(i=>{k(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(o).fill(-1):typeof t=="number"?s=[t,...new Array(o-1).fill(-1)]:t.length<o?s=t.concat(new Array(o-t.length).fill(-1)):s=t,s=s.map((i,a)=>i>=0?i:(k(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),e.shape[a]-r[a])),[r,s]}function Ene(e,n,t,r,o,s,i,a,c){let l;if(r==null?(l=new Array(n.length),l.fill(1)):l=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1,p={dims:l.length,numAddAxisAfterEllipsis:0,begin:n.slice(),end:t.slice(),strides:l.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:c};for(let w=0;w<p.dims;w++)u&&(1<<w&a)!==0&&p.numAddAxisAfterEllipsis++,1<<w&i&&(u=!0);u||(p.ellipsisMask|=1<<p.dims,p.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Tne(p,d);let f=!0,m=!0,h=!0,g=[],x=[];for(let w=0;w<e.length;++w){if(d.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);let I=!!(d.shrinkAxisMask&1<<w),_=e[w];if(_===-1){g.push(I?1:-1);continue}let A=[d.beginMask&1<<w,d.endMask&1<<w],R=[d.strides[w]>0?0:-1,d.strides[w]>0?_:_-1];if(I&&d.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&d.strides[w]===1;let F=!!(d.beginMask&1<<w&&d.endMask&1<<w);if(d.beginValid&&d.endValid){if(I){let z=d.begin[w]<0?_+d.begin[w]:d.begin[w];if(d.begin[w]=z,d.end[w]=d.begin[w]+1,z<0||z>=_)throw Error(`slice index ${d.begin[w]} of dimension ${w} out of bounds.`)}else d.begin[w]=ML(d.begin[w],0,d.strides[w],_,A,R),d.end[w]=ML(d.end[w],1,d.strides[w],_,A,R);let V=d.strides[w]===1&&d.begin[w]===0&&d.end[w]===_;f=f&&V,m=m&&(w===0&&d.strides[w]===1||V)}else f=f&&d.strides[w]===1&&F,m=m&&(w===0&&d.strides[w]===1||F);let P,L=!1;if(d.beginValid&&d.endValid?(P=d.end[w]-d.begin[w],L=!0):I?(P=1,L=!0):F&&_>=0&&(d.strides[w]<0?P=-_:P=_,L=!0),L){let V;P===0||P<0!=d.strides[w]<0?V=0:V=Math.trunc(P/d.strides[w])+(P%d.strides[w]!==0?1:0),g.push(V)}else g.push(-1)}for(let w=0;w<d.finalShapeGatherIndices.length;++w){let I=d.finalShapeGatherIndices[w];I>=0?x.push(g[I]):I===HN&&x.push(1)}return{finalShapeSparse:x.filter((w,I)=>d.finalShapeGatherIndices[I]!==HN),finalShape:x,isIdentity:f,sliceDim0:m,isSimpleSlice:h,begin:d.begin,end:d.end,strides:d.strides}}function Tne(e,n){n.beginMask=0,n.endMask=0,n.shrinkAxisMask=0;let t=0;n.beginValid=e.begin!=null,n.endValid=e.end!=null,n.begin=new Array(n.dims),n.end=new Array(n.dims),n.strides=new Array(n.dims),n.finalShapeGatherIndices=[],n.finalShapeGatherIndicesSparse=[],n.inputShapeGatherIndicesSparse=new Array(n.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let o=Math.min(n.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,n.dims);for(;t<o;t++)n.begin[t]=0,n.end[t]=0,n.strides[t]=1,n.beginMask|=1<<t,n.endMask|=1<<t,n.finalShapeGatherIndices.push(t),n.finalShapeGatherIndicesSparse.push(-1),n.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&e.newAxisMask)n.finalShapeGatherIndices.push(HN),n.finalShapeGatherIndicesSparse.push(-1);else{if(t===n.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${n.dims} dims, ${n.begin.length}.`);e.begin!=null&&(n.begin[t]=e.begin[r]),e.end!=null&&(n.end[t]=e.end[r]),n.strides[t]=e.strides[r],e.beginMask&1<<r&&(n.beginMask|=1<<t),e.endMask&1<<r&&(n.endMask|=1<<t),e.shrinkAxisMask&1<<r?(n.finalShapeGatherIndices.push(gne),n.finalShapeGatherIndicesSparse.push(-1),n.shrinkAxisMask|=1<<t):(n.finalShapeGatherIndices.push(t),n.finalShapeGatherIndicesSparse.push(r)),n.inputShapeGatherIndicesSparse[t]=r,t++}}function ML(e,n,t,r,o,s){if(o[n])return t>0?s[n]:s[n+1&1];{let i=e<0?r+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var HN,gne,WN=D(()=>{"use strict";q();HN=-2,gne=-1});var HL,WL=D(()=>{"use strict";HL="4.22.0"});var Td,jN=D(()=>{"use strict";ev();tv();nv();rv();ov();sv();Ih();Td=class{static sgd(n){return new Ko(n)}static momentum(n,t,r=!1){return new _a(n,t,r)}static rmsprop(n,t=.9,r=0,o=null,s=!1){return new Aa(n,t,r,o,s)}static adam(n=.001,t=.9,r=.999,o=null){return new Da(n,t,r,o)}static adadelta(n=.001,t=.95,r=null){return new Sa(n,t,r)}static adamax(n=.002,t=.9,r=.999,o=null,s=0){return new ka(n,t,r,o,s)}static adagrad(n,t=.1){return new Na(n,t)}}});var Sne,jL=D(()=>{"use strict";jN();Sne=Td});function lv(){return new Promise(e=>Nne(()=>e()))}var Nne,qL=D(()=>{"use strict";Nne=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e()});function Dne(e,n){let t=e[0].length;e.forEach((o,s)=>{k(o.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),k(n>=0&&n<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);let r=e[0];e.forEach((o,s)=>{for(let i=0;i<t;i++)k(i===n||o[i]===r[i],()=>`Error in concat${t}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function kne(e,n){let t=e[0].slice();for(let r=1;r<e.length;r++)t[n]+=e[r][n];return t}var KL=D(()=>{"use strict";q();});var XL=D(()=>{"use strict";});function _ne(e,n,t){let r=new Array;if(t==null&&n==null)return r;if(n==null)for(;r.length<e+t.length;)r.push(-1);else r=n.slice();if(t==null)return r;if(e+t.length!==r.length)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.rank = ${e+t.length}, but shape.rank = ${r.length}`);for(let o=1;o<t.length;++o){let s=t[o],i=r[r.length-t.length+o],a=r[i];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.shape[${o+e}] = ${s} but shape[${o+e}] = ${a}`)}else r[i]=s}return r}function Ane(e){let n={FIRST_DIM_SIZE:Ls.FIRST_DIM_SIZE,VALUE_ROWIDS:Ls.VALUE_ROWIDS,ROW_LENGTHS:Ls.ROW_LENGTHS,ROW_SPLITS:Ls.ROW_SPLITS,ROW_LIMITS:Ls.ROW_LIMITS,ROW_STARTS:Ls.ROW_STARTS},t=[];for(let r of e)if(r in n)t.push(n[r]);else break;return t}function Rne(e){return e.length===0?0:e[0]===Ls.FIRST_DIM_SIZE?e.length-1:e.length}function Fne(e,n){if(e==null||n==null)return;let t=e.length,r=n.length;if(t>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${n}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let o=0;o<Math.min(t,r-1);++o){let s=e[o],i=n[o+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${n} are incompatible: defaultValue.shape[${o-e.length}] = ${s} but ragged tensor input.flatValues.shape[${o-e.length}] = ${i}`)}}var Ls,YL=D(()=>{"use strict";Ls=(function(e){return e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS",e})(Ls||{})});function One(e){return e<=uv?e:Pp(e,Math.floor(Math.sqrt(e)))}var uv,qN=D(()=>{"use strict";q();uv=30});function Mne(e,n,t){let r=t*(typeof e=="number"?e:e[0]),o=n*(typeof e=="number"?e:e[1]);return[r,o]}var ZL=D(()=>{"use strict";});function $ne(e,n,t,r=!0){let o=[];if(r)o=o.concat(n.slice(0)),o.push(e[0]/t),o=o.concat(e.slice(1));else{o=o.concat(e[0]);let s=n.length;for(let i=0;i<s;++i)o=o.concat([e[i+1]/n[i],n[i]]);o=o.concat(e.slice(s+1))}return o}function Pne(e,n,t=!0){let r=[];if(t){r.push(n);for(let o=n+1;o<e;++o)o<=2*n?(r.push(o),r.push(o-(n+1))):r.push(o)}else{let o=[],s=[];for(let i=1;i<e;++i)i>=n*2+1||i%2===1?s.push(i):o.push(i);r.push(...o),r.push(0),r.push(...s)}return r}function Lne(e,n,t,r=!0){let o=[];r?o.push(e[0]/t):o.push(e[0]*t);for(let s=1;s<e.length;++s)s<=n.length?r?o.push(n[s-1]*e[s]):o.push(e[s]/n[s-1]):o.push(e[s]);return o}function Bne(e,n){let t=[0];for(let r=0;r<n;++r)t.push(e[r][0]);return t}function Vne(e,n,t){let r=e.slice(0,1);for(let o=0;o<t;++o)r.push(e[o+1]-n[o][0]-n[o][1]);return r}var QL=D(()=>{"use strict";});var Une,zne,JL=D(()=>{"use strict";Une=1.7580993408473768,zne=1.0507009873554805});var Gne,Hne,Wne,jne,qne,Kne,eB=D(()=>{"use strict";Gne=.3275911,Hne=.254829592,Wne=-.284496736,jne=1.421413741,qne=-1.453152027,Kne=1.061405429});function Xne(e,n){if(e.length!==n.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${n.length}.`);let t=new Float32Array(e.length*2);for(let r=0;r<t.length;r+=2)t[r]=e[r/2],t[r+1]=n[r/2];return t}function Yne(e){let n=new Float32Array(e.length/2),t=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)n[r/2]=e[r],t[r/2]=e[r+1];return{real:n,imag:t}}function Zne(e){let n=Math.ceil(e.length/4),t=new Float32Array(n),r=new Float32Array(n);for(let o=0;o<e.length;o+=4)t[Math.floor(o/4)]=e[o],r[Math.floor(o/4)]=e[o+1];return{real:t,imag:r}}function Qne(e){let n=Math.floor(e.length/4),t=new Float32Array(n),r=new Float32Array(n);for(let o=2;o<e.length;o+=4)t[Math.floor(o/4)]=e[o],r[Math.floor(o/4)]=e[o+1];return{real:t,imag:r}}function Jne(e,n){let t=e[n*2],r=e[n*2+1];return{real:t,imag:r}}function ere(e,n,t,r){e[r*2]=n,e[r*2+1]=t}function tre(e,n){let t=new Float32Array(e/2),r=new Float32Array(e/2);for(let o=0;o<Math.ceil(e/2);o++){let s=(n?2:-2)*Math.PI*(o/e);t[o]=Math.cos(s),r[o]=Math.sin(s)}return{real:t,imag:r}}function nre(e,n,t){let r=(t?2:-2)*Math.PI*(e/n),o=Math.cos(r),s=Math.sin(r);return{real:o,imag:s}}var tB=D(()=>{"use strict";});function ore(e,n){e=e.replace(/\s/g,"");let t=(e.length-e.replace(rre,"").length)/KN.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${KN}").`);let[r,o]=e.split(KN);k(r.indexOf(rB)===-1,()=>`The ellipsis notation ("${rB}") is not supported yet.`);let s=r.split(nB),i=s.length;if(n!==i)throw new Error(`Expected ${i} input tensors, received ${n}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let d=0;d<o.length;++d){let f=o[d];if(!s.some(m=>m.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let d=0;d<r.length;++d){let f=r[d];a.indexOf(f)===-1&&f!==nB&&a.push(f)}let c=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);c[d]=[];for(let f=0;f<s[d].length;++f)c[d].push(a.indexOf(s[d][f]))}let l=a.length,u=o.length,p=[];for(let d=u;d<l;++d)p.push(d);return{allDims:a,summedDims:p,idDims:c}}function sre(e,n){let t=new Array(e);t.fill(-1);for(let o=0;o<n.length;++o)t[n[o]]=o;let r=[];for(let o=0;o<e;++o)t[o]===-1&&r.push(o);return t=t.filter(o=>o!==-1),{permutationIndices:t,expandDims:r}}function ire(e,n,t){let r=new Array(e);for(let o=0;o<t.length;++o){let s=t[o].shape;for(let i=0;i<n[o].length;++i)r[n[o][i]]===void 0?r[n[o][i]]=s[i]:k(r[n[o][i]]===s[i],()=>`Expected dimension ${r[n[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function are(e,n){let t=e,r=[],o=0;e.length===0&&t.push(-1),o=e.length+1;for(let i=0;i<o;++i)r.push([]);let s=[];for(let i=0;i<t.length;++i){let a=t[i],c=lre(n,a);for(let l of c)s.indexOf(l)===-1&&(r[i].push(l),s.push(l))}return{path:t,steps:r}}function cre(e){return e.every((n,t)=>n===t)}function lre(e,n){let t=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(n)!==-1||n===-1)&&t.push(r);return t}var KN,rre,nB,rB,oB=D(()=>{"use strict";jt();KN="->",rre=/->/g,nB=",",rB="..."});function ure(e,n,t=0){let r=[];if(typeof n=="number")k(e.shape[t]%n===0,()=>"Number of splits must evenly divide the axis."),r=new Array(n).fill(e.shape[t]/n);else{let o=n.reduce((i,a)=>(a===-1&&(i+=1),i),0);k(o<=1,()=>"There should be only one negative value in split array.");let s=n.indexOf(-1);if(s!==-1){let i=n.reduce((a,c)=>c>0?a+c:a);n[s]=e.shape[t]-i}k(e.shape[t]===n.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=n}return r}var sB=D(()=>{"use strict";q()});function pre(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function dre(e,n){return`indices(${e}, 0) is invalid: ${n} < 0`}function fre(e,n,t){return`indices(${e}, 0) is invalid: ${n} >= ${t}`}var iB=D(()=>{"use strict";});function mre(e,n){return`only one output dimension may be -1, not both ${e} and ${n}`}function hre(e,n){return`size ${e} must be non-negative, not ${n}`}function gre(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function xre(e,n){let t=ke(e),r=ke(n);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${n}`}function yre(e,n){let t=ke(e),r=ke(n);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${n}`}var aB=D(()=>{"use strict";q();});function vre(){return"segment ids must be >= 0"}function bre(){return"segment ids are not increasing"}function Cre(e,n){return`Segment id ${e} out of range [0, ${n}), possibly because segmentIds input is not sorted.`}function wre(e,n,t){return`Bad: indices[${e}] == ${n} out of range [0, ${t})`}var cB=D(()=>{"use strict";});var XN={};He(XN,{collectGatherOpShapeInfo:()=>Tre,computeOutShape:()=>Ere,segOpComputeOptimalWindowSize:()=>Ire});function Ire(e,n){let t=!1,r;for(e<=uv?(r=e,t=!0):r=Pp(e,Math.floor(Math.sqrt(e)));!t;)r>n||r===e?t=!0:r=Pp(e,r+1);return r}function Ere(e,n,t){let r=[],o=e.length;for(let s=0;s<o;s++)s!==n?r.push(e[s]):r.push(t);return r}function Tre(e,n,t,r){let o=n.shape.length,s=e.shape.length;if(r!==0&&(r<-o||r>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${r}`);if(r<0&&(r+=o),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let p=0;p<r;++p)if(e.shape[p]!==n.shape[p])throw new Error(`x.shape[${p}]: ${e.shape[p]} should be equal to indices.shape[${p}]: ${n.shape[p]}.`);let i=e.shape[t],a=[],c=1,l=1,u=1;for(let p=0;p<r;++p)a.push(e.shape[p]),c*=e.shape[p];for(let p=r;p<t;p++)a.push(e.shape[p]),l*=e.shape[p];for(let p=r;p<o;p++)a.push(n.shape[p]);for(let p=t+1;p<s;p++)a.push(e.shape[p]),u*=e.shape[p];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:i,outputShape:a}}var lB=D(()=>{"use strict";q();qN();});var S={};He(S,{ERF_A1:()=>Hne,ERF_A2:()=>Wne,ERF_A3:()=>jne,ERF_A4:()=>qne,ERF_A5:()=>Kne,ERF_P:()=>Gne,PARALLELIZE_THRESHOLD:()=>uv,RowPartitionType:()=>Ls,SELU_SCALE:()=>zne,SELU_SCALEALPHA:()=>Une,applyActivation:()=>Bu,assertAndGetBroadcastShape:()=>Ye,assertAxesAreInnerMostDims:()=>gQ,assertParamsConsistent:()=>Dne,assignToTypedArray:()=>ere,axesAreInnerMostDims:()=>AT,calculateShapes:()=>YM,checkEinsumDimSizes:()=>ire,checkPadOnDimRoundingMode:()=>Pt,combineLocations:()=>IO,combineRaggedTensorToTensorShapes:()=>_ne,complexWithEvenIndex:()=>Zne,complexWithOddIndex:()=>Qne,computeConv2DInfo:()=>Su,computeConv3DInfo:()=>UF,computeDefaultPad:()=>jE,computeDilation2DInfo:()=>mZ,computeOptimalWindowSize:()=>One,computeOutAndReduceShapes:()=>hQ,computeOutShape:()=>kne,computePool2DInfo:()=>WE,computePool3DInfo:()=>hZ,convertConv2DDataFormat:()=>zF,decodeEinsumEquation:()=>ore,eitherStridesOrDilationsAreOne:()=>yn,expandShapeToKeepDim:()=>ks,exponent:()=>nre,exponents:()=>tre,fromStringArrayToUint8:()=>Nre,fromUint8ToStringArray:()=>Sre,getAxesPermutation:()=>xQ,getBroadcastDims:()=>yO,getComplexWithIndex:()=>Jne,getEinsumComputePath:()=>are,getEinsumPermutation:()=>sre,getFusedBiasGradient:()=>Lu,getFusedDyActivation:()=>Pu,getImageCenter:()=>Mne,getInnerMostAxes:()=>vQ,getPermuted:()=>Pne,getRaggedRank:()=>Rne,getReductionAxes:()=>yy,getReshaped:()=>$ne,getReshapedPermuted:()=>Lne,getRowPartitionTypesHelper:()=>Ane,getSliceBeginCoords:()=>Bne,getSliceSize:()=>Vne,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>pre,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>dre,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>fre,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>gre,getSparseReshapeInputOutputMismatchErrorMessage:()=>yre,getSparseReshapeInputOutputMultipleErrorMessage:()=>xre,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>mre,getSparseReshapeNegativeOutputDimErrorMessage:()=>hre,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>wre,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>vre,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>bre,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Cre,getUndoAxesPermutation:()=>yQ,isIdentityPermutation:()=>cre,log:()=>GX,mergeRealAndImagArrays:()=>Xne,prepareAndValidate:()=>OL,prepareSplitSize:()=>ure,segment_util:()=>XN,shouldFuse:()=>Vu,slice_util:()=>zt,splitRealAndImagArrays:()=>Yne,stridesOrDilationsArePositive:()=>Uo,tupleValuesAreOne:()=>Tu,upcastType:()=>Mt,validateDefaultValueShape:()=>Fne,validateInput:()=>wd,validateUpdateShape:()=>gN,warn:()=>Lo});function Sre(e){try{return e.map(n=>td(n))}catch(n){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${n}`)}}function Nre(e){return e.map(n=>pa(n))}var uB=D(()=>{"use strict";q();md();Xt();KL();zn();Ed();XL();YL();qN();WN();rd();ZL();QL();GN();xh();JL();Ed();eB();Qx();tB();oB();sB();iB();aB();cB();lB();});var sn={};He(sn,{nonMaxSuppressionV3Impl:()=>Xy,nonMaxSuppressionV4Impl:()=>Yy,nonMaxSuppressionV5Impl:()=>Zy,whereImpl:()=>Gy});var pB=D(()=>{"use strict";bh();EN();});var dB=D(()=>{"use strict";SL();kL();Xt();FL();GN();xh();WN();Jy();vt();EM();q();WL();ev();tv();nv();rv();ov();Ta();jN();sv();Ih();Er();rd();Ch();yo();jL();rr();ey();Fs();nn();qL();uB();mE();pB();GI();H();});var pv={};He(pv,{Abs:()=>Ec,Acos:()=>hi,Acosh:()=>gi,AdadeltaOptimizer:()=>Sa,AdagradOptimizer:()=>Na,AdamOptimizer:()=>Da,AdamaxOptimizer:()=>ka,Add:()=>ds,AddN:()=>Tc,All:()=>Vp,Any:()=>Up,ArgMax:()=>Sc,ArgMin:()=>Nc,Asin:()=>xi,Asinh:()=>yi,Atan:()=>vi,Atan2:()=>Ci,Atanh:()=>bi,AvgPool:()=>Dc,AvgPool3D:()=>kc,AvgPool3DGrad:()=>im,AvgPoolGrad:()=>sm,BatchMatMul:()=>_c,BatchToSpaceND:()=>Ac,Bincount:()=>Rc,BitwiseAnd:()=>wi,BroadcastArgs:()=>Fc,BroadcastTo:()=>$X,Cast:()=>fs,Ceil:()=>Ii,ClipByValue:()=>Ei,Complex:()=>Oc,ComplexAbs:()=>Mc,Concat:()=>$c,Conv2D:()=>Pc,Conv2DBackpropFilter:()=>Lc,Conv2DBackpropInput:()=>Bc,Conv3D:()=>Vc,Conv3DBackpropFilterV2:()=>am,Conv3DBackpropInputV2:()=>Uc,Cos:()=>zc,Cosh:()=>Ti,CropAndResize:()=>Wc,Cumprod:()=>Gc,Cumsum:()=>Hc,DataStorage:()=>di,DenseBincount:()=>jc,DepthToSpace:()=>qc,DepthwiseConv2dNative:()=>Kc,DepthwiseConv2dNativeBackpropFilter:()=>Xc,DepthwiseConv2dNativeBackpropInput:()=>Yc,Diag:()=>Zc,Dilation2D:()=>Qc,Dilation2DBackpropFilter:()=>Zx,Dilation2DBackpropInput:()=>Yx,Draw:()=>zp,ENV:()=>Kx,Einsum:()=>Jc,Elu:()=>el,EluGrad:()=>cm,Environment:()=>Bp,Equal:()=>Ni,Erf:()=>tl,Exp:()=>nl,ExpandDims:()=>rl,Expm1:()=>Di,FFT:()=>Gp,Fill:()=>ol,FlipLeftRight:()=>sl,Floor:()=>ki,FloorDiv:()=>_i,FromPixels:()=>Xp,FusedBatchNorm:()=>il,FusedConv2D:()=>ca,FusedDepthwiseConv2D:()=>la,GatherNd:()=>cl,GatherV2:()=>al,Greater:()=>Ai,GreaterEqual:()=>Ri,IFFT:()=>ll,Identity:()=>ms,Imag:()=>ul,IsFinite:()=>Fi,IsInf:()=>Oi,IsNan:()=>Mi,KernelBackend:()=>Mo,LRN:()=>Hp,LRNGrad:()=>lm,LeakyRelu:()=>pl,Less:()=>$i,LessEqual:()=>Pi,LinSpace:()=>dl,Log:()=>fl,Log1p:()=>Li,LogSoftmax:()=>LX,LogicalAnd:()=>Bi,LogicalNot:()=>Vi,LogicalOr:()=>Ui,LogicalXor:()=>PX,LowerBound:()=>BX,MatrixBandPart:()=>VX,Max:()=>Wp,MaxPool:()=>ml,MaxPool3D:()=>hl,MaxPool3DGrad:()=>pm,MaxPoolGrad:()=>um,MaxPoolWithArgmax:()=>gl,Maximum:()=>zi,Mean:()=>xl,Min:()=>jp,Minimum:()=>Gi,MirrorPad:()=>yl,Mod:()=>vl,MomentumOptimizer:()=>_a,Multinomial:()=>bl,Multiply:()=>Hi,Neg:()=>qp,NonMaxSuppressionV3:()=>Cl,NonMaxSuppressionV4:()=>wl,NonMaxSuppressionV5:()=>Il,NotEqual:()=>Wi,OP_SCOPE_SUFFIX:()=>ly,OneHot:()=>Tl,OnesLike:()=>El,Optimizer:()=>wn,OptimizerConstructors:()=>Td,Pack:()=>Sl,PadV2:()=>Nl,Pool:()=>UX,Pow:()=>Dl,Prelu:()=>kl,Prod:()=>_l,RMSPropOptimizer:()=>Aa,RaggedGather:()=>Al,RaggedRange:()=>Rl,RaggedTensorToTensor:()=>Fl,Range:()=>Ol,Rank:()=>aE,Real:()=>Ml,RealDiv:()=>Si,Reciprocal:()=>ji,Reduction:()=>Dt,Relu:()=>qi,Relu6:()=>Ki,Reshape:()=>$l,ResizeBilinear:()=>Ll,ResizeBilinearGrad:()=>fm,ResizeNearestNeighbor:()=>Pl,ResizeNearestNeighborGrad:()=>dm,Reverse:()=>Bl,RotateWithOffset:()=>du,Round:()=>Xi,Rsqrt:()=>Yi,SGDOptimizer:()=>Ko,ScatterNd:()=>Vl,SearchSorted:()=>zl,Select:()=>Gl,Selu:()=>Zi,Sigmoid:()=>ea,Sign:()=>Ji,Sin:()=>Wl,Sinh:()=>Qi,Slice:()=>Hl,Softmax:()=>Kl,Softplus:()=>ta,SpaceToBatchND:()=>jl,SparseFillEmptyRows:()=>Xl,SparseReshape:()=>Yl,SparseSegmentMean:()=>Zl,SparseSegmentSum:()=>Ql,SparseToDense:()=>Jl,SplitV:()=>ql,Sqrt:()=>na,Square:()=>mm,SquaredDifference:()=>ra,StaticRegexReplace:()=>oa,Step:()=>ia,StridedSlice:()=>eu,StringNGrams:()=>tu,StringSplit:()=>nu,StringToHashBucketFast:()=>ru,Sub:()=>ou,Sum:()=>Kp,Tan:()=>su,Tanh:()=>sa,Tensor:()=>ot,TensorBuffer:()=>Ke,TensorScatterUpdate:()=>Ul,Tile:()=>hs,TopK:()=>iu,Transform:()=>au,Transpose:()=>gs,Unique:()=>cu,Unpack:()=>lu,UnsortedSegmentSum:()=>uu,UpperBound:()=>zX,Variable:()=>Bo,ZerosLike:()=>pu,_FusedMatMul:()=>aa,abs:()=>Kt,acos:()=>RE,acosh:()=>FE,add:()=>de,addN:()=>OE,all:()=>ME,any:()=>$E,argMax:()=>PE,argMin:()=>LE,asin:()=>BE,asinh:()=>VE,atan:()=>UE,atan2:()=>zE,atanh:()=>GE,avgPool:()=>km,avgPool3d:()=>KE,backend:()=>xE,backend_util:()=>S,basicLSTMCell:()=>YE,batchNorm:()=>Es,batchNorm2d:()=>QE,batchNorm3d:()=>JE,batchNorm4d:()=>eT,batchToSpaceND:()=>Am,bincount:()=>Fm,bitwiseAnd:()=>nT,booleanMaskAsync:()=>o$,broadcastArgs:()=>rT,broadcastTo:()=>Ts,broadcast_util:()=>fo,browser:()=>UN,buffer:()=>le,cast:()=>_e,ceil:()=>sT,clipByValue:()=>iT,clone:()=>Vn,complex:()=>An,concat:()=>ut,concat1d:()=>aT,concat2d:()=>cT,concat3d:()=>lT,concat4d:()=>uT,conv1d:()=>pT,conv2d:()=>Ss,conv2dTranspose:()=>fT,conv3d:()=>mT,conv3dTranspose:()=>hT,copyRegisteredKernels:()=>qX,cos:()=>gT,cosh:()=>xT,cosineWindow:()=>Id,cumprod:()=>yT,cumsum:()=>vT,customGrad:()=>bn,denseBincount:()=>bT,deprecationWarn:()=>eF,depthToSpace:()=>CT,depthwiseConv2d:()=>Nu,device_util:()=>xs,diag:()=>wT,dilation2d:()=>IT,disableDeprecationWarnings:()=>vY,dispose:()=>Nt,disposeVariables:()=>bY,div:()=>Ve,divNoNan:()=>TT,dot:()=>ST,dropout:()=>y$,einsum:()=>Ds,elu:()=>$m,enableDebugMode:()=>yY,enableProdMode:()=>xY,enclosingPowerOfTwo:()=>Wy,engine:()=>Tr,ensureShape:()=>kT,env:()=>M,equal:()=>Mm,erf:()=>_T,euclideanNorm:()=>FT,exp:()=>Sr,expandDims:()=>Vr,expm1:()=>OT,eye:()=>Vm,fft:()=>Fu,fill:()=>po,findBackend:()=>NY,findBackendFactory:()=>DY,floor:()=>Um,floorDiv:()=>Sm,fused:()=>jy,gather:()=>zm,gatherND:()=>m$,gather_util:()=>zN,getBackend:()=>gE,getGradient:()=>Jx,getKernel:()=>fu,getKernelsForBackend:()=>gm,grad:()=>RO,grads:()=>FO,greater:()=>va,greaterEqual:()=>Gm,ifft:()=>Ia,imag:()=>Rs,image:()=>sL,inTopKAsync:()=>b$,io:()=>Xo,irfft:()=>uh,isFinite:()=>BT,isInf:()=>VT,isNaN:()=>UT,keep:()=>Fn,kernel_impls:()=>sn,leakyRelu:()=>Wm,less:()=>yd,lessEqual:()=>Du,linalg:()=>iL,linspace:()=>HT,localResponseNormalization:()=>WT,log:()=>Ho,log1p:()=>qm,logSigmoid:()=>KT,logSoftmax:()=>XT,logSumExp:()=>Xm,logicalAnd:()=>ba,logicalNot:()=>Ym,logicalOr:()=>Zm,logicalXor:()=>JT,losses:()=>aL,lowerBound:()=>eS,matMul:()=>je,math:()=>VN,max:()=>mo,maxPool:()=>Qm,maxPool3d:()=>nS,maxPoolWithArgmax:()=>rS,maximum:()=>Jm,mean:()=>Ca,memory:()=>CY,meshgrid:()=>sS,min:()=>hd,minimum:()=>wa,mirrorPad:()=>iS,mod:()=>aS,moments:()=>cS,movingAverage:()=>i$,mul:()=>ee,multiRNNCell:()=>lS,multinomial:()=>uS,neg:()=>on,nextFrame:()=>lv,norm:()=>ya,notEqual:()=>th,oneHot:()=>bd,ones:()=>go,onesLike:()=>fS,op:()=>E,outerProduct:()=>mS,pad:()=>xo,pad1d:()=>hS,pad2d:()=>gS,pad3d:()=>xS,pad4d:()=>yS,pool:()=>bS,pow:()=>Go,prelu:()=>rh,print:()=>Tm,prod:()=>wS,profile:()=>wY,raggedGather:()=>IS,raggedRange:()=>ES,raggedTensorToTensor:()=>TS,rand:()=>SS,randomGamma:()=>LS,randomNormal:()=>sh,randomStandardNormal:()=>VS,randomUniform:()=>Au,randomUniformInt:()=>US,range:()=>Ms,ready:()=>TY,real:()=>Wo,reciprocal:()=>zS,registerBackend:()=>Im,registerGradient:()=>HX,registerKernel:()=>Zp,relu:()=>$s,relu6:()=>ch,removeBackend:()=>SY,reshape:()=>U,reverse:()=>sr,reverse1d:()=>HS,reverse2d:()=>WS,reverse3d:()=>jS,reverse4d:()=>qS,rfft:()=>Ou,round:()=>lh,rsqrt:()=>XS,scalar:()=>me,scatterND:()=>c$,scatter_util:()=>gh,searchSorted:()=>vd,selu:()=>YS,separableConv2d:()=>ZS,serialization:()=>AN,setBackend:()=>EY,setPlatform:()=>kY,setdiff1dAsync:()=>QS,sigmoid:()=>uo,sign:()=>JS,signal:()=>oL,sin:()=>eN,sinh:()=>tN,slice:()=>Ue,slice1d:()=>nN,slice2d:()=>rN,slice3d:()=>oN,slice4d:()=>sN,slice_util:()=>zt,softmax:()=>iN,softplus:()=>Km,spaceToBatchND:()=>nh,sparse:()=>cL,sparseToDense:()=>d$,spectral:()=>rL,split:()=>jo,sqrt:()=>On,square:()=>Yt,squaredDifference:()=>dh,squeeze:()=>Mu,stack:()=>Cn,step:()=>mh,stridedSlice:()=>uN,string:()=>lL,sub:()=>ge,sum:()=>Ze,sumOutType:()=>da,tan:()=>pN,tanh:()=>pd,tensor:()=>xn,tensor1d:()=>Qt,tensor2d:()=>Ps,tensor3d:()=>hh,tensor4d:()=>fN,tensor5d:()=>mN,tensor6d:()=>hN,tensorScatterUpdate:()=>xN,tensor_util:()=>lE,test_util:()=>PS,tidy:()=>Ce,tile:()=>As,time:()=>IY,topk:()=>yN,train:()=>Sne,transpose:()=>$u,truncatedNormal:()=>vN,unique:()=>bN,unregisterGradient:()=>jX,unregisterKernel:()=>WX,unsortedSegmentSum:()=>CN,unstack:()=>ir,upcastType:()=>Mt,upperBound:()=>wN,util:()=>y,valueAndGrad:()=>OO,valueAndGrads:()=>MO,variable:()=>IN,variableGrads:()=>Iy,version_core:()=>HL,where:()=>or,whereAsync:()=>yh,zeros:()=>Nr,zerosLike:()=>Bt});var T=D(()=>{"use strict";DF();pL();dB();uL()});var $de,_j=D(()=>{"use strict";T();$de=M();$de.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})});var pr,Aj,Rj=D(()=>{"use strict";pr=(function(e){return e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF",e})(pr||{});(function(e){let n;(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(n=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(Aj||(Aj={}))});function Fj(e,n){let t={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:n};A1[e]=t}function w0(e){return A1[e]}function Oj(e){delete A1[e]}var A1,I0=D(()=>{"use strict";A1={}});function b(e,n,t,r,o){let s=n.inputParams[e];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,c=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd,l=a<0?n.inputNames.length+a:a;if(s.type==="tensor")return Lt(n.inputNames[l],t,r,o);if(s.type==="tensors"){let d=n.inputs.slice(a,c);return n.inputNames.slice(a,c).filter((m,h)=>{var g;return((g=d[h])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(m=>Lt(m,t,r,o))}let u=Lt(n.inputNames[l],t,r,o),p=u.dataSync();return s.type==="number"?p[0]:y.toNestedArray(u.shape,p)}let i=n.attrParams[e];return i&&i.value}function Lt(e,n,t,r){let[o,s]=Mn(e,t);if(r!=null){let a=r.getHashTableHandleByName(o);if(a!=null)return a}let i=t.currentContextIds.find(a=>!!n[E0(o,a)]);return i!==void 0?n[E0(o,i)][s]:void 0}function R1(e,n,t){return n[E0(e,t.currentContextId)]}function Io(e,n){let[t,r,o]=Mn(e,n);return[E0(t,n&&n.currentContextId),r,o]}function E0(e,n){return n?`${e}-${n}`:e}function Mn(e,n){if(e==="")return["",0,void 0];let t=n!=null&&n.parseNodeNameCache!=null;if(t){let s=n.parseNodeNameCache.get(e);if(s!=null)return s}let r=e.split(":"),o;if(r.length===1)o=[e,0,void 0];else{let s=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);o=[s,a,i]}return t&&n.parseNodeNameCache.set(e,o),o}function Yh(e,n,t){let r=b("pad",e,n,t);if(r==="explicit"){r=b("explicitPaddings",e,n,t);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=r[s*2],o[s][1]=r[s*2+1];return o}return r}function Eo(e){return e.kept?e:Vn(e)}var At=D(()=>{"use strict";T();});var F1={};He(F1,{json:()=>Lde});var Lde,Mj=D(()=>{"use strict";Lde=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var O1={};He(O1,{json:()=>Bde});var Bde,$j=D(()=>{"use strict";Bde=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var M1={};He(M1,{json:()=>Vde});var Vde,Pj=D(()=>{"use strict";Vde=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]});var $1={};He($1,{json:()=>Ude});var Ude,Lj=D(()=>{"use strict";Ude=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]});var P1={};He(P1,{json:()=>zde});var zde,Bj=D(()=>{"use strict";zde=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]});var L1={};He(L1,{json:()=>Gde});var Gde,Vj=D(()=>{"use strict";Gde=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]});var B1={};He(B1,{json:()=>Hde});var Hde,Uj=D(()=>{"use strict";Hde=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]});var V1={};He(V1,{json:()=>Wde});var Wde,zj=D(()=>{"use strict";Wde=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]});var U1={};He(U1,{json:()=>jde});var jde,Gj=D(()=>{"use strict";jde=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]});var z1={};He(z1,{json:()=>qde});var qde,Hj=D(()=>{"use strict";qde=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]});var G1={};He(G1,{json:()=>Kde});var Kde,Wj=D(()=>{"use strict";Kde=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}]});var H1={};He(H1,{json:()=>Xde});var Xde,jj=D(()=>{"use strict";Xde=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}]});var W1={};He(W1,{json:()=>Yde});var Yde,qj=D(()=>{"use strict";Yde=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}]});var j1={};He(j1,{json:()=>Zde});var Zde,Kj=D(()=>{"use strict";Zde=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]});var q1={};He(q1,{json:()=>Qde});var Qde,Xj=D(()=>{"use strict";Qde=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]});var K1={};He(K1,{json:()=>Jde});var Jde,Yj=D(()=>{"use strict";Jde=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]});var X1={};He(X1,{json:()=>efe});var efe,Zj=D(()=>{"use strict";efe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]});var Y1={};He(Y1,{json:()=>tfe});var tfe,Qj=D(()=>{"use strict";tfe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]});var Z1={};He(Z1,{json:()=>nfe});var nfe,Jj=D(()=>{"use strict";nfe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]});function rfe(e){let n=M().global;if(typeof n.atob<"u")return n.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function t6(e,n){let t=Array.isArray(e)?String.fromCharCode.apply(null,e):rfe(e);return n?t:t.toLowerCase()}function T0(e,n,t,r=!1){let o=e[n];return o!=null?t6(o.s,r):t}function S0(e,n,t){let r=e[n];return r?r.b:t}function N0(e,n,t){let r=e[n]||{},o=r.i!=null?r.i:r.f!=null?r.f:t;return typeof o=="number"?o:parseInt(o,10)}function Q1(e){switch(typeof e=="string"&&(e=pr[e]),e){case pr.DT_FLOAT:case pr.DT_HALF:return"float32";case pr.DT_INT32:case pr.DT_INT64:case pr.DT_INT8:case pr.DT_UINT8:return"int32";case pr.DT_BOOL:return"bool";case pr.DT_DOUBLE:return"float32";case pr.DT_STRING:return"string";case pr.DT_COMPLEX64:case pr.DT_COMPLEX128:return"complex64";default:return null}}function e6(e,n,t){let r=e[n];return r&&r.func?r.func.name:t}function D0(e,n,t){let r=e[n];return r&&r.type?Q1(r.type):t}function k0(e,n,t){let r=e[n];return r&&r.list&&r.list.type?r.list.type.map(o=>Q1(o)):t}function n6(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(n=>typeof n.size=="number"?n.size:parseInt(n.size,10)):[]}function _0(e,n,t){let r=e[n];return r&&r.shape?n6(r.shape):t}function A0(e,n,t){let r=e[n];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):t}function R0(e,n,t,r=!1){let o=e[n];return o&&o.list&&o.list.s?o.list.s.map(s=>t6(s,r)):t}function F0(e,n,t){let r=e[n];return r&&r.list&&r.list.shape?r.list.shape.map(o=>n6(o)):t}function O0(e,n,t){let r=e[n];return r&&r.list&&r.list.b?r.list.b:t}var Zh,J1=D(()=>{"use strict";T();Rj();I0();At();Mj();$j();Pj();Lj();Bj();Vj();Uj();zj();Gj();Hj();Wj();jj();qj();Kj();Xj();Yj();Zj();Qj();Jj();Zh=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let n=[F1,O1,M1,$1,P1,L1,B1,V1,U1,z1,G1,H1,W1,j1,q1,K1,X1,Y1,Z1],t=[].concat(...n.map(r=>r.json));this.opMappers=t.reduce((r,o)=>(r[o.tfOpName]=o,r),{})}transformGraph(n,t={}){let r=n.node,o=[],s=[],i=[],a=r.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&i.push(h[g.name]),h),{}),c=[],l=[],u={},p={};t!=null&&(u=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let d=Object.keys(a);d.forEach(h=>{let g=a[h];g.inputNames.forEach((x,v)=>{let[w,,I]=Io(x),_=a[w];if(_.outputs!=null){let A=_.outputs.indexOf(I);if(A!==-1){let R=`${w}:${A}`;g.inputNames[v]=R}}g.inputs.push(_),_.children.push(g)})}),Object.keys(p).length===0?d.forEach(h=>{let g=a[h];g.children.length===0&&l.push(g)}):Object.keys(p).forEach(h=>{let[g]=Io(h),x=a[g];x!=null&&(x.signatureKey=p[h],l.push(x))}),Object.keys(u).length>0?Object.keys(u).forEach(h=>{let[g]=Io(h),x=a[g];x&&(x.signatureKey=u[h],c.push(x))}):c=o;let f={};n.library!=null&&n.library.function!=null&&(f=n.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let m={nodes:a,inputs:c,outputs:l,weights:s,placeholders:o,signature:t,functions:f};return i.length>0&&(m.initNodes=i),m}mapSignatureEntries(n){return Object.keys(n||{}).reduce((t,r)=>(t[n[r].name]=r,t),{})}mapNode(n){let t=w0(n.op)||this.opMappers[n.op]||{};n.attr==null&&(n.attr={});let r={name:n.name,op:n.op,category:t.category,inputNames:(n.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:n.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=T0(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=T0(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=R0(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=R0(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=N0(n.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=N0(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=A0(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=A0(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=S0(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=S0(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=O0(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=O0(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=_0(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=_0(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=F0(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=F0(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=D0(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=D0(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=k0(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=k0(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=e6(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=e6(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${n.op}`)}return o[s.name]={value:a,type:i},o},{})),r}mapFunction(n){let t=n.nodeDef,r=[],o=[],s={};t!=null&&(s=t.reduce((p,d)=>(p[d.name]=this.mapNode(d),d.op==="Const"&&o.push(p[d.name]),p),{}));let i=[],a=[];n.signature.inputArg.forEach(p=>{let[d]=Io(p.name),f={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Q1(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,i.push(f),s[d]=f}),Object.keys(s).forEach(p=>{let d=s[p];d.inputNames.forEach((f,m)=>{let[h,,g]=Io(f),x=s[h];if(x.outputs!=null){let v=x.outputs.indexOf(g);if(v!==-1){let w=`${h}:${v}`;d.inputNames[m]=w}}d.inputs.push(x),x.children.push(d)})});let l=n.ret;n.signature.outputArg.forEach(p=>{let[d,f]=Io(l[p.name]),m=s[d];m!=null&&(m.defaultOutput=f,a.push(m))});let u=this.mapArgsToSignature(n);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:r,signature:u}}mapArgsToSignature(n){return{methodName:n.signature.name,inputs:n.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:n.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,n.ret),t),{})}}mapArgToTensorInfo(n,t){let r=n.name;return t!=null&&(r=t[r]),{name:r,dtype:n.type}}}});var M0,r6=D(()=>{"use strict";At();J1();M0=class{constructor(n,t,r){this.node=n,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=n.inputNames.map(o=>this.getInput(o)),n.rawAttrs!=null&&(this.attrs=Object.keys(n.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(n){return Lt(n,this.tensorMap,this.context)}getAttr(n,t){let r=this.node.rawAttrs[n];if(r.tensor!=null)return Lt(n,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return N0(this.node.rawAttrs,n,t);if(r.s!=null)return T0(this.node.rawAttrs,n,t);if(r.b!=null)return S0(this.node.rawAttrs,n,t);if(r.shape!=null)return _0(this.node.rawAttrs,n,t);if(r.type!=null)return D0(this.node.rawAttrs,n,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return A0(this.node.rawAttrs,n,t);if(r.list.s!=null)return R0(this.node.rawAttrs,n,t);if(r.list.shape!=null)return F0(this.node.rawAttrs,n,t);if(r.list.b!=null)return O0(this.node.rawAttrs,n,t);if(r.list.type!=null)return k0(this.node.rawAttrs,n,t)}return t}}});var Xe={};He(Xe,{OP_SCOPE_SUFFIX:()=>ly,abs:()=>Kt,acos:()=>RE,acosh:()=>FE,add:()=>de,addN:()=>OE,all:()=>ME,any:()=>$E,argMax:()=>PE,argMin:()=>LE,asin:()=>BE,asinh:()=>VE,atan:()=>UE,atan2:()=>zE,atanh:()=>GE,avgPool:()=>km,avgPool3d:()=>KE,basicLSTMCell:()=>YE,batchNorm:()=>Es,batchNorm2d:()=>QE,batchNorm3d:()=>JE,batchNorm4d:()=>eT,batchToSpaceND:()=>Am,bincount:()=>Fm,bitwiseAnd:()=>nT,booleanMaskAsync:()=>o$,broadcastArgs:()=>rT,broadcastTo:()=>Ts,buffer:()=>le,cast:()=>_e,ceil:()=>sT,clipByValue:()=>iT,clone:()=>Vn,complex:()=>An,concat:()=>ut,concat1d:()=>aT,concat2d:()=>cT,concat3d:()=>lT,concat4d:()=>uT,conv1d:()=>pT,conv2d:()=>Ss,conv2dTranspose:()=>fT,conv3d:()=>mT,conv3dTranspose:()=>hT,cos:()=>gT,cosh:()=>xT,cosineWindow:()=>Id,cumprod:()=>yT,cumsum:()=>vT,denseBincount:()=>bT,depthToSpace:()=>CT,depthwiseConv2d:()=>Nu,diag:()=>wT,dilation2d:()=>IT,div:()=>Ve,divNoNan:()=>TT,dot:()=>ST,dropout:()=>y$,einsum:()=>Ds,elu:()=>$m,enclosingPowerOfTwo:()=>Wy,ensureShape:()=>kT,equal:()=>Mm,erf:()=>_T,euclideanNorm:()=>FT,exp:()=>Sr,expandDims:()=>Vr,expm1:()=>OT,eye:()=>Vm,fft:()=>Fu,fill:()=>po,floor:()=>Um,floorDiv:()=>Sm,fused:()=>jy,gather:()=>zm,gatherND:()=>m$,greater:()=>va,greaterEqual:()=>Gm,ifft:()=>Ia,imag:()=>Rs,image:()=>sL,inTopKAsync:()=>b$,irfft:()=>uh,isFinite:()=>BT,isInf:()=>VT,isNaN:()=>UT,leakyRelu:()=>Wm,less:()=>yd,lessEqual:()=>Du,linalg:()=>iL,linspace:()=>HT,localResponseNormalization:()=>WT,log:()=>Ho,log1p:()=>qm,logSigmoid:()=>KT,logSoftmax:()=>XT,logSumExp:()=>Xm,logicalAnd:()=>ba,logicalNot:()=>Ym,logicalOr:()=>Zm,logicalXor:()=>JT,losses:()=>aL,lowerBound:()=>eS,matMul:()=>je,max:()=>mo,maxPool:()=>Qm,maxPool3d:()=>nS,maxPoolWithArgmax:()=>rS,maximum:()=>Jm,mean:()=>Ca,meshgrid:()=>sS,min:()=>hd,minimum:()=>wa,mirrorPad:()=>iS,mod:()=>aS,moments:()=>cS,movingAverage:()=>i$,mul:()=>ee,multiRNNCell:()=>lS,multinomial:()=>uS,neg:()=>on,norm:()=>ya,notEqual:()=>th,oneHot:()=>bd,ones:()=>go,onesLike:()=>fS,op:()=>E,outerProduct:()=>mS,pad:()=>xo,pad1d:()=>hS,pad2d:()=>gS,pad3d:()=>xS,pad4d:()=>yS,pool:()=>bS,pow:()=>Go,prelu:()=>rh,print:()=>Tm,prod:()=>wS,raggedGather:()=>IS,raggedRange:()=>ES,raggedTensorToTensor:()=>TS,rand:()=>SS,randomGamma:()=>LS,randomNormal:()=>sh,randomStandardNormal:()=>VS,randomUniform:()=>Au,randomUniformInt:()=>US,range:()=>Ms,real:()=>Wo,reciprocal:()=>zS,relu:()=>$s,relu6:()=>ch,reshape:()=>U,reverse:()=>sr,reverse1d:()=>HS,reverse2d:()=>WS,reverse3d:()=>jS,reverse4d:()=>qS,rfft:()=>Ou,round:()=>lh,rsqrt:()=>XS,scalar:()=>me,scatterND:()=>c$,searchSorted:()=>vd,selu:()=>YS,separableConv2d:()=>ZS,setdiff1dAsync:()=>QS,sigmoid:()=>uo,sign:()=>JS,signal:()=>oL,sin:()=>eN,sinh:()=>tN,slice:()=>Ue,slice1d:()=>nN,slice2d:()=>rN,slice3d:()=>oN,slice4d:()=>sN,softmax:()=>iN,softplus:()=>Km,spaceToBatchND:()=>nh,sparse:()=>cL,sparseToDense:()=>d$,spectral:()=>rL,split:()=>jo,sqrt:()=>On,square:()=>Yt,squaredDifference:()=>dh,squeeze:()=>Mu,stack:()=>Cn,step:()=>mh,stridedSlice:()=>uN,string:()=>lL,sub:()=>ge,sum:()=>Ze,tan:()=>pN,tanh:()=>pd,tensor:()=>xn,tensor1d:()=>Qt,tensor2d:()=>Ps,tensor3d:()=>hh,tensor4d:()=>fN,tensor5d:()=>mN,tensor6d:()=>hN,tensorScatterUpdate:()=>xN,tile:()=>As,topk:()=>yN,transpose:()=>$u,truncatedNormal:()=>vN,unique:()=>bN,unsortedSegmentSum:()=>CN,unstack:()=>ir,upperBound:()=>wN,variable:()=>IN,where:()=>or,whereAsync:()=>yh,zeros:()=>Nr,zerosLike:()=>Bt});var en=D(()=>{"use strict";Ch();});var o6,s6=D(()=>{"use strict";en();At();o6=(e,n,t,r=Xe)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(b("a",e,n,t),b("b",e,n,t))];case"AddN":return[r.addN(b("tensors",e,n,t))];case"FloorMod":case"Mod":return[r.mod(b("a",e,n,t),b("b",e,n,t))];case"Mul":return[r.mul(b("a",e,n,t),b("b",e,n,t))];case"RealDiv":case"Div":return[r.div(b("a",e,n,t),b("b",e,n,t))];case"DivNoNan":return[r.divNoNan(b("a",e,n,t),b("b",e,n,t))];case"FloorDiv":return[r.floorDiv(b("a",e,n,t),b("b",e,n,t))];case"Sub":return[r.sub(b("a",e,n,t),b("b",e,n,t))];case"Minimum":return[r.minimum(b("a",e,n,t),b("b",e,n,t))];case"Maximum":return[r.maximum(b("a",e,n,t),b("b",e,n,t))];case"Pow":return[r.pow(b("a",e,n,t),b("b",e,n,t))];case"SquaredDifference":return[r.squaredDifference(b("a",e,n,t),b("b",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var i6,a6=D(()=>{"use strict";en();At();i6=(e,n,t,r=Xe)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(b("x",e,n,t))];case"Acos":return[r.acos(b("x",e,n,t))];case"Acosh":return[r.acosh(b("x",e,n,t))];case"Asin":return[r.asin(b("x",e,n,t))];case"Asinh":return[r.asinh(b("x",e,n,t))];case"Atan":return[r.atan(b("x",e,n,t))];case"Atan2":return[r.atan2(b("x",e,n,t),b("y",e,n,t))];case"Atanh":return[r.atanh(b("x",e,n,t))];case"Ceil":return[r.ceil(b("x",e,n,t))];case"Complex":return[r.complex(b("real",e,n,t),b("imag",e,n,t))];case"Cos":return[r.cos(b("x",e,n,t))];case"Cosh":return[r.cosh(b("x",e,n,t))];case"Elu":return[r.elu(b("x",e,n,t))];case"Erf":return[r.erf(b("x",e,n,t))];case"Exp":return[r.exp(b("x",e,n,t))];case"Expm1":return[r.expm1(b("x",e,n,t))];case"Floor":return[r.floor(b("x",e,n,t))];case"Log":return[r.log(b("x",e,n,t))];case"Log1p":return[r.log1p(b("x",e,n,t))];case"Imag":return[r.imag(b("x",e,n,t))];case"Neg":return[r.neg(b("x",e,n,t))];case"Reciprocal":return[r.reciprocal(b("x",e,n,t))];case"Real":return[r.real(b("x",e,n,t))];case"Relu":return[r.relu(b("x",e,n,t))];case"Round":return[r.round(b("x",e,n,t))];case"Selu":return[r.selu(b("x",e,n,t))];case"Sigmoid":return[r.sigmoid(b("x",e,n,t))];case"Sin":return[r.sin(b("x",e,n,t))];case"Sign":return[r.sign(b("x",e,n,t))];case"Sinh":return[r.sinh(b("x",e,n,t))];case"Softplus":return[r.softplus(b("x",e,n,t))];case"Sqrt":return[r.sqrt(b("x",e,n,t))];case"Square":return[r.square(b("x",e,n,t))];case"Tanh":return[r.tanh(b("x",e,n,t))];case"Tan":return[r.tan(b("x",e,n,t))];case"ClipByValue":return[r.clipByValue(b("x",e,n,t),b("clipValueMin",e,n,t),b("clipValueMax",e,n,t))];case"Relu6":return[r.relu6(b("x",e,n,t))];case"Rsqrt":return[r.rsqrt(Lt(e.inputNames[0],n,t))];case"LeakyRelu":return[r.leakyRelu(b("x",e,n,t),b("alpha",e,n,t))];case"Prelu":return[r.prelu(b("x",e,n,t),b("alpha",e,n,t))];case"IsNan":return[r.isNaN(Lt(e.inputNames[0],n,t))];case"IsInf":return[r.isInf(Lt(e.inputNames[0],n,t))];case"IsFinite":return[r.isFinite(Lt(e.inputNames[0],n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});function dr(e,n,t=""){if(!(typeof e=="number"||typeof n=="number")){y.assert(e.length===n.length,()=>t+` Shapes ${e} and ${n} must match`);for(let r=0;r<e.length;r++){let o=e[r],s=n[r];y.assert(o<0||s<0||o===s,()=>t+` Shapes ${e} and ${n} must match`)}}}function c6(e){return!(typeof e=="number"||e.some(n=>n<0))}function Qd(e,n,t){let r=$0(e,t),o=!c6(r);if(o&&n.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(o&&n.forEach(s=>{r=$0(s.shape,r)}),!c6(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function $0(e,n){if(typeof e=="number")return n;if(typeof n=="number")return e;if(e.length!==n.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${n}`);let t=[];for(let r=0;r<e.length;++r){let o=e[r],s=n[r];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${n}`);t[r]=o>=0?o:s}return t}var ek=D(()=>{"use strict";T();});var P0,l6=D(()=>{"use strict";T();ek();P0=class{constructor(n,t,r,o,s,i,a){this.name=n,this.dtype=t,this.maxSize=r,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=me(0),Fn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(n){this.tensors.forEach(t=>{(n==null||!n.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||n>=this.size())throw new Error(`Tried to read from index ${n}, but array size is: ${this.size()}`);let t=this.tensors[n];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${n} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(n){return n.map(t=>this.read(t))}write(n,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||!this.dynamicSize&&n>=this.maxSize)throw new Error(`Tried to write to index ${n}, but array is not resizeable and size is: ${this.maxSize}`);let r=this.tensors[n]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),dr(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${n}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been written.`);r.tensor=t,Fn(t),r.written=!0,this.tensors[n]=r}writeMany(n,t){if(n.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${n.length} is not the same as tensors size: ${t.length}.`);n.forEach((r,o)=>this.write(r,t[o]))}gather(n,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(n)n=n.slice(0,this.size());else{n=[];for(let o=0;o<this.size();o++)n.push(o)}if(n.length===0)return xn([],[0].concat(this.elementShape));let r=this.readMany(n);return dr(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Cn(r,0)}concat(n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${n}`);if(this.size()===0)return xn([],[0].concat(this.elementShape));let t=[];for(let o=0;o<this.size();o++)t.push(o);let r=this.readMany(t);return dr(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),ut(r,0)}scatter(n,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(n.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${t.shape[0]}`);let r=Math.max(...n);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(n,ir(t,0))}split(n,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0,o=n.map(c=>(r+=c,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&n.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${n.length}), and the TensorArray is not marked as dynamically resizeable`);let s=r===0?0:t.size/r,i=[];Ce(()=>{t=U(t,[1,r,s]);for(let c=0;c<n.length;++c){let u=[0,c===0?0:o[c-1],0],p=[1,n[c],s];i[c]=U(Ue(t,u,p),this.elementShape)}return i});let a=[];for(let c=0;c<n.length;c++)a[c]=c;this.writeMany(a,i)}}});function u6(e,n,t){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==t)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${t}`);let o=e.shape.slice(1);dr(o,n,"TensorList shape mismatch: ");let s=ir(e);return new Jd(s,n,r)}function p6(e,n,t,r){return new Jd([],e,n,r)}function d6(e,n,t,r){if(n.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${e.shape[0]}`);let o=Math.max(...n);if(r!=null&&r!==-1&&o>=r)throw new Error(`Max index must be < array size (${o}  vs. ${r})`);let s=new Jd([],t,e.dtype,r),i=ir(e,0);return n.forEach((a,c)=>{s.setItem(a,i[c])}),s}function f6(e,n,t){let r=0,o=n.map(u=>(r+=u,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=$0(s,t),a=r===0?0:e.size/r,c=Ce(()=>{let u=[];e=U(e,[1,r,a]);for(let p=0;p<n.length;++p){let f=[0,p===0?0:o[p-1],0],m=[1,n[p],a];u[p]=U(Ue(e,f,m),i)}return e.dispose(),u}),l=new Jd([],t,e.dtype,n.length);for(let u=0;u<c.length;u++)l.setItem(u,c[u]);return l}var Jd,m6=D(()=>{"use strict";T();ek();Jd=class e{get id(){return this.idTensor.id}constructor(n,t,r,o=-1){this.tensors=n,this.elementShape=t,this.elementDtype=r,n?.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);dr(t,s.shape,"TensorList shape mismatch: "),Fn(s)}),this.idTensor=me(0),this.maxNumElements=o,Fn(this.idTensor)}copy(){return new e([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(n){this.tensors.forEach(t=>{(n==null||!n.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(n,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);dr(n,this.elementShape,"TensorList shape mismatch: ");let o=Qd(this.elementShape,this.tensors,n);return Ce(()=>{let s=this.tensors.map(i=>U(i,o));return Cn(s,0)})}popBack(n,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=Qd(this.elementShape,this.tensors,n),o=this.tensors.pop();return o.kept=!1,dr(o.shape,n,"TensorList shape mismatch: "),U(o,r)}pushBack(n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(dr(n.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Fn(n),this.tensors.push(n)}resize(n){if(n<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${n}`);if(this.maxNumElements!==-1&&n>this.maxNumElements)throw new Error(`TensorListResize input size ${n} is greater maxNumElement ${this.maxNumElements}.`);let t=new e([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=n;for(let r=0;r<Math.min(this.tensors.length,n);++r)t.tensors[r]=this.tensors[r];return t}getItem(n,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(n<0||n>this.tensors.length)throw new Error(`Trying to access element ${n} in a list with ${this.tensors.length} elements.`);if(this.tensors[n]==null)throw new Error(`element at index ${n} is null.`);dr(this.tensors[n].shape,t,"TensorList shape mismatch: ");let o=Qd(this.elementShape,this.tensors,t);return U(this.tensors[n],o)}setItem(n,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(n<0||this.maxNumElements!==-1&&n>=this.maxNumElements)throw new Error(`Trying to set element ${n} in a list with max ${this.maxNumElements} elements.`);dr(this.elementShape,t.shape,"TensorList shape mismatch: "),Fn(t),this.tensors[n]!=null&&(this.tensors[n].kept=!1),this.tensors[n]=t}gather(n,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);dr(this.elementShape,r,"TensorList shape mismatch: "),n=n.slice(0,this.size());let o=Qd(this.elementShape,this.tensors,r);return n.length===0?xn([],[0].concat(o)):Ce(()=>{let s=n.map(i=>U(this.tensors[i],o));return Cn(s,0)})}concat(n,t){if(n&&n!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${n}`);dr(this.elementShape,t,"TensorList shape mismatch: ");let r=Qd(this.elementShape,this.tensors,t);return this.size()===0?xn([],[0].concat(r)):Ce(()=>{let o=this.tensors.map(s=>U(s,r));return ut(o,0)})}}});var h6,g6=D(()=>{"use strict";T();l6();m6();At();h6=async(e,n,t)=>{switch(e.op){case"If":case"StatelessIf":{let r=b("thenBranch",e,n,t),o=b("elseBranch",e,n,t),s=b("cond",e,n,t),i=b("args",e,n,t);return(await s.data())[0]?t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[o].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{let r=b("body",e,n,t),o=b("cond",e,n,t),s=b("args",e,n,t),i=await t.functionMap[o].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),a=s.map(u=>u.id),c=await i[0].data();i.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let l=s;for(;c[0];){let u=l;l=await t.functionMap[r].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);let p=l.map(f=>f.id);u.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let d=await t.functionMap[o].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);c=await d[0].data(),d.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{let r=b("pred",e,n,t);return[Eo(r)]}case"Switch":{let r=b("pred",e,n,t),o=b("data",e,n,t);return o.kept||(o=Eo(o)),(await r.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let r=e.inputNames.find(o=>Lt(o,n,t)!==void 0);if(r){let o=Lt(r,n,t);return[Eo(o)]}return}case"Enter":{let r=b("frameName",e,n,t),o=b("tensor",e,n,t);return t.enterFrame(r),[Eo(o)]}case"Exit":{let r=b("tensor",e,n,t);return t.exitFrame(),[Eo(r)]}case"NextIteration":{let r=b("tensor",e,n,t);return t.nextIteration(),[Eo(r)]}case"TensorArrayV3":{let r=b("size",e,n,t),o=b("dtype",e,n,t),s=b("elementShape",e,n,t),i=b("dynamicSize",e,n,t),a=b("clearAfterRead",e,n,t),c=b("identicalElementShapes",e,n,t),l=b("name",e,n,t),u=new P0(l,o,r,s,c,i,a);return t.addTensorArray(u),[u.idTensor,me(1)]}case"TensorArrayWriteV3":{let r=b("tensorArrayId",e,n,t),o=b("index",e,n,t),s=b("tensor",e,n,t),i=t.getTensorArray(r.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let r=b("tensorArrayId",e,n,t),o=b("index",e,n,t);return[t.getTensorArray(r.id).read(o)]}case"TensorArrayGatherV3":{let r=b("tensorArrayId",e,n,t),o=b("indices",e,n,t),s=b("dtype",e,n,t);return[t.getTensorArray(r.id).gather(o,s)]}case"TensorArrayScatterV3":{let r=b("tensorArrayId",e,n,t),o=b("indices",e,n,t),s=b("tensor",e,n,t),i=t.getTensorArray(r.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=b("tensorArrayId",e,n,t),o=t.getTensorArray(r.id),s=b("dtype",e,n,t);return[o.concat(s)]}case"TensorArraySplitV3":{let r=b("tensorArrayId",e,n,t),o=b("tensor",e,n,t),s=b("lengths",e,n,t),i=t.getTensorArray(r.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let r=b("tensorArrayId",e,n,t),o=t.getTensorArray(r.id);return[me(o.size(),"int32")]}case"TensorArrayCloseV3":{let r=b("tensorArrayId",e,n,t),o=t.getTensorArray(r.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let r=b("tensorListId",e,n,t),o=b("index",e,n,t),s=b("tensor",e,n,t),i=t.getTensorList(r.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let r=b("tensorListId",e,n,t),o=b("index",e,n,t),s=b("elementShape",e,n,t),i=b("elementDType",e,n,t);return[t.getTensorList(r.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=b("indices",e,n,t),o=b("tensor",e,n,t),s=b("elementShape",e,n,t),i=b("numElements",e,n,t),a=d6(o,r,s,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=b("elementShape",e,n,t),o=b("elementDType",e,n,t),s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=b(s,e,n,t),a=e.op==="TensorListReserve"?-1:i,c=p6(r,o,i,a);return t.addTensorList(c),[c.idTensor]}case"TensorListGather":{let r=b("tensorListId",e,n,t),o=b("indices",e,n,t),s=b("elementShape",e,n,t),i=b("elementDType",e,n,t);return[t.getTensorList(r.id).gather(o,i,s)]}case"TensorListStack":{let r=b("tensorListId",e,n,t),o=b("elementShape",e,n,t),s=b("elementDType",e,n,t),i=b("numElements",e,n,t);return[t.getTensorList(r.id).stack(o,s,i)]}case"TensorListFromTensor":{let r=b("tensor",e,n,t),o=b("elementShape",e,n,t),s=b("elementDType",e,n,t),i=u6(r,o,s);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=b("tensorListId",e,n,t),o=t.getTensorList(r.id),s=b("dtype",e,n,t),i=b("elementShape",e,n,t);return[o.concat(s,i)]}case"TensorListPushBack":{let r=b("tensorListId",e,n,t),o=b("tensor",e,n,t),s=t.getTensorList(r.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let r=b("tensorListId",e,n,t),o=b("elementShape",e,n,t),s=b("elementDType",e,n,t);return[t.getTensorList(r.id).popBack(o,s)]}case"TensorListSplit":{let r=b("tensor",e,n,t),o=b("elementShape",e,n,t),s=b("lengths",e,n,t),i=f6(r,s,o);return t.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=b("tensorListId",e,n,t),o=t.getTensorList(r.id);return[me(o.size(),"int32")]}case"TensorListResize":{let r=b("tensorListId",e,n,t),o=b("size",e,n,t),i=t.getTensorList(r.id).resize(o);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}});function x6(e,n,t){let[r,o]=b("fusedOps",e,n,t),s=r==="biasadd",i=!s,a=o==="prelu",c=r==="fusedbatchnorm",l=b("numArgs",e,n,t);if(s){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=b("strides",e,n,t),p=Yh(e,n,t),d=b("dataFormat",e,n,t).toUpperCase(),f=b("dilations",e,n,t),[m,h]=b("args",e,n,t);i&&(h=m,m=void 0);let g=b("leakyreluAlpha",e,n,t);return{stride:u,pad:p,dataFormat:d,dilations:f,biasArg:m,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var y6,v6=D(()=>{"use strict";en();At();y6=(e,n,t,r=Xe)=>{switch(e.op){case"Conv1D":{let o=b("stride",e,n,t),s=b("pad",e,n,t),i=b("dataFormat",e,n,t).toUpperCase(),a=b("dilation",e,n,t);return[r.conv1d(b("x",e,n,t),b("filter",e,n,t),o,s,i,a)]}case"Conv2D":{let o=b("strides",e,n,t),s=Yh(e,n,t),i=b("dataFormat",e,n,t).toUpperCase(),a=b("dilations",e,n,t);return[r.conv2d(b("x",e,n,t),b("filter",e,n,t),[o[1],o[2]],s,i,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:p}=x6(e,n,t);return[r.fused.conv2d({x:b("x",e,n,t),filter:b("filter",e,n,t),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:p}=x6(e,n,t);return[r.fused.depthwiseConv2d({x:b("x",e,n,t),filter:b("filter",e,n,t),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=b("outputShape",e,n,t),s=b("strides",e,n,t),i=Yh(e,n,t);return[r.conv2dTranspose(b("x",e,n,t),b("filter",e,n,t),o,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=b("strides",e,n,t),s=Yh(e,n,t),i=b("dilations",e,n,t),a=b("dataFormat",e,n,t).toUpperCase();return[r.depthwiseConv2d(b("input",e,n,t),b("filter",e,n,t),[o[1],o[2]],s,a,[i[1],i[2]])]}case"Conv3D":{let o=b("strides",e,n,t),s=b("pad",e,n,t),i=b("dataFormat",e,n,t).toUpperCase(),a=b("dilations",e,n,t);return[r.conv3d(b("x",e,n,t),b("filter",e,n,t),[o[1],o[2],o[3]],s,i,[a[1],a[2],a[3]])]}case"AvgPool":{let o=b("strides",e,n,t),s=b("pad",e,n,t),i=b("kernelSize",e,n,t);return[r.avgPool(b("x",e,n,t),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=b("strides",e,n,t),s=b("pad",e,n,t),i=b("kernelSize",e,n,t);return[r.maxPool(b("x",e,n,t),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=b("strides",e,n,t),s=b("pad",e,n,t),i=b("kernelSize",e,n,t),a=b("includeBatchInIndex",e,n,t),{result:c,indexes:l}=r.maxPoolWithArgmax(b("x",e,n,t),[i[1],i[2]],[o[1],o[2]],s,a);return[c,l]}case"AvgPool3D":{let o=b("strides",e,n,t),s=b("pad",e,n,t),i=b("kernelSize",e,n,t);return[r.avgPool3d(b("x",e,n,t),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=b("strides",e,n,t),s=b("pad",e,n,t),i=b("kernelSize",e,n,t);return[r.maxPool3d(b("x",e,n,t),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=b("strides",e,n,t),s=b("pad",e,n,t),i=b("dilations",e,n,t),a=o[1],c=o[2],l=i[1],u=i[2];return[r.dilation2d(b("x",e,n,t),b("filter",e,n,t),[a,c],s,[l,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var b6,C6=D(()=>{"use strict";en();At();b6=(e,n,t,r=Xe)=>{switch(e.op){case"Fill":{let o=b("shape",e,n,t),s=b("dtype",e,n,t),i=b("value",e,n,t);return[r.fill(o,i,s)]}case"LinSpace":{let o=b("start",e,n,t),s=b("stop",e,n,t),i=b("num",e,n,t);return[r.linspace(o,s,i)]}case"Multinomial":{let o=b("logits",e,n,t),s=b("numSamples",e,n,t),i=b("seed",e,n,t);return[r.multinomial(o,s,i)]}case"OneHot":{let o=b("indices",e,n,t),s=b("depth",e,n,t),i=b("onValue",e,n,t),a=b("offValue",e,n,t),c=b("dtype",e,n,t);return[r.oneHot(o,s,i,a,c)]}case"Ones":return[r.ones(b("shape",e,n,t),b("dtype",e,n,t))];case"OnesLike":return[r.onesLike(b("x",e,n,t))];case"RandomStandardNormal":return[r.randomStandardNormal(b("shape",e,n,t),b("dtype",e,n,t),b("seed",e,n,t))];case"RandomUniform":return[r.randomUniform(b("shape",e,n,t),b("minval",e,n,t),b("maxval",e,n,t),b("dtype",e,n,t))];case"RandomUniformInt":return[r.randomUniformInt(b("shape",e,n,t),b("minval",e,n,t),b("maxval",e,n,t),b("seed",e,n,t))];case"Range":{let o=b("start",e,n,t),s=b("stop",e,n,t),i=b("step",e,n,t);return[r.range(o,s,i,b("dtype",e,n,t))]}case"TruncatedNormal":{let o=b("shape",e,n,t),s=b("mean",e,n,t),i=b("stdDev",e,n,t),a=b("seed",e,n,t);return[r.truncatedNormal(o,s,i,b("dtype",e,n,t),a)]}case"Zeros":return[r.zeros(b("shape",e,n,t),b("dtype",e,n,t))];case"ZerosLike":return[r.zerosLike(b("x",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});function tk(e,n,t){let r=b("boxes",e,n,t),o=b("scores",e,n,t),s=b("maxOutputSize",e,n,t),i=b("iouThreshold",e,n,t),a=b("scoreThreshold",e,n,t),c=b("softNmsSigma",e,n,t);return{boxes:r,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:c}}var w6,I6=D(()=>{"use strict";en();At();w6=async(e,n,t,r,o=Xe)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:l,softNmsSigma:u}=tk(e,n,t),p=await o.image.nonMaxSuppressionWithScoreAsync(s,i,a,c,l,u);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:l}=tk(e,n,t),u=b("padToMaxOutputSize",e,n,t),p=await o.image.nonMaxSuppressionPaddedAsync(s,i,a,c,l,u);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:a,iouThreshold:c,scoreThreshold:l}=tk(e,n,t);return[await o.image.nonMaxSuppressionAsync(s,i,a,c,l)]}case"Where":{let s=o.cast(b("condition",e,n,t),"bool"),i=[await o.whereAsync(s)];return s.dispose(),i}case"ListDiff":return o.setdiff1dAsync(b("x",e,n,t),b("y",e,n,t));default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var E6,T6=D(()=>{"use strict";en();At();E6=(e,n,t,r=Xe)=>{switch(e.op){case"LowerBound":{let o=b("sortedSequence",e,n,t),s=b("values",e,n,t);return[r.lowerBound(o,s)]}case"TopKV2":{let o=b("x",e,n,t),s=b("k",e,n,t),i=b("sorted",e,n,t),a=r.topk(o,s,i);return[a.values,a.indices]}case"UpperBound":{let o=b("sortedSequence",e,n,t),s=b("values",e,n,t);return[r.upperBound(o,s)]}case"Unique":{let o=b("x",e,n,t),s=r.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=b("x",e,n,t),s=b("axis",e,n,t),i=r.unique(o,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var S6,N6=D(()=>{"use strict";en();At();S6=(e,n,t,r=Xe)=>{switch(e.op){case"Const":return n[e.name];case"PlaceholderWithDefault":let o=b("default",e,n,t);return[Lt(e.name,n,t)||o];case"Placeholder":return[Lt(e.name,n,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=b("x",e,n,t);return[Eo(u)]}case"IdentityN":return b("x",e,n,t).map(u=>Eo(u));case"Snapshot":let s=b("x",e,n,t);return[Eo(s)];case"Shape":return[r.tensor1d(b("x",e,n,t).shape,"int32")];case"ShapeN":return b("x",e,n,t).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(b("x",e,n,t).size,"int32")];case"Rank":return[r.scalar(b("x",e,n,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=b("x",e,n,t),a=b("data",e,n,t),c=b("message",e,n,t),l=b("summarize",e,n,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(c);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var L0,D6=D(()=>{"use strict";T();en();L0=class{get id(){return this.handle.id}constructor(n,t){this.keyDType=n,this.valueDType=t,this.handle=me(0),this.tensorMap=new Map,Fn(this.handle)}clearAndClose(){this.tensorMap.forEach(n=>n.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return me(this.size(),"int32")}async import(n,t){this.checkKeyAndValueTensor(n,t);let r=await n.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),Ce(()=>{let o=ir(t),s=r.length,i=o.length;y.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let c=r[a],l=o[a];Fn(l),this.tensorMap.set(c,l)}return this.handle})}async find(n,t){this.checkKeyAndValueTensor(n,t);let r=await n.data();return Ce(()=>{let o=[];for(let s=0;s<r.length;s++){let i=r[s],a=this.findWithDefault(i,t);o.push(a)}return Cn(o)})}findWithDefault(n,t){let r=this.tensorMap.get(n);return r??t}checkKeyAndValueTensor(n,t){if(n.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${n.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}});var k6,_6=D(()=>{"use strict";D6();At();k6=async(e,n,t,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let o=r.getHashTableHandleByName(e.name);if(o!=null)return[o];{let s=b("keyDType",e,n,t),i=b("valueDType",e,n,t),a=new L0(s,i);return r.addHashTable(e.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let o=b("tableHandle",e,n,t,r),s=b("keys",e,n,t),i=b("values",e,n,t);return[await r.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=b("tableHandle",e,n,t,r),s=b("keys",e,n,t),i=b("defaultValue",e,n,t);return[await r.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=b("tableHandle",e,n,t,r);return[r.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var A6,R6=D(()=>{"use strict";en();At();A6=(e,n,t,r=Xe)=>{switch(e.op){case"ResizeBilinear":{let o=b("images",e,n,t),s=b("size",e,n,t),i=b("alignCorners",e,n,t),a=b("halfPixelCenters",e,n,t);return[r.image.resizeBilinear(o,[s[0],s[1]],i,a)]}case"ResizeNearestNeighbor":{let o=b("images",e,n,t),s=b("size",e,n,t),i=b("alignCorners",e,n,t),a=b("halfPixelCenters",e,n,t);return[r.image.resizeNearestNeighbor(o,[s[0],s[1]],i,a)]}case"CropAndResize":{let o=b("image",e,n,t),s=b("boxes",e,n,t),i=b("boxInd",e,n,t),a=b("cropSize",e,n,t),c=b("method",e,n,t),l=b("extrapolationValue",e,n,t);return[r.image.cropAndResize(o,s,i,a,c,l)]}case"ImageProjectiveTransformV3":{let o=b("images",e,n,t),s=b("transforms",e,n,t),i=b("outputShape",e,n,t),a=b("fillValue",e,n,t),c=b("interpolation",e,n,t),l=b("fillMode",e,n,t);return[r.image.transform(o,s,c.toLowerCase(),l.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var F6,O6=D(()=>{"use strict";en();At();F6=(e,n,t,r=Xe)=>{switch(e.op){case"Equal":return[r.equal(b("a",e,n,t),b("b",e,n,t))];case"NotEqual":return[r.notEqual(b("a",e,n,t),b("b",e,n,t))];case"Greater":return[r.greater(b("a",e,n,t),b("b",e,n,t))];case"GreaterEqual":return[r.greaterEqual(b("a",e,n,t),b("b",e,n,t))];case"Less":return[r.less(b("a",e,n,t),b("b",e,n,t))];case"LessEqual":return[r.lessEqual(b("a",e,n,t),b("b",e,n,t))];case"LogicalAnd":return[r.logicalAnd(b("a",e,n,t),b("b",e,n,t))];case"LogicalNot":return[r.logicalNot(b("a",e,n,t))];case"LogicalOr":return[r.logicalOr(b("a",e,n,t),b("b",e,n,t))];case"Select":case"SelectV2":return[r.where(b("condition",e,n,t),b("a",e,n,t),b("b",e,n,t))];case"BitwiseAnd":return[r.bitwiseAnd(b("a",e,n,t),b("b",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var M6,$6=D(()=>{"use strict";en();At();M6=(e,n,t,r=Xe)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(b("a",e,n,t),b("b",e,n,t),b("transposeA",e,n,t),b("transposeB",e,n,t))];case"Einsum":return[r.einsum(b("equation",e,n,t),...b("tensors",e,n,t))];case"Transpose":return[r.transpose(b("x",e,n,t),b("perm",e,n,t))];case"_FusedMatMul":let[o,s]=b("fusedOps",e,n,t),i=o==="biasadd",a=s==="prelu",c=b("numArgs",e,n,t),l=b("leakyreluAlpha",e,n,t);if(i){if(a&&c!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&c!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,p]=b("args",e,n,t);return[r.fused.matMul({a:b("a",e,n,t),b:b("b",e,n,t),transposeA:b("transposeA",e,n,t),transposeB:b("transposeB",e,n,t),bias:u,activation:s,preluActivationWeights:p,leakyreluAlpha:l})];case"MatrixBandPart":return[r.linalg.bandPart(b("a",e,n,t),b("numLower",e,n,t),b("numUpper",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var P6,L6=D(()=>{"use strict";en();At();P6=(e,n,t,r=Xe)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(b("x",e,n,t),b("axis",e,n,t),b("keepDims",e,n,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(b("x",e,n,t),b("mean",e,n,t),b("variance",e,n,t),b("offset",e,n,t),b("scale",e,n,t),b("epsilon",e,n,t))];case"FusedBatchNormV3":return[r.batchNorm(b("x",e,n,t),b("mean",e,n,t),b("variance",e,n,t),b("offset",e,n,t),b("scale",e,n,t),b("epsilon",e,n,t))];case"LRN":return[r.localResponseNormalization(b("x",e,n,t),b("radius",e,n,t),b("bias",e,n,t),b("alpha",e,n,t),b("beta",e,n,t))];case"Softmax":return[r.softmax(b("x",e,n,t))];case"LogSoftmax":return[r.logSoftmax(b("x",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var B6,V6=D(()=>{"use strict";en();At();B6=(e,n,t,r=Xe)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:o,outputDenseValues:s}=r.raggedGather(b("paramsNestedSplits",e,n,t),b("paramsDenseValues",e,n,t),b("indices",e,n,t),b("outputRaggedRank",e,n,t));return o.concat(s)}case"RaggedRange":{let{rtNestedSplits:o,rtDenseValues:s}=r.raggedRange(b("starts",e,n,t),b("limits",e,n,t),b("splits",e,n,t));return[o,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(b("shape",e,n,t),b("values",e,n,t),b("defaultValue",e,n,t),b("rowPartitionTensors",e,n,t),b("rowPartitionTypes",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var U6,z6=D(()=>{"use strict";en();At();U6=(e,n,t,r=Xe)=>{switch(e.op){case"Max":{let a=b("axis",e,n,t),c=b("keepDims",e,n,t);return[r.max(b("x",e,n,t),a,c)]}case"Mean":{let a=b("axis",e,n,t),c=b("keepDims",e,n,t);return[r.mean(b("x",e,n,t),a,c)]}case"Min":{let a=b("axis",e,n,t),c=b("keepDims",e,n,t);return[r.min(b("x",e,n,t),a,c)]}case"Sum":{let a=b("axis",e,n,t),c=b("keepDims",e,n,t);return[r.sum(b("x",e,n,t),a,c)]}case"All":{let a=b("axis",e,n,t),c=b("keepDims",e,n,t);return[r.all(b("x",e,n,t),a,c)]}case"Any":{let a=b("axis",e,n,t),c=b("keepDims",e,n,t);return[r.any(b("x",e,n,t),a,c)]}case"ArgMax":{let a=b("axis",e,n,t);return[r.argMax(b("x",e,n,t),a)]}case"ArgMin":{let a=b("axis",e,n,t);return[r.argMin(b("x",e,n,t),a)]}case"Prod":{let a=b("axis",e,n,t),c=b("keepDims",e,n,t);return[r.prod(b("x",e,n,t),a,c)]}case"Cumprod":{let a=b("axis",e,n,t),c=b("exclusive",e,n,t),l=b("reverse",e,n,t);return[r.cumprod(b("x",e,n,t),a,c,l)]}case"Cumsum":{let a=b("axis",e,n,t),c=b("exclusive",e,n,t),l=b("reverse",e,n,t);return[r.cumsum(b("x",e,n,t),a,c,l)]}case"Bincount":let o=b("x",e,n,t),s=b("weights",e,n,t),i=b("size",e,n,t);return[r.bincount(o,s,i)];case"DenseBincount":{let a=b("x",e,n,t),c=b("weights",e,n,t),l=b("size",e,n,t),u=b("binaryOutput",e,n,t);return[r.denseBincount(a,c,l,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var G6,H6=D(()=>{"use strict";T();en();At();G6=(e,n,t,r=Xe)=>{switch(e.op){case"ConcatV2":case"Concat":{let o=b("n",e,n,t),s=b("axis",e,n,t),i=b("tensors",e,n,t);return i=i.slice(0,o),[r.concat(i,s)]}case"Gather":{let o=b("x",e,n,t),s=b("indices",e,n,t);return[r.gather(o,r.cast(s,"int32"),0)]}case"GatherV2":{let o=b("axis",e,n,t),s=b("batchDims",e,n,t),i=b("x",e,n,t),a=b("indices",e,n,t);return[r.gather(i,r.cast(a,"int32"),o,s)]}case"Reverse":{let o=b("dims",e,n,t),s=[];for(let a=0;a<o.length;a++)o[a]&&s.push(a);let i=b("x",e,n,t);return[r.reverse(i,s)]}case"ReverseV2":{let o=b("axis",e,n,t),s=b("x",e,n,t);return[r.reverse(s,o)]}case"Slice":{let o=b("begin",e,n,t),s=b("size",e,n,t);return[r.slice(b("x",e,n,t),o,s)]}case"StridedSlice":{let o=b("begin",e,n,t),s=b("end",e,n,t),i=b("strides",e,n,t),a=b("beginMask",e,n,t),c=b("endMask",e,n,t),l=b("ellipsisMask",e,n,t),u=b("newAxisMask",e,n,t),p=b("shrinkAxisMask",e,n,t),d=b("x",e,n,t);return[r.stridedSlice(d,o,s,i,a,c,l,u,p)]}case"Pack":return Ce(()=>{let o=b("axis",e,n,t),s=b("tensors",e,n,t),i=s[0].shape,a=r.squeeze(s[0]).shape,c=s.map(l=>{let u=y.arraysEqual(l.shape,i);if(!u&&!y.arraysEqual(r.squeeze(l).shape,a))throw new Error("the input tensors shape does not match");return u?l:r.reshape(l,i)});return[r.stack(c,o)]});case"Unpack":{let o=b("axis",e,n,t),s=b("tensor",e,n,t);return r.unstack(s,o)}case"Tile":{let o=b("reps",e,n,t);return[r.tile(b("x",e,n,t),o)]}case"Split":case"SplitV":{let o=b("axis",e,n,t),s=b("numOrSizeSplits",e,n,t),i=b("x",e,n,t);return r.split(i,s,o)}case"ScatterNd":{let o=b("indices",e,n,t),s=b("values",e,n,t),i=b("shape",e,n,t);return[r.scatterND(o,s,i)]}case"GatherNd":{let o=b("x",e,n,t),s=b("indices",e,n,t);return[r.gatherND(o,s)]}case"SparseToDense":{let o=b("sparseIndices",e,n,t),s=b("outputShape",e,n,t),i=b("sparseValues",e,n,t),a=b("defaultValue",e,n,t);return[r.sparseToDense(o,i,s,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{let o=b("indices",e,n,t),s=b("values",e,n,t),i=b("tensor",e,n,t);return[r.tensorScatterUpdate(i,o,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var W6,j6=D(()=>{"use strict";en();At();W6=(e,n,t,r=Xe)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(b("indices",e,n,t),b("values",e,n,t),b("denseShape",e,n,t),b("defaultValue",e,n,t));return[o,s,i,a]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=r.sparse.sparseReshape(b("inputIndices",e,n,t),b("inputShape",e,n,t),b("newShape",e,n,t));return[o,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(b("data",e,n,t),b("indices",e,n,t),b("segmentIds",e,n,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(b("data",e,n,t),b("indices",e,n,t),b("segmentIds",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var q6,K6=D(()=>{"use strict";en();At();q6=(e,n,t,r=Xe)=>{switch(e.op){case"FFT":return[r.fft(b("x",e,n,t))];case"IFFT":return[r.ifft(b("x",e,n,t))];case"RFFT":return[r.rfft(b("x",e,n,t))];case"IRFFT":return[r.irfft(b("x",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var X6,Y6=D(()=>{"use strict";en();At();X6=(e,n,t,r=Xe)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(b("input",e,n,t),b("pattern",e,n,t),b("rewrite",e,n,t),b("replaceGlobal",e,n,t))];case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=r.string.stringNGrams(b("data",e,n,t),b("dataSplits",e,n,t),b("separator",e,n,t),b("nGramWidths",e,n,t),b("leftPad",e,n,t),b("rightPad",e,n,t),b("padWidth",e,n,t),b("preserveShortSequences",e,n,t));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:i}=r.string.stringSplit(b("input",e,n,t),b("delimiter",e,n,t),b("skipEmpty",e,n,t));return[o,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(b("input",e,n,t),b("numBuckets",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});var Z6,Q6=D(()=>{"use strict";en();At();Z6=(e,n,t,r=Xe)=>{switch(e.op){case"Cast":return[r.cast(b("x",e,n,t),b("dtype",e,n,t))];case"ExpandDims":{let o=b("axis",e,n,t);return[r.expandDims(b("x",e,n,t),o)]}case"Squeeze":{let o=b("axis",e,n,t);return[r.squeeze(b("x",e,n,t),o)]}case"Reshape":return[r.reshape(b("x",e,n,t),b("shape",e,n,t))];case"EnsureShape":return[r.ensureShape(b("x",e,n,t),b("shape",e,n,t))];case"MirrorPad":return[r.mirrorPad(b("x",e,n,t),b("padding",e,n,t),b("mode",e,n,t))];case"PadV2":case"Pad":return[r.pad(b("x",e,n,t),b("padding",e,n,t),b("constantValue",e,n,t))];case"SpaceToBatchND":{let o=b("blockShape",e,n,t),s=b("paddings",e,n,t);return[r.spaceToBatchND(b("x",e,n,t),o,s)]}case"BatchToSpaceND":{let o=b("blockShape",e,n,t),s=b("crops",e,n,t);return[r.batchToSpaceND(b("x",e,n,t),o,s)]}case"DepthToSpace":{let o=b("blockSize",e,n,t),s=b("dataFormat",e,n,t).toUpperCase();return[r.depthToSpace(b("x",e,n,t),o,s)]}case"BroadcastTo":return[r.broadcastTo(b("x",e,n,t),b("shape",e,n,t))];case"BroadcastArgs":return[r.broadcastArgs(b("s0",e,n,t),b("s1",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}});function nk(e,n,t,r,o=Ce){let s=((i,a,c)=>{switch(i.category){case"arithmetic":return o(()=>o6(i,a,c));case"basic_math":return o(()=>i6(i,a,c));case"control":return h6(i,a,c);case"convolution":return o(()=>y6(i,a,c));case"creation":return o(()=>b6(i,a,c));case"dynamic":return w6(i,a,c);case"evaluation":return o(()=>E6(i,a,c));case"image":return o(()=>A6(i,a,c));case"graph":return o(()=>S6(i,a,c));case"logical":return o(()=>F6(i,a,c));case"matrices":return o(()=>M6(i,a,c));case"normalization":return o(()=>P6(i,a,c));case"ragged":return o(()=>B6(i,a,c));case"reduction":return o(()=>U6(i,a,c));case"slice_join":return o(()=>G6(i,a,c));case"sparse":return o(()=>W6(i,a,c));case"spectral":return o(()=>q6(i,a,c));case"string":return o(()=>X6(i,a,c));case"transformation":return o(()=>Z6(i,a,c));case"hash_table":return k6(i,a,c,r);case"custom":let l=w0(i.op);if(l&&l.customExecutor)return l.customExecutor(new M0(i,a,c));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,n,t);return y.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var J6=D(()=>{"use strict";T();r6();I0();s6();a6();g6();v6();C6();I6();T6();N6();_6();R6();O6();$6();L6();V6();z6();H6();j6();K6();Y6();Q6();});var Qh,e8=D(()=>{"use strict";Qh=class{constructor(n={},t={},r={},o={},s){this.weightMap=n,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=o,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(n,t){return{id:n,frameName:t,iterationId:0}}set currentContext(n){this.contexts!==n&&(this.contexts=n,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let n=[];for(let t=0;t<this.contexts.length-1;t++){let r=this.contexts.slice(0,this.contexts.length-t);n.push(this.contextIdforContexts(r))}n.push(""),this._currentContextIds=n}contextIdforContexts(n){return n?n.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(n){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,n)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let n=Object.assign({},this.contexts[this.contexts.length-1]);n.iterationId+=1,n.id=this.lastId,this.contexts.splice(-1,1,n),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(n){return this.weightMap[n]}addTensorArray(n){this.tensorArrayMap[n.id]=n}getTensorArray(n){return this.tensorArrayMap[n]}addTensorList(n){this.tensorListMap[n.id]=n}getTensorList(n){return this.tensorListMap[n]}dispose(n){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(n);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(n)}}});function rk(e,n,t,r){let o=new Set,s=[],i=null,a=null,c=new Set,l=new Set(Object.keys(e).map(d=>Mn(d)[0]));r=r||[];let u=new Set(r.map(d=>Mn(d.name)[0])),p=[...n];for(;p.length>0;){let d=p.pop();if((Ba(d)||kfe(d)||_fe(d))&&i==null&&(i=d,a=i.children.map(f=>f.name).filter(f=>o.has(f))),o.add(d.name),t[d.name]==null&&!l.has(d.name)&&!u.has(d.name)){if(d.inputs.length===0){s.push(d.name);continue}d.inputs.forEach(f=>{c.has(f.name)||(c.add(f.name),p.push(f))})}}return{inputs:e,outputs:n,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function t8(e,n){let{usedNodes:t,inputs:r}=n,o=Object.keys(r).map(g=>Mn(g)[0]).map(g=>e.nodes[g]),s=e.initNodes||[],i=g=>t.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(x=>[x.name,x])).values()]}let c=a([...o,...e.weights,...s]).filter(i),l=a([...c,...Object.values(e.nodes)]).filter(i),u=new Map(l.map(g=>[g.name,g])),p={};for(let g of l){p[g.name]=p[g.name]||0;for(let x of g.children)i(x)||(p[x.name]=Number.POSITIVE_INFINITY),p[x.name]=(p[x.name]||0)+1}let d=Object.entries(p).filter(([,g])=>g===0).map(([g])=>g),f=[...d];for(;d.length>0;){let g=d.pop(),x=u.get(g);for(let v of x.children.filter(i))--p[v.name]===0&&(f.push(v.name),d.push(v.name))}let m=f.map(g=>u.get(g)),h=Efe(m,c);return Tfe(h,c),h}function Efe(e,n){let t=new Map(e.map(i=>[i.name,i])),r=n.map(i=>i.name),o=new Set(r);for(;r.length>0;){let i=r.pop(),a=t.get(i);for(let c of a.children)!t.has(c.name)||o.has(c.name)||(o.add(c.name),r.push(c.name))}return e.filter(i=>o.has(i.name))}function Tfe(e,n){let t=new Map(e.map((a,c)=>[a.name,c])),r=new Set(n.map(a=>a.name)),o=a=>r.has(typeof a=="string"?a:a.name),s=new Set(e.map(a=>a.name)),i=a=>s.has(typeof a=="string"?a:a.name);for(let a of e){for(let c of a.children.filter(i)){if(!t.has(c.name))throw new ef(`Child ${c.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(c.name))throw new ef(`Node ${a.name} is scheduled to run after its child ${c.name}.`)}if(!o(a))for(let c of a.inputs){if(!t.has(c.name))throw new ef(`Input ${c.name} of node ${a.name} is unreachable.`);if(t.get(c.name)>t.get(a.name))throw new ef(`Node ${a.name} is scheduled to run before its input ${c.name}.`)}}}function n8(e){let n=new Map(e.map((a,c)=>[a.name,c])),t=Number.MAX_SAFE_INTEGER,r=e.map((a,c)=>Ba(a)?t:c),o=a=>{let c=r[n.get(a.name)];return c??-1},s=e.map((a,c)=>a.children.map(o).reduce((l,u)=>Math.max(l,u),r[c])),i=new Map;for(let a=0;a<e.length;++a){let c=s[a];if(c===t)continue;let l=e[a],u=e[c];i.has(u.name)||i.set(u.name,[]),i.get(u.name).push(l)}return i}function Ba(e){return Sfe.has(e.op)}function kfe(e){return Nfe.has(e.op)}function _fe(e){return Dfe.has(e.op)}var ef,Sfe,Nfe,Dfe,r8=D(()=>{"use strict";At();ef=class extends Error{constructor(n){super(`NodesExecutionOrderError: ${n}`)}};Sfe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Nfe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Dfe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"])});var Jh,o8=D(()=>{"use strict";T();At();J6();e8();r8();Jh=class e{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(n){let t=Object.keys(n).map(r=>n[r].map(o=>o.id));this._weightIds=[].concat(...t),this._weightMap=n}set resourceManager(n){this._resourceManager=n}get inputs(){return this._inputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(n=>n.signatureKey||n.name)}get outputNodes(){return this._outputs.map(n=>{let t=n.signatureKey||n.name;return n.defaultOutput?`${t}:${n.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((n,t)=>(n[t]=this._functions[t].signature,n),{})}constructor(n,t){this.graph=n,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=n.outputs,this._inputs=n.inputs,this._initNodes=n.initNodes,this._signature=n.signature,this._functions=n.functions,n.functions!=null&&Object.keys(n.functions).forEach(r=>{this._functionExecutorMap[r]=new e(n.functions[r],this)})}getCompilationKey(n,t){let r=n.map(s=>s.name).sort(),o=t.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+o.join(this.SEPARATOR)}compile(n,t){let r=rk(n,t,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let l=t.map(p=>p.name),u=Object.keys(n);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}let a=t8(this.graph,r),c=n8(a);return{orderedNodes:a,nodeLiveUntilMap:c}}cloneAndKeepTensor(n){if(n==null)return null;let t=n.clone();return Fn(t),t}cloneTensorList(n){return n?n.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(n){return Object.fromEntries(Object.entries(n).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(n,t){this.disposeIntermediateTensors(),n=this.mapInputs(n);let r=Object.keys(n).sort();this.checkInputs(n),this.checkInputShapeAndType(n),t=this.mapOutputs(t),this.checkOutputs(t);let o=r.map(d=>this.graph.nodes[Mn(d)[0]]),s=t.map(d=>Mn(d)[0]),i=new Set(s),a=s.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);let c=this.getCompilationKey(o,a),l=this.compiledMap.get(c);l==null&&(l=this.compile(n,a),this.compiledMap.set(c,l));try{this.keepIntermediateTensors=M().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let u={},p={};return Ce(()=>{let d=new Qh(this.weightMap,u,p,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(n).forEach(x=>{let[v,w]=Mn(x,d),I=[];I[w]=n[x],f[v]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[v]=this.cloneTensorList(I))});let m=this.getFrozenTensorIds(f),{orderedNodes:h,nodeLiveUntilMap:g}=l;for(let x of h){if(f[x.name])continue;let v=nk(x,f,d,this._resourceManager);if(y.isPromise(v))throw new Error(`The execution of the op '${x.op}' returned a promise. Please use model.executeAsync() instead.`);f[x.name]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[x.name]=this.cloneTensorList(v)),this.checkTensorForDisposalWithNodeLiveUntilInfo(x,f,d,m,i,g.get(x.name))}return this.parent==null&&d.dispose(m),t.map(x=>Lt(x,f,d))})}getFrozenTensorIds(n){let t=[].concat.apply([],Object.keys(n).map(r=>n[r]).map(r=>r.map(o=>o.id)));return new Set(t)}checkTensorForDisposal(n,t,r,o,s,i,a){if(!(Ba(t)||i.has(n))){for(let c of r[n])c!=null&&(a[c.id]=(a[c.id]||0)+t.children.length);for(let c of t.inputs){if(Ba(c))continue;let l=R1(c.name,r,o);if(l!=null)for(let u of l){if(!u||u.kept||s.has(u.id))continue;let p=a[u.id];p===1?(u.dispose(),delete a[u.id]):p!=null&&a[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(n,t,r,o,s,i){function a(c){return Ba(c)||s.has(c.name)}if(!(Ba(n)||i==null))for(let c of i){if(a(c))continue;let l=R1(c.name,t,r);for(let u of l)!u||u.kept||o.has(u.id)||u.dispose()}}async executeAsync(n,t){return this._executeAsync(n,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(n=>{for(let t of n)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(n,t,r=!1,o={},s={}){this.disposeIntermediateTensors(),r||(n=this.mapInputs(n),this.checkInputs(n),this.checkInputShapeAndType(n),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=M().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let i=new Qh(this.weightMap,o,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let a=await this.executeWithControlFlow(n,i,t,r),c=t.map(d=>Lt(d,a,i)),l=c.map(d=>d.id),u=Object.keys(n).map(d=>n[d].id),p=new Set([...l,...u,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(f=>{f&&!f.isDisposed&&!p.has(f.id)&&f.dispose()})}),this.parent==null&&i.dispose(p),c}async executeFunctionAsync(n,t,r){let o=n.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,t,r)}async executeWithControlFlow(n,t,r,o){let s=Object.keys(n),i=s.map(I=>this.graph.nodes[Mn(I)[0]]),a=r.map(I=>Mn(I)[0]),c=new Set(a),l=a.map(I=>this.graph.nodes[I]);l.length===0&&(l=this._outputs);let{usedNodes:u,missingInputs:p,dynamicNode:d,syncInputs:f}=rk(n,l,this.weightMap,this._initNodes),m=[...i,...this.graph.weights,...this._initNodes||[]].map(I=>({node:I,contexts:t.currentContext})),h=Object.assign({},this.weightMap);Object.keys(n).forEach(I=>{let[_,A]=Mn(I),R=[];R[A]=n[I],h[_]=R});let g={},x=this.getFrozenTensorIds(h),v={};for(;m.length>0;){let I=this.processStack(i,m,t,h,v,x,c,g,u);await Promise.all(I)}d==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let w=l.filter(I=>!Ba(I)&&!Lt(I.name,h,t)).map(I=>I.name);if(w.length>0){let I="";throw d!=null&&(I=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${I}`)}return h}processStack(n,t,r,o,s,i,a,c,l){let u=[];for(;t.length>0;){let p=t.pop();r.currentContext=p.contexts;let d="";if(p.node.op==="Enter"&&b("isConstant",p.node,o,r)&&([d]=Io(p.node.name,r)),o[p.node.name]==null){let f=nk(p.node,o,r,this._resourceManager);d||([d]=Io(p.node.name,r));let m=r.currentContext;y.isPromise(f)?u.push(f.then(h=>(o[d]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(h)),r.currentContext=m,this.checkTensorForDisposal(d,p.node,o,r,i,a,c),this.processChildNodes(p.node,t,r,o,s,l),h))):(o[d]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(f)),this.checkTensorForDisposal(d,p.node,o,r,i,a,c),this.processChildNodes(p.node,t,r,o,s,l))}else this.processChildNodes(p.node,t,r,o,s,l)}return u}processChildNodes(n,t,r,o,s,i){n.children.forEach(a=>{let[c]=Io(a.name,r);s[c]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!Lt(l,o,r))&&(s[c]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(l=>!!Lt(l,o,r))&&(s[c]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(n=>this.weightMap[n].forEach(t=>t.dispose()))}checkInputShapeAndType(n){Object.keys(n).forEach(t=>{let r=n[t],[o]=Mn(t),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((c,l)=>i[l]===-1||i[l]===c);y.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&y.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(n){var t,r;let o={};for(let s in n){let i=(r=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||r===void 0?void 0:r[s];i!=null?o[i.name]=n[s]:o[s]=n[s]}return o}checkInputs(n){let t=Object.keys(n).filter(r=>{let[o]=Mn(r);return this.graph.nodes[o]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(n){return n.map(t=>{var r,o;let s=(o=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||o===void 0?void 0:o[t];return s!=null?s.name:t},{})}checkOutputs(n){n.forEach(t=>{let[r]=Mn(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}});var B0,s8=D(()=>{"use strict";B0=class{constructor(n={},t={}){this.hashTableNameToHandle=n,this.hashTableMap=t}addHashTable(n,t){this.hashTableNameToHandle[n]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(n){return this.hashTableNameToHandle[n]}getHashTableById(n){return this.hashTableMap[n]}dispose(){for(let n in this.hashTableMap)this.hashTableMap[n].clearAndClose(),delete this.hashTableMap[n];for(let n in this.hashTableNameToHandle)this.hashTableNameToHandle[n].dispose(),delete this.hashTableNameToHandle[n]}}});async function i8(e,n={},t=Xo){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");n==null&&(n={}),n.fromTFHub&&typeof e=="string"&&(e=Ffe(e));let r=new tf(e,n,t);return await r.load(),r}function a8(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let n;if(e instanceof Array){let[r,o]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!o||!(o instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let s=Xo.getWeightSpecs(r.weightsManifest),i=Xo.getModelArtifactsForJSONSync(r,s,o);n=Xo.fromMemorySync(i)}else if("load"in e)n=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)n=Xo.fromMemorySync(e);else throw new Error("Unknown model format");let t=new tf(n);return t.load(),t}function Ffe(e){return e.endsWith("/")||(e=e+"/"),`${e}${Rfe}${Afe}`}var Afe,Rfe,tf,c8=D(()=>{"use strict";T();J1();o8();s8();ga();Afe="?tfjs-format=file",Rfe="model.json",tf=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(n,t={},r=Xo){this.modelUrl=n,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new B0}findIOHandler(){let n=this.modelUrl;if(n.load!=null)this.handler=n;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(n,this.loadOptions);else{let t=this.io.getLoadHandlers(n,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(n,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[n]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=this.handler.load();return y.isPromise(n)?n.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(n)}loadSync(n){let t=this.io.decodeWeights(n.weightData,n.weightSpecs);return this.loadWithWeightMap(n,t)}async loadStreaming(n){if(n.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await py(n.getWeightStream(),n.weightSpecs);return this.loadWithWeightMap(n,t)}loadWithWeightMap(n,t){this.artifacts=n;let r=this.artifacts.modelTopology,o=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(o=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=o,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Jh(Zh.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,n.modelInitializer!=null&&n.modelInitializer.node!=null){let s=Zh.Instance.transformGraph(n.modelInitializer);this.initializer=new Jh(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=n.initializerSignature}return!0}async save(n,t){if(typeof n=="string"){let r=this.io.getSaveHandlers(n);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${n}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${n}'`);n=r[0]}if(n.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return n.save(this.artifacts)}addStructuredOutputNames(n){if(this.structuredOutputKeys){let t=n instanceof ot?[n]:n,r={};return t.forEach((o,s)=>r[this.structuredOutputKeys[s]]=o),r}return n}predict(n,t){let r=this.execute(n,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(n,t){let r=await this.executeAsync(n,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(n){var t;if(!(n instanceof ot)&&!Array.isArray(n)){let s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(let i in s){let a=s[i];a.resourceId!=null&&(n[i]=this.resourceIdToCapturedInput[a.resourceId])}return n}n=Array.isArray(n)?n:[n];let r=Object.keys(this.resourceIdToCapturedInput).length;if(n.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${n.length} input tensors provided.`);let o=0;return this.inputNodes.reduce((s,i)=>{var a,c,l;let u=(l=(c=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||c===void 0?void 0:c[i])===null||l===void 0?void 0:l.resourceId;return u!=null?s[i]=this.resourceIdToCapturedInput[u]:s[i]=n[o++],s},{})}normalizeOutputs(n){return n=n||this.outputNodes,Array.isArray(n)?n:[n]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(n){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,r=Object.keys(t);for(let o=0;o<r.length;o++){let s=r[o],i=t[s];this.resourceIdToCapturedInput[i.resourceId]=n[o]}}}execute(n,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),n=this.normalizeInputs(n),t=this.normalizeOutputs(t);let r=this.executor.execute(n,t);return r.length>1?r:r[0]}async executeAsync(n,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),n=this.normalizeInputs(n),t=this.normalizeOutputs(t);let r=await this.executor.executeAsync(n,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(n){return Object.keys(n).reduce((t,r)=>(t[r]=[n[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Nt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}});var l8,u8=D(()=>{"use strict";l8="4.22.0"});var p8={};He(p8,{GraphModel:()=>tf,deregisterOp:()=>Oj,loadGraphModel:()=>i8,loadGraphModelSync:()=>a8,registerOp:()=>Fj,version_converter:()=>l8});var d8=D(()=>{"use strict";_j();c8();I0();u8();});var m8=mr((V0,f8)=>{"use strict";(function(e,n){typeof V0=="object"&&typeof f8<"u"?n(V0,(d8(),sk(p8)),(T(),sk(pv))):typeof define=="function"&&define.amd?define(["exports","@tensorflow/tfjs-converter","@tensorflow/tfjs-core"],n):n((e=e||self).cocoSsd=e.cocoSsd||{},e.tf,e.tf)})(V0,function(e,n,t){"use strict";let r={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class o{constructor(i,a){this.modelPath=a||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(i)}/model.json`}getPrefix(i){return i==="lite_mobilenet_v2"?`ssd${i}`:`ssd_${i}`}async load(){this.model=await n.loadGraphModel(this.modelPath);let i=t.zeros([1,300,300,3],"int32"),a=await this.model.executeAsync(i);await Promise.all(a.map(c=>c.data())),a.map(c=>c.dispose()),i.dispose()}async infer(i,a,c){let l=t.tidy(()=>(i instanceof t.Tensor||(i=t.browser.fromPixels(i)),t.expandDims(i))),u=l.shape[1],p=l.shape[2],d=await this.model.executeAsync(l),f=d[0].dataSync(),m=d[1].dataSync();l.dispose(),t.dispose(d);let[h,g]=this.calculateMaxScores(f,d[0].shape[1],d[0].shape[2]),x=t.getBackend();t.getBackend()==="webgl"&&t.setBackend("cpu");let v=t.tidy(()=>{let I=t.tensor2d(m,[d[1].shape[1],d[1].shape[3]]);return t.image.nonMaxSuppression(I,h,a,c,c)}),w=v.dataSync();return v.dispose(),x!==t.getBackend()&&t.setBackend(x),this.buildDetectedObjects(p,u,m,h,w,g)}buildDetectedObjects(i,a,c,l,u,p){let d=u.length,f=[];for(let m=0;m<d;m++){let h=[];for(let I=0;I<4;I++)h[I]=c[4*u[m]+I];let g=h[0]*a,x=h[1]*i,v=h[2]*a,w=h[3]*i;h[0]=x,h[1]=g,h[2]=w-x,h[3]=v-g,f.push({bbox:h,class:r[p[u[m]]+1].displayName,score:l[u[m]]})}return f}calculateMaxScores(i,a,c){let l=[],u=[];for(let p=0;p<a;p++){let d=Number.MIN_VALUE,f=-1;for(let m=0;m<c;m++)i[p*c+m]>d&&(d=i[p*c+m],f=m);l[p]=d,u[p]=f}return[l,u]}async detect(i,a=20,c=.5){return this.infer(i,a,c)}dispose(){this.model!=null&&this.model.dispose()}}e.ObjectDetection=o,e.load=async function(s={}){if(t==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");let i=s.base||"lite_mobilenet_v2",a=s.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(i)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${i}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);let c=new o(i,a);return await c.load(),c},e.version="2.2.3",Object.defineProperty(e,"__esModule",{value:!0})})});var j0;function ng(){return j0}function To(e){let n=j0;return j0=e,n}var ik=Symbol("NotFound");function np(e){return e===ik||e?.name==="\u0275NotFound"}function q0(e,n){return Object.is(e,n)}var En=null,rg=!1,K0=1,v8=null,qn=Symbol("SIGNAL");function De(e){let n=En;return En=e,n}function sg(){return En}var rp={version:0,lastCleanEpoch:0,dirty:!1,producers:void 0,producersTail:void 0,consumers:void 0,consumersTail:void 0,recomputing:!1,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,kind:"unknown",producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function rf(e){if(rg)throw new Error("");if(En===null)return;En.consumerOnSignalRead(e);let n=En.producersTail;if(n!==void 0&&n.producer===e)return;let t,r=En.recomputing;if(r&&(t=n!==void 0?n.nextProducer:En.producers,t!==void 0&&t.producer===e)){En.producersTail=t,t.lastReadVersion=e.version;return}let o=e.consumersTail;if(o!==void 0&&o.consumer===En&&(!r||C8(o,En)))return;let s=ip(En),i={producer:e,consumer:En,nextProducer:t,prevConsumer:o,lastReadVersion:e.version,nextConsumer:void 0};En.producersTail=i,n!==void 0?n.nextProducer=i:En.producers=i,s&&ck(e,i)}function ak(){K0++}function X0(e){if(!(ip(e)&&!e.dirty)&&!(!e.dirty&&e.lastCleanEpoch===K0)){if(!e.producerMustRecompute(e)&&!sp(e)){og(e);return}e.producerRecomputeValue(e),og(e)}}function Y0(e){if(e.consumers===void 0)return;let n=rg;rg=!0;try{for(let t=e.consumers;t!==void 0;t=t.nextConsumer){let r=t.consumer;r.dirty||b8(r)}}finally{rg=n}}function Z0(){return En?.consumerAllowSignalWrites!==!1}function b8(e){e.dirty=!0,Y0(e),e.consumerMarkedDirty?.(e)}function og(e){e.dirty=!1,e.lastCleanEpoch=K0}function op(e){return e&&(e.producersTail=void 0,e.recomputing=!0),De(e)}function of(e,n){if(De(n),!e)return;e.recomputing=!1;let t=e.producersTail,r=t!==void 0?t.nextProducer:e.producers;if(r!==void 0){if(ip(e))do r=Q0(r);while(r!==void 0);t!==void 0?t.nextProducer=void 0:e.producers=void 0}}function sp(e){for(let n=e.producers;n!==void 0;n=n.nextProducer){let t=n.producer,r=n.lastReadVersion;if(r!==t.version||(X0(t),r!==t.version))return!0}return!1}function Ua(e){if(ip(e)){let n=e.producers;for(;n!==void 0;)n=Q0(n)}e.producers=void 0,e.producersTail=void 0,e.consumers=void 0,e.consumersTail=void 0}function ck(e,n){let t=e.consumersTail,r=ip(e);if(t!==void 0?(n.nextConsumer=t.nextConsumer,t.nextConsumer=n):(n.nextConsumer=void 0,e.consumers=n),n.prevConsumer=t,e.consumersTail=n,!r)for(let o=e.producers;o!==void 0;o=o.nextProducer)ck(o.producer,o)}function Q0(e){let n=e.producer,t=e.nextProducer,r=e.nextConsumer,o=e.prevConsumer;if(e.nextConsumer=void 0,e.prevConsumer=void 0,r!==void 0?r.prevConsumer=o:n.consumersTail=o,o!==void 0)o.nextConsumer=r;else if(n.consumers=r,!ip(n)){let s=n.producers;for(;s!==void 0;)s=Q0(s)}return t}function ip(e){return e.consumerIsAlwaysLive||e.consumers!==void 0}function J0(e){v8?.(e)}function C8(e,n){let t=n.producersTail;if(t!==void 0){let r=n.producers;do{if(r===e)return!0;if(r===t)break;r=r.nextProducer}while(r!==void 0)}return!1}function w8(){throw new Error}var lk=w8;function uk(e){lk(e)}function eC(e){lk=e}var I8=null;function tC(e,n){let t=Object.create(ig);t.value=e,n!==void 0&&(t.equal=n);let r=()=>pk(t);return r[qn]=t,J0(t),[r,i=>ap(t,i),i=>nC(t,i)]}function pk(e){return rf(e),e.value}function ap(e,n){Z0()||uk(e),e.equal(e.value,n)||(e.value=n,E8(e))}function nC(e,n){Z0()||uk(e),ap(e,n(e.value))}var ig=Ft(Je({},rp),{equal:q0,value:void 0,kind:"signal"});function E8(e){e.version++,ak(),Y0(e),I8?.(e)}function Fe(e){return typeof e=="function"}function cp(e){let t=e(r=>{Error.call(r),r.stack=new Error().stack});return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}var ag=cp(e=>function(t){e(this),this.message=t?`${t.length} errors occurred during unsubscription:
${t.map((r,o)=>`${o+1}) ${r.toString()}`).join(`
  `)}`:"",this.name="UnsubscriptionError",this.errors=t});function za(e,n){if(e){let t=e.indexOf(n);0<=t&&e.splice(t,1)}}var Ht=class e{constructor(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let n;if(!this.closed){this.closed=!0;let{_parentage:t}=this;if(t)if(this._parentage=null,Array.isArray(t))for(let s of t)s.remove(this);else t.remove(this);let{initialTeardown:r}=this;if(Fe(r))try{r()}catch(s){n=s instanceof ag?s.errors:[s]}let{_finalizers:o}=this;if(o){this._finalizers=null;for(let s of o)try{dk(s)}catch(i){n=n??[],i instanceof ag?n=[...n,...i.errors]:n.push(i)}}if(n)throw new ag(n)}}add(n){var t;if(n&&n!==this)if(this.closed)dk(n);else{if(n instanceof e){if(n.closed||n._hasParent(this))return;n._addParent(this)}(this._finalizers=(t=this._finalizers)!==null&&t!==void 0?t:[]).push(n)}}_hasParent(n){let{_parentage:t}=this;return t===n||Array.isArray(t)&&t.includes(n)}_addParent(n){let{_parentage:t}=this;this._parentage=Array.isArray(t)?(t.push(n),t):t?[t,n]:n}_removeParent(n){let{_parentage:t}=this;t===n?this._parentage=null:Array.isArray(t)&&za(t,n)}remove(n){let{_finalizers:t}=this;t&&za(t,n),n instanceof e&&n._removeParent(this)}};Ht.EMPTY=(()=>{let e=new Ht;return e.closed=!0,e})();var rC=Ht.EMPTY;function cg(e){return e instanceof Ht||e&&"closed"in e&&Fe(e.remove)&&Fe(e.add)&&Fe(e.unsubscribe)}function dk(e){Fe(e)?e():e.unsubscribe()}var Kr={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1};var lp={setTimeout(e,n,...t){let{delegate:r}=lp;return r?.setTimeout?r.setTimeout(e,n,...t):setTimeout(e,n,...t)},clearTimeout(e){let{delegate:n}=lp;return(n?.clearTimeout||clearTimeout)(e)},delegate:void 0};function lg(e){lp.setTimeout(()=>{let{onUnhandledError:n}=Kr;if(n)n(e);else throw e})}function sf(){}var fk=oC("C",void 0,void 0);function mk(e){return oC("E",void 0,e)}function hk(e){return oC("N",e,void 0)}function oC(e,n,t){return{kind:e,value:n,error:t}}var Ga=null;function up(e){if(Kr.useDeprecatedSynchronousErrorHandling){let n=!Ga;if(n&&(Ga={errorThrown:!1,error:null}),e(),n){let{errorThrown:t,error:r}=Ga;if(Ga=null,t)throw r}}else e()}function gk(e){Kr.useDeprecatedSynchronousErrorHandling&&Ga&&(Ga.errorThrown=!0,Ga.error=e)}var Ha=class extends Ht{constructor(n){super(),this.isStopped=!1,n?(this.destination=n,cg(n)&&n.add(this)):this.destination=N8}static create(n,t,r){return new rs(n,t,r)}next(n){this.isStopped?iC(hk(n),this):this._next(n)}error(n){this.isStopped?iC(mk(n),this):(this.isStopped=!0,this._error(n))}complete(){this.isStopped?iC(fk,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(n){this.destination.next(n)}_error(n){try{this.destination.error(n)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}},T8=Function.prototype.bind;function sC(e,n){return T8.call(e,n)}var aC=class{constructor(n){this.partialObserver=n}next(n){let{partialObserver:t}=this;if(t.next)try{t.next(n)}catch(r){ug(r)}}error(n){let{partialObserver:t}=this;if(t.error)try{t.error(n)}catch(r){ug(r)}else ug(n)}complete(){let{partialObserver:n}=this;if(n.complete)try{n.complete()}catch(t){ug(t)}}},rs=class extends Ha{constructor(n,t,r){super();let o;if(Fe(n)||!n)o={next:n??void 0,error:t??void 0,complete:r??void 0};else{let s;this&&Kr.useDeprecatedNextContext?(s=Object.create(n),s.unsubscribe=()=>this.unsubscribe(),o={next:n.next&&sC(n.next,s),error:n.error&&sC(n.error,s),complete:n.complete&&sC(n.complete,s)}):o=n}this.destination=new aC(o)}};function ug(e){Kr.useDeprecatedSynchronousErrorHandling?gk(e):lg(e)}function S8(e){throw e}function iC(e,n){let{onStoppedNotification:t}=Kr;t&&lp.setTimeout(()=>t(e,n))}var N8={closed:!0,next:sf,error:S8,complete:sf};var pp=typeof Symbol=="function"&&Symbol.observable||"@@observable";function $n(e){return e}function D8(...e){return cC(e)}function cC(e){return e.length===0?$n:e.length===1?e[0]:function(t){return e.reduce((r,o)=>o(r),t)}}var et=(()=>{class e{constructor(t){t&&(this._subscribe=t)}lift(t){let r=new e;return r.source=this,r.operator=t,r}subscribe(t,r,o){let s=_8(t)?t:new rs(t,r,o);return up(()=>{let{operator:i,source:a}=this;s.add(i?i.call(s,a):a?this._subscribe(s):this._trySubscribe(s))}),s}_trySubscribe(t){try{return this._subscribe(t)}catch(r){t.error(r)}}forEach(t,r){return r=xk(r),new r((o,s)=>{let i=new rs({next:a=>{try{t(a)}catch(c){s(c),i.unsubscribe()}},error:s,complete:o});this.subscribe(i)})}_subscribe(t){var r;return(r=this.source)===null||r===void 0?void 0:r.subscribe(t)}[pp](){return this}pipe(...t){return cC(t)(this)}toPromise(t){return t=xk(t),new t((r,o)=>{let s;this.subscribe(i=>s=i,i=>o(i),()=>r(s))})}}return e.create=n=>new e(n),e})();function xk(e){var n;return(n=e??Kr.Promise)!==null&&n!==void 0?n:Promise}function k8(e){return e&&Fe(e.next)&&Fe(e.error)&&Fe(e.complete)}function _8(e){return e&&e instanceof Ha||k8(e)&&cg(e)}function lC(e){return Fe(e?.lift)}function qe(e){return n=>{if(lC(n))return n.lift(function(t){try{return e(t,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function We(e,n,t,r,o){return new uC(e,n,t,r,o)}var uC=class extends Ha{constructor(n,t,r,o,s,i){super(n),this.onFinalize=s,this.shouldUnsubscribe=i,this._next=t?function(a){try{t(a)}catch(c){n.error(c)}}:super._next,this._error=o?function(a){try{o(a)}catch(c){n.error(c)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){n.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var n;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){let{closed:t}=this;super.unsubscribe(),!t&&((n=this.onFinalize)===null||n===void 0||n.call(this))}}};function pC(){return qe((e,n)=>{let t=null;e._refCount++;let r=We(n,void 0,void 0,void 0,()=>{if(!e||e._refCount<=0||0<--e._refCount){t=null;return}let o=e._connection,s=t;t=null,o&&(!s||o===s)&&o.unsubscribe(),n.unsubscribe()});e.subscribe(r),r.closed||(t=e.connect())})}var dC=class extends et{constructor(n,t){super(),this.source=n,this.subjectFactory=t,this._subject=null,this._refCount=0,this._connection=null,lC(n)&&(this.lift=n.lift)}_subscribe(n){return this.getSubject().subscribe(n)}getSubject(){let n=this._subject;return(!n||n.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;let{_connection:n}=this;this._subject=this._connection=null,n?.unsubscribe()}connect(){let n=this._connection;if(!n){n=this._connection=new Ht;let t=this.getSubject();n.add(this.source.subscribe(We(t,void 0,()=>{this._teardown(),t.complete()},r=>{this._teardown(),t.error(r)},()=>this._teardown()))),n.closed&&(this._connection=null,n=Ht.EMPTY)}return n}refCount(){return pC()(this)}};var yk=cp(e=>function(){e(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});var Tn=(()=>{class e extends et{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(t){let r=new pg(this,this);return r.operator=t,r}_throwIfClosed(){if(this.closed)throw new yk}next(t){up(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(let r of this.currentObservers)r.next(t)}})}error(t){up(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=t;let{observers:r}=this;for(;r.length;)r.shift().error(t)}})}complete(){up(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;let{observers:t}=this;for(;t.length;)t.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var t;return((t=this.observers)===null||t===void 0?void 0:t.length)>0}_trySubscribe(t){return this._throwIfClosed(),super._trySubscribe(t)}_subscribe(t){return this._throwIfClosed(),this._checkFinalizedStatuses(t),this._innerSubscribe(t)}_innerSubscribe(t){let{hasError:r,isStopped:o,observers:s}=this;return r||o?rC:(this.currentObservers=null,s.push(t),new Ht(()=>{this.currentObservers=null,za(s,t)}))}_checkFinalizedStatuses(t){let{hasError:r,thrownError:o,isStopped:s}=this;r?t.error(o):s&&t.complete()}asObservable(){let t=new et;return t.source=this,t}}return e.create=(n,t)=>new pg(n,t),e})(),pg=class extends Tn{constructor(n,t){super(),this.destination=n,this.source=t}next(n){var t,r;(r=(t=this.destination)===null||t===void 0?void 0:t.next)===null||r===void 0||r.call(t,n)}error(n){var t,r;(r=(t=this.destination)===null||t===void 0?void 0:t.error)===null||r===void 0||r.call(t,n)}complete(){var n,t;(t=(n=this.destination)===null||n===void 0?void 0:n.complete)===null||t===void 0||t.call(n)}_subscribe(n){var t,r;return(r=(t=this.source)===null||t===void 0?void 0:t.subscribe(n))!==null&&r!==void 0?r:rC}};var Wa=class extends Tn{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){let t=super._subscribe(n);return!t.closed&&n.next(this._value),t}getValue(){let{hasError:n,thrownError:t,_value:r}=this;if(n)throw t;return this._throwIfClosed(),r}next(n){super.next(this._value=n)}};var af={now(){return(af.delegate||Date).now()},delegate:void 0};var dg=class extends Tn{constructor(n=1/0,t=1/0,r=af){super(),this._bufferSize=n,this._windowTime=t,this._timestampProvider=r,this._buffer=[],this._infiniteTimeWindow=!0,this._infiniteTimeWindow=t===1/0,this._bufferSize=Math.max(1,n),this._windowTime=Math.max(1,t)}next(n){let{isStopped:t,_buffer:r,_infiniteTimeWindow:o,_timestampProvider:s,_windowTime:i}=this;t||(r.push(n),!o&&r.push(s.now()+i)),this._trimBuffer(),super.next(n)}_subscribe(n){this._throwIfClosed(),this._trimBuffer();let t=this._innerSubscribe(n),{_infiniteTimeWindow:r,_buffer:o}=this,s=o.slice();for(let i=0;i<s.length&&!n.closed;i+=r?1:2)n.next(s[i]);return this._checkFinalizedStatuses(n),t}_trimBuffer(){let{_bufferSize:n,_timestampProvider:t,_buffer:r,_infiniteTimeWindow:o}=this,s=(o?1:2)*n;if(n<1/0&&s<r.length&&r.splice(0,r.length-s),!o){let i=t.now(),a=0;for(let c=1;c<r.length&&r[c]<=i;c+=2)a=c;a&&r.splice(0,a+1)}}};var fg=class extends Ht{constructor(n,t){super()}schedule(n,t=0){return this}};var cf={setInterval(e,n,...t){let{delegate:r}=cf;return r?.setInterval?r.setInterval(e,n,...t):setInterval(e,n,...t)},clearInterval(e){let{delegate:n}=cf;return(n?.clearInterval||clearInterval)(e)},delegate:void 0};var mg=class extends fg{constructor(n,t){super(n,t),this.scheduler=n,this.work=t,this.pending=!1}schedule(n,t=0){var r;if(this.closed)return this;this.state=n;let o=this.id,s=this.scheduler;return o!=null&&(this.id=this.recycleAsyncId(s,o,t)),this.pending=!0,this.delay=t,this.id=(r=this.id)!==null&&r!==void 0?r:this.requestAsyncId(s,this.id,t),this}requestAsyncId(n,t,r=0){return cf.setInterval(n.flush.bind(n,this),r)}recycleAsyncId(n,t,r=0){if(r!=null&&this.delay===r&&this.pending===!1)return t;t!=null&&cf.clearInterval(t)}execute(n,t){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;let r=this._execute(n,t);if(r)return r;this.pending===!1&&this.id!=null&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(n,t){let r=!1,o;try{this.work(n)}catch(s){r=!0,o=s||new Error("Scheduled action threw falsy error")}if(r)return this.unsubscribe(),o}unsubscribe(){if(!this.closed){let{id:n,scheduler:t}=this,{actions:r}=t;this.work=this.state=this.scheduler=null,this.pending=!1,za(r,this),n!=null&&(this.id=this.recycleAsyncId(t,n,null)),this.delay=null,super.unsubscribe()}}};var dp=class e{constructor(n,t=e.now){this.schedulerActionCtor=n,this.now=t}schedule(n,t=0,r){return new this.schedulerActionCtor(this,n).schedule(r,t)}};dp.now=af.now;var hg=class extends dp{constructor(n,t=dp.now){super(n,t),this.actions=[],this._active=!1}flush(n){let{actions:t}=this;if(this._active){t.push(n);return}let r;this._active=!0;do if(r=n.execute(n.state,n.delay))break;while(n=t.shift());if(this._active=!1,r){for(;n=t.shift();)n.unsubscribe();throw r}}};var A8=new hg(mg),vk=A8;var ja=new et(e=>e.complete());function gg(e){return e&&Fe(e.schedule)}function bk(e){return e[e.length-1]}function xg(e){return Fe(bk(e))?e.pop():void 0}function Ks(e){return gg(bk(e))?e.pop():void 0}function wk(e,n,t,r){function o(s){return s instanceof t?s:new t(function(i){i(s)})}return new(t||(t=Promise))(function(s,i){function a(u){try{l(r.next(u))}catch(p){i(p)}}function c(u){try{l(r.throw(u))}catch(p){i(p)}}function l(u){u.done?s(u.value):o(u.value).then(a,c)}l((r=r.apply(e,n||[])).next())})}function Ck(e){var n=typeof Symbol=="function"&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&typeof e.length=="number")return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}function qa(e){return this instanceof qa?(this.v=e,this):new qa(e)}function Ik(e,n,t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r=t.apply(e,n||[]),o,s=[];return o=Object.create((typeof AsyncIterator=="function"?AsyncIterator:Object).prototype),a("next"),a("throw"),a("return",i),o[Symbol.asyncIterator]=function(){return this},o;function i(f){return function(m){return Promise.resolve(m).then(f,p)}}function a(f,m){r[f]&&(o[f]=function(h){return new Promise(function(g,x){s.push([f,h,g,x])>1||c(f,h)})},m&&(o[f]=m(o[f])))}function c(f,m){try{l(r[f](m))}catch(h){d(s[0][3],h)}}function l(f){f.value instanceof qa?Promise.resolve(f.value.v).then(u,p):d(s[0][2],f)}function u(f){c("next",f)}function p(f){c("throw",f)}function d(f,m){f(m),s.shift(),s.length&&c(s[0][0],s[0][1])}}function Ek(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n=e[Symbol.asyncIterator],t;return n?n.call(e):(e=typeof Ck=="function"?Ck(e):e[Symbol.iterator](),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=function(){return this},t);function r(s){t[s]=e[s]&&function(i){return new Promise(function(a,c){i=e[s](i),o(a,c,i.done,i.value)})}}function o(s,i,a,c){Promise.resolve(c).then(function(l){s({value:l,done:a})},i)}}var yg=e=>e&&typeof e.length=="number"&&typeof e!="function";function vg(e){return Fe(e?.then)}function bg(e){return Fe(e[pp])}function Cg(e){return Symbol.asyncIterator&&Fe(e?.[Symbol.asyncIterator])}function wg(e){return new TypeError(`You provided ${e!==null&&typeof e=="object"?"an invalid object":`'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}function R8(){return typeof Symbol!="function"||!Symbol.iterator?"@@iterator":Symbol.iterator}var Ig=R8();function Eg(e){return Fe(e?.[Ig])}function Tg(e){return Ik(this,arguments,function*(){let t=e.getReader();try{for(;;){let{value:r,done:o}=yield qa(t.read());if(o)return yield qa(void 0);yield yield qa(r)}}finally{t.releaseLock()}})}function Sg(e){return Fe(e?.getReader)}function St(e){if(e instanceof et)return e;if(e!=null){if(bg(e))return F8(e);if(yg(e))return O8(e);if(vg(e))return M8(e);if(Cg(e))return Tk(e);if(Eg(e))return $8(e);if(Sg(e))return P8(e)}throw wg(e)}function F8(e){return new et(n=>{let t=e[pp]();if(Fe(t.subscribe))return t.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}function O8(e){return new et(n=>{for(let t=0;t<e.length&&!n.closed;t++)n.next(e[t]);n.complete()})}function M8(e){return new et(n=>{e.then(t=>{n.closed||(n.next(t),n.complete())},t=>n.error(t)).then(null,lg)})}function $8(e){return new et(n=>{for(let t of e)if(n.next(t),n.closed)return;n.complete()})}function Tk(e){return new et(n=>{L8(e,n).catch(t=>n.error(t))})}function P8(e){return Tk(Tg(e))}function L8(e,n){var t,r,o,s;return wk(this,void 0,void 0,function*(){try{for(t=Ek(e);r=yield t.next(),!r.done;){let i=r.value;if(n.next(i),n.closed)return}}catch(i){o={error:i}}finally{try{r&&!r.done&&(s=t.return)&&(yield s.call(t))}finally{if(o)throw o.error}}n.complete()})}function Kn(e,n,t,r=0,o=!1){let s=n.schedule(function(){t(),o?e.add(this.schedule(null,r)):this.unsubscribe()},r);if(e.add(s),!o)return s}function Ng(e,n=0){return qe((t,r)=>{t.subscribe(We(r,o=>Kn(r,e,()=>r.next(o),n),()=>Kn(r,e,()=>r.complete(),n),o=>Kn(r,e,()=>r.error(o),n)))})}function Dg(e,n=0){return qe((t,r)=>{r.add(e.schedule(()=>t.subscribe(r),n))})}function Sk(e,n){return St(e).pipe(Dg(n),Ng(n))}function Nk(e,n){return St(e).pipe(Dg(n),Ng(n))}function Dk(e,n){return new et(t=>{let r=0;return n.schedule(function(){r===e.length?t.complete():(t.next(e[r++]),t.closed||this.schedule())})})}function kk(e,n){return new et(t=>{let r;return Kn(t,n,()=>{r=e[Ig](),Kn(t,n,()=>{let o,s;try{({value:o,done:s}=r.next())}catch(i){t.error(i);return}s?t.complete():t.next(o)},0,!0)}),()=>Fe(r?.return)&&r.return()})}function kg(e,n){if(!e)throw new Error("Iterable cannot be null");return new et(t=>{Kn(t,n,()=>{let r=e[Symbol.asyncIterator]();Kn(t,n,()=>{r.next().then(o=>{o.done?t.complete():t.next(o.value)})},0,!0)})})}function _k(e,n){return kg(Tg(e),n)}function Ak(e,n){if(e!=null){if(bg(e))return Sk(e,n);if(yg(e))return Dk(e,n);if(vg(e))return Nk(e,n);if(Cg(e))return kg(e,n);if(Eg(e))return kk(e,n);if(Sg(e))return _k(e,n)}throw wg(e)}function Xr(e,n){return n?Ak(e,n):St(e)}function lf(...e){let n=Ks(e);return Xr(e,n)}function B8(e,n){let t=Fe(e)?e:()=>e,r=o=>o.error(t());return new et(n?o=>n.schedule(r,0,o):r)}function V8(e){return!!e&&(e instanceof et||Fe(e.lift)&&Fe(e.subscribe))}var Ka=cp(e=>function(){e(this),this.name="EmptyError",this.message="no elements in sequence"});function Rk(e){return e instanceof Date&&!isNaN(e)}function Xn(e,n){return qe((t,r)=>{let o=0;t.subscribe(We(r,s=>{r.next(e.call(n,s,o++))}))})}var{isArray:U8}=Array;function z8(e,n){return U8(n)?e(...n):e(n)}function _g(e){return Xn(n=>z8(e,n))}var{isArray:G8}=Array,{getPrototypeOf:H8,prototype:W8,keys:j8}=Object;function Ag(e){if(e.length===1){let n=e[0];if(G8(n))return{args:n,keys:null};if(q8(n)){let t=j8(n);return{args:t.map(r=>n[r]),keys:t}}}return{args:e,keys:null}}function q8(e){return e&&typeof e=="object"&&H8(e)===W8}function Rg(e,n){return e.reduce((t,r,o)=>(t[r]=n[o],t),{})}function fC(...e){let n=Ks(e),t=xg(e),{args:r,keys:o}=Ag(e);if(r.length===0)return Xr([],n);let s=new et(K8(r,n,o?i=>Rg(o,i):$n));return t?s.pipe(_g(t)):s}function K8(e,n,t=$n){return r=>{Fk(n,()=>{let{length:o}=e,s=new Array(o),i=o,a=o;for(let c=0;c<o;c++)Fk(n,()=>{let l=Xr(e[c],n),u=!1;l.subscribe(We(r,p=>{s[c]=p,u||(u=!0,a--),a||r.next(t(s.slice()))},()=>{--i||r.complete()}))},r)},r)}}function Fk(e,n,t){e?Kn(t,e,n):n()}function Ok(e,n,t,r,o,s,i,a){let c=[],l=0,u=0,p=!1,d=()=>{p&&!c.length&&!l&&n.complete()},f=h=>l<r?m(h):c.push(h),m=h=>{s&&n.next(h),l++;let g=!1;St(t(h,u++)).subscribe(We(n,x=>{o?.(x),s?f(x):n.next(x)},()=>{g=!0},void 0,()=>{if(g)try{for(l--;c.length&&l<r;){let x=c.shift();i?Kn(n,i,()=>m(x)):m(x)}d()}catch(x){n.error(x)}}))};return e.subscribe(We(n,f,()=>{p=!0,d()})),()=>{a?.()}}function Xa(e,n,t=1/0){return Fe(n)?Xa((r,o)=>Xn((s,i)=>n(r,s,o,i))(St(e(r,o))),t):(typeof n=="number"&&(t=n),qe((r,o)=>Ok(r,o,e,t)))}function Mk(e=1/0){return Xa($n,e)}function $k(){return Mk(1)}function Fg(...e){return $k()(Xr(e,Ks(e)))}function X8(e){return new et(n=>{St(e()).subscribe(n)})}function Og(...e){let n=xg(e),{args:t,keys:r}=Ag(e),o=new et(s=>{let{length:i}=t;if(!i){s.complete();return}let a=new Array(i),c=i,l=i;for(let u=0;u<i;u++){let p=!1;St(t[u]).subscribe(We(s,d=>{p||(p=!0,l--),a[u]=d},()=>c--,void 0,()=>{(!c||!p)&&(l||s.next(r?Rg(r,a):a),s.complete())}))}});return n?o.pipe(_g(n)):o}function Pk(e=0,n,t=vk){let r=-1;return n!=null&&(gg(n)?t=n:r=n),new et(o=>{let s=Rk(e)?+e-t.now():e;s<0&&(s=0);let i=0;return t.schedule(function(){o.closed||(o.next(i++),0<=r?this.schedule(void 0,r):o.complete())},s)})}function uf(e,n){return qe((t,r)=>{let o=0;t.subscribe(We(r,s=>e.call(n,s,o++)&&r.next(s)))})}function pf(e){return qe((n,t)=>{let r=null,o=!1,s;r=n.subscribe(We(t,void 0,void 0,i=>{s=St(e(i,pf(e)(n))),r?(r.unsubscribe(),r=null,s.subscribe(t)):o=!0})),o&&(r.unsubscribe(),r=null,s.subscribe(t))})}function Lk(e,n,t,r,o){return(s,i)=>{let a=t,c=n,l=0;s.subscribe(We(i,u=>{let p=l++;c=a?e(c,u,p):(a=!0,u),r&&i.next(c)},o&&(()=>{a&&i.next(c),i.complete()})))}}function Y8(e,n){return Fe(n)?Xa(e,n,1):Xa(e,1)}function df(e){return qe((n,t)=>{let r=!1;n.subscribe(We(t,o=>{r=!0,t.next(o)},()=>{r||t.next(e),t.complete()}))})}function fp(e){return e<=0?()=>ja:qe((n,t)=>{let r=0;n.subscribe(We(t,o=>{++r<=e&&(t.next(o),e<=r&&t.complete())}))})}function Mg(e=Z8){return qe((n,t)=>{let r=!1;n.subscribe(We(t,o=>{r=!0,t.next(o)},()=>r?t.complete():t.error(e())))})}function Z8(){return new Ka}function Q8(e){return qe((n,t)=>{try{n.subscribe(t)}finally{t.add(e)}})}function J8(e,n){let t=arguments.length>=2;return r=>r.pipe(e?uf((o,s)=>e(o,s,r)):$n,fp(1),t?df(n):Mg(()=>new Ka))}function mC(e){return e<=0?()=>ja:qe((n,t)=>{let r=[];n.subscribe(We(t,o=>{r.push(o),e<r.length&&r.shift()},()=>{for(let o of r)t.next(o);t.complete()},void 0,()=>{r=null}))})}function e5(e,n){let t=arguments.length>=2;return r=>r.pipe(e?uf((o,s)=>e(o,s,r)):$n,mC(1),t?df(n):Mg(()=>new Ka))}function hC(e=1/0){let n;e&&typeof e=="object"?n=e:n={count:e};let{count:t=1/0,delay:r,resetOnSuccess:o=!1}=n;return t<=0?$n:qe((s,i)=>{let a=0,c,l=()=>{let u=!1;c=s.subscribe(We(i,p=>{o&&(a=0),i.next(p)},void 0,p=>{if(a++<t){let d=()=>{c?(c.unsubscribe(),c=null,l()):u=!0};if(r!=null){let f=typeof r=="number"?Pk(r):St(r(p,a)),m=We(i,()=>{m.unsubscribe(),d()},()=>{i.complete()});f.subscribe(m)}else d()}else i.error(p)})),u&&(c.unsubscribe(),c=null,l())};l()})}function t5(e,n){return qe(Lk(e,n,arguments.length>=2,!0))}function Bk(e={}){let{connector:n=()=>new Tn,resetOnError:t=!0,resetOnComplete:r=!0,resetOnRefCountZero:o=!0}=e;return s=>{let i,a,c,l=0,u=!1,p=!1,d=()=>{a?.unsubscribe(),a=void 0},f=()=>{d(),i=c=void 0,u=p=!1},m=()=>{let h=i;f(),h?.unsubscribe()};return qe((h,g)=>{l++,!p&&!u&&d();let x=c=c??n();g.add(()=>{l--,l===0&&!p&&!u&&(a=gC(m,o))}),x.subscribe(g),!i&&l>0&&(i=new rs({next:v=>x.next(v),error:v=>{p=!0,d(),a=gC(f,t,v),x.error(v)},complete:()=>{u=!0,d(),a=gC(f,r),x.complete()}}),St(h).subscribe(i))})(s)}}function gC(e,n,...t){if(n===!0){e();return}if(n===!1)return;let r=new rs({next:()=>{r.unsubscribe(),e()}});return St(n(...t)).subscribe(r)}function xC(e,n,t){let r,o=!1;return e&&typeof e=="object"?{bufferSize:r=1/0,windowTime:n=1/0,refCount:o=!1,scheduler:t}=e:r=e??1/0,Bk({connector:()=>new dg(r,n,t),resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:o})}function n5(...e){let n=Ks(e);return qe((t,r)=>{(n?Fg(e,t,n):Fg(e,t)).subscribe(r)})}function Ya(e,n){return qe((t,r)=>{let o=null,s=0,i=!1,a=()=>i&&!o&&r.complete();t.subscribe(We(r,c=>{o?.unsubscribe();let l=0,u=s++;St(e(c,u)).subscribe(o=We(r,p=>r.next(n?n(c,p,u,l++):p),()=>{o=null,a()}))},()=>{i=!0,a()}))})}function r5(e){return qe((n,t)=>{St(e).subscribe(We(t,()=>t.complete(),sf)),!t.closed&&n.subscribe(t)})}function $g(e,n,t){let r=Fe(e)||n||t?{next:e,error:n,complete:t}:e;return r?qe((o,s)=>{var i;(i=r.subscribe)===null||i===void 0||i.call(r);let a=!0;o.subscribe(We(s,c=>{var l;(l=r.next)===null||l===void 0||l.call(r,c),s.next(c)},()=>{var c;a=!1,(c=r.complete)===null||c===void 0||c.call(r),s.complete()},c=>{var l;a=!1,(l=r.error)===null||l===void 0||l.call(r,c),s.error(c)},()=>{var c,l;a&&((c=r.unsubscribe)===null||c===void 0||c.call(r)),(l=r.finalize)===null||l===void 0||l.call(r)}))}):$n}function Vk(e){let n=De(null);try{return e()}finally{De(n)}}var Uk=Ft(Je({},rp),{consumerIsAlwaysLive:!0,consumerAllowSignalWrites:!0,dirty:!0,hasRun:!1,kind:"effect"});function zk(e){if(e.dirty=!1,e.hasRun&&!sp(e))return;e.hasRun=!0;let n=op(e);try{e.cleanup(),e.fn()}finally{of(e,n)}}var zg="https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss",ze=class extends Error{code;constructor(n,t){super(hp(n,t)),this.code=n}};function o5(e){return`NG0${Math.abs(e)}`}function hp(e,n){return`${o5(e)}${n?": "+n:""}`}var gp=globalThis;function it(e){for(let n in e)if(e[n]===it)return n;throw Error("")}function ss(e){if(typeof e=="string")return e;if(Array.isArray(e))return`[${e.map(ss).join(", ")}]`;if(e==null)return""+e;let n=e.overriddenName||e.name;if(n)return`${n}`;let t=e.toString();if(t==null)return""+t;let r=t.indexOf(`
`);return r>=0?t.slice(0,r):t}function DC(e,n){return e?n?`${e} ${n}`:e:n||""}var s5=it({__forward_ref__:it});function Gg(e){return e.__forward_ref__=Gg,e.toString=function(){return ss(this())},e}function Yn(e){return kC(e)?e():e}function kC(e){return typeof e=="function"&&e.hasOwnProperty(s5)&&e.__forward_ref__===Gg}function jk(e,n){e==null&&_C(n,e,null,"!=")}function _C(e,n,t,r){throw new Error(`ASSERTION ERROR: ${e}`+(r==null?"":` [Expected=> ${t} ${r} ${n} <=Actual]`))}function tt(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function yf(e){return{providers:e.providers||[],imports:e.imports||[]}}function vf(e){return a5(e,Hg)}function i5(e){return vf(e)!==null}function a5(e,n){return e.hasOwnProperty(n)&&e[n]||null}function c5(e){let n=e?.[Hg]??null;return n||null}function vC(e){return e&&e.hasOwnProperty(Lg)?e[Lg]:null}var Hg=it({\u0275prov:it}),Lg=it({\u0275inj:it}),Ee=class{_desc;ngMetadataName="InjectionToken";\u0275prov;constructor(n,t){this._desc=n,this.\u0275prov=void 0,typeof t=="number"?this.__NG_ELEMENT_ID__=t:t!==void 0&&(this.\u0275prov=tt({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}};function AC(e){return e&&!!e.\u0275providers}var RC=it({\u0275cmp:it}),FC=it({\u0275dir:it}),OC=it({\u0275pipe:it}),MC=it({\u0275mod:it}),hf=it({\u0275fac:it}),ec=it({__NG_ELEMENT_ID__:it}),Hk=it({__NG_ENV_ID__:it});function tc(e){return typeof e=="string"?e:e==null?"":String(e)}function Bg(e){return typeof e=="function"?e.name||e.toString():typeof e=="object"&&e!=null&&typeof e.type=="function"?e.type.name||e.type.toString():tc(e)}var $C=it({ngErrorCode:it}),qk=it({ngErrorMessage:it}),mf=it({ngTokenPath:it});function PC(e,n){return Kk("",-200,n)}function Wg(e,n){throw new ze(-201,!1)}function l5(e,n){e[mf]??=[];let t=e[mf],r;typeof n=="object"&&"multi"in n&&n?.multi===!0?(jk(n.provide,"Token with multi: true should have a provide property"),r=Bg(n.provide)):r=Bg(n),t[0]!==r&&e[mf].unshift(r)}function u5(e,n){let t=e[mf],r=e[$C],o=e[qk]||e.message;return e.message=d5(o,r,t,n),e}function Kk(e,n,t){let r=new ze(n,e);return r[$C]=n,r[qk]=e,t&&(r[mf]=t),r}function p5(e){return e[$C]}function d5(e,n,t=[],r=null){let o="";t&&t.length>1&&(o=` Path: ${t.join(" -> ")}.`);let s=r?` Source: ${r}.`:"";return hp(n,`${e}${s}${o}`)}var bC;function Xk(){return bC}function Pn(e){let n=bC;return bC=e,n}function LC(e,n,t){let r=vf(e);if(r&&r.providedIn=="root")return r.value===void 0?r.value=r.factory():r.value;if(t&8)return null;if(n!==void 0)return n;Wg(e,"Injector")}var f5={},Za=f5,m5="__NG_DI_FLAG__",CC=class{injector;constructor(n){this.injector=n}retrieve(n,t){let r=Qa(t)||0;try{return this.injector.get(n,r&8?null:Za,r)}catch(o){if(np(o))return o;throw o}}};function h5(e,n=0){let t=ng();if(t===void 0)throw new ze(-203,!1);if(t===null)return LC(e,void 0,n);{let r=g5(n),o=t.retrieve(e,r);if(np(o)){if(r.optional)return null;throw o}return o}}function at(e,n=0){return(Xk()||h5)(Yn(e),n)}function Ie(e,n){return at(e,Qa(n))}function Qa(e){return typeof e>"u"||typeof e=="number"?e:0|(e.optional&&8)|(e.host&&1)|(e.self&&2)|(e.skipSelf&&4)}function g5(e){return{optional:!!(e&8),host:!!(e&1),self:!!(e&2),skipSelf:!!(e&4)}}function wC(e){let n=[];for(let t=0;t<e.length;t++){let r=Yn(e[t]);if(Array.isArray(r)){if(r.length===0)throw new ze(900,!1);let o,s=0;for(let i=0;i<r.length;i++){let a=r[i],c=x5(a);typeof c=="number"?c===-1?o=a.token:s|=c:o=a}n.push(at(o,s))}else n.push(at(r))}return n}function x5(e){return e[m5]}function Xs(e,n){let t=e.hasOwnProperty(hf);return t?e[hf]:null}function Yk(e,n,t){if(e.length!==n.length)return!1;for(let r=0;r<e.length;r++){let o=e[r],s=n[r];if(t&&(o=t(o),s=t(s)),s!==o)return!1}return!0}function Zk(e){return e.flat(Number.POSITIVE_INFINITY)}function jg(e,n){e.forEach(t=>Array.isArray(t)?jg(t,n):n(t))}function BC(e,n,t){n>=e.length?e.push(t):e.splice(n,0,t)}function bf(e,n){return n>=e.length-1?e.pop():e.splice(n,1)[0]}function Qk(e,n,t,r){let o=e.length;if(o==n)e.push(t,r);else if(o===1)e.push(r,e[0]),e[0]=t;else{for(o--,e.push(e[o-1],e[o]);o>n;){let s=o-2;e[o]=e[s],o--}e[n]=t,e[n+1]=r}}function Jk(e,n,t){let r=xp(e,n);return r>=0?e[r|1]=t:(r=~r,Qk(e,r,n,t)),r}function qg(e,n){let t=xp(e,n);if(t>=0)return e[t|1]}function xp(e,n){return y5(e,n,1)}function y5(e,n,t){let r=0,o=e.length>>t;for(;o!==r;){let s=r+(o-r>>1),i=e[s<<t];if(n===i)return s<<t;i>n?o=s:r=s+1}return~(o<<t)}var nc={},kr=[],Qs=new Ee(""),VC=new Ee("",-1),UC=new Ee(""),gf=class{get(n,t=Za){if(t===Za){let o=Kk("",-201);throw o.name="\u0275NotFound",o}return t}};function zC(e){return e[MC]||null}function Js(e){return e[RC]||null}function GC(e){return e[FC]||null}function e_(e){return e[OC]||null}function hr(e){return{\u0275providers:e}}function t_(e){return hr([{provide:Qs,multi:!0,useValue:e}])}function n_(...e){return{\u0275providers:HC(!0,e),\u0275fromNgModule:!0}}function HC(e,...n){let t=[],r=new Set,o,s=i=>{t.push(i)};return jg(n,i=>{let a=i;Vg(a,s,[],r)&&(o||=[],o.push(a))}),o!==void 0&&r_(o,s),t}function r_(e,n){for(let t=0;t<e.length;t++){let{ngModule:r,providers:o}=e[t];WC(o,s=>{n(s,r)})}}function Vg(e,n,t,r){if(e=Yn(e),!e)return!1;let o=null,s=vC(e),i=!s&&Js(e);if(!s&&!i){let c=e.ngModule;if(s=vC(c),s)o=c;else return!1}else{if(i&&!i.standalone)return!1;o=e}let a=r.has(o);if(i){if(a)return!1;if(r.add(o),i.dependencies){let c=typeof i.dependencies=="function"?i.dependencies():i.dependencies;for(let l of c)Vg(l,n,t,r)}}else if(s){if(s.imports!=null&&!a){r.add(o);let l;try{jg(s.imports,u=>{Vg(u,n,t,r)&&(l||=[],l.push(u))})}finally{}l!==void 0&&r_(l,n)}if(!a){let l=Xs(o)||(()=>new o);n({provide:o,useFactory:l,deps:kr},o),n({provide:UC,useValue:o,multi:!0},o),n({provide:Qs,useValue:()=>at(o),multi:!0},o)}let c=s.providers;if(c!=null&&!a){let l=e;WC(c,u=>{n(u,l)})}}else return!1;return o!==e&&e.providers!==void 0}function WC(e,n){for(let t of e)AC(t)&&(t=t.\u0275providers),Array.isArray(t)?WC(t,n):n(t)}var v5=it({provide:String,useValue:it});function o_(e){return e!==null&&typeof e=="object"&&v5 in e}function b5(e){return!!(e&&e.useExisting)}function C5(e){return!!(e&&e.useFactory)}function Ug(e){return typeof e=="function"}var jC=new Ee(""),Pg={},Wk={},yC;function Cf(){return yC===void 0&&(yC=new gf),yC}var _r=class{},Ja=class extends _r{parent;source;scopes;records=new Map;_ngOnDestroyHooks=new Set;_onDestroyHooks=[];get destroyed(){return this._destroyed}_destroyed=!1;injectorDefTypes;constructor(n,t,r,o){super(),this.parent=t,this.source=r,this.scopes=o,EC(n,i=>this.processProvider(i)),this.records.set(VC,mp(void 0,this)),o.has("environment")&&this.records.set(_r,mp(void 0,this));let s=this.records.get(jC);s!=null&&typeof s.value=="string"&&this.scopes.add(s.value),this.injectorDefTypes=new Set(this.get(UC,kr,{self:!0}))}retrieve(n,t){let r=Qa(t)||0;try{return this.get(n,Za,r)}catch(o){if(np(o))return o;throw o}}destroy(){ff(this),this._destroyed=!0;let n=De(null);try{for(let r of this._ngOnDestroyHooks)r.ngOnDestroy();let t=this._onDestroyHooks;this._onDestroyHooks=[];for(let r of t)r()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),De(n)}}onDestroy(n){return ff(this),this._onDestroyHooks.push(n),()=>this.removeOnDestroy(n)}runInContext(n){ff(this);let t=To(this),r=Pn(void 0),o;try{return n()}finally{To(t),Pn(r)}}get(n,t=Za,r){if(ff(this),n.hasOwnProperty(Hk))return n[Hk](this);let o=Qa(r),s,i=To(this),a=Pn(void 0);try{if(!(o&4)){let l=this.records.get(n);if(l===void 0){let u=S5(n)&&vf(n);u&&this.injectableDefInScope(u)?l=mp(IC(n),Pg):l=null,this.records.set(n,l)}if(l!=null)return this.hydrate(n,l,o)}let c=o&2?Cf():this.parent;return t=o&8&&t===Za?null:t,c.get(n,t)}catch(c){let l=p5(c);throw l===-200||l===-201?new ze(l,null):c}finally{Pn(a),To(i)}}resolveInjectorInitializers(){let n=De(null),t=To(this),r=Pn(void 0),o;try{let s=this.get(Qs,kr,{self:!0});for(let i of s)i()}finally{To(t),Pn(r),De(n)}}toString(){let n=[],t=this.records;for(let r of t.keys())n.push(ss(r));return`R3Injector[${n.join(", ")}]`}processProvider(n){n=Yn(n);let t=Ug(n)?n:Yn(n&&n.provide),r=I5(n);if(!Ug(n)&&n.multi===!0){let o=this.records.get(t);o||(o=mp(void 0,Pg,!0),o.factory=()=>wC(o.multi),this.records.set(t,o)),t=n,o.multi.push(n)}this.records.set(t,r)}hydrate(n,t,r){let o=De(null);try{if(t.value===Wk)throw PC(ss(n));return t.value===Pg&&(t.value=Wk,t.value=t.factory(void 0,r)),typeof t.value=="object"&&t.value&&T5(t.value)&&this._ngOnDestroyHooks.add(t.value),t.value}finally{De(o)}}injectableDefInScope(n){if(!n.providedIn)return!1;let t=Yn(n.providedIn);return typeof t=="string"?t==="any"||this.scopes.has(t):this.injectorDefTypes.has(t)}removeOnDestroy(n){let t=this._onDestroyHooks.indexOf(n);t!==-1&&this._onDestroyHooks.splice(t,1)}};function IC(e){let n=vf(e),t=n!==null?n.factory:Xs(e);if(t!==null)return t;if(e instanceof Ee)throw new ze(204,!1);if(e instanceof Function)return w5(e);throw new ze(204,!1)}function w5(e){if(e.length>0)throw new ze(204,!1);let t=c5(e);return t!==null?()=>t.factory(e):()=>new e}function I5(e){if(o_(e))return mp(void 0,e.useValue);{let n=s_(e);return mp(n,Pg)}}function s_(e,n,t){let r;if(Ug(e)){let o=Yn(e);return Xs(o)||IC(o)}else if(o_(e))r=()=>Yn(e.useValue);else if(C5(e))r=()=>e.useFactory(...wC(e.deps||[]));else if(b5(e))r=(o,s)=>at(Yn(e.useExisting),s!==void 0&&s&8?8:void 0);else{let o=Yn(e&&(e.useClass||e.provide));if(E5(e))r=()=>new o(...wC(e.deps));else return Xs(o)||IC(o)}return r}function ff(e){if(e.destroyed)throw new ze(205,!1)}function mp(e,n,t=!1){return{factory:e,value:n,multi:t?[]:void 0}}function E5(e){return!!e.deps}function T5(e){return e!==null&&typeof e=="object"&&typeof e.ngOnDestroy=="function"}function S5(e){return typeof e=="function"||typeof e=="object"&&e.ngMetadataName==="InjectionToken"}function EC(e,n){for(let t of e)Array.isArray(t)?EC(t,n):t&&AC(t)?EC(t.\u0275providers,n):n(t)}function Kg(e,n){let t;e instanceof Ja?(ff(e),t=e):t=new CC(e);let r,o=To(t),s=Pn(void 0);try{return n()}finally{To(o),Pn(s)}}function i_(){return Xk()!==void 0||ng()!=null}var Yr=0,we=1,Te=2,ln=3,Ar=4,Rr=5,wf=6,yp=7,gn=8,rc=9,Do=10,tn=11,vp=12,qC=13,oc=14,Fr=15,ei=16,sc=17,ko=18,If=19,KC=20,os=21,Xg=22,is=23,gr=24,Yg=25,Wt=26,a_=1;var ti=7,Ef=8,ic=9,Sn=10;function as(e){return Array.isArray(e)&&typeof e[a_]=="object"}function Zr(e){return Array.isArray(e)&&e[a_]===!0}function XC(e){return(e.flags&4)!==0}function ni(e){return e.componentOffset>-1}function Tf(e){return(e.flags&1)===1}function ac(e){return!!e.template}function bp(e){return(e[Te]&512)!==0}function cc(e){return(e[Te]&256)===256}var YC="svg",c_="math";function Or(e){for(;Array.isArray(e);)e=e[Yr];return e}function ZC(e,n){return Or(n[e])}function Qr(e,n){return Or(n[e.index])}function Sf(e,n){return e.data[n]}function QC(e,n){return e[n]}function JC(e,n,t,r){t>=e.data.length&&(e.data[t]=null,e.blueprint[t]=null),n[t]=r}function Jr(e,n){let t=n[e];return as(t)?t:t[Yr]}function l_(e){return(e[Te]&4)===4}function Zg(e){return(e[Te]&128)===128}function u_(e){return Zr(e[ln])}function _o(e,n){return n==null?null:e[n]}function ew(e){e[sc]=0}function tw(e){e[Te]&1024||(e[Te]|=1024,Zg(e)&&lc(e))}function p_(e,n){for(;e>0;)n=n[oc],e--;return n}function Nf(e){return!!(e[Te]&9216||e[gr]?.dirty)}function Qg(e){e[Do].changeDetectionScheduler?.notify(8),e[Te]&64&&(e[Te]|=1024),Nf(e)&&lc(e)}function lc(e){e[Do].changeDetectionScheduler?.notify(0);let n=Ys(e);for(;n!==null&&!(n[Te]&8192||(n[Te]|=8192,!Zg(n)));)n=Ys(n)}function nw(e,n){if(cc(e))throw new ze(911,!1);e[os]===null&&(e[os]=[]),e[os].push(n)}function d_(e,n){if(e[os]===null)return;let t=e[os].indexOf(n);t!==-1&&e[os].splice(t,1)}function Ys(e){let n=e[ln];return Zr(n)?n[ln]:n}function rw(e){return e[yp]??=[]}function ow(e){return e.cleanup??=[]}function f_(e,n,t,r){let o=rw(n);o.push(t),e.firstCreatePass&&ow(e).push(r,o.length-1)}var Le={lFrame:S_(null),bindingsEnabled:!0,skipHydrationRootTNode:null},Df=(function(e){return e[e.Off=0]="Off",e[e.Exhaustive=1]="Exhaustive",e[e.OnlyDirtyViews=2]="OnlyDirtyViews",e})(Df||{}),N5=0,TC=!1;function m_(){return Le.lFrame.elementDepthCount}function h_(){Le.lFrame.elementDepthCount++}function sw(){Le.lFrame.elementDepthCount--}function iw(){return Le.bindingsEnabled}function g_(){return Le.skipHydrationRootTNode!==null}function aw(e){return Le.skipHydrationRootTNode===e}function cw(){Le.skipHydrationRootTNode=null}function nt(){return Le.lFrame.lView}function Zn(){return Le.lFrame.tView}function eo(e){return Le.lFrame.contextLView=e,e[gn]}function to(e){return Le.lFrame.contextLView=null,e}function xr(){let e=lw();for(;e!==null&&e.type===64;)e=e.parent;return e}function lw(){return Le.lFrame.currentTNode}function x_(){let e=Le.lFrame,n=e.currentTNode;return e.isParent?n:n.parent}function Cp(e,n){let t=Le.lFrame;t.currentTNode=e,t.isParent=n}function uw(){return Le.lFrame.isParent}function y_(){Le.lFrame.isParent=!1}function pw(e){_C("Must never be called in production mode"),N5=e}function dw(){return TC}function wp(e){let n=TC;return TC=e,n}function fw(){let e=Le.lFrame,n=e.bindingRootIndex;return n===-1&&(n=e.bindingRootIndex=e.tView.bindingStartIndex),n}function v_(){return Le.lFrame.bindingIndex}function b_(e){return Le.lFrame.bindingIndex=e}function kf(){return Le.lFrame.bindingIndex++}function mw(e){let n=Le.lFrame,t=n.bindingIndex;return n.bindingIndex=n.bindingIndex+e,t}function C_(){return Le.lFrame.inI18n}function w_(e,n){let t=Le.lFrame;t.bindingIndex=t.bindingRootIndex=e,Jg(n)}function I_(){return Le.lFrame.currentDirectiveIndex}function Jg(e){Le.lFrame.currentDirectiveIndex=e}function E_(e){let n=Le.lFrame.currentDirectiveIndex;return n===-1?null:e[n]}function hw(){return Le.lFrame.currentQueryIndex}function ex(e){Le.lFrame.currentQueryIndex=e}function D5(e){let n=e[we];return n.type===2?n.declTNode:n.type===1?e[Rr]:null}function gw(e,n,t){if(t&4){let o=n,s=e;for(;o=o.parent,o===null&&!(t&1);)if(o=D5(s),o===null||(s=s[oc],o.type&10))break;if(o===null)return!1;n=o,e=s}let r=Le.lFrame=T_();return r.currentTNode=n,r.lView=e,!0}function tx(e){let n=T_(),t=e[we];Le.lFrame=n,n.currentTNode=t.firstChild,n.lView=e,n.tView=t,n.contextLView=e,n.bindingIndex=t.bindingStartIndex,n.inI18n=!1}function T_(){let e=Le.lFrame,n=e===null?null:e.child;return n===null?S_(e):n}function S_(e){let n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return e!==null&&(e.child=n),n}function N_(){let e=Le.lFrame;return Le.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}var xw=N_;function nx(){let e=N_();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function D_(e){return(Le.lFrame.contextLView=p_(e,Le.lFrame.contextLView))[gn]}function ri(){return Le.lFrame.selectedIndex}function oi(e){Le.lFrame.selectedIndex=e}function yw(){let e=Le.lFrame;return Sf(e.tView,e.selectedIndex)}function _f(){Le.lFrame.currentNamespace=YC}function Af(){k5()}function k5(){Le.lFrame.currentNamespace=null}function k_(){return Le.lFrame.currentNamespace}var __=!0;function rx(){return __}function ox(e){__=e}var _5={elements:void 0};function A_(){return _5}function SC(e,n=null,t=null,r){let o=vw(e,n,t,r);return o.resolveInjectorInitializers(),o}function vw(e,n=null,t=null,r,o=new Set){let s=[t||kr,n_(e)];return r=r||(typeof e=="object"?void 0:ss(e)),new Ja(s,n||Cf(),r||null,o)}var So=class e{static THROW_IF_NOT_FOUND=Za;static NULL=new gf;static create(n,t){if(Array.isArray(n))return SC({name:""},t,n,"");{let r=n.name??"";return SC({name:r},n.parent,n.providers,r)}}static \u0275prov=tt({token:e,providedIn:"any",factory:()=>at(VC)});static __NG_ELEMENT_ID__=-1},Ip=new Ee(""),uc=(()=>{class e{static __NG_ELEMENT_ID__=A5;static __NG_ENV_ID__=t=>t}return e})(),xf=class extends uc{_lView;constructor(n){super(),this._lView=n}get destroyed(){return cc(this._lView)}onDestroy(n){let t=this._lView;return nw(t,n),()=>d_(t,n)}};function A5(){return new xf(nt())}var Zs=class{_console=console;handleError(n){this._console.error("ERROR",n)}},Ao=new Ee("",{providedIn:"root",factory:()=>{let e=Ie(_r),n;return t=>{e.destroyed&&!n?setTimeout(()=>{throw t}):(n??=e.get(Zs),n.handleError(t))}}}),R_={provide:Qs,useValue:()=>void Ie(Zs),multi:!0},R5=new Ee("",{providedIn:"root",factory:()=>{let e=Ie(Ip).defaultView;if(!e)return;let n=Ie(Ao),t=s=>{n(s.reason),s.preventDefault()},r=s=>{s.error?n(s.error):n(new Error(s.message,{cause:s})),s.preventDefault()},o=()=>{e.addEventListener("unhandledrejection",t),e.addEventListener("error",r)};typeof Zone<"u"?Zone.root.run(o):o(),Ie(uc).onDestroy(()=>{e.removeEventListener("error",r),e.removeEventListener("unhandledrejection",t)})}});function F5(){return hr([t_(()=>void Ie(R5))])}function lt(e,n){let[t,r,o]=tC(e,n?.equal),s=t,i=s[qn];return s.set=r,s.update=o,s.asReadonly=bw.bind(s),s}function bw(){let e=this[qn];if(e.readonlyFn===void 0){let n=()=>this();n[qn]=e,e.readonlyFn=n}return e.readonlyFn}var No=class{},Rf=new Ee("",{providedIn:"root",factory:()=>!1});var Cw=new Ee(""),sx=new Ee("");var Ff=(()=>{class e{view;node;constructor(t,r){this.view=t,this.node=r}static __NG_ELEMENT_ID__=O5}return e})();function O5(){return new Ff(nt(),xr())}var pc=(()=>{class e{taskId=0;pendingTasks=new Set;destroyed=!1;pendingTask=new Wa(!1);get hasPendingTasks(){return this.destroyed?!1:this.pendingTask.value}get hasPendingTasksObservable(){return this.destroyed?new et(t=>{t.next(!1),t.complete()}):this.pendingTask}add(){!this.hasPendingTasks&&!this.destroyed&&this.pendingTask.next(!0);let t=this.taskId++;return this.pendingTasks.add(t),t}has(t){return this.pendingTasks.has(t)}remove(t){this.pendingTasks.delete(t),this.pendingTasks.size===0&&this.hasPendingTasks&&this.pendingTask.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this.hasPendingTasks&&this.pendingTask.next(!1),this.destroyed=!0,this.pendingTask.unsubscribe()}static \u0275prov=tt({token:e,providedIn:"root",factory:()=>new e})}return e})();function dc(...e){}var Of=(()=>{class e{static \u0275prov=tt({token:e,providedIn:"root",factory:()=>new NC})}return e})(),NC=class{dirtyEffectCount=0;queues=new Map;add(n){this.enqueue(n),this.schedule(n)}schedule(n){n.dirty&&this.dirtyEffectCount++}remove(n){let t=n.zone,r=this.queues.get(t);r.has(n)&&(r.delete(n),n.dirty&&this.dirtyEffectCount--)}enqueue(n){let t=n.zone;this.queues.has(t)||this.queues.set(t,new Set);let r=this.queues.get(t);r.has(n)||r.add(n)}flush(){for(;this.dirtyEffectCount>0;){let n=!1;for(let[t,r]of this.queues)t===null?n||=this.flushQueue(r):n||=t.run(()=>this.flushQueue(r));n||(this.dirtyEffectCount=0)}}flushQueue(n){let t=!1;for(let r of n)r.dirty&&(this.dirtyEffectCount--,t=!0,r.run());return t}};function Hf(e){return{toString:e}.toString()}function z5(e){return typeof e=="function"}var px=class{previousValue;currentValue;firstChange;constructor(n,t,r){this.previousValue=n,this.currentValue=t,this.firstChange=r}isFirstChange(){return this.firstChange}};function cA(e,n,t,r){n!==null?n.applyValueToInputSignal(n,r):e[t]=r}var Qw=(()=>{let e=()=>lA;return e.ngInherit=!0,e})();function lA(e){return e.type.prototype.ngOnChanges&&(e.setInput=H5),G5}function G5(){let e=pA(this),n=e?.current;if(n){let t=e.previous;if(t===nc)e.previous=n;else for(let r in n)t[r]=n[r];e.current=null,this.ngOnChanges(n)}}function H5(e,n,t,r,o){let s=this.declaredInputs[r],i=pA(e)||W5(e,{previous:nc,current:null}),a=i.current||(i.current={}),c=i.previous,l=c[s];a[s]=new px(l&&l.currentValue,t,c===nc),cA(e,n,o,t)}var uA="__ngSimpleChanges__";function pA(e){return e[uA]||null}function W5(e,n){return e[uA]=n}var F_=[];var gt=function(e,n=null,t){for(let r=0;r<F_.length;r++){let o=F_[r];o(e,n,t)}};function j5(e,n,t){let{ngOnChanges:r,ngOnInit:o,ngDoCheck:s}=n.type.prototype;if(r){let i=lA(n);(t.preOrderHooks??=[]).push(e,i),(t.preOrderCheckHooks??=[]).push(e,i)}o&&(t.preOrderHooks??=[]).push(0-e,o),s&&((t.preOrderHooks??=[]).push(e,s),(t.preOrderCheckHooks??=[]).push(e,s))}function dA(e,n){for(let t=n.directiveStart,r=n.directiveEnd;t<r;t++){let s=e.data[t].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:c,ngAfterViewChecked:l,ngOnDestroy:u}=s;i&&(e.contentHooks??=[]).push(-t,i),a&&((e.contentHooks??=[]).push(t,a),(e.contentCheckHooks??=[]).push(t,a)),c&&(e.viewHooks??=[]).push(-t,c),l&&((e.viewHooks??=[]).push(t,l),(e.viewCheckHooks??=[]).push(t,l)),u!=null&&(e.destroyHooks??=[]).push(t,u)}}function ax(e,n,t){fA(e,n,3,t)}function cx(e,n,t,r){(e[Te]&3)===t&&fA(e,n,t,r)}function ww(e,n){let t=e[Te];(t&3)===n&&(t&=16383,t+=1,e[Te]=t)}function fA(e,n,t,r){let o=r!==void 0?e[sc]&65535:0,s=r??-1,i=n.length-1,a=0;for(let c=o;c<i;c++)if(typeof n[c+1]=="number"){if(a=n[c],r!=null&&a>=r)break}else n[c]<0&&(e[sc]+=65536),(a<s||s==-1)&&(q5(e,t,n,c),e[sc]=(e[sc]&4294901760)+c+2),c++}function O_(e,n){gt(4,e,n);let t=De(null);try{n.call(e)}finally{De(t),gt(5,e,n)}}function q5(e,n,t,r){let o=t[r]<0,s=t[r+1],i=o?-t[r]:t[r],a=e[i];o?e[Te]>>14<e[sc]>>16&&(e[Te]&3)===n&&(e[Te]+=16384,O_(a,s)):O_(a,s)}var Tp=-1,Pf=class{factory;name;injectImpl;resolving=!1;canSeeViewProviders;multi;componentProviders;index;providerFactory;constructor(n,t,r,o){this.factory=n,this.name=o,this.canSeeViewProviders=t,this.injectImpl=r}};function K5(e){return(e.flags&8)!==0}function X5(e){return(e.flags&16)!==0}function Y5(e,n,t){let r=0;for(;r<t.length;){let o=t[r];if(typeof o=="number"){if(o!==0)break;r++;let s=t[r++],i=t[r++],a=t[r++];e.setAttribute(n,i,a,s)}else{let s=o,i=t[++r];Q5(s)?e.setProperty(n,s,i):e.setAttribute(n,s,i),r++}}return r}function Z5(e){return e===3||e===4||e===6}function Q5(e){return e.charCodeAt(0)===64}function Dx(e,n){if(!(n===null||n.length===0))if(e===null||e.length===0)e=n.slice();else{let t=-1;for(let r=0;r<n.length;r++){let o=n[r];typeof o=="number"?t=o:t===0||(t===-1||t===2?M_(e,t,o,null,n[++r]):M_(e,t,o,null,null))}}return e}function M_(e,n,t,r,o){let s=0,i=e.length;if(n===-1)i=-1;else for(;s<e.length;){let a=e[s++];if(typeof a=="number"){if(a===n){i=-1;break}else if(a>n){i=s-1;break}}}for(;s<e.length;){let a=e[s];if(typeof a=="number")break;if(a===t){o!==null&&(e[s+1]=o);return}s++,o!==null&&s++}i!==-1&&(e.splice(i,0,n),s=i+1),e.splice(s++,0,t),o!==null&&e.splice(s++,0,o)}function mA(e){return e!==Tp}function dx(e){return e&32767}function J5(e){return e>>16}function fx(e,n){let t=J5(e),r=n;for(;t>0;)r=r[oc],t--;return r}var _w=!0;function mx(e){let n=_w;return _w=e,n}var eq=256,hA=eq-1,gA=5,tq=0,Ro={};function nq(e,n,t){let r;typeof t=="string"?r=t.charCodeAt(0)||0:t.hasOwnProperty(ec)&&(r=t[ec]),r==null&&(r=t[ec]=tq++);let o=r&hA,s=1<<o;n.data[e+(o>>gA)]|=s}function xA(e,n){let t=yA(e,n);if(t!==-1)return t;let r=n[we];r.firstCreatePass&&(e.injectorIndex=n.length,Iw(r.data,e),Iw(n,null),Iw(r.blueprint,null));let o=Jw(e,n),s=e.injectorIndex;if(mA(o)){let i=dx(o),a=fx(o,n),c=a[we].data;for(let l=0;l<8;l++)n[s+l]=a[i+l]|c[i+l]}return n[s+8]=o,s}function Iw(e,n){e.push(0,0,0,0,0,0,0,0,n)}function yA(e,n){return e.injectorIndex===-1||e.parent&&e.parent.injectorIndex===e.injectorIndex||n[e.injectorIndex+8]===null?-1:e.injectorIndex}function Jw(e,n){if(e.parent&&e.parent.injectorIndex!==-1)return e.parent.injectorIndex;let t=0,r=null,o=n;for(;o!==null;){if(r=EA(o),r===null)return Tp;if(t++,o=o[oc],r.injectorIndex!==-1)return r.injectorIndex|t<<16}return Tp}function rq(e,n,t){nq(e,n,t)}function vA(e,n,t){if(t&8||e!==void 0)return e;Wg(n,"NodeInjector")}function bA(e,n,t,r){if(t&8&&r===void 0&&(r=null),(t&3)===0){let o=e[rc],s=Pn(void 0);try{return o?o.get(n,r,t&8):LC(n,r,t&8)}finally{Pn(s)}}return vA(r,n,t)}function CA(e,n,t,r=0,o){if(e!==null){if(n[Te]&2048&&!(r&2)){let i=aq(e,n,t,r,Ro);if(i!==Ro)return i}let s=wA(e,n,t,r,Ro);if(s!==Ro)return s}return bA(n,t,r,o)}function wA(e,n,t,r,o){let s=sq(t);if(typeof s=="function"){if(!gw(n,e,r))return r&1?vA(o,t,r):bA(n,t,r,o);try{let i;if(i=s(r),i==null&&!(r&8))Wg(t);else return i}finally{xw()}}else if(typeof s=="number"){let i=null,a=yA(e,n),c=Tp,l=r&1?n[Fr][Rr]:null;for((a===-1||r&4)&&(c=a===-1?Jw(e,n):n[a+8],c===Tp||!P_(r,!1)?a=-1:(i=n[we],a=dx(c),n=fx(c,n)));a!==-1;){let u=n[we];if($_(s,a,u.data)){let p=oq(a,n,t,i,r,l);if(p!==Ro)return p}c=n[a+8],c!==Tp&&P_(r,n[we].data[a+8]===l)&&$_(s,a,n)?(i=u,a=dx(c),n=fx(c,n)):a=-1}}return o}function oq(e,n,t,r,o,s){let i=n[we],a=i.data[e+8],c=r==null?ni(a)&&_w:r!=i&&(a.type&3)!==0,l=o&1&&s===a,u=lx(a,i,t,c,l);return u!==null?hx(n,i,u,a,o):Ro}function lx(e,n,t,r,o){let s=e.providerIndexes,i=n.data,a=s&1048575,c=e.directiveStart,l=e.directiveEnd,u=s>>20,p=r?a:a+u,d=o?a+u:l;for(let f=p;f<d;f++){let m=i[f];if(f<c&&t===m||f>=c&&m.type===t)return f}if(o){let f=i[c];if(f&&ac(f)&&f.type===t)return c}return null}function hx(e,n,t,r,o){let s=e[t],i=n.data;if(s instanceof Pf){let a=s;if(a.resolving){let f=Bg(i[t]);throw PC(f)}let c=mx(a.canSeeViewProviders);a.resolving=!0;let l=i[t].type||i[t],u,p=a.injectImpl?Pn(a.injectImpl):null,d=gw(e,r,0);try{s=e[t]=a.factory(void 0,o,i,e,r),n.firstCreatePass&&t>=r.directiveStart&&j5(t,i[t],n)}finally{p!==null&&Pn(p),mx(c),a.resolving=!1,xw()}}return s}function sq(e){if(typeof e=="string")return e.charCodeAt(0)||0;let n=e.hasOwnProperty(ec)?e[ec]:void 0;return typeof n=="number"?n>=0?n&hA:iq:n}function $_(e,n,t){let r=1<<e;return!!(t[n+(e>>gA)]&r)}function P_(e,n){return!(e&2)&&!(e&1&&n)}var mc=class{_tNode;_lView;constructor(n,t){this._tNode=n,this._lView=t}get(n,t,r){return CA(this._tNode,this._lView,n,Qa(r),t)}};function iq(){return new mc(xr(),nt())}function IA(e){return Hf(()=>{let n=e.prototype.constructor,t=n[hf]||Aw(n),r=Object.prototype,o=Object.getPrototypeOf(e.prototype).constructor;for(;o&&o!==r;){let s=o[hf]||Aw(o);if(s&&s!==t)return s;o=Object.getPrototypeOf(o)}return s=>new s})}function Aw(e){return kC(e)?()=>{let n=Aw(Yn(e));return n&&n()}:Xs(e)}function aq(e,n,t,r,o){let s=e,i=n;for(;s!==null&&i!==null&&i[Te]&2048&&!bp(i);){let a=wA(s,i,t,r|2,Ro);if(a!==Ro)return a;let c=s.parent;if(!c){let l=i[KC];if(l){let u=l.get(t,Ro,r);if(u!==Ro)return u}c=EA(i),i=i[oc]}s=c}return o}function EA(e){let n=e[we],t=n.type;return t===2?n.declTNode:t===1?e[Rr]:null}function cq(){return _p(xr(),nt())}function _p(e,n){return new xc(Qr(e,n))}var xc=(()=>{class e{nativeElement;constructor(t){this.nativeElement=t}static __NG_ELEMENT_ID__=cq}return e})();function lq(e){return e instanceof xc?e.nativeElement:e}function uq(){return this._results[Symbol.iterator]()}var gx=class{_emitDistinctChangesOnly;dirty=!0;_onDirty=void 0;_results=[];_changesDetected=!1;_changes=void 0;length=0;first=void 0;last=void 0;get changes(){return this._changes??=new Tn}constructor(n=!1){this._emitDistinctChangesOnly=n}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,t){return this._results.reduce(n,t)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,t){this.dirty=!1;let r=Zk(n);(this._changesDetected=!Yk(this._results,r,t))&&(this._results=r,this.length=r.length,this.last=r[this.length-1],this.first=r[0])}notifyOnChanges(){this._changes!==void 0&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.next(this)}onDirty(n){this._onDirty=n}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){this._changes!==void 0&&(this._changes.complete(),this._changes.unsubscribe())}[Symbol.iterator]=uq};function TA(e){return(e.flags&128)===128}var eI=(function(e){return e[e.OnPush=0]="OnPush",e[e.Default=1]="Default",e})(eI||{}),SA=new Map,pq=0;function dq(){return pq++}function fq(e){SA.set(e[If],e)}function Rw(e){SA.delete(e[If])}var L_="__ngContext__";function Sp(e,n){as(n)?(e[L_]=n[If],fq(n)):e[L_]=n}function NA(e){return kA(e[vp])}function DA(e){return kA(e[Ar])}function kA(e){for(;e!==null&&!Zr(e);)e=e[Ar];return e}var Fw;function mq(e){Fw=e}function _A(){if(Fw!==void 0)return Fw;if(typeof document<"u")return document;throw new ze(210,!1)}var hq=new Ee("",{providedIn:"root",factory:()=>gq}),gq="ng",AA=new Ee(""),xq=new Ee("",{providedIn:"platform",factory:()=>"unknown"});var yq=new Ee("",{providedIn:"root",factory:()=>_A().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});var vq="h",bq="b";var RA=!1,FA=new Ee("",{providedIn:"root",factory:()=>RA});var Cq=(e,n,t,r)=>{};function wq(e,n,t,r){Cq(e,n,t,r)}function tI(e){return(e.flags&32)===32}var Iq=()=>null;function OA(e,n,t=!1){return Iq(e,n,t)}function MA(e,n){let t=e.contentQueries;if(t!==null){let r=De(null);try{for(let o=0;o<t.length;o+=2){let s=t[o],i=t[o+1];if(i!==-1){let a=e.data[i];ex(s),a.contentQueries(2,n[i],i)}}}finally{De(r)}}}function Ow(e,n,t){ex(0);let r=De(null);try{n(e,t)}finally{De(r)}}function $A(e,n,t){if(XC(n)){let r=De(null);try{let o=n.directiveStart,s=n.directiveEnd;for(let i=o;i<s;i++){let a=e.data[i];if(a.contentQueries){let c=t[i];a.contentQueries(1,c,i)}}}finally{De(r)}}}var Np=(function(e){return e[e.Emulated=0]="Emulated",e[e.None=2]="None",e[e.ShadowDom=3]="ShadowDom",e})(Np||{});var xx=class{changingThisBreaksApplicationSecurity;constructor(n){this.changingThisBreaksApplicationSecurity=n}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${zg})`}};function nI(e){return e instanceof xx?e.changingThisBreaksApplicationSecurity:e}function PA(e,n){let t=LA(e);if(t!=null&&t!==n){if(t==="ResourceURL"&&n==="URL")return!0;throw new Error(`Required a safe ${n}, got a ${t} (see ${zg})`)}return t===n}function LA(e){return e instanceof xx&&e.getTypeName()||null}var Eq=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;function BA(e){return e=String(e),e.match(Eq)?e:"unsafe:"+e}var rI=(function(e){return e[e.NONE=0]="NONE",e[e.HTML=1]="HTML",e[e.STYLE=2]="STYLE",e[e.SCRIPT=3]="SCRIPT",e[e.URL=4]="URL",e[e.RESOURCE_URL=5]="RESOURCE_URL",e})(rI||{});function oI(e){let n=Tq();return n?n.sanitize(rI.URL,e)||"":PA(e,"URL")?nI(e):BA(tc(e))}function Tq(){let e=nt();return e&&e[Do].sanitizer}function VA(e){return e instanceof Function?e():e}function Sq(e,n,t){let r=e.length;for(;;){let o=e.indexOf(n,t);if(o===-1)return o;if(o===0||e.charCodeAt(o-1)<=32){let s=n.length;if(o+s===r||e.charCodeAt(o+s)<=32)return o}t=o+1}}var UA="ng-template";function Nq(e,n,t,r){let o=0;if(r){for(;o<n.length&&typeof n[o]=="string";o+=2)if(n[o]==="class"&&Sq(n[o+1].toLowerCase(),t,0)!==-1)return!0}else if(sI(e))return!1;if(o=n.indexOf(1,o),o>-1){let s;for(;++o<n.length&&typeof(s=n[o])=="string";)if(s.toLowerCase()===t)return!0}return!1}function sI(e){return e.type===4&&e.value!==UA}function Dq(e,n,t){let r=e.type===4&&!t?UA:e.value;return n===r}function kq(e,n,t){let r=4,o=e.attrs,s=o!==null?Rq(o):0,i=!1;for(let a=0;a<n.length;a++){let c=n[a];if(typeof c=="number"){if(!i&&!no(r)&&!no(c))return!1;if(i&&no(c))continue;i=!1,r=c|r&1;continue}if(!i)if(r&4){if(r=2|r&1,c!==""&&!Dq(e,c,t)||c===""&&n.length===1){if(no(r))return!1;i=!0}}else if(r&8){if(o===null||!Nq(e,o,c,t)){if(no(r))return!1;i=!0}}else{let l=n[++a],u=_q(c,o,sI(e),t);if(u===-1){if(no(r))return!1;i=!0;continue}if(l!==""){let p;if(u>s?p="":p=o[u+1].toLowerCase(),r&2&&l!==p){if(no(r))return!1;i=!0}}}}return no(r)||i}function no(e){return(e&1)===0}function _q(e,n,t,r){if(n===null)return-1;let o=0;if(r||!t){let s=!1;for(;o<n.length;){let i=n[o];if(i===e)return o;if(i===3||i===6)s=!0;else if(i===1||i===2){let a=n[++o];for(;typeof a=="string";)a=n[++o];continue}else{if(i===4)break;if(i===0){o+=4;continue}}o+=s?1:2}return-1}else return Fq(n,e)}function Aq(e,n,t=!1){for(let r=0;r<n.length;r++)if(kq(e,n[r],t))return!0;return!1}function Rq(e){for(let n=0;n<e.length;n++){let t=e[n];if(Z5(t))return n}return e.length}function Fq(e,n){let t=e.indexOf(4);if(t>-1)for(t++;t<e.length;){let r=e[t];if(typeof r=="number")return-1;if(r===n)return t;t++}return-1}function B_(e,n){return e?":not("+n.trim()+")":n}function Oq(e){let n=e[0],t=1,r=2,o="",s=!1;for(;t<e.length;){let i=e[t];if(typeof i=="string")if(r&2){let a=e[++t];o+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else r&8?o+="."+i:r&4&&(o+=" "+i);else o!==""&&!no(i)&&(n+=B_(s,o),o=""),r=i,s=s||!no(r);t++}return o!==""&&(n+=B_(s,o)),n}function Mq(e){return e.map(Oq).join(",")}function $q(e){let n=[],t=[],r=1,o=2;for(;r<e.length;){let s=e[r];if(typeof s=="string")o===2?s!==""&&n.push(s,e[++r]):o===8&&t.push(s);else{if(!no(o))break;o=s}r++}return t.length&&n.push(1,...t),n}var Mr={};function Pq(e,n){return e.createText(n)}function Lq(e,n,t){e.setValue(n,t)}function zA(e,n,t){return e.createElement(n,t)}function yx(e,n,t,r,o){e.insertBefore(n,t,r,o)}function GA(e,n,t){e.appendChild(n,t)}function V_(e,n,t,r,o){r!==null?yx(e,n,t,r,o):GA(e,n,t)}function Bq(e,n,t){e.removeChild(null,n,t)}function Vq(e,n,t){e.setAttribute(n,"style",t)}function Uq(e,n,t){t===""?e.removeAttribute(n,"class"):e.setAttribute(n,"class",t)}function HA(e,n,t){let{mergedAttrs:r,classes:o,styles:s}=t;r!==null&&Y5(e,n,r),o!==null&&Uq(e,n,o),s!==null&&Vq(e,n,s)}function iI(e,n,t,r,o,s,i,a,c,l,u){let p=Wt+r,d=p+o,f=zq(p,d),m=typeof l=="function"?l():l;return f[we]={type:e,blueprint:f,template:t,queries:null,viewQuery:a,declTNode:n,data:f.slice().fill(null,p),bindingStartIndex:p,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:typeof s=="function"?s():s,pipeRegistry:typeof i=="function"?i():i,firstChild:null,schemas:c,consts:m,incompleteFirstPass:!1,ssrId:u}}function zq(e,n){let t=[];for(let r=0;r<n;r++)t.push(r<e?null:Mr);return t}function Gq(e){let n=e.tView;return n===null||n.incompleteFirstPass?e.tView=iI(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts,e.id):n}function aI(e,n,t,r,o,s,i,a,c,l,u){let p=n.blueprint.slice();return p[Yr]=o,p[Te]=r|4|128|8|64|1024,(l!==null||e&&e[Te]&2048)&&(p[Te]|=2048),ew(p),p[ln]=p[oc]=e,p[gn]=t,p[Do]=i||e&&e[Do],p[tn]=a||e&&e[tn],p[rc]=c||e&&e[rc]||null,p[Rr]=s,p[If]=dq(),p[wf]=u,p[KC]=l,p[Fr]=n.type==2?e[Fr]:p,p}function Hq(e,n,t){let r=Qr(n,e),o=Gq(t),s=e[Do].rendererFactory,i=cI(e,aI(e,o,null,WA(t),r,n,null,s.createRenderer(r,t),null,null,null));return e[n.index]=i}function WA(e){let n=16;return e.signals?n=4096:e.onPush&&(n=64),n}function jA(e,n,t,r){if(t===0)return-1;let o=n.length;for(let s=0;s<t;s++)n.push(r),e.blueprint.push(r),e.data.push(null);return o}function cI(e,n){return e[vp]?e[qC][Ar]=n:e[vp]=n,e[qC]=n,n}function Me(e=1){qA(Zn(),nt(),ri()+e,!1)}function qA(e,n,t,r){if(!r)if((n[Te]&3)===3){let s=e.preOrderCheckHooks;s!==null&&ax(n,s,t)}else{let s=e.preOrderHooks;s!==null&&cx(n,s,0,t)}oi(t)}var kx=(function(e){return e[e.None=0]="None",e[e.SignalBased=1]="SignalBased",e[e.HasDecoratorInputTransform=2]="HasDecoratorInputTransform",e})(kx||{});function Mw(e,n,t,r){let o=De(null);try{let[s,i,a]=e.inputs[t],c=null;(i&kx.SignalBased)!==0&&(c=n[s][qn]),c!==null&&c.transformFn!==void 0?r=c.transformFn(r):a!==null&&(r=a.call(n,r)),e.setInput!==null?e.setInput(n,c,r,t,s):cA(n,c,s,r)}finally{De(o)}}var Lf=(function(e){return e[e.Important=1]="Important",e[e.DashCase=2]="DashCase",e})(Lf||{}),Wq;function lI(e,n){return Wq(e,n)}function Ep(e,n,t,r,o){if(r!=null){let s,i=!1;Zr(r)?s=r:as(r)&&(i=!0,r=r[Yr]);let a=Or(r);e===0&&t!==null?o==null?GA(n,t,a):yx(n,t,a,o||null,!0):e===1&&t!==null?yx(n,t,a,o||null,!0):e===2?Bq(n,a,i):e===3&&n.destroyNode(a),s!=null&&rK(n,e,s,t,o)}}function jq(e,n){KA(e,n),n[Yr]=null,n[Rr]=null}function qq(e,n,t,r,o,s){r[Yr]=o,r[Rr]=n,_x(e,r,t,1,o,s)}function KA(e,n){n[Do].changeDetectionScheduler?.notify(9),_x(e,n,n[tn],2,null,null)}function Kq(e){let n=e[vp];if(!n)return Ew(e[we],e);for(;n;){let t=null;if(as(n))t=n[vp];else{let r=n[Sn];r&&(t=r)}if(!t){for(;n&&!n[Ar]&&n!==e;)as(n)&&Ew(n[we],n),n=n[ln];n===null&&(n=e),as(n)&&Ew(n[we],n),t=n&&n[Ar]}n=t}}function uI(e,n){let t=e[ic],r=t.indexOf(n);t.splice(r,1)}function pI(e,n){if(cc(n))return;let t=n[tn];t.destroyNode&&_x(e,n,t,3,null,null),Kq(n)}function Ew(e,n){if(cc(n))return;let t=De(null);try{n[Te]&=-129,n[Te]|=256,n[gr]&&Ua(n[gr]),Yq(e,n),Xq(e,n),n[we].type===1&&n[tn].destroy();let r=n[ei];if(r!==null&&Zr(n[ln])){r!==n[ln]&&uI(r,n);let o=n[ko];o!==null&&o.detachView(e)}Rw(n)}finally{De(t)}}function Xq(e,n){let t=e.cleanup,r=n[yp];if(t!==null)for(let i=0;i<t.length-1;i+=2)if(typeof t[i]=="string"){let a=t[i+3];a>=0?r[a]():r[-a].unsubscribe(),i+=2}else{let a=r[t[i+1]];t[i].call(a)}r!==null&&(n[yp]=null);let o=n[os];if(o!==null){n[os]=null;for(let i=0;i<o.length;i++){let a=o[i];a()}}let s=n[is];if(s!==null){n[is]=null;for(let i of s)i.destroy()}}function Yq(e,n){let t;if(e!=null&&(t=e.destroyHooks)!=null)for(let r=0;r<t.length;r+=2){let o=n[t[r]];if(!(o instanceof Pf)){let s=t[r+1];if(Array.isArray(s))for(let i=0;i<s.length;i+=2){let a=o[s[i]],c=s[i+1];gt(4,a,c);try{c.call(a)}finally{gt(5,a,c)}}else{gt(4,o,s);try{s.call(o)}finally{gt(5,o,s)}}}}}function Zq(e,n,t){return Qq(e,n.parent,t)}function Qq(e,n,t){let r=n;for(;r!==null&&r.type&168;)n=r,r=n.parent;if(r===null)return t[Yr];if(ni(r)){let{encapsulation:o}=e.data[r.directiveStart+r.componentOffset];if(o===Np.None||o===Np.Emulated)return null}return Qr(r,t)}function Jq(e,n,t){return tK(e,n,t)}function eK(e,n,t){return e.type&40?Qr(e,t):null}var tK=eK,U_;function dI(e,n,t,r){let o=Zq(e,r,n),s=n[tn],i=r.parent||n[Rr],a=Jq(i,r,n);if(o!=null)if(Array.isArray(t))for(let c=0;c<t.length;c++)V_(s,o,t[c],a,!1);else V_(s,o,t,a,!1);U_!==void 0&&U_(s,r,n,t,o)}function Mf(e,n){if(n!==null){let t=n.type;if(t&3)return Qr(n,e);if(t&4)return $w(-1,e[n.index]);if(t&8){let r=n.child;if(r!==null)return Mf(e,r);{let o=e[n.index];return Zr(o)?$w(-1,o):Or(o)}}else{if(t&128)return Mf(e,n.next);if(t&32)return lI(n,e)()||Or(e[n.index]);{let r=XA(e,n);if(r!==null){if(Array.isArray(r))return r[0];let o=Ys(e[Fr]);return Mf(o,r)}else return Mf(e,n.next)}}}return null}function XA(e,n){if(n!==null){let r=e[Fr][Rr],o=n.projection;return r.projection[o]}return null}function $w(e,n){let t=Sn+e+1;if(t<n.length){let r=n[t],o=r[we].firstChild;if(o!==null)return Mf(r,o)}return n[ti]}function fI(e,n,t,r,o,s,i){for(;t!=null;){if(t.type===128){t=t.next;continue}let a=r[t.index],c=t.type;if(i&&n===0&&(a&&Sp(Or(a),r),t.flags|=2),!tI(t))if(c&8)fI(e,n,t.child,r,o,s,!1),Ep(n,e,o,a,s);else if(c&32){let l=lI(t,r),u;for(;u=l();)Ep(n,e,o,u,s);Ep(n,e,o,a,s)}else c&16?nK(e,n,r,t,o,s):Ep(n,e,o,a,s);t=i?t.projectionNext:t.next}}function _x(e,n,t,r,o,s){fI(t,r,e.firstChild,n,o,s,!1)}function nK(e,n,t,r,o,s){let i=t[Fr],c=i[Rr].projection[r.projection];if(Array.isArray(c))for(let l=0;l<c.length;l++){let u=c[l];Ep(n,e,o,u,s)}else{let l=c,u=i[ln];TA(r)&&(l.flags|=128),fI(e,n,l,u,o,s,!0)}}function rK(e,n,t,r,o){let s=t[ti],i=Or(t);s!==i&&Ep(n,e,r,s,o);for(let a=Sn;a<t.length;a++){let c=t[a];_x(c[we],c,e,n,r,s)}}function oK(e,n,t,r,o){if(n)o?e.addClass(t,r):e.removeClass(t,r);else{let s=r.indexOf("-")===-1?void 0:Lf.DashCase;o==null?e.removeStyle(t,r,s):(typeof o=="string"&&o.endsWith("!important")&&(o=o.slice(0,-10),s|=Lf.Important),e.setStyle(t,r,o,s))}}function YA(e,n,t,r,o){let s=ri(),i=r&2;try{oi(-1),i&&n.length>Wt&&qA(e,n,Wt,!1),gt(i?2:0,o,t),t(r,o)}finally{oi(s),gt(i?3:1,o,t)}}function mI(e,n,t){dK(e,n,t),(t.flags&64)===64&&fK(e,n,t)}function Ax(e,n,t=Qr){let r=n.localNames;if(r!==null){let o=n.index+1;for(let s=0;s<r.length;s+=2){let i=r[s+1],a=i===-1?t(n,e):e[i];e[o++]=a}}}function sK(e,n,t,r){let s=r.get(FA,RA)||t===Np.ShadowDom,i=e.selectRootElement(n,s);return iK(i),i}function iK(e){aK(e)}var aK=()=>null;function cK(e){return e==="class"?"className":e==="for"?"htmlFor":e==="formaction"?"formAction":e==="innerHtml"?"innerHTML":e==="readonly"?"readOnly":e==="tabindex"?"tabIndex":e}function lK(e,n,t,r,o,s){let i=n[we];if(hI(e,i,n,t,r)){ni(e)&&pK(n,e.index);return}e.type&3&&(t=cK(t)),uK(e,n,t,r,o,s)}function uK(e,n,t,r,o,s){if(e.type&3){let i=Qr(e,n);r=s!=null?s(r,e.value||"",t):r,o.setProperty(i,t,r)}else e.type&12}function pK(e,n){let t=Jr(n,e);t[Te]&16||(t[Te]|=64)}function dK(e,n,t){let r=t.directiveStart,o=t.directiveEnd;ni(t)&&Hq(n,t,e.data[r+t.componentOffset]),e.firstCreatePass||xA(t,n);let s=t.initialInputs;for(let i=r;i<o;i++){let a=e.data[i],c=hx(n,e,i,t);if(Sp(c,n),s!==null&&xK(n,i-r,c,a,t,s),ac(a)){let l=Jr(t.index,n);l[gn]=hx(n,e,i,t)}}}function fK(e,n,t){let r=t.directiveStart,o=t.directiveEnd,s=t.index,i=I_();try{oi(s);for(let a=r;a<o;a++){let c=e.data[a],l=n[a];Jg(a),(c.hostBindings!==null||c.hostVars!==0||c.hostAttrs!==null)&&mK(c,l)}}finally{oi(-1),Jg(i)}}function mK(e,n){e.hostBindings!==null&&e.hostBindings(1,n)}function ZA(e,n){let t=e.directiveRegistry,r=null;if(t)for(let o=0;o<t.length;o++){let s=t[o];Aq(n,s.selectors,!1)&&(r??=[],ac(s)?r.unshift(s):r.push(s))}return r}function hK(e,n,t,r,o,s){let i=Qr(e,n);gK(n[tn],i,s,e.value,t,r,o)}function gK(e,n,t,r,o,s,i){if(s==null)e.removeAttribute(n,o,t);else{let a=i==null?tc(s):i(s,r||"",o);e.setAttribute(n,o,a,t)}}function xK(e,n,t,r,o,s){let i=s[n];if(i!==null)for(let a=0;a<i.length;a+=2){let c=i[a],l=i[a+1];Mw(r,t,c,l)}}function QA(e,n,t,r,o){let s=Wt+t,i=n[we],a=o(i,n,e,r,t);n[s]=a,Cp(e,!0);let c=e.type===2;return c?(HA(n[tn],a,e),(m_()===0||Tf(e))&&Sp(a,n),h_()):Sp(a,n),rx()&&(!c||!tI(e))&&dI(i,n,a,e),e}function JA(e){let n=e;return uw()?y_():(n=n.parent,Cp(n,!1)),n}function yK(e,n){let t=e[rc];if(!t)return;let r;try{r=t.get(Ao,null)}catch{r=null}r?.(n)}function hI(e,n,t,r,o){let s=e.inputs?.[r],i=e.hostDirectiveInputs?.[r],a=!1;if(i)for(let c=0;c<i.length;c+=2){let l=i[c],u=i[c+1],p=n.data[l];Mw(p,t[l],u,o),a=!0}if(s)for(let c of s){let l=t[c],u=n.data[c];Mw(u,l,r,o),a=!0}return a}function vK(e,n){let t=Jr(n,e),r=t[we];bK(r,t);let o=t[Yr];o!==null&&t[wf]===null&&(t[wf]=OA(o,t[rc])),gt(18),gI(r,t,t[gn]),gt(19,t[gn])}function bK(e,n){for(let t=n.length;t<e.blueprint.length;t++)n.push(e.blueprint[t])}function gI(e,n,t){tx(n);try{let r=e.viewQuery;r!==null&&Ow(1,r,t);let o=e.template;o!==null&&YA(e,n,o,1,t),e.firstCreatePass&&(e.firstCreatePass=!1),n[ko]?.finishViewCreation(e),e.staticContentQueries&&MA(e,n),e.staticViewQueries&&Ow(2,e.viewQuery,t);let s=e.components;s!==null&&CK(n,s)}catch(r){throw e.firstCreatePass&&(e.incompleteFirstPass=!0,e.firstCreatePass=!1),r}finally{n[Te]&=-5,nx()}}function CK(e,n){for(let t=0;t<n.length;t++)vK(e,n[t])}function eR(e,n,t,r){let o=De(null);try{let s=n.tView,a=e[Te]&4096?4096:16,c=aI(e,s,t,a,null,n,null,null,r?.injector??null,r?.embeddedViewInjector??null,r?.dehydratedView??null),l=e[n.index];c[ei]=l;let u=e[ko];return u!==null&&(c[ko]=u.createEmbeddedView(s)),gI(s,c,t),c}finally{De(o)}}function Pw(e,n){return!n||n.firstChild===null||TA(e)}var z_=!1,wK=new Ee("");function Bf(e,n,t,r,o=!1){for(;t!==null;){if(t.type===128){t=o?t.projectionNext:t.next;continue}let s=n[t.index];s!==null&&r.push(Or(s)),Zr(s)&&tR(s,r);let i=t.type;if(i&8)Bf(e,n,t.child,r);else if(i&32){let a=lI(t,n),c;for(;c=a();)r.push(c)}else if(i&16){let a=XA(n,t);if(Array.isArray(a))r.push(...a);else{let c=Ys(n[Fr]);Bf(c[we],c,a,r,!0)}}t=o?t.projectionNext:t.next}return r}function tR(e,n){for(let t=Sn;t<e.length;t++){let r=e[t],o=r[we].firstChild;o!==null&&Bf(r[we],r,o,n)}e[ti]!==e[Yr]&&n.push(e[ti])}function nR(e){if(e[Yg]!==null){for(let n of e[Yg])n.impl.addSequence(n);e[Yg].length=0}}var rR=[];function IK(e){return e[gr]??EK(e)}function EK(e){let n=rR.pop()??Object.create(SK);return n.lView=e,n}function TK(e){e.lView[gr]!==e&&(e.lView=null,rR.push(e))}var SK=Ft(Je({},rp),{consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:e=>{lc(e.lView)},consumerOnSignalRead(){this.lView[gr]=this}});function NK(e){let n=e[gr]??Object.create(DK);return n.lView=e,n}var DK=Ft(Je({},rp),{consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:e=>{let n=Ys(e.lView);for(;n&&!oR(n[we]);)n=Ys(n);n&&tw(n)},consumerOnSignalRead(){this.lView[gr]=this}});function oR(e){return e.type!==2}function sR(e){if(e[is]===null)return;let n=!0;for(;n;){let t=!1;for(let r of e[is])r.dirty&&(t=!0,r.zone===null||Zone.current===r.zone?r.run():r.zone.run(()=>r.run()));n=t&&!!(e[Te]&8192)}}var kK=100;function xI(e,n=0){let r=e[Do].rendererFactory,o=!1;o||r.begin?.();try{_K(e,n)}finally{o||r.end?.()}}function _K(e,n){let t=dw();try{wp(!0),Lw(e,n);let r=0;for(;Nf(e);){if(r===kK)throw new ze(103,!1);r++,Lw(e,1)}}finally{wp(t)}}function iR(e,n){pw(n?Df.Exhaustive:Df.OnlyDirtyViews);try{xI(e)}finally{pw(Df.Off)}}function AK(e,n,t,r){if(cc(n))return;let o=n[Te],s=!1,i=!1;tx(n);let a=!0,c=null,l=null;s||(oR(e)?(l=IK(n),c=op(l)):sg()===null?(a=!1,l=NK(n),c=op(l)):n[gr]&&(Ua(n[gr]),n[gr]=null));try{ew(n),b_(e.bindingStartIndex),t!==null&&YA(e,n,t,2,r);let u=(o&3)===3;if(!s)if(u){let f=e.preOrderCheckHooks;f!==null&&ax(n,f,null)}else{let f=e.preOrderHooks;f!==null&&cx(n,f,0,null),ww(n,0)}if(i||RK(n),sR(n),aR(n,0),e.contentQueries!==null&&MA(e,n),!s)if(u){let f=e.contentCheckHooks;f!==null&&ax(n,f)}else{let f=e.contentHooks;f!==null&&cx(n,f,1),ww(n,1)}OK(e,n);let p=e.components;p!==null&&lR(n,p,0);let d=e.viewQuery;if(d!==null&&Ow(2,d,r),!s)if(u){let f=e.viewCheckHooks;f!==null&&ax(n,f)}else{let f=e.viewHooks;f!==null&&cx(n,f,2),ww(n,2)}if(e.firstUpdatePass===!0&&(e.firstUpdatePass=!1),n[Xg]){for(let f of n[Xg])f();n[Xg]=null}s||(nR(n),n[Te]&=-73)}catch(u){throw s||lc(n),u}finally{l!==null&&(of(l,c),a&&TK(l)),nx()}}function aR(e,n){for(let t=NA(e);t!==null;t=DA(t))for(let r=Sn;r<t.length;r++){let o=t[r];cR(o,n)}}function RK(e){for(let n=NA(e);n!==null;n=DA(n)){if(!(n[Te]&2))continue;let t=n[ic];for(let r=0;r<t.length;r++){let o=t[r];tw(o)}}}function FK(e,n,t){gt(18);let r=Jr(n,e);cR(r,t),gt(19,r[gn])}function cR(e,n){Zg(e)&&Lw(e,n)}function Lw(e,n){let r=e[we],o=e[Te],s=e[gr],i=!!(n===0&&o&16);if(i||=!!(o&64&&n===0),i||=!!(o&1024),i||=!!(s?.dirty&&sp(s)),i||=!1,s&&(s.dirty=!1),e[Te]&=-9217,i)AK(r,e,r.template,e[gn]);else if(o&8192){let a=De(null);try{sR(e),aR(e,1);let c=r.components;c!==null&&lR(e,c,1),nR(e)}finally{De(a)}}}function lR(e,n,t){for(let r=0;r<n.length;r++)FK(e,n[r],t)}function OK(e,n){let t=e.hostBindingOpCodes;if(t!==null)try{for(let r=0;r<t.length;r++){let o=t[r];if(o<0)oi(~o);else{let s=o,i=t[++r],a=t[++r];w_(i,s);let c=n[s];gt(24,c),a(2,c),gt(25,c)}}}finally{oi(-1)}}function yI(e,n){let t=dw()?64:1088;for(e[Do].changeDetectionScheduler?.notify(n);e;){e[Te]|=t;let r=Ys(e);if(bp(e)&&!r)return e;e=r}return null}function uR(e,n,t,r){return[e,!0,0,n,null,r,null,t,null,null]}function MK(e,n){let t=Sn+n;if(t<e.length)return e[t]}function pR(e,n,t,r=!0){let o=n[we];if(PK(o,n,e,t),r){let i=$w(t,e),a=n[tn],c=a.parentNode(e[ti]);c!==null&&qq(o,e[Rr],a,n,c,i)}let s=n[wf];s!==null&&s.firstChild!==null&&(s.firstChild=null)}function $K(e,n){let t=vx(e,n);return t!==void 0&&pI(t[we],t),t}function vx(e,n){if(e.length<=Sn)return;let t=Sn+n,r=e[t];if(r){let o=r[ei];o!==null&&o!==e&&uI(o,r),n>0&&(e[t-1][Ar]=r[Ar]);let s=bf(e,Sn+n);jq(r[we],r);let i=s[ko];i!==null&&i.detachView(s[we]),r[ln]=null,r[Ar]=null,r[Te]&=-129}return r}function PK(e,n,t,r){let o=Sn+r,s=t.length;r>0&&(t[o-1][Ar]=n),r<s-Sn?(n[Ar]=t[o],BC(t,Sn+r,n)):(t.push(n),n[Ar]=null),n[ln]=t;let i=n[ei];i!==null&&t!==i&&dR(i,n);let a=n[ko];a!==null&&a.insertView(e),Qg(n),n[Te]|=128}function dR(e,n){let t=e[ic],r=n[ln];if(as(r))e[Te]|=2;else{let o=r[ln][Fr];n[Fr]!==o&&(e[Te]|=2)}t===null?e[ic]=[n]:t.push(n)}var si=class{_lView;_cdRefInjectingView;_appRef=null;_attachedToViewContainer=!1;exhaustive;get rootNodes(){let n=this._lView,t=n[we];return Bf(t,n,t.firstChild,[])}constructor(n,t){this._lView=n,this._cdRefInjectingView=t}get context(){return this._lView[gn]}set context(n){this._lView[gn]=n}get destroyed(){return cc(this._lView)}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){let n=this._lView[ln];if(Zr(n)){let t=n[Ef],r=t?t.indexOf(this):-1;r>-1&&(vx(n,r),bf(t,r))}this._attachedToViewContainer=!1}pI(this._lView[we],this._lView)}onDestroy(n){nw(this._lView,n)}markForCheck(){yI(this._cdRefInjectingView||this._lView,4)}detach(){this._lView[Te]&=-129}reattach(){Qg(this._lView),this._lView[Te]|=128}detectChanges(){this._lView[Te]|=1024,xI(this._lView)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new ze(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;let n=bp(this._lView),t=this._lView[ei];t!==null&&!n&&uI(t,this._lView),KA(this._lView[we],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new ze(902,!1);this._appRef=n;let t=bp(this._lView),r=this._lView[ei];r!==null&&!t&&dR(r,this._lView),Qg(this._lView)}};var ii=(()=>{class e{_declarationLView;_declarationTContainer;elementRef;static __NG_ELEMENT_ID__=LK;constructor(t,r,o){this._declarationLView=t,this._declarationTContainer=r,this.elementRef=o}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,r){return this.createEmbeddedViewImpl(t,r)}createEmbeddedViewImpl(t,r,o){let s=eR(this._declarationLView,this._declarationTContainer,t,{embeddedViewInjector:r,dehydratedView:o});return new si(s)}}return e})();function LK(){return vI(xr(),nt())}function vI(e,n){return e.type&4?new ii(n,e,_p(e,n)):null}function Wf(e,n,t,r,o){let s=e.data[n];if(s===null)s=BK(e,n,t,r,o),C_()&&(s.flags|=32);else if(s.type&64){s.type=t,s.value=r,s.attrs=o;let i=x_();s.injectorIndex=i===null?-1:i.injectorIndex}return Cp(s,!0),s}function BK(e,n,t,r,o){let s=lw(),i=uw(),a=i?s:s&&s.parent,c=e.data[n]=UK(e,a,t,n,r,o);return VK(e,c,s,i),c}function VK(e,n,t,r){e.firstChild===null&&(e.firstChild=n),t!==null&&(r?t.child==null&&n.parent!==null&&(t.child=n):t.next===null&&(t.next=n,n.prev=t))}function UK(e,n,t,r,o,s){let i=n?n.injectorIndex:-1,a=0;return g_()&&(a|=128),{type:t,index:r,insertBeforeIndex:null,injectorIndex:i,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:o,attrs:s,mergedAttrs:null,localNames:null,initialInputs:null,inputs:null,hostDirectiveInputs:null,outputs:null,hostDirectiveOutputs:null,directiveToIndex:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}var fCe=new RegExp(`^(\\d+)*(${bq}|${vq})*(.*)`);var zK=()=>null,GK=()=>null;function G_(e,n){return zK(e,n)}function HK(e,n,t){return GK(e,n,t)}var fR=class{},Rx=class{},Bw=class{resolveComponentFactory(n){throw new ze(917,!1)}},jf=class{static NULL=new Bw},Vf=class{};var mR=(()=>{class e{static \u0275prov=tt({token:e,providedIn:"root",factory:()=>null})}return e})();var ux={},Vw=class{injector;parentInjector;constructor(n,t){this.injector=n,this.parentInjector=t}get(n,t,r){let o=this.injector.get(n,ux,r);return o!==ux||t===ux?o:this.parentInjector.get(n,t,r)}};function bx(e,n,t){let r=t?e.styles:null,o=t?e.classes:null,s=0;if(n!==null)for(let i=0;i<n.length;i++){let a=n[i];if(typeof a=="number")s=a;else if(s==1)o=DC(o,a);else if(s==2){let c=a,l=n[++i];r=DC(r,c+": "+l+";")}}t?e.styles=r:e.stylesWithoutHost=r,t?e.classes=o:e.classesWithoutHost=o}function Nn(e,n=0){let t=nt();if(t===null)return at(e,n);let r=xr();return CA(r,t,Yn(e),n)}function hR(e,n,t,r,o){let s=r===null?null:{"":-1},i=o(e,t);if(i!==null){let a=i,c=null,l=null;for(let u of i)if(u.resolveHostDirectives!==null){[a,c,l]=u.resolveHostDirectives(i);break}qK(e,n,t,a,s,c,l)}s!==null&&r!==null&&WK(t,r,s)}function WK(e,n,t){let r=e.localNames=[];for(let o=0;o<n.length;o+=2){let s=t[n[o+1]];if(s==null)throw new ze(-301,!1);r.push(n[o],s)}}function jK(e,n,t){n.componentOffset=t,(e.components??=[]).push(n.index)}function qK(e,n,t,r,o,s,i){let a=r.length,c=!1;for(let d=0;d<a;d++){let f=r[d];!c&&ac(f)&&(c=!0,jK(e,t,d)),rq(xA(t,n),e,f.type)}JK(t,e.data.length,a);for(let d=0;d<a;d++){let f=r[d];f.providersResolver&&f.providersResolver(f)}let l=!1,u=!1,p=jA(e,n,a,null);a>0&&(t.directiveToIndex=new Map);for(let d=0;d<a;d++){let f=r[d];if(t.mergedAttrs=Dx(t.mergedAttrs,f.hostAttrs),XK(e,t,n,p,f),QK(p,f,o),i!==null&&i.has(f)){let[h,g]=i.get(f);t.directiveToIndex.set(f.type,[p,h+t.directiveStart,g+t.directiveStart])}else(s===null||!s.has(f))&&t.directiveToIndex.set(f.type,p);f.contentQueries!==null&&(t.flags|=4),(f.hostBindings!==null||f.hostAttrs!==null||f.hostVars!==0)&&(t.flags|=64);let m=f.type.prototype;!l&&(m.ngOnChanges||m.ngOnInit||m.ngDoCheck)&&((e.preOrderHooks??=[]).push(t.index),l=!0),!u&&(m.ngOnChanges||m.ngDoCheck)&&((e.preOrderCheckHooks??=[]).push(t.index),u=!0),p++}KK(e,t,s)}function KK(e,n,t){for(let r=n.directiveStart;r<n.directiveEnd;r++){let o=e.data[r];if(t===null||!t.has(o))H_(0,n,o,r),H_(1,n,o,r),j_(n,r,!1);else{let s=t.get(o);W_(0,n,s,r),W_(1,n,s,r),j_(n,r,!0)}}}function H_(e,n,t,r){let o=e===0?t.inputs:t.outputs;for(let s in o)if(o.hasOwnProperty(s)){let i;e===0?i=n.inputs??={}:i=n.outputs??={},i[s]??=[],i[s].push(r),gR(n,s)}}function W_(e,n,t,r){let o=e===0?t.inputs:t.outputs;for(let s in o)if(o.hasOwnProperty(s)){let i=o[s],a;e===0?a=n.hostDirectiveInputs??={}:a=n.hostDirectiveOutputs??={},a[i]??=[],a[i].push(r,s),gR(n,i)}}function gR(e,n){n==="class"?e.flags|=8:n==="style"&&(e.flags|=16)}function j_(e,n,t){let{attrs:r,inputs:o,hostDirectiveInputs:s}=e;if(r===null||!t&&o===null||t&&s===null||sI(e)){e.initialInputs??=[],e.initialInputs.push(null);return}let i=null,a=0;for(;a<r.length;){let c=r[a];if(c===0){a+=4;continue}else if(c===5){a+=2;continue}else if(typeof c=="number")break;if(!t&&o.hasOwnProperty(c)){let l=o[c];for(let u of l)if(u===n){i??=[],i.push(c,r[a+1]);break}}else if(t&&s.hasOwnProperty(c)){let l=s[c];for(let u=0;u<l.length;u+=2)if(l[u]===n){i??=[],i.push(l[u+1],r[a+1]);break}}a+=2}e.initialInputs??=[],e.initialInputs.push(i)}function XK(e,n,t,r,o){e.data[r]=o;let s=o.factory||(o.factory=Xs(o.type,!0)),i=new Pf(s,ac(o),Nn,null);e.blueprint[r]=i,t[r]=i,YK(e,n,r,jA(e,t,o.hostVars,Mr),o)}function YK(e,n,t,r,o){let s=o.hostBindings;if(s){let i=e.hostBindingOpCodes;i===null&&(i=e.hostBindingOpCodes=[]);let a=~n.index;ZK(i)!=a&&i.push(a),i.push(t,r,s)}}function ZK(e){let n=e.length;for(;n>0;){let t=e[--n];if(typeof t=="number"&&t<0)return t}return 0}function QK(e,n,t){if(t){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)t[n.exportAs[r]]=e;ac(n)&&(t[""]=e)}}function JK(e,n,t){e.flags|=1,e.directiveStart=n,e.directiveEnd=n+t,e.providerIndexes=n}function xR(e,n,t,r,o,s,i,a){let c=n[we],l=c.consts,u=_o(l,i),p=Wf(c,e,t,r,u);return s&&hR(c,n,p,_o(l,a),o),p.mergedAttrs=Dx(p.mergedAttrs,p.attrs),p.attrs!==null&&bx(p,p.attrs,!1),p.mergedAttrs!==null&&bx(p,p.mergedAttrs,!0),c.queries!==null&&c.queries.elementStart(c,p),p}function yR(e,n){dA(e,n),XC(n)&&e.queries.elementEnd(n)}function e7(e,n,t,r,o,s){let i=n.consts,a=_o(i,o),c=Wf(n,e,t,r,a);if(c.mergedAttrs=Dx(c.mergedAttrs,c.attrs),s!=null){let l=_o(i,s);c.localNames=[];for(let u=0;u<l.length;u+=2)c.localNames.push(l[u],-1)}return c.attrs!==null&&bx(c,c.attrs,!1),c.mergedAttrs!==null&&bx(c,c.mergedAttrs,!0),n.queries!==null&&n.queries.elementStart(n,c),c}function vR(e,n,t){return e[n]=t}function ai(e,n,t){if(t===Mr)return!1;let r=e[n];return Object.is(r,t)?!1:(e[n]=t,!0)}function bR(e,n,t,r){let o=ai(e,n,t);return ai(e,n+1,r)||o}function Tw(e,n,t){return function r(o){let s=ni(e)?Jr(e.index,n):n;yI(s,5);let i=n[gn],a=q_(n,i,t,o),c=r.__ngNextListenerFn__;for(;c;)a=q_(n,i,c,o)&&a,c=c.__ngNextListenerFn__;return a}}function q_(e,n,t,r){let o=De(null);try{return gt(6,n,t),t(r)!==!1}catch(s){return yK(e,s),!1}finally{gt(7,n,t),De(o)}}function t7(e,n,t,r,o,s,i,a){let c=Tf(e),l=!1,u=null;if(!r&&c&&(u=n7(n,t,s,e.index)),u!==null){let p=u.__ngLastListenerFn__||u;p.__ngNextListenerFn__=i,u.__ngLastListenerFn__=i,l=!0}else{let p=Qr(e,t),d=r?r(p):p;wq(t,d,s,a);let f=o.listen(d,s,a),m=r?h=>r(Or(h[e.index])):e.index;CR(m,n,t,s,a,f,!1)}return l}function n7(e,n,t,r){let o=e.cleanup;if(o!=null)for(let s=0;s<o.length-1;s+=2){let i=o[s];if(i===t&&o[s+1]===r){let a=n[yp],c=o[s+2];return a&&a.length>c?a[c]:null}typeof i=="string"&&(s+=2)}return null}function CR(e,n,t,r,o,s,i){let a=n.firstCreatePass?ow(n):null,c=rw(t),l=c.length;c.push(o,s),a&&a.push(r,e,l,(l+1)*(i?-1:1))}function K_(e,n,t,r,o,s){let i=n[t],a=n[we],l=a.data[t].outputs[r],p=i[l].subscribe(s);CR(e.index,a,n,o,s,p,!0)}var Uw=Symbol("BINDING");var Cx=class extends jf{ngModule;constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){let t=Js(n);return new Dp(t,this.ngModule)}};function r7(e){return Object.keys(e).map(n=>{let[t,r,o]=e[n],s={propName:t,templateName:n,isSignal:(r&kx.SignalBased)!==0};return o&&(s.transform=o),s})}function o7(e){return Object.keys(e).map(n=>({propName:e[n],templateName:n}))}function s7(e,n,t){let r=n instanceof _r?n:n?.injector;return r&&e.getStandaloneInjector!==null&&(r=e.getStandaloneInjector(r)||r),r?new Vw(t,r):t}function i7(e){let n=e.get(Vf,null);if(n===null)throw new ze(407,!1);let t=e.get(mR,null),r=e.get(No,null);return{rendererFactory:n,sanitizer:t,changeDetectionScheduler:r,ngReflect:!1}}function a7(e,n){let t=wR(e);return zA(n,t,t==="svg"?YC:t==="math"?c_:null)}function wR(e){return(e.selectors[0][0]||"div").toLowerCase()}var Dp=class extends Rx{componentDef;ngModule;selector;componentType;ngContentSelectors;isBoundToModule;cachedInputs=null;cachedOutputs=null;get inputs(){return this.cachedInputs??=r7(this.componentDef.inputs),this.cachedInputs}get outputs(){return this.cachedOutputs??=o7(this.componentDef.outputs),this.cachedOutputs}constructor(n,t){super(),this.componentDef=n,this.ngModule=t,this.componentType=n.type,this.selector=Mq(n.selectors),this.ngContentSelectors=n.ngContentSelectors??[],this.isBoundToModule=!!t}create(n,t,r,o,s,i){gt(22);let a=De(null);try{let c=this.componentDef,l=c7(r,c,i,s),u=s7(c,o||this.ngModule,n),p=i7(u),d=p.rendererFactory.createRenderer(null,c),f=r?sK(d,r,c.encapsulation,u):a7(c,d),m=i?.some(X_)||s?.some(x=>typeof x!="function"&&x.bindings.some(X_)),h=aI(null,l,null,512|WA(c),null,null,p,d,u,null,OA(f,u,!0));h[Wt]=f,tx(h);let g=null;try{let x=xR(Wt,h,2,"#host",()=>l.directiveRegistry,!0,0);f&&(HA(d,f,x),Sp(f,h)),mI(l,h,x),$A(l,x,h),yR(l,x),t!==void 0&&u7(x,this.ngContentSelectors,t),g=Jr(x.index,h),h[gn]=g[gn],gI(l,h,null)}catch(x){throw g!==null&&Rw(g),Rw(h),x}finally{gt(23),nx()}return new wx(this.componentType,h,!!m)}finally{De(a)}}};function c7(e,n,t,r){let o=e?["ng-version","20.3.0"]:$q(n.selectors[0]),s=null,i=null,a=0;if(t)for(let u of t)a+=u[Uw].requiredVars,u.create&&(u.targetIdx=0,(s??=[]).push(u)),u.update&&(u.targetIdx=0,(i??=[]).push(u));if(r)for(let u=0;u<r.length;u++){let p=r[u];if(typeof p!="function")for(let d of p.bindings){a+=d[Uw].requiredVars;let f=u+1;d.create&&(d.targetIdx=f,(s??=[]).push(d)),d.update&&(d.targetIdx=f,(i??=[]).push(d))}}let c=[n];if(r)for(let u of r){let p=typeof u=="function"?u:u.type,d=GC(p);c.push(d)}return iI(0,null,l7(s,i),1,a,c,null,null,null,[o],null)}function l7(e,n){return!e&&!n?null:t=>{if(t&1&&e)for(let r of e)r.create();if(t&2&&n)for(let r of n)r.update()}}function X_(e){let n=e[Uw].kind;return n==="input"||n==="twoWay"}var wx=class extends fR{_rootLView;_hasInputBindings;instance;hostView;changeDetectorRef;componentType;location;previousInputValues=null;_tNode;constructor(n,t,r){super(),this._rootLView=t,this._hasInputBindings=r,this._tNode=Sf(t[we],Wt),this.location=_p(this._tNode,t),this.instance=Jr(this._tNode.index,t)[gn],this.hostView=this.changeDetectorRef=new si(t,void 0),this.componentType=n}setInput(n,t){this._hasInputBindings;let r=this._tNode;if(this.previousInputValues??=new Map,this.previousInputValues.has(n)&&Object.is(this.previousInputValues.get(n),t))return;let o=this._rootLView,s=hI(r,o[we],o,n,t);this.previousInputValues.set(n,t);let i=Jr(r.index,o);yI(i,1)}get injector(){return new mc(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}};function u7(e,n,t){let r=e.projection=[];for(let o=0;o<n.length;o++){let s=t[o];r.push(s!=null&&s.length?Array.from(s):null)}}var yc=(()=>{class e{static __NG_ELEMENT_ID__=p7}return e})();function p7(){let e=xr();return ER(e,nt())}var d7=yc,IR=class extends d7{_lContainer;_hostTNode;_hostLView;constructor(n,t,r){super(),this._lContainer=n,this._hostTNode=t,this._hostLView=r}get element(){return _p(this._hostTNode,this._hostLView)}get injector(){return new mc(this._hostTNode,this._hostLView)}get parentInjector(){let n=Jw(this._hostTNode,this._hostLView);if(mA(n)){let t=fx(n,this._hostLView),r=dx(n),o=t[we].data[r+8];return new mc(o,t)}else return new mc(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){let t=Y_(this._lContainer);return t!==null&&t[n]||null}get length(){return this._lContainer.length-Sn}createEmbeddedView(n,t,r){let o,s;typeof r=="number"?o=r:r!=null&&(o=r.index,s=r.injector);let i=G_(this._lContainer,n.ssrId),a=n.createEmbeddedViewImpl(t||{},s,i);return this.insertImpl(a,o,Pw(this._hostTNode,i)),a}createComponent(n,t,r,o,s,i,a){let c=n&&!z5(n),l;if(c)l=t;else{let g=t||{};l=g.index,r=g.injector,o=g.projectableNodes,s=g.environmentInjector||g.ngModuleRef,i=g.directives,a=g.bindings}let u=c?n:new Dp(Js(n)),p=r||this.parentInjector;if(!s&&u.ngModule==null){let x=(c?p:this.parentInjector).get(_r,null);x&&(s=x)}let d=Js(u.componentType??{}),f=G_(this._lContainer,d?.id??null),m=f?.firstChild??null,h=u.create(p,o,m,s,i,a);return this.insertImpl(h.hostView,l,Pw(this._hostTNode,f)),h}insert(n,t){return this.insertImpl(n,t,!0)}insertImpl(n,t,r){let o=n._lView;if(u_(o)){let a=this.indexOf(n);if(a!==-1)this.detach(a);else{let c=o[ln],l=new IR(c,c[Rr],c[ln]);l.detach(l.indexOf(n))}}let s=this._adjustIndex(t),i=this._lContainer;return pR(i,o,s,r),n.attachToViewContainerRef(),BC(Sw(i),s,n),n}move(n,t){return this.insert(n,t)}indexOf(n){let t=Y_(this._lContainer);return t!==null?t.indexOf(n):-1}remove(n){let t=this._adjustIndex(n,-1),r=vx(this._lContainer,t);r&&(bf(Sw(this._lContainer),t),pI(r[we],r))}detach(n){let t=this._adjustIndex(n,-1),r=vx(this._lContainer,t);return r&&bf(Sw(this._lContainer),t)!=null?new si(r):null}_adjustIndex(n,t=0){return n??this.length+t}};function Y_(e){return e[Ef]}function Sw(e){return e[Ef]||(e[Ef]=[])}function ER(e,n){let t,r=n[e.index];return Zr(r)?t=r:(t=uR(r,n,null,e),n[e.index]=t,cI(n,t)),m7(t,n,e,r),new IR(t,e,n)}function f7(e,n){let t=e[tn],r=t.createComment(""),o=Qr(n,e),s=t.parentNode(o);return yx(t,s,r,t.nextSibling(o),!1),r}var m7=x7,h7=()=>!1;function g7(e,n,t){return h7(e,n,t)}function x7(e,n,t,r){if(e[ti])return;let o;t.type&8?o=Or(r):o=f7(n,t),e[ti]=o}var zw=class e{queryList;matches=null;constructor(n){this.queryList=n}clone(){return new e(this.queryList)}setDirty(){this.queryList.setDirty()}},Gw=class e{queries;constructor(n=[]){this.queries=n}createEmbeddedView(n){let t=n.queries;if(t!==null){let r=n.contentQueries!==null?n.contentQueries[0]:t.length,o=[];for(let s=0;s<r;s++){let i=t.getByIndex(s),a=this.queries[i.indexInDeclarationView];o.push(a.clone())}return new e(o)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}finishViewCreation(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let t=0;t<this.queries.length;t++)bI(n,t).matches!==null&&this.queries[t].setDirty()}},Hw=class{flags;read;predicate;constructor(n,t,r=null){this.flags=t,this.read=r,typeof n=="string"?this.predicate=T7(n):this.predicate=n}},Ww=class e{queries;constructor(n=[]){this.queries=n}elementStart(n,t){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,t)}elementEnd(n){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(n)}embeddedTView(n){let t=null;for(let r=0;r<this.length;r++){let o=t!==null?t.length:0,s=this.getByIndex(r).embeddedTView(n,o);s&&(s.indexInDeclarationView=r,t!==null?t.push(s):t=[s])}return t!==null?new e(t):null}template(n,t){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,t)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}},jw=class e{metadata;matches=null;indexInDeclarationView=-1;crossesNgTemplate=!1;_declarationNodeIndex;_appliesToNextNode=!0;constructor(n,t=-1){this.metadata=n,this._declarationNodeIndex=t}elementStart(n,t){this.isApplyingToNode(t)&&this.matchTNode(n,t)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,t){this.elementStart(n,t)}embeddedTView(n,t){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,t),new e(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&(this.metadata.flags&1)!==1){let t=this._declarationNodeIndex,r=n.parent;for(;r!==null&&r.type&8&&r.index!==t;)r=r.parent;return t===(r!==null?r.index:-1)}return this._appliesToNextNode}matchTNode(n,t){let r=this.metadata.predicate;if(Array.isArray(r))for(let o=0;o<r.length;o++){let s=r[o];this.matchTNodeWithReadOption(n,t,y7(t,s)),this.matchTNodeWithReadOption(n,t,lx(t,n,s,!1,!1))}else r===ii?t.type&4&&this.matchTNodeWithReadOption(n,t,-1):this.matchTNodeWithReadOption(n,t,lx(t,n,r,!1,!1))}matchTNodeWithReadOption(n,t,r){if(r!==null){let o=this.metadata.read;if(o!==null)if(o===xc||o===yc||o===ii&&t.type&4)this.addMatch(t.index,-2);else{let s=lx(t,n,o,!1,!1);s!==null&&this.addMatch(t.index,s)}else this.addMatch(t.index,r)}}addMatch(n,t){this.matches===null?this.matches=[n,t]:this.matches.push(n,t)}};function y7(e,n){let t=e.localNames;if(t!==null){for(let r=0;r<t.length;r+=2)if(t[r]===n)return t[r+1]}return null}function v7(e,n){return e.type&11?_p(e,n):e.type&4?vI(e,n):null}function b7(e,n,t,r){return t===-1?v7(n,e):t===-2?C7(e,n,r):hx(e,e[we],t,n)}function C7(e,n,t){if(t===xc)return _p(n,e);if(t===ii)return vI(n,e);if(t===yc)return ER(n,e)}function TR(e,n,t,r){let o=n[ko].queries[r];if(o.matches===null){let s=e.data,i=t.matches,a=[];for(let c=0;i!==null&&c<i.length;c+=2){let l=i[c];if(l<0)a.push(null);else{let u=s[l];a.push(b7(n,u,i[c+1],t.metadata.read))}}o.matches=a}return o.matches}function qw(e,n,t,r){let o=e.queries.getByIndex(t),s=o.matches;if(s!==null){let i=TR(e,n,o,t);for(let a=0;a<s.length;a+=2){let c=s[a];if(c>0)r.push(i[a/2]);else{let l=s[a+1],u=n[-c];for(let p=Sn;p<u.length;p++){let d=u[p];d[ei]===d[ln]&&qw(d[we],d,l,r)}if(u[ic]!==null){let p=u[ic];for(let d=0;d<p.length;d++){let f=p[d];qw(f[we],f,l,r)}}}}}return r}function w7(e,n){return e[ko].queries[n].queryList}function I7(e,n,t){let r=new gx((t&4)===4);return f_(e,n,r,r.destroy),(n[ko]??=new Gw).queries.push(new zw(r))-1}function E7(e,n,t){let r=Zn();return r.firstCreatePass&&(S7(r,new Hw(e,n,t),-1),(n&2)===2&&(r.staticViewQueries=!0)),I7(r,nt(),n)}function T7(e){return e.split(",").map(n=>n.trim())}function S7(e,n,t){e.queries===null&&(e.queries=new Ww),e.queries.track(new jw(n,t))}function bI(e,n){return e.queries.getByIndex(n)}function N7(e,n){let t=e[we],r=bI(t,n);return r.crossesNgTemplate?qw(t,e,n,[]):TR(t,e,r,n)}var Z_=new Set;function Ap(e){Z_.has(e)||(Z_.add(e),performance?.mark?.("mark_feature_usage",{detail:{feature:e}}))}var hc=class{},SR=class{};var Ix=class extends hc{ngModuleType;_parent;_bootstrapComponents=[];_r3Injector;instance;destroyCbs=[];componentFactoryResolver=new Cx(this);constructor(n,t,r,o=!0){super(),this.ngModuleType=n,this._parent=t;let s=zC(n);this._bootstrapComponents=VA(s.bootstrap),this._r3Injector=vw(n,t,[{provide:hc,useValue:this},{provide:jf,useValue:this.componentFactoryResolver},...r],ss(n),new Set(["environment"])),o&&this.resolveInjectorInitializers()}resolveInjectorInitializers(){this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(this.ngModuleType)}get injector(){return this._r3Injector}destroy(){let n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(t=>t()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}},Ex=class extends SR{moduleType;constructor(n){super(),this.moduleType=n}create(n){return new Ix(this.moduleType,n,[])}};var Uf=class extends hc{injector;componentFactoryResolver=new Cx(this);instance=null;constructor(n){super();let t=new Ja([...n.providers,{provide:hc,useValue:this},{provide:jf,useValue:this.componentFactoryResolver}],n.parent||Cf(),n.debugName,new Set(["environment"]));this.injector=t,n.runEnvironmentInitializers&&t.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}};function NR(e,n,t=null){return new Uf({providers:e,parent:n,debugName:t,runEnvironmentInitializers:!0}).injector}var D7=(()=>{class e{_injector;cachedInjectors=new Map;constructor(t){this._injector=t}getOrCreateStandaloneInjector(t){if(!t.standalone)return null;if(!this.cachedInjectors.has(t)){let r=HC(!1,t.type),o=r.length>0?NR([r],this._injector,`Standalone[${t.type.name}]`):null;this.cachedInjectors.set(t,o)}return this.cachedInjectors.get(t)}ngOnDestroy(){try{for(let t of this.cachedInjectors.values())t!==null&&t.destroy()}finally{this.cachedInjectors.clear()}}static \u0275prov=tt({token:e,providedIn:"environment",factory:()=>new e(at(_r))})}return e})();function Rp(e){return Hf(()=>{let n=DR(e),t=Ft(Je({},n),{decls:e.decls,vars:e.vars,template:e.template,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,onPush:e.changeDetection===eI.OnPush,directiveDefs:null,pipeDefs:null,dependencies:n.standalone&&e.dependencies||null,getStandaloneInjector:n.standalone?o=>o.get(D7).getOrCreateStandaloneInjector(t):null,getExternalStyles:null,signals:e.signals??!1,data:e.data||{},encapsulation:e.encapsulation||Np.Emulated,styles:e.styles||kr,_:null,schemas:e.schemas||null,tView:null,id:""});n.standalone&&Ap("NgStandalone"),kR(t);let r=e.dependencies;return t.directiveDefs=Q_(r,k7),t.pipeDefs=Q_(r,e_),t.id=R7(t),t})}function k7(e){return Js(e)||GC(e)}function Fx(e){return Hf(()=>({type:e.type,bootstrap:e.bootstrap||kr,declarations:e.declarations||kr,imports:e.imports||kr,exports:e.exports||kr,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null}))}function _7(e,n){if(e==null)return nc;let t={};for(let r in e)if(e.hasOwnProperty(r)){let o=e[r],s,i,a,c;Array.isArray(o)?(a=o[0],s=o[1],i=o[2]??s,c=o[3]||null):(s=o,i=o,a=kx.None,c=null),t[s]=[r,a,c],n[s]=i}return t}function A7(e){if(e==null)return nc;let n={};for(let t in e)e.hasOwnProperty(t)&&(n[e[t]]=t);return n}function Ox(e){return Hf(()=>{let n=DR(e);return kR(n),n})}function qf(e){return{type:e.type,name:e.name,factory:null,pure:e.pure!==!1,standalone:e.standalone??!0,onDestroy:e.type.prototype.ngOnDestroy||null}}function DR(e){let n={};return{type:e.type,providersResolver:null,factory:null,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:n,inputConfig:e.inputs||nc,exportAs:e.exportAs||null,standalone:e.standalone??!0,signals:e.signals===!0,selectors:e.selectors||kr,viewQuery:e.viewQuery||null,features:e.features||null,setInput:null,resolveHostDirectives:null,hostDirectives:null,inputs:_7(e.inputs,n),outputs:A7(e.outputs),debugInfo:null}}function kR(e){e.features?.forEach(n=>n(e))}function Q_(e,n){return e?()=>{let t=typeof e=="function"?e():e,r=[];for(let o of t){let s=n(o);s!==null&&r.push(s)}return r}:null}function R7(e){let n=0,t=typeof e.consts=="function"?"":e.consts,r=[e.selectors,e.ngContentSelectors,e.hostVars,e.hostAttrs,t,e.vars,e.decls,e.encapsulation,e.standalone,e.signals,e.exportAs,JSON.stringify(e.inputs),JSON.stringify(e.outputs),Object.getOwnPropertyNames(e.type.prototype),!!e.contentQueries,!!e.viewQuery];for(let s of r.join("|"))n=Math.imul(31,n)+s.charCodeAt(0)<<0;return n+=2147483648,"c"+n}function _R(e,n,t,r,o,s,i,a){if(t.firstCreatePass){e.mergedAttrs=Dx(e.mergedAttrs,e.attrs);let u=e.tView=iI(2,e,o,s,i,t.directiveRegistry,t.pipeRegistry,null,t.schemas,t.consts,null);t.queries!==null&&(t.queries.template(t,e),u.queries=t.queries.embeddedTView(e))}a&&(e.flags|=a),Cp(e,!1);let c=O7(t,n,e,r);rx()&&dI(t,n,c,e),Sp(c,n);let l=uR(c,n,c,e);n[r+Wt]=l,cI(n,l),g7(l,e,n)}function F7(e,n,t,r,o,s,i,a,c,l,u){let p=t+Wt,d;return n.firstCreatePass?(d=Wf(n,p,4,i||null,a||null),iw()&&hR(n,e,d,_o(n.consts,l),ZA),dA(n,d)):d=n.data[p],_R(d,e,n,t,r,o,s,c),Tf(d)&&mI(n,e,d),l!=null&&Ax(e,d,u),d}function AR(e,n,t,r,o,s,i,a,c,l,u){let p=t+Wt,d;if(n.firstCreatePass){if(d=Wf(n,p,4,i||null,a||null),l!=null){let f=_o(n.consts,l);d.localNames=[];for(let m=0;m<f.length;m+=2)d.localNames.push(f[m],-1)}}else d=n.data[p];return _R(d,e,n,t,r,o,s,c),l!=null&&Ax(e,d,u),d}function Kf(e,n,t,r,o,s,i,a){let c=nt(),l=Zn(),u=_o(l.consts,s);return F7(c,l,e,n,t,r,o,u,void 0,i,a),Kf}var O7=M7;function M7(e,n,t,r){return ox(!0),n[tn].createComment("")}var CI=(function(e){return e[e.CHANGE_DETECTION=0]="CHANGE_DETECTION",e[e.AFTER_NEXT_RENDER=1]="AFTER_NEXT_RENDER",e})(CI||{}),wI=new Ee(""),RR=!1,Kw=class extends Tn{__isAsync;destroyRef=void 0;pendingTasks=void 0;constructor(n=!1){super(),this.__isAsync=n,i_()&&(this.destroyRef=Ie(uc,{optional:!0})??void 0,this.pendingTasks=Ie(pc,{optional:!0})??void 0)}emit(n){let t=De(null);try{super.next(n)}finally{De(t)}}subscribe(n,t,r){let o=n,s=t||(()=>null),i=r;if(n&&typeof n=="object"){let c=n;o=c.next?.bind(c),s=c.error?.bind(c),i=c.complete?.bind(c)}this.__isAsync&&(s=this.wrapInTimeout(s),o&&(o=this.wrapInTimeout(o)),i&&(i=this.wrapInTimeout(i)));let a=super.subscribe({next:o,error:s,complete:i});return n instanceof Ht&&n.add(a),a}wrapInTimeout(n){return t=>{let r=this.pendingTasks?.add();setTimeout(()=>{try{n(t)}finally{r!==void 0&&this.pendingTasks?.remove(r)}})}}},cs=Kw;function FR(e){let n,t;function r(){e=dc;try{t!==void 0&&typeof cancelAnimationFrame=="function"&&cancelAnimationFrame(t),n!==void 0&&clearTimeout(n)}catch{}}return n=setTimeout(()=>{e(),r()}),typeof requestAnimationFrame=="function"&&(t=requestAnimationFrame(()=>{e(),r()})),()=>r()}function J_(e){return queueMicrotask(()=>e()),()=>{e=dc}}var II="isAngularZone",Tx=II+"_ID",$7=0,Qn=class e{hasPendingMacrotasks=!1;hasPendingMicrotasks=!1;isStable=!0;onUnstable=new cs(!1);onMicrotaskEmpty=new cs(!1);onStable=new cs(!1);onError=new cs(!1);constructor(n){let{enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:r=!1,shouldCoalesceRunChangeDetection:o=!1,scheduleInRootZone:s=RR}=n;if(typeof Zone>"u")throw new ze(908,!1);Zone.assertZonePatched();let i=this;i._nesting=0,i._outer=i._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(i._inner=i._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(i._inner=i._inner.fork(Zone.longStackTraceZoneSpec)),i.shouldCoalesceEventChangeDetection=!o&&r,i.shouldCoalesceRunChangeDetection=o,i.callbackScheduled=!1,i.scheduleInRootZone=s,B7(i)}static isInAngularZone(){return typeof Zone<"u"&&Zone.current.get(II)===!0}static assertInAngularZone(){if(!e.isInAngularZone())throw new ze(909,!1)}static assertNotInAngularZone(){if(e.isInAngularZone())throw new ze(909,!1)}run(n,t,r){return this._inner.run(n,t,r)}runTask(n,t,r,o){let s=this._inner,i=s.scheduleEventTask("NgZoneEvent: "+o,n,P7,dc,dc);try{return s.runTask(i,t,r)}finally{s.cancelTask(i)}}runGuarded(n,t,r){return this._inner.runGuarded(n,t,r)}runOutsideAngular(n){return this._outer.run(n)}},P7={};function EI(e){if(e._nesting==0&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function L7(e){if(e.isCheckStableRunning||e.callbackScheduled)return;e.callbackScheduled=!0;function n(){FR(()=>{e.callbackScheduled=!1,Xw(e),e.isCheckStableRunning=!0,EI(e),e.isCheckStableRunning=!1})}e.scheduleInRootZone?Zone.root.run(()=>{n()}):e._outer.run(()=>{n()}),Xw(e)}function B7(e){let n=()=>{L7(e)},t=$7++;e._inner=e._inner.fork({name:"angular",properties:{[II]:!0,[Tx]:t,[Tx+t]:!0},onInvokeTask:(r,o,s,i,a,c)=>{if(V7(c))return r.invokeTask(s,i,a,c);try{return eA(e),r.invokeTask(s,i,a,c)}finally{(e.shouldCoalesceEventChangeDetection&&i.type==="eventTask"||e.shouldCoalesceRunChangeDetection)&&n(),tA(e)}},onInvoke:(r,o,s,i,a,c,l)=>{try{return eA(e),r.invoke(s,i,a,c,l)}finally{e.shouldCoalesceRunChangeDetection&&!e.callbackScheduled&&!U7(c)&&n(),tA(e)}},onHasTask:(r,o,s,i)=>{r.hasTask(s,i),o===s&&(i.change=="microTask"?(e._hasPendingMicrotasks=i.microTask,Xw(e),EI(e)):i.change=="macroTask"&&(e.hasPendingMacrotasks=i.macroTask))},onHandleError:(r,o,s,i)=>(r.handleError(s,i),e.runOutsideAngular(()=>e.onError.emit(i)),!1)})}function Xw(e){e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&e.callbackScheduled===!0?e.hasPendingMicrotasks=!0:e.hasPendingMicrotasks=!1}function eA(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function tA(e){e._nesting--,EI(e)}var zf=class{hasPendingMicrotasks=!1;hasPendingMacrotasks=!1;isStable=!0;onUnstable=new cs;onMicrotaskEmpty=new cs;onStable=new cs;onError=new cs;run(n,t,r){return n.apply(t,r)}runGuarded(n,t,r){return n.apply(t,r)}runOutsideAngular(n){return n()}runTask(n,t,r,o){return n.apply(t,r)}};function V7(e){return OR(e,"__ignore_ng_zone__")}function U7(e){return OR(e,"__scheduler_tick__")}function OR(e,n){return!Array.isArray(e)||e.length!==1?!1:e[0]?.data?.[n]===!0}var MR=(()=>{class e{impl=null;execute(){this.impl?.execute()}static \u0275prov=tt({token:e,providedIn:"root",factory:()=>new e})}return e})();var z7=(()=>{class e{log(t){console.log(t)}warn(t){console.warn(t)}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"platform"})}return e})();var $R=new Ee("");function Mx(e){return!!e&&typeof e.then=="function"}function TI(e){return!!e&&typeof e.subscribe=="function"}var $x=new Ee("");function G7(e){return hr([{provide:$x,multi:!0,useValue:e}])}var SI=(()=>{class e{resolve;reject;initialized=!1;done=!1;donePromise=new Promise((t,r)=>{this.resolve=t,this.reject=r});appInits=Ie($x,{optional:!0})??[];injector=Ie(So);constructor(){}runInitializers(){if(this.initialized)return;let t=[];for(let o of this.appInits){let s=Kg(this.injector,o);if(Mx(s))t.push(s);else if(TI(s)){let i=new Promise((a,c)=>{s.subscribe({complete:a,error:c})});t.push(i)}}let r=()=>{this.done=!0,this.resolve()};Promise.all(t).then(()=>{r()}).catch(o=>{this.reject(o)}),t.length===0&&r(),this.initialized=!0}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),PR=new Ee("");function LR(){eC(()=>{let e="";throw new ze(600,e)})}function BR(e){return e.isBoundToModule}var H7=10;var Xf=(()=>{class e{_runningTick=!1;_destroyed=!1;_destroyListeners=[];_views=[];internalErrorHandler=Ie(Ao);afterRenderManager=Ie(MR);zonelessEnabled=Ie(Rf);rootEffectScheduler=Ie(Of);dirtyFlags=0;tracingSnapshot=null;allTestViews=new Set;autoDetectTestViews=new Set;includeAllTestViews=!1;afterTick=new Tn;get allViews(){return[...(this.includeAllTestViews?this.allTestViews:this.autoDetectTestViews).keys(),...this._views]}get destroyed(){return this._destroyed}componentTypes=[];components=[];internalPendingTask=Ie(pc);get isStable(){return this.internalPendingTask.hasPendingTasksObservable.pipe(Xn(t=>!t))}constructor(){Ie(wI,{optional:!0})}whenStable(){let t;return new Promise(r=>{t=this.isStable.subscribe({next:o=>{o&&r()}})}).finally(()=>{t.unsubscribe()})}_injector=Ie(_r);_rendererFactory=null;get injector(){return this._injector}bootstrap(t,r){return this.bootstrapImpl(t,r)}bootstrapImpl(t,r,o=So.NULL){return this._injector.get(Qn).run(()=>{gt(10);let i=t instanceof Rx;if(!this._injector.get(SI).done){let m="";throw new ze(405,m)}let c;i?c=t:c=this._injector.get(jf).resolveComponentFactory(t),this.componentTypes.push(c.componentType);let l=BR(c)?void 0:this._injector.get(hc),u=r||c.selector,p=c.create(o,[],u,l),d=p.location.nativeElement,f=p.injector.get($R,null);return f?.registerApplication(d),p.onDestroy(()=>{this.detachView(p.hostView),$f(this.components,p),f?.unregisterApplication(d)}),this._loadComponent(p),gt(11,p),p})}tick(){this.zonelessEnabled||(this.dirtyFlags|=1),this._tick()}_tick(){gt(12),this.tracingSnapshot!==null?this.tracingSnapshot.run(CI.CHANGE_DETECTION,this.tickImpl):this.tickImpl()}tickImpl=()=>{if(this._runningTick)throw new ze(101,!1);let t=De(null);try{this._runningTick=!0,this.synchronize()}finally{this._runningTick=!1,this.tracingSnapshot?.dispose(),this.tracingSnapshot=null,De(t),this.afterTick.next(),gt(13)}};synchronize(){this._rendererFactory===null&&!this._injector.destroyed&&(this._rendererFactory=this._injector.get(Vf,null,{optional:!0}));let t=0;for(;this.dirtyFlags!==0&&t++<H7;)gt(14),this.synchronizeOnce(),gt(15)}synchronizeOnce(){this.dirtyFlags&16&&(this.dirtyFlags&=-17,this.rootEffectScheduler.flush());let t=!1;if(this.dirtyFlags&7){let r=!!(this.dirtyFlags&1);this.dirtyFlags&=-8,this.dirtyFlags|=8;for(let{_lView:o}of this.allViews){if(!r&&!Nf(o))continue;let s=r&&!this.zonelessEnabled?0:1;xI(o,s),t=!0}if(this.dirtyFlags&=-5,this.syncDirtyFlagsWithViews(),this.dirtyFlags&23)return}t||(this._rendererFactory?.begin?.(),this._rendererFactory?.end?.()),this.dirtyFlags&8&&(this.dirtyFlags&=-9,this.afterRenderManager.execute()),this.syncDirtyFlagsWithViews()}syncDirtyFlagsWithViews(){if(this.allViews.some(({_lView:t})=>Nf(t))){this.dirtyFlags|=2;return}else this.dirtyFlags&=-8}attachView(t){let r=t;this._views.push(r),r.attachToAppRef(this)}detachView(t){let r=t;$f(this._views,r),r.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView);try{this.tick()}catch(o){this.internalErrorHandler(o)}this.components.push(t),this._injector.get(PR,[]).forEach(o=>o(t))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(t=>t()),this._views.slice().forEach(t=>t.destroy())}finally{this._destroyed=!0,this._views=[],this._destroyListeners=[]}}onDestroy(t){return this._destroyListeners.push(t),()=>$f(this._destroyListeners,t)}destroy(){if(this._destroyed)throw new ze(406,!1);let t=this._injector;t.destroy&&!t.destroyed&&t.destroy()}get viewCount(){return this._views.length}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function $f(e,n){let t=e.indexOf(n);t>-1&&e.splice(t,1)}function Fo(e,n,t,r){let o=nt(),s=kf();if(ai(o,s,n)){let i=Zn(),a=yw();hK(a,o,e,n,t,r)}return Fo}var W7=new Ee("",{providedIn:"root",factory:()=>!1}),j7=new Ee("",{providedIn:"root",factory:()=>q7}),q7=4e3;var bCe=typeof document<"u"&&typeof document?.documentElement?.getAnimations=="function";function ci(e,n,t,r,o,s,i,a){Ap("NgControlFlow");let c=nt(),l=Zn(),u=_o(l.consts,s);return AR(c,l,e,n,t,r,o,u,256,i,a),NI}function NI(e,n,t,r,o,s,i,a){Ap("NgControlFlow");let c=nt(),l=Zn(),u=_o(l.consts,s);return AR(c,l,e,n,t,r,o,u,512,i,a),NI}function li(e,n){Ap("NgControlFlow");let t=nt(),r=kf(),o=t[r]!==Mr?t[r]:-1,s=o!==-1?nA(t,Wt+o):void 0,i=0;if(ai(t,r,e)){let a=De(null);try{if(s!==void 0&&$K(s,i),e!==-1){let c=Wt+e,l=nA(t,c),u=K7(t[we],c),p=HK(l,u,t),d=eR(t,u,n,{dehydratedView:p});pR(l,d,i,Pw(u,p))}}finally{De(a)}}else if(s!==void 0){let a=MK(s,i);a!==void 0&&(a[gn]=n)}}function nA(e,n){return e[n]}function K7(e,n){return Sf(e,n)}function Jn(e,n,t){let r=nt(),o=kf();if(ai(r,o,n)){let s=Zn(),i=yw();lK(i,r,e,n,r[tn],t)}return Jn}function rA(e,n,t,r,o){hI(n,e,t,o?"class":"style",r)}function $e(e,n,t,r){let o=nt(),s=o[we],i=e+Wt,a=s.firstCreatePass?xR(i,o,2,n,ZA,iw(),t,r):s.data[i];if(QA(a,o,e,n,VR),Tf(a)){let c=o[we];mI(c,o,a),$A(c,a,o)}return r!=null&&Ax(o,a),$e}function Be(){let e=Zn(),n=xr(),t=JA(n);return e.firstCreatePass&&yR(e,t),aw(t)&&cw(),sw(),t.classesWithoutHost!=null&&K5(t)&&rA(e,t,nt(),t.classesWithoutHost,!0),t.stylesWithoutHost!=null&&X5(t)&&rA(e,t,nt(),t.stylesWithoutHost,!1),Be}function pt(e,n,t,r){return $e(e,n,t,r),Be(),pt}function DI(e,n,t,r){let o=nt(),s=o[we],i=e+Wt,a=s.firstCreatePass?e7(i,s,2,n,t,r):s.data[i];return QA(a,o,e,n,VR),r!=null&&Ax(o,a),DI}function kI(){let e=xr(),n=JA(e);return aw(n)&&cw(),sw(),kI}function Yf(e,n,t,r){return DI(e,n,t,r),kI(),Yf}var VR=(e,n,t,r,o)=>(ox(!0),zA(n[tn],r,k_()));function vc(){return nt()}var fc=void 0;function X7(e){let n=Math.floor(Math.abs(e)),t=e.toString().replace(/^[^.]*\.?/,"").length;return n===1&&t===0?1:5}var Y7=["en",[["a","p"],["AM","PM"],fc],[["AM","PM"],fc,fc],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],fc,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],fc,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",fc,"{1} 'at' {0}",fc],[".",",",";","%","+","-","E","\xD7","\u2030","\u221E","NaN",":"],["#,##0.###","#,##0%","\xA4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",X7],Nw={};function Px(e){let n=Z7(e),t=oA(n);if(t)return t;let r=n.split("-")[0];if(t=oA(r),t)return t;if(r==="en")return Y7;throw new ze(701,!1)}function oA(e){return e in Nw||(Nw[e]=gp.ng&&gp.ng.common&&gp.ng.common.locales&&gp.ng.common.locales[e]),Nw[e]}var bc=(function(e){return e[e.LocaleId=0]="LocaleId",e[e.DayPeriodsFormat=1]="DayPeriodsFormat",e[e.DayPeriodsStandalone=2]="DayPeriodsStandalone",e[e.DaysFormat=3]="DaysFormat",e[e.DaysStandalone=4]="DaysStandalone",e[e.MonthsFormat=5]="MonthsFormat",e[e.MonthsStandalone=6]="MonthsStandalone",e[e.Eras=7]="Eras",e[e.FirstDayOfWeek=8]="FirstDayOfWeek",e[e.WeekendRange=9]="WeekendRange",e[e.DateFormat=10]="DateFormat",e[e.TimeFormat=11]="TimeFormat",e[e.DateTimeFormat=12]="DateTimeFormat",e[e.NumberSymbols=13]="NumberSymbols",e[e.NumberFormats=14]="NumberFormats",e[e.CurrencyCode=15]="CurrencyCode",e[e.CurrencySymbol=16]="CurrencySymbol",e[e.CurrencyName=17]="CurrencyName",e[e.Currencies=18]="Currencies",e[e.Directionality=19]="Directionality",e[e.PluralCase=20]="PluralCase",e[e.ExtraData=21]="ExtraData",e})(bc||{});function Z7(e){return e.toLowerCase().replace(/_/g,"-")}var Zf="en-US";var Q7=Zf;function UR(e){typeof e=="string"&&(Q7=e.toLowerCase().replace(/_/g,"-"))}function ro(e,n,t){let r=nt(),o=Zn(),s=xr();return J7(o,r,r[tn],s,e,n,t),ro}function J7(e,n,t,r,o,s,i){let a=!0,c=null;if((r.type&3||i)&&(c??=Tw(r,n,s),t7(r,e,n,i,t,o,s,c)&&(a=!1)),a){let l=r.outputs?.[o],u=r.hostDirectiveOutputs?.[o];if(u&&u.length)for(let p=0;p<u.length;p+=2){let d=u[p],f=u[p+1];c??=Tw(r,n,s),K_(r,n,d,f,o,c)}if(l&&l.length)for(let p of l)c??=Tw(r,n,s),K_(r,n,p,o,o,c)}}function yr(e=1){return D_(e)}function vr(e,n,t){E7(e,n,t)}function br(e){let n=nt(),t=Zn(),r=hw();ex(r+1);let o=bI(t,r);if(e.dirty&&l_(n)===((o.metadata.flags&2)===2)){if(o.matches===null)e.reset([]);else{let s=N7(n,r);e.reset(s,lq),e.notifyOnChanges()}return!0}return!1}function Cr(){return w7(nt(),hw())}function ix(e,n){return e<<17|n<<2}function gc(e){return e>>17&32767}function e9(e){return(e&2)==2}function t9(e,n){return e&131071|n<<17}function Yw(e){return e|2}function kp(e){return(e&131068)>>2}function Dw(e,n){return e&-131069|n<<2}function n9(e){return(e&1)===1}function Zw(e){return e|1}function r9(e,n,t,r,o,s){let i=s?n.classBindings:n.styleBindings,a=gc(i),c=kp(i);e[r]=t;let l=!1,u;if(Array.isArray(t)){let p=t;u=p[1],(u===null||xp(p,u)>0)&&(l=!0)}else u=t;if(o)if(c!==0){let d=gc(e[a+1]);e[r+1]=ix(d,a),d!==0&&(e[d+1]=Dw(e[d+1],r)),e[a+1]=t9(e[a+1],r)}else e[r+1]=ix(a,0),a!==0&&(e[a+1]=Dw(e[a+1],r)),a=r;else e[r+1]=ix(c,0),a===0?a=r:e[c+1]=Dw(e[c+1],r),c=r;l&&(e[r+1]=Yw(e[r+1])),sA(e,u,r,!0),sA(e,u,r,!1),o9(n,u,e,r,s),i=ix(a,c),s?n.classBindings=i:n.styleBindings=i}function o9(e,n,t,r,o){let s=o?e.residualClasses:e.residualStyles;s!=null&&typeof n=="string"&&xp(s,n)>=0&&(t[r+1]=Zw(t[r+1]))}function sA(e,n,t,r){let o=e[t+1],s=n===null,i=r?gc(o):kp(o),a=!1;for(;i!==0&&(a===!1||s);){let c=e[i],l=e[i+1];s9(c,n)&&(a=!0,e[i+1]=r?Zw(l):Yw(l)),i=r?gc(l):kp(l)}a&&(e[t+1]=r?Yw(o):Zw(o))}function s9(e,n){return e===null||n==null||(Array.isArray(e)?e[1]:e)===n?!0:Array.isArray(e)&&typeof n=="string"?xp(e,n)>=0:!1}function Qf(e,n,t){return zR(e,n,t,!1),Qf}function Fp(e,n){return zR(e,n,null,!0),Fp}function zR(e,n,t,r){let o=nt(),s=Zn(),i=mw(2);if(s.firstUpdatePass&&a9(s,e,i,r),n!==Mr&&ai(o,i,n)){let a=s.data[ri()];d9(s,a,o,o[tn],e,o[i+1]=f9(n,t),r,i)}}function i9(e,n){return n>=e.expandoStartIndex}function a9(e,n,t,r){let o=e.data;if(o[t+1]===null){let s=o[ri()],i=i9(e,t);m9(s,r)&&n===null&&!i&&(n=!1),n=c9(o,s,n,r),r9(o,s,n,t,i,r)}}function c9(e,n,t,r){let o=E_(e),s=r?n.residualClasses:n.residualStyles;if(o===null)(r?n.classBindings:n.styleBindings)===0&&(t=kw(null,e,n,t,r),t=Gf(t,n.attrs,r),s=null);else{let i=n.directiveStylingLast;if(i===-1||e[i]!==o)if(t=kw(o,e,n,t,r),s===null){let c=l9(e,n,r);c!==void 0&&Array.isArray(c)&&(c=kw(null,e,n,c[1],r),c=Gf(c,n.attrs,r),u9(e,n,r,c))}else s=p9(e,n,r)}return s!==void 0&&(r?n.residualClasses=s:n.residualStyles=s),t}function l9(e,n,t){let r=t?n.classBindings:n.styleBindings;if(kp(r)!==0)return e[gc(r)]}function u9(e,n,t,r){let o=t?n.classBindings:n.styleBindings;e[gc(o)]=r}function p9(e,n,t){let r,o=n.directiveEnd;for(let s=1+n.directiveStylingLast;s<o;s++){let i=e[s].hostAttrs;r=Gf(r,i,t)}return Gf(r,n.attrs,t)}function kw(e,n,t,r,o){let s=null,i=t.directiveEnd,a=t.directiveStylingLast;for(a===-1?a=t.directiveStart:a++;a<i&&(s=n[a],r=Gf(r,s.hostAttrs,o),s!==e);)a++;return e!==null&&(t.directiveStylingLast=a),r}function Gf(e,n,t){let r=t?1:2,o=-1;if(n!==null)for(let s=0;s<n.length;s++){let i=n[s];typeof i=="number"?o=i:o===r&&(Array.isArray(e)||(e=e===void 0?[]:["",e]),Jk(e,i,t?!0:n[++s]))}return e===void 0?null:e}function d9(e,n,t,r,o,s,i,a){if(!(n.type&3))return;let c=e.data,l=c[a+1],u=n9(l)?iA(c,n,t,o,kp(l),i):void 0;if(!Sx(u)){Sx(s)||e9(l)&&(s=iA(c,null,t,o,a,i));let p=ZC(ri(),t);oK(r,i,p,o,s)}}function iA(e,n,t,r,o,s){let i=n===null,a;for(;o>0;){let c=e[o],l=Array.isArray(c),u=l?c[1]:c,p=u===null,d=t[o+1];d===Mr&&(d=p?kr:void 0);let f=p?qg(d,r):u===r?d:void 0;if(l&&!Sx(f)&&(f=qg(c,r)),Sx(f)&&(a=f,i))return a;let m=e[o+1];o=i?gc(m):kp(m)}if(n!==null){let c=s?n.residualClasses:n.residualStyles;c!=null&&(a=qg(c,r))}return a}function Sx(e){return e!==void 0}function f9(e,n){return e==null||e===""||(typeof n=="string"?e=e+n:typeof e=="object"&&(e=ss(nI(e)))),e}function m9(e,n){return(e.flags&(n?8:16))!==0}function Dn(e,n=""){let t=nt(),r=Zn(),o=e+Wt,s=r.firstCreatePass?Wf(r,o,1,n,null):r.data[o],i=h9(r,t,s,n,e);t[o]=i,rx()&&dI(r,t,i,s),Cp(s,!1)}var h9=(e,n,t,r,o)=>(ox(!0),Pq(n[tn],r));function g9(e,n,t,r=""){return ai(e,kf(),t)?n+tc(t)+r:Mr}function x9(e,n,t,r,o,s=""){let i=v_(),a=bR(e,i,t,o);return mw(2),a?n+tc(t)+r+tc(o)+s:Mr}function ls(e){return us("",e),ls}function us(e,n,t){let r=nt(),o=g9(r,e,n,t);return o!==Mr&&GR(r,ri(),o),us}function Jf(e,n,t,r,o){let s=nt(),i=x9(s,e,n,t,r,o);return i!==Mr&&GR(s,ri(),i),Jf}function GR(e,n,t){let r=ZC(n,e);Lq(e[tn],r,t)}function HR(e,n){let t=e[n];return t===Mr?void 0:t}function y9(e,n,t,r,o,s){let i=n+t;return ai(e,i,o)?vR(e,i+1,s?r.call(s,o):r(o)):HR(e,i+1)}function v9(e,n,t,r,o,s,i){let a=n+t;return bR(e,a,o,s)?vR(e,a+2,i?r.call(i,o,s):r(o,s)):HR(e,a+2)}function Ln(e,n){let t=Zn(),r,o=e+Wt;t.firstCreatePass?(r=b9(n,t.pipeRegistry),t.data[o]=r,r.onDestroy&&(t.destroyHooks??=[]).push(o,r.onDestroy)):r=t.data[o];let s=r.factory||(r.factory=Xs(r.type,!0)),i,a=Pn(Nn);try{let c=mx(!1),l=s();return mx(c),JC(t,nt(),o,l),l}finally{Pn(a)}}function b9(e,n){if(n)for(let t=n.length-1;t>=0;t--){let r=n[t];if(e===r.name)return r}}function wr(e,n,t){let r=e+Wt,o=nt(),s=QC(o,r);return WR(o,r)?y9(o,fw(),n,s.transform,t,s):s.transform(t)}function Lx(e,n,t,r){let o=e+Wt,s=nt(),i=QC(s,o);return WR(s,o)?v9(s,fw(),n,i.transform,t,r,i):i.transform(t,r)}function WR(e,n){return e[we].data[n].pure}var Nx=class{ngModuleFactory;componentFactories;constructor(n,t){this.ngModuleFactory=n,this.componentFactories=t}},C9=(()=>{class e{compileModuleSync(t){return new Ex(t)}compileModuleAsync(t){return Promise.resolve(this.compileModuleSync(t))}compileModuleAndAllComponentsSync(t){let r=this.compileModuleSync(t),o=zC(t),s=VA(o.declarations).reduce((i,a)=>{let c=Js(a);return c&&i.push(new Dp(c)),i},[]);return new Nx(r,s)}compileModuleAndAllComponentsAsync(t){return Promise.resolve(this.compileModuleAndAllComponentsSync(t))}clearCache(){}clearCacheFor(t){}getModuleId(t){}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();var w9=(()=>{class e{zone=Ie(Qn);changeDetectionScheduler=Ie(No);applicationRef=Ie(Xf);applicationErrorHandler=Ie(Ao);_onMicrotaskEmptySubscription;initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.changeDetectionScheduler.runningTick||this.zone.run(()=>{try{this.applicationRef.dirtyFlags|=1,this.applicationRef._tick()}catch(t){this.applicationErrorHandler(t)}})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function jR({ngZoneFactory:e,ignoreChangesOutsideZone:n,scheduleInRootZone:t}){return e??=()=>new Qn(Ft(Je({},qR()),{scheduleInRootZone:t})),[{provide:Qn,useFactory:e},{provide:Qs,multi:!0,useFactory:()=>{let r=Ie(w9,{optional:!0});return()=>r.initialize()}},{provide:Qs,multi:!0,useFactory:()=>{let r=Ie(I9);return()=>{r.initialize()}}},n===!0?{provide:Cw,useValue:!0}:[],{provide:sx,useValue:t??RR},{provide:Ao,useFactory:()=>{let r=Ie(Qn),o=Ie(_r),s;return i=>{r.runOutsideAngular(()=>{o.destroyed&&!s?setTimeout(()=>{throw i}):(s??=o.get(Zs),s.handleError(i))})}}}]}function qR(e){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:e?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:e?.runCoalescing??!1}}var I9=(()=>{class e{subscription=new Ht;initialized=!1;zone=Ie(Qn);pendingTasks=Ie(pc);initialize(){if(this.initialized)return;this.initialized=!0;let t=null;!this.zone.isStable&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(t=this.pendingTasks.add()),this.zone.runOutsideAngular(()=>{this.subscription.add(this.zone.onStable.subscribe(()=>{Qn.assertNotInAngularZone(),queueMicrotask(()=>{t!==null&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(this.pendingTasks.remove(t),t=null)})}))}),this.subscription.add(this.zone.onUnstable.subscribe(()=>{Qn.assertInAngularZone(),t??=this.pendingTasks.add()}))}ngOnDestroy(){this.subscription.unsubscribe()}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();var _I=(()=>{class e{applicationErrorHandler=Ie(Ao);appRef=Ie(Xf);taskService=Ie(pc);ngZone=Ie(Qn);zonelessEnabled=Ie(Rf);tracing=Ie(wI,{optional:!0});disableScheduling=Ie(Cw,{optional:!0})??!1;zoneIsDefined=typeof Zone<"u"&&!!Zone.root.run;schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}];subscriptions=new Ht;angularZoneId=this.zoneIsDefined?this.ngZone._inner?.get(Tx):null;scheduleInRootZone=!this.zonelessEnabled&&this.zoneIsDefined&&(Ie(sx,{optional:!0})??!1);cancelScheduledCallback=null;useMicrotaskScheduler=!1;runningTick=!1;pendingRenderTaskId=null;constructor(){this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{this.runningTick||this.cleanup()})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()})),this.disableScheduling||=!this.zonelessEnabled&&(this.ngZone instanceof zf||!this.zoneIsDefined)}notify(t){if(!this.zonelessEnabled&&t===5)return;let r=!1;switch(t){case 0:{this.appRef.dirtyFlags|=2;break}case 3:case 2:case 4:case 5:case 1:{this.appRef.dirtyFlags|=4;break}case 6:{this.appRef.dirtyFlags|=2,r=!0;break}case 12:{this.appRef.dirtyFlags|=16,r=!0;break}case 13:{this.appRef.dirtyFlags|=2,r=!0;break}case 11:{r=!0;break}case 9:case 8:case 7:case 10:default:this.appRef.dirtyFlags|=8}if(this.appRef.tracingSnapshot=this.tracing?.snapshot(this.appRef.tracingSnapshot)??null,!this.shouldScheduleTick(r))return;let o=this.useMicrotaskScheduler?J_:FR;this.pendingRenderTaskId=this.taskService.add(),this.scheduleInRootZone?this.cancelScheduledCallback=Zone.root.run(()=>o(()=>this.tick())):this.cancelScheduledCallback=this.ngZone.runOutsideAngular(()=>o(()=>this.tick()))}shouldScheduleTick(t){return!(this.disableScheduling&&!t||this.appRef.destroyed||this.pendingRenderTaskId!==null||this.runningTick||this.appRef._runningTick||!this.zonelessEnabled&&this.zoneIsDefined&&Zone.current.get(Tx+this.angularZoneId))}tick(){if(this.runningTick||this.appRef.destroyed)return;if(this.appRef.dirtyFlags===0){this.cleanup();return}!this.zonelessEnabled&&this.appRef.dirtyFlags&7&&(this.appRef.dirtyFlags|=1);let t=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick()},void 0,this.schedulerTickApplyArgs)}catch(r){this.taskService.remove(t),this.applicationErrorHandler(r)}finally{this.cleanup()}this.useMicrotaskScheduler=!0,J_(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(t)})}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,this.pendingRenderTaskId!==null){let t=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(t)}}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function E9(){return Ap("NgZoneless"),hr([{provide:No,useExisting:_I},{provide:Qn,useClass:zf},{provide:Rf,useValue:!0},{provide:sx,useValue:!1},[]])}function T9(){return typeof $localize<"u"&&$localize.locale||Zf}var em=new Ee("",{providedIn:"root",factory:()=>Ie(em,{optional:!0,skipSelf:!0})||T9()});function KR(e){return Vk(e)}var AI=class{[qn];constructor(n){this[qn]=n}destroy(){this[qn].destroy()}};function RI(e,n){let t=n?.injector??Ie(So),r=n?.manualCleanup!==!0?t.get(uc):null,o,s=t.get(Ff,null,{optional:!0}),i=t.get(No);return s!==null?(o=D9(s.view,i,e),r instanceof xf&&r._lView===s.view&&(r=null)):o=k9(e,t.get(Of),i),o.injector=t,r!==null&&(o.onDestroyFn=r.onDestroy(()=>o.destroy())),new AI(o)}var XR=Ft(Je({},Uk),{cleanupFns:void 0,zone:null,onDestroyFn:dc,run(){let e=wp(!1);try{zk(this)}finally{wp(e)}},cleanup(){if(!this.cleanupFns?.length)return;let e=De(null);try{for(;this.cleanupFns.length;)this.cleanupFns.pop()()}finally{this.cleanupFns=[],De(e)}}}),S9=Ft(Je({},XR),{consumerMarkedDirty(){this.scheduler.schedule(this),this.notifier.notify(12)},destroy(){Ua(this),this.onDestroyFn(),this.cleanup(),this.scheduler.remove(this)}}),N9=Ft(Je({},XR),{consumerMarkedDirty(){this.view[Te]|=8192,lc(this.view),this.notifier.notify(13)},destroy(){Ua(this),this.onDestroyFn(),this.cleanup(),this.view[is]?.delete(this)}});function D9(e,n,t){let r=Object.create(N9);return r.view=e,r.zone=typeof Zone<"u"?Zone.current:null,r.notifier=n,r.fn=YR(r,t),e[is]??=new Set,e[is].add(r),r.consumerMarkedDirty(r),r}function k9(e,n,t){let r=Object.create(S9);return r.fn=YR(r,e),r.scheduler=n,r.notifier=t,r.zone=typeof Zone<"u"?Zone.current:null,r.scheduler.add(r),r.notifier.notify(12),r}function YR(e,n){return()=>{n(t=>(e.cleanupFns??=[]).push(t))}}var e2=Symbol("InputSignalNode#UNSET"),B9=Ft(Je({},ig),{transformFn:void 0,applyValueToInputSignal(e,n){ap(e,n)}});function t2(e,n){let t=Object.create(B9);t.value=e,t.transformFn=n?.transform;function r(){if(rf(t),t.value===e2){let o=null;throw new ze(-950,o)}return t.value}return r[qn]=t,r}var V9=new Ee("");V9.__NG_ELEMENT_ID__=e=>{let n=xr();if(n===null)throw new ze(204,!1);if(n.type&2)return n.value;if(e&8)return null;throw new ze(204,!1)};function ZR(e,n){return t2(e,n)}function U9(e){return t2(e2,e)}var Vx=(ZR.required=U9,ZR);var FI=new Ee(""),z9=new Ee("");function tm(e){return!e.moduleRef}function G9(e){let n=tm(e)?e.r3Injector:e.moduleRef.injector,t=n.get(Qn);return t.run(()=>{tm(e)?e.r3Injector.resolveInjectorInitializers():e.moduleRef.resolveInjectorInitializers();let r=n.get(Ao),o;if(t.runOutsideAngular(()=>{o=t.onError.subscribe({next:r})}),tm(e)){let s=()=>n.destroy(),i=e.platformInjector.get(FI);i.add(s),n.onDestroy(()=>{o.unsubscribe(),i.delete(s)})}else{let s=()=>e.moduleRef.destroy(),i=e.platformInjector.get(FI);i.add(s),e.moduleRef.onDestroy(()=>{$f(e.allPlatformModules,e.moduleRef),o.unsubscribe(),i.delete(s)})}return W9(r,t,()=>{let s=n.get(pc),i=s.add(),a=n.get(SI);return a.runInitializers(),a.donePromise.then(()=>{let c=n.get(em,Zf);if(UR(c||Zf),!n.get(z9,!0))return tm(e)?n.get(Xf):(e.allPlatformModules.push(e.moduleRef),e.moduleRef);if(tm(e)){let u=n.get(Xf);return e.rootComponent!==void 0&&u.bootstrap(e.rootComponent),u}else return H9?.(e.moduleRef,e.allPlatformModules),e.moduleRef}).finally(()=>void s.remove(i))})})}var H9;function W9(e,n,t){try{let r=t();return Mx(r)?r.catch(o=>{throw n.runOutsideAngular(()=>e(o)),o}):r}catch(r){throw n.runOutsideAngular(()=>e(r)),r}}var Bx=null;function j9(e=[],n){return So.create({name:n,providers:[{provide:jC,useValue:"platform"},{provide:FI,useValue:new Set([()=>Bx=null])},...e]})}function q9(e=[]){if(Bx)return Bx;let n=j9(e);return Bx=n,LR(),K9(n),n}function K9(e){let n=e.get(AA,null);Kg(e,()=>{n?.forEach(t=>t())})}var Ux=(()=>{class e{static __NG_ELEMENT_ID__=X9}return e})();function X9(e){return Y9(xr(),nt(),(e&16)===16)}function Y9(e,n,t){if(ni(e)&&!t){let r=Jr(e.index,n);return new si(r,r)}else if(e.type&175){let r=n[Fr];return new si(r,n)}return null}function sDe(e){let{rootComponent:n,appProviders:t,platformProviders:r,platformRef:o}=e;gt(8);try{let s=o?.injector??q9(r),i=[jR({}),{provide:No,useExisting:_I},R_,...t||[]],a=new Uf({providers:i,parent:s,debugName:"",runEnvironmentInitializers:!1});return G9({r3Injector:a.injector,platformInjector:s,rootComponent:n})}catch(s){return Promise.reject(s)}finally{gt(9)}}var o2=null;function zx(){return o2}function Z9(e){o2??=e}var OI=class{},MI=(()=>{class e{historyGo(t){throw new Error("")}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:()=>Ie(s2),providedIn:"platform"})}return e})();var s2=(()=>{class e extends MI{_location;_history;_doc=Ie(Ip);constructor(){super(),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return zx().getBaseHref(this._doc)}onPopState(t){let r=zx().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",t,!1),()=>r.removeEventListener("popstate",t)}onHashChange(t){let r=zx().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",t,!1),()=>r.removeEventListener("hashchange",t)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(t){this._location.pathname=t}pushState(t,r,o){this._history.pushState(t,r,o)}replaceState(t,r,o){this._history.replaceState(t,r,o)}forward(){this._history.forward()}back(){this._history.back()}historyGo(t=0){this._history.go(t)}getState(){return this._history.state}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:()=>new e,providedIn:"platform"})}return e})();function i2(e,n){return e?n?e.endsWith("/")?n.startsWith("/")?e+n.slice(1):e+n:n.startsWith("/")?e+n:`${e}/${n}`:e:n}function n2(e){let n=e.search(/#|\?|$/);return e[n-1]==="/"?e.slice(0,n-1)+e.slice(n):e}function pi(e){return e&&e[0]!=="?"?`?${e}`:e}var Gx=(()=>{class e{historyGo(t){throw new Error("")}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:()=>Ie(c2),providedIn:"root"})}return e})(),a2=new Ee(""),c2=(()=>{class e extends Gx{_platformLocation;_baseHref;_removeListenerFns=[];constructor(t,r){super(),this._platformLocation=t,this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??Ie(Ip).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(t){this._removeListenerFns.push(this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t))}getBaseHref(){return this._baseHref}prepareExternalUrl(t){return i2(this._baseHref,t)}path(t=!1){let r=this._platformLocation.pathname+pi(this._platformLocation.search),o=this._platformLocation.hash;return o&&t?`${r}${o}`:r}pushState(t,r,o,s){let i=this.prepareExternalUrl(o+pi(s));this._platformLocation.pushState(t,r,i)}replaceState(t,r,o,s){let i=this.prepareExternalUrl(o+pi(s));this._platformLocation.replaceState(t,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(t=0){this._platformLocation.historyGo?.(t)}static \u0275fac=function(r){return new(r||e)(at(MI),at(a2,8))};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),l2=(()=>{class e{_subject=new Tn;_basePath;_locationStrategy;_urlChangeListeners=[];_urlChangeSubscription=null;constructor(t){this._locationStrategy=t;let r=this._locationStrategy.getBaseHref();this._basePath=eX(n2(r2(r))),this._locationStrategy.onPopState(o=>{this._subject.next({url:this.path(!0),pop:!0,state:o.state,type:o.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(t=!1){return this.normalize(this._locationStrategy.path(t))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(t,r=""){return this.path()==this.normalize(t+pi(r))}normalize(t){return e.stripTrailingSlash(J9(this._basePath,r2(t)))}prepareExternalUrl(t){return t&&t[0]!=="/"&&(t="/"+t),this._locationStrategy.prepareExternalUrl(t)}go(t,r="",o=null){this._locationStrategy.pushState(o,"",t,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+pi(r)),o)}replaceState(t,r="",o=null){this._locationStrategy.replaceState(o,"",t,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+pi(r)),o)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(t=0){this._locationStrategy.historyGo?.(t)}onUrlChange(t){return this._urlChangeListeners.push(t),this._urlChangeSubscription??=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)}),()=>{let r=this._urlChangeListeners.indexOf(t);this._urlChangeListeners.splice(r,1),this._urlChangeListeners.length===0&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(t="",r){this._urlChangeListeners.forEach(o=>o(t,r))}subscribe(t,r,o){return this._subject.subscribe({next:t,error:r??void 0,complete:o??void 0})}static normalizeQueryParams=pi;static joinWithSlash=i2;static stripTrailingSlash=n2;static \u0275fac=function(r){return new(r||e)(at(Gx))};static \u0275prov=tt({token:e,factory:()=>Q9(),providedIn:"root"})}return e})();function Q9(){return new l2(at(Gx))}function J9(e,n){if(!e||!n.startsWith(e))return n;let t=n.substring(e.length);return t===""||["/",";","?","#"].includes(t[0])?t:n}function r2(e){return e.replace(/\/index.html$/,"")}function eX(e){if(new RegExp("^(https?:)?//").test(e)){let[,t]=e.split(/\/\/[^\/]+/);return t}return e}var LI=(function(e){return e[e.Decimal=0]="Decimal",e[e.Percent=1]="Percent",e[e.Currency=2]="Currency",e[e.Scientific=3]="Scientific",e})(LI||{});var Oo={Decimal:0,Group:1,List:2,PercentSign:3,PlusSign:4,MinusSign:5,Exponential:6,SuperscriptingExponent:7,PerMille:8,Infinity:9,NaN:10,TimeSeparator:11,CurrencyDecimal:12,CurrencyGroup:13};function Op(e,n){let t=Px(e),r=t[bc.NumberSymbols][n];if(typeof r>"u"){if(n===Oo.CurrencyDecimal)return t[bc.NumberSymbols][Oo.Decimal];if(n===Oo.CurrencyGroup)return t[bc.NumberSymbols][Oo.Group]}return r}function d2(e,n){return Px(e)[bc.NumberFormats][n]}var tX=/^(\d+)?\.((\d+)(-(\d+))?)?$/,u2=22,Hx=".",nm="0",nX=";",rX=",",$I="#";function oX(e,n,t,r,o,s,i=!1){let a="",c=!1;if(!isFinite(e))a=Op(t,Oo.Infinity);else{let l=aX(e);i&&(l=iX(l));let u=n.minInt,p=n.minFrac,d=n.maxFrac;if(s){let v=s.match(tX);if(v===null)throw new ze(2306,!1);let w=v[1],I=v[3],_=v[5];w!=null&&(u=PI(w)),I!=null&&(p=PI(I)),_!=null?d=PI(_):I!=null&&p>d&&(d=p)}cX(l,p,d);let f=l.digits,m=l.integerLen,h=l.exponent,g=[];for(c=f.every(v=>!v);m<u;m++)f.unshift(0);for(;m<0;m++)f.unshift(0);m>0?g=f.splice(m,f.length):(g=f,f=[0]);let x=[];for(f.length>=n.lgSize&&x.unshift(f.splice(-n.lgSize,f.length).join(""));f.length>n.gSize;)x.unshift(f.splice(-n.gSize,f.length).join(""));f.length&&x.unshift(f.join("")),a=x.join(Op(t,r)),g.length&&(a+=Op(t,o)+g.join("")),h&&(a+=Op(t,Oo.Exponential)+"+"+h)}return e<0&&!c?a=n.negPre+a+n.negSuf:a=n.posPre+a+n.posSuf,a}function f2(e,n,t){let r=d2(n,LI.Decimal),o=sX(r,Op(n,Oo.MinusSign));return oX(e,o,n,Oo.Group,Oo.Decimal,t)}function sX(e,n="-"){let t={minInt:1,minFrac:0,maxFrac:0,posPre:"",posSuf:"",negPre:"",negSuf:"",gSize:0,lgSize:0},r=e.split(nX),o=r[0],s=r[1],i=o.indexOf(Hx)!==-1?o.split(Hx):[o.substring(0,o.lastIndexOf(nm)+1),o.substring(o.lastIndexOf(nm)+1)],a=i[0],c=i[1]||"";t.posPre=a.substring(0,a.indexOf($I));for(let u=0;u<c.length;u++){let p=c.charAt(u);p===nm?t.minFrac=t.maxFrac=u+1:p===$I?t.maxFrac=u+1:t.posSuf+=p}let l=a.split(rX);if(t.gSize=l[1]?l[1].length:0,t.lgSize=l[2]||l[1]?(l[2]||l[1]).length:0,s){let u=o.length-t.posPre.length-t.posSuf.length,p=s.indexOf($I);t.negPre=s.substring(0,p).replace(/'/g,""),t.negSuf=s.slice(p+u).replace(/'/g,"")}else t.negPre=n+t.posPre,t.negSuf=t.posSuf;return t}function iX(e){if(e.digits[0]===0)return e;let n=e.digits.length-e.integerLen;return e.exponent?e.exponent+=2:(n===0?e.digits.push(0,0):n===1&&e.digits.push(0),e.integerLen+=2),e}function aX(e){let n=Math.abs(e)+"",t=0,r,o,s,i,a;for((o=n.indexOf(Hx))>-1&&(n=n.replace(Hx,"")),(s=n.search(/e/i))>0?(o<0&&(o=s),o+=+n.slice(s+1),n=n.substring(0,s)):o<0&&(o=n.length),s=0;n.charAt(s)===nm;s++);if(s===(a=n.length))r=[0],o=1;else{for(a--;n.charAt(a)===nm;)a--;for(o-=s,r=[],i=0;s<=a;s++,i++)r[i]=Number(n.charAt(s))}return o>u2&&(r=r.splice(0,u2-1),t=o-1,o=1),{digits:r,exponent:t,integerLen:o}}function cX(e,n,t){if(n>t)throw new ze(2307,!1);let r=e.digits,o=r.length-e.integerLen,s=Math.min(Math.max(n,o),t),i=s+e.integerLen,a=r[i];if(i>0){r.splice(Math.max(e.integerLen,i));for(let p=i;p<r.length;p++)r[p]=0}else{o=Math.max(0,o),e.integerLen=1,r.length=Math.max(1,i=s+1),r[0]=0;for(let p=1;p<i;p++)r[p]=0}if(a>=5)if(i-1<0){for(let p=0;p>i;p--)r.unshift(0),e.integerLen++;r.unshift(1),e.integerLen++}else r[i-1]++;for(;o<Math.max(0,s);o++)r.push(0);let c=s!==0,l=n+e.integerLen,u=r.reduceRight(function(p,d,f,m){return d=d+p,m[f]=d<10?d:d-10,c&&(m[f]===0&&f>=l?m.pop():c=!1),d>=10?1:0},0);u&&(r.unshift(u),e.integerLen++)}function PI(e){let n=parseInt(e);if(isNaN(n))throw new ze(2305,!1);return n}var BI=(()=>{class e{_viewContainer;_context=new Wx;_thenTemplateRef=null;_elseTemplateRef=null;_thenViewRef=null;_elseViewRef=null;constructor(t,r){this._viewContainer=t,this._thenTemplateRef=r}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){p2(t,!1),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){p2(t,!1),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngIfUseIfTypeGuard;static ngTemplateGuard_ngIf;static ngTemplateContextGuard(t,r){return!0}static \u0275fac=function(r){return new(r||e)(Nn(yc),Nn(ii))};static \u0275dir=Ox({type:e,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}})}return e})(),Wx=class{$implicit=null;ngIf=null};function p2(e,n){if(e&&!e.createEmbeddedView)throw new ze(2020,!1)}function lX(e,n){return new ze(2100,!1)}var VI=(()=>{class e{_locale;constructor(t){this._locale=t}transform(t,r,o){if(!uX(t))return null;o||=this._locale;try{let s=pX(t);return f2(s,o,r)}catch(s){throw lX(e,s.message)}}static \u0275fac=function(r){return new(r||e)(Nn(em,16))};static \u0275pipe=qf({name:"number",type:e,pure:!0})}return e})();function uX(e){return!(e==null||e===""||e!==e)}function pX(e){if(typeof e=="string"&&!isNaN(Number(e)-parseFloat(e)))return Number(e);if(typeof e!="number")throw new ze(2309,!1);return e}var UI=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275mod=Fx({type:e});static \u0275inj=yf({})}return e})();function dX(e,n){n=encodeURIComponent(n);for(let t of e.split(";")){let r=t.indexOf("="),[o,s]=r==-1?[t,""]:[t.slice(0,r),t.slice(r+1)];if(o.trim()===n)return decodeURIComponent(s)}return null}var zI=class{};var R1e="browser";T();T();T();function X(e,n){Array.isArray(e)||(e=[e]),e.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${n} does not support complex64 tensors in the CPU backend.`)})}var Dre=sn.whereImpl,fB=(()=>{class e extends Mo{nextDataId(){return e.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new di(this,Tr())}write(t,r,o){this.firstUse&&(this.firstUse=!1,M().get("IS_NODE")&&S.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:o,refCount:1}),s}makeTensorInfo(t,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&y.isString(o[0])){let i=o.map(a=>y.encodeString(a));s=this.write(i,t,r)}else s=this.write(o,t,r);return{dataId:s,shape:t,dtype:r}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let r=this.data.get(t);r.refCount++}decRef(t){if(this.data.has(t)){let r=this.data.get(t);r.refCount--}}move(t,r,o,s,i){this.data.set(t,{values:r,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:r,complexTensorInfos:o}=this.data.get(t);if(r==="complex64"){let s=this.readSync(o.real.dataId),i=this.readSync(o.imag.dataId);return S.mergeRealAndImagArrays(s,i)}return y.convertBackendValuesAndArrayBuffer(this.data.get(t).values,r)}bufferSync(t){let r=this.readSync(t.dataId);if(t.dtype==="string")try{let o=r.map(s=>y.decodeString(s));return le(t.shape,t.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return le(t.shape,t.dtype,r)}makeOutput(t,r,o){return Tr().makeTensorFromTensorInfo(this.makeTensorInfo(r,o,t),this)}disposeData(t,r=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!r&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:o}=this.data.get(t);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let r=y.now();return t(),{kernelMs:y.now()-r}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){X([t],"where");let r=this.readSync(t.dataId);return Dre(t.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return e.nextDataId=0,e})();var SD={};He(SD,{addImpl:()=>QN,bincountImpl:()=>Dd,bincountReduceImpl:()=>dv,bitwiseAndImpl:()=>JN,castImpl:()=>ZN,ceilImpl:()=>eD,concatImpl:()=>fv,equalImpl:()=>tD,expImpl:()=>rD,expm1Impl:()=>sD,floorDivImpl:()=>aD,floorImpl:()=>iD,gatherNdImpl:()=>mv,gatherV2Impl:()=>hv,greaterEqualImpl:()=>lD,greaterImpl:()=>cD,lessEqualImpl:()=>pD,lessImpl:()=>uD,linSpaceImpl:()=>gv,logImpl:()=>dD,maxImpl:()=>xv,maximumImpl:()=>fD,minimumImpl:()=>mD,multiplyImpl:()=>Th,negImpl:()=>hD,notEqualImpl:()=>gD,prodImpl:()=>xD,raggedGatherImpl:()=>yv,raggedRangeImpl:()=>vv,raggedTensorToTensorImpl:()=>bv,rangeImpl:()=>Cv,rsqrtImpl:()=>vD,scatterImpl:()=>vo,sigmoidImpl:()=>HB,simpleAbsImpl:()=>YN,sliceImpl:()=>CD,sparseFillEmptyRowsImpl:()=>wv,sparseReshapeImpl:()=>Iv,sparseSegmentReductionImpl:()=>_d,sqrtImpl:()=>qB,squaredDifferenceImpl:()=>wD,staticRegexReplaceImpl:()=>ID,stridedSliceImpl:()=>Ev,stringNGramsImpl:()=>Tv,stringSplitImpl:()=>Sv,stringToHashBucketFastImpl:()=>Nv,subImpl:()=>TD,tileImpl:()=>Dv,topKImpl:()=>kv,transposeImpl:()=>kd,uniqueImpl:()=>_v});T();function YN(e){let n=new Float32Array(e.length);for(let t=0;t<e.length;++t)n[t]=Math.abs(e[t]);return n}var kre=e=>{let{x:n}=e.inputs,t=e.backend;X(n,"abs");let r=new Float32Array(y.sizeFromShape(n.shape)),o=t.data.get(n.dataId).values;return r=YN(o),t.makeOutput(r,n.shape,n.dtype)},mB={kernelName:"Abs",backendName:"cpu",kernelFunc:kre};T();T();function Ae(e){return(n,t,r,o,s)=>{let i=S.assertAndGetBroadcastShape(n,t),a=i.length,c=y.computeStrides(i),l=y.sizeFromShape(i),u=y.getTypedArrayFromDType(s,l),p=n.length,d=t.length,f=y.computeStrides(n),m=y.computeStrides(t),h=S.getBroadcastDims(n,i),g=S.getBroadcastDims(t,i);if(h.length+g.length===0)for(let x=0;x<u.length;++x)u[x]=e(r[x%r.length],o[x%o.length]);else for(let x=0;x<u.length;++x){let v=y.indexToLoc(x,a,c),w=v.slice(-p);h.forEach(R=>w[R]=0);let I=y.locToIndex(w,p,f),_=v.slice(-d);g.forEach(R=>_[R]=0);let A=y.locToIndex(_,d,m);u[x]=e(r[I],o[A])}return[u,i]}}T();T();T();T();function Gt(e){let{inputs:n,backend:t}=e,{real:r,imag:o}=n,s=t.data.get(r.dataId).values,i=t.data.get(o.dataId).values,a=t.makeTensorInfo(r.shape,"complex64"),c=t.data.get(a.dataId);return c.complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",s),imag:t.makeTensorInfo(o.shape,"float32",i)},a}var hB={kernelName:Oc,backendName:"cpu",kernelFunc:Gt};function Sd(e,n,t="float32"){if(t==="complex64"){let o=Sd(e,n,"float32"),s=Sd(e,n,"float32");return Gt({inputs:{real:o,imag:s},backend:e})}let r=y.makeZerosTypedArray(y.sizeFromShape(n),t);return e.makeTensorInfo(n,t,r)}T();function mn(e){let{inputs:n,backend:t}=e,{x:r}=n;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var gB={kernelName:ms,backendName:"cpu",kernelFunc:mn};T();function zr(e){let{inputs:n,backend:t}=e,{input:r}=n,o=t.data.get(r.dataId).complexTensorInfos.real,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var xB={kernelName:Ml,backendName:"cpu",kernelFunc:zr};function ZN(e,n,t,r){if(r==="int32"){let o=Int32Array.from(e);return[n,"int32",o]}if(r==="bool"){let o=y.toTypedArray([0],t),[s,i]=Ae((a,c)=>a!==c?1:0)(n,[],e,o,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}function Gr(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return mn({inputs:{x:o},backend:t});let u=Sd(t,o.shape,o.dtype),p=Gr({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),d=Gt({inputs:{real:p,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(p),d}if(o.dtype==="complex64"){let u=zr({inputs:{input:o},backend:t}),p=Gr({inputs:{x:u},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(u),p}if(!y.hasEncodingLoss(o.dtype,s)){let u=mn({inputs:{x:o},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:s}}let i=t.data.get(o.dataId).values,[a,c,l]=ZN(i,o.shape,o.dtype,s);return t.makeTensorInfo(a,c,l)}var yB={kernelName:fs,backendName:"cpu",kernelFunc:Gr};function Ge(e,n,t,r){return t==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,c=s;X([i,a],e);let l=c.data.get(i.dataId).values,u=c.data.get(a.dataId).values,p=i.dtype==="string"?S.fromUint8ToStringArray(l):l,d=i.dtype==="string"?S.fromUint8ToStringArray(u):u,f=r||i.dtype,[m,h]=n(i.shape,a.shape,p,d,f);return c.makeTensorInfo(h,f,m)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,c=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let l=Gr({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),u=c.data.get(l.dataId),p=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,f=c.data.get(p.dataId).values,m=c.data.get(d.dataId).values,h=Gr({inputs:{x:a},backend:c,attrs:{dtype:"complex64"}}),g=c.data.get(h.dataId),x=g.complexTensorInfos.real,v=g.complexTensorInfos.imag,w=c.data.get(x.dataId).values,I=c.data.get(v.dataId).values,[_,A,R]=t(i.shape,a.shape,f,m,w,I),F=c.makeTensorInfo(R,"float32",_),P=c.makeTensorInfo(R,"float32",A),L=Gt({inputs:{real:F,imag:P},backend:c});return c.disposeIntermediateTensorInfo(l),c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(F),c.disposeIntermediateTensorInfo(P),L}else{let l=c.data.get(i.dataId).values,u=c.data.get(a.dataId).values,p=r||i.dtype,[d,f]=n(i.shape,a.shape,l,u,p);return c.makeTensorInfo(f,p,d)}}}function Nd(e){return(n,t,r,o,s,i)=>{let a=S.assertAndGetBroadcastShape(n,t),c=y.sizeFromShape(a),l=a.length,u=y.computeStrides(a),p=y.getTypedArrayFromDType("float32",c),d=y.getTypedArrayFromDType("float32",c),f=S.getBroadcastDims(n,a),m=S.getBroadcastDims(t,a),h=S.mergeRealAndImagArrays(r,o),g=S.mergeRealAndImagArrays(s,i),x=n.length,v=y.computeStrides(n),w=t.length,I=y.computeStrides(t);if(f.length+m.length===0)for(let _=0;_<p.length;_++){let A=_%h.length,R=_%g.length,F=e(h[A*2],h[A*2+1],g[R*2],g[R*2+1]);p[_]=F.real,d[_]=F.imag}else for(let _=0;_<p.length;_++){let A=y.indexToLoc(_,l,u),R=A.slice(-x);f.forEach(z=>R[z]=0);let F=y.locToIndex(R,x,v),P=A.slice(-w);m.forEach(z=>P[z]=0);let L=y.locToIndex(P,w,I),V=e(h[F*2],h[F*2+1],g[L*2],g[L*2+1]);p[_]=V.real,d[_]=V.imag}return[p,d,a]}}var QN=Ae((e,n)=>e+n),_re=Nd((e,n,t,r)=>({real:e+t,imag:n+r})),Yo=Ge("Add",QN,_re),vB={kernelName:"Add",backendName:"cpu",kernelFunc:Yo};T();function Dd(e,n,t,r,o){let s=y.sizeFromShape(r),i=y.makeZerosTypedArray(o,t);for(let a=0;a<e.length;a++){let c=e[a];if(c<0)throw new Error("Input x must be non-negative!");c>=o||(s>0?i[c]+=n[a]:i[c]+=1)}return i}function dv(e,n,t,r=!1){let o=e.shape[0],s=e.shape[1],i=le([o,t],n.dtype);for(let a=0;a<o;a++)for(let c=0;c<s;c++){let l=e.get(a,c);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(r?i.set(1,a,l):n.size>0?i.set(i.get(a,l)+n.get(a,c),a,l):i.set(i.get(a,l)+1,a,l))}return i}T();var JN=Ae((e,n)=>e&n),Are=Ge(wi,JN),bB={kernelName:wi,backendName:"cpu",kernelFunc:Are};T();T();function Jt(e){return(n,t,r)=>{let o=y.getArrayFromDType(t,n.length);for(let s=0;s<n.length;++s)o[s]=e(n[s],r);return o}}T();function he(e,n,t){let r=Jt(n);return Gn(e,r,t)}function Gn(e,n,t){return({inputs:r,attrs:o,backend:s})=>{let{x:i}=r;X(i,e);let a=s,c=a.data.get(i.dataId).values,l;if(i.dtype==="string"){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");l=S.fromUint8ToStringArray(c)}else l=c;let u=t||i.dtype,p=n(l,u,o);return a.makeTensorInfo(i.shape,u,p)}}var eD=Jt(e=>Math.ceil(e)),Rre=Gn(Ii,eD),CB={kernelName:Ii,backendName:"cpu",kernelFunc:Rre};T();function fv(e,n,t,r){let o=y.getArrayFromDType(t,y.sizeFromShape(n));if(r&&t!=="string"){let s=0;e.forEach(i=>{let a=y.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;e.forEach(i=>{let a=t==="string"?S.fromUint8ToStringArray(i.vals):i.vals,c=0;for(let l=0;l<i.shape[0];++l){let u=l*n[1]+s;for(let p=0;p<i.shape[1];++p)o[u+p]=a[c++]}s+=i.shape[1]})}return o}T();var tD=Ae((e,n)=>e===n?1:0),nD=Ge(Ni,tD,null,"bool"),wB={kernelName:Ni,backendName:"cpu",kernelFunc:nD};T();var rD=Jt(e=>Math.exp(e)),oD=Gn("Exp",rD,"float32"),IB={kernelName:"Exp",backendName:"cpu",kernelFunc:oD};T();var sD=Jt(e=>Math.expm1(e)),Fre=Gn(Di,sD),EB={kernelName:Di,backendName:"cpu",kernelFunc:Fre};T();var iD=Jt(e=>Math.floor(e)),Ore=Gn(ki,iD),TB={kernelName:ki,backendName:"cpu",kernelFunc:Ore};T();var aD=Ae((e,n)=>Math.floor(e/n)),Mre=Ge(_i,aD,null,"int32"),SB={kernelName:_i,backendName:"cpu",kernelFunc:Mre};T();function mv(e,n,t,r,o,s,i,a,c){let l=le([r,s],t);for(let u=0;u<r;u++){let p=[],d=0;for(let f=0;f<o;f++){let m=e[u*o+f];d+=m*i[f],p.push(m)}if(d<0||d>=c/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let f=0;f<s;f++)l.values[u*s+f]=n.get(...n.indexToLoc(d*s+f))}return l}T();function hv(e,n,t){let r=le(t,e.dtype);for(let o=0;o<r.size;++o){let i=r.indexToLoc(o).slice(),a=i[0],c=i[2],l=n.locToIndex([a,c]);i[2]=n.values[l];let u=e.locToIndex(i);0<=u&&u<e.values.length&&(r.values[o]=e.values[u])}return r}T();var cD=Ae((e,n)=>e>n?1:0),$re=Ge(Ai,cD,null,"bool"),NB={kernelName:Ai,backendName:"cpu",kernelFunc:$re};T();var lD=Ae((e,n)=>e>=n?1:0),Pre=Ge(Ri,lD,null,"bool"),DB={kernelName:Ri,backendName:"cpu",kernelFunc:Pre};T();var uD=Ae((e,n)=>e<n?1:0),Lre=Ge($i,uD,null,"bool"),kB={kernelName:$i,backendName:"cpu",kernelFunc:Lre};T();var pD=Ae((e,n)=>e<=n?1:0),Bre=Ge(Pi,pD,null,"bool"),_B={kernelName:Pi,backendName:"cpu",kernelFunc:Bre};T();function gv(e,n,t){let r=(n-e)/(t-1),o=y.makeZerosTypedArray(t,"float32");o[0]=e;for(let s=1;s<o.length;s++)o[s]=o[s-1]+r;return o}T();var dD=Jt(e=>Math.log(e)),Vre=Gn("Log",dD),AB={kernelName:"Log",backendName:"cpu",kernelFunc:Vre};T();function xv(e,n,t,r){let o=y.getTypedArrayFromDType(r,y.sizeFromShape(t));for(let s=0;s<o.length;++s){let i=s*n,a=e[i];for(let c=0;c<n;++c){let l=e[i+c];(Number.isNaN(l)||l>a)&&(a=l)}o[s]=a}return o}T();var fD=Ae((e,n)=>Math.max(e,n)),Ure=Ge(zi,fD),RB={kernelName:zi,backendName:"cpu",kernelFunc:Ure};T();var mD=Ae((e,n)=>Math.min(e,n)),zre=Ge(Gi,mD),FB={kernelName:Gi,backendName:"cpu",kernelFunc:zre};T();var Th=Ae((e,n)=>e*n),Gre=Nd((e,n,t,r)=>({real:e*t-n*r,imag:e*r+n*t})),Gu=Ge(Hi,Th,Gre),OB={kernelName:Hi,backendName:"cpu",kernelFunc:Gu};T();function hD(e,n,t){let r=y.createScalarValue(-1,t);return Th([],n,r,e,t)}function Hre(e){let{inputs:n,backend:t}=e,{x:r}=n;X(r,"neg");let o=t.data.get(r.dataId).values,[s,i]=hD(o,r.shape,r.dtype);return t.makeTensorInfo(i,r.dtype,s)}var MB={kernelName:"Neg",backendName:"cpu",kernelFunc:Hre};T();var gD=Ae((e,n)=>e!==n?1:0),Wre=Ge(Wi,gD,null,"bool"),$B={kernelName:Wi,backendName:"cpu",kernelFunc:Wre};T();T();T();function kd(e,n,t,r,o){let s=n.length,i=y.sizeFromShape(n),a=y.computeStrides(n),c=y.computeStrides(o),l=y.getTypedArrayFromDType(t,y.sizeFromShape(o));for(let u=0;u<i;++u){let p=y.indexToLoc(u,s,a),d=new Array(p.length);for(let m=0;m<d.length;m++)d[m]=p[r[m]];let f=y.locToIndex(d,s,c);l[f]=e[u]}return l}function Ct(e){let{inputs:n,attrs:t,backend:r}=e,{x:o}=n,{perm:s}=t;X(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let c=r.data.get(o.dataId).values,l=kd(c,o.shape,o.dtype,s,a);return{dataId:r.write(l,a,o.dtype),shape:a,dtype:o.dtype}}var PB={kernelName:gs,backendName:"cpu",kernelFunc:Ct};function xD(e,n,t,r){let[o,s]=S.computeOutAndReduceShapes(e,r),i=Mt(n,"int32"),a=y.makeZerosTypedArray(y.sizeFromShape(o),i),c=y.sizeFromShape(s);for(let l=0;l<a.length;++l){let u=l*c,p=1;for(let d=0;d<c;++d)p*=t[u+d];a[l]=p}return{outVals:a,outShape:o,outDtype:i}}function jre(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r;X(o,"prod");let a=o.shape.length,c=y.parseAxisParam(s,o.shape),l=S.getAxesPermutation(c,a),u=c,p=o,d=[];l!=null&&(p=Ct({inputs:{x:o},backend:t,attrs:{perm:l}}),d.push(p),u=S.getInnerMostAxes(u.length,a));let f=t.data.get(p.dataId).values,{outVals:m,outShape:h,outDtype:g}=xD(p.shape,p.dtype,f,u),x=h;return i&&(x=S.expandShapeToKeepDim(h,c)),d.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(x,g,m)}var LB={kernelName:_l,backendName:"cpu",kernelFunc:jre};T();function qre(e,n,t){e.forEach((r,o)=>{if(r<0||r>=t){let s=y.indexToLoc(o,n.length,y.computeStrides(n)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${t})`)}})}function Kre(e,n){for(let t=0;t<e.length;++t){let r=e[t],o=t===e.length-1?n:e[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>o)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function Xre(e,n,t,r){let o=[],s=0,i=n.length-1+t.length,a=new Array(i).fill(null).map(()=>[0]);Kre(t,r);let c=1;for(let l=0;l<n.length-1;++l){c*=n[l];let u=n[l+1];for(let p=1;p<c+1;++p)a[l].push(p*u)}for(let l=0;l<e.length;++l){let u=e[l],p=e[l]+1;for(let d=0;d<t.length;++d){let f=t[d],m=d+n.length-1;if(m>=0){let h=a[m],g=h[h.length-1]-f[u];for(let x=u;x<p;++x)a[m].push(f[x+1]+g)}u=f[u],p=f[p]}p!==u&&(o.push([u,p]),s+=p-u)}return{outSplits:a,valueSlices:o,numValues:s}}function Yre(e){let n=[];for(let t=0;t<e.length;++t){let r=e[t].length,o=y.getArrayFromDType("int32",r);n.push(o),e[t].forEach((s,i)=>o[i]=s)}return n}function BB(e,n){let t=e.slice(0,n);for(;t.length<n;)t.push(1);for(let r=n;r<e.length;r++)t[n-1]*=e[r];return t}function Zre(e,n,t,r,o,s){let i=BB(n,2)[1],a=BB(s,2)[1],c=0;for(let l of t)for(let u=l[0];u<l[1];++u){for(let p=0;p<r;++p)o[c*a+p]=e[u*i+p];++c}}function Qre(e,n,t,r,o){let s=n.slice();s[0]=o;let i=y.getArrayFromDType(t,y.sizeFromShape(s)),a=e.length,c=a===0?0:a/n[0];return Zre(e,n,r,c,i,s),[i,s]}function yv(e,n,t,r,o,s,i,a){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(n[0].length===0)throw new Error("Split tensors must not be scalars");let c=n[0][0]-1;if(qre(s,i,c),r.length===0)throw new Error("params.rank must be nonzero");let l=r[0],{outSplits:u,valueSlices:p,numValues:d}=Xre(s,i,e,l),f=Yre(u),m=Qre(t,r,o,p,d);return[f,m[0],m[1]]}T();var VB=2147483647;function vv(e,n,t,r,o,s,i){if(n.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let a=n.length===0,c=o.length===0,l=i.length===0,u=[];a||u.push(n[0]),c||u.push(o[0]),l||u.push(i[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");let p=u.length===0?1:u[0],d=y.getArrayFromDType("int32",p+1);d[0]=0;for(let g=0;g<p;++g){let x=a?e[0]:e[g],v=c?r[0]:r[g],w=l?s[0]:s[g];if(w===0)throw new Error("Requires delta != 0");let I;if(w>0&&v<x||w<0&&v>x)I=0;else if(I=Math.ceil(Math.abs((v-x)/w)),I>VB)throw new Error(`Requires ((limit - start) / delta) <= ${VB}`);d[g+1]=d[g]+I}let f=d[p],m=y.getArrayFromDType(t,f),h=0;for(let g=0;g<p;++g){let x=d[g+1]-d[g],v=a?e[0]:e[g],w=l?s[0]:s[g];for(let I=0;I<x;++I)m[h++]=v,v+=w}return[d,m]}T();var Hr=S.RowPartitionType,yD=class e{constructor(n,t,r,o,s,i,a,c,l,u){this.shape=n,this.shapeShape=t,this.values=r,this.valuesShape=o,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=c,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=S.getRowPartitionTypesHelper(u),this.raggedRank=S.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(n){return this.rowPartitionTypes[0]===Hr.FIRST_DIM_SIZE?this.rowPartitionTypes[n+1]:this.rowPartitionTypes[n]}getRowPartitionTensor(n){return this.rowPartitionTypes[0]===Hr.FIRST_DIM_SIZE?this.rowPartitionValues[n+1]:this.rowPartitionValues[n]}getMaxWidth(n){let t=this.getRowPartitionTensor(n-1);switch(this.getRowPartitionTypeByDimension(n-1)){case Hr.VALUE_ROWIDS:return e.getMaxWidthValueRowID(t);case Hr.ROW_SPLITS:return e.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Hr[this.getRowPartitionTypeByDimension(n-1)]}`)}}static getMaxWidthRowSplit(n){let t=n.length;if(t===0||t===1)return 0;let r=0;for(let o=0;o<t-1;++o){let s=n[o+1]-n[o];s>r&&(r=s)}return r}static getMaxWidthValueRowID(n){let t=n.length;if(t===0)return 0;let r=0,o=n[0],s=0;for(let i=1;i<t;++i){let a=n[i];a!==o&&(o=a,s=Math.max(i-r,s),r=i)}return Math.max(t-r,s)}tensorShapeFromTensor(n,t,r=!0){if(t.length===0){if(n[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return zB(n,r)}calculateOutputSize(n){let t=this.valuesShape,r=this.defaultValueShape;S.validateDefaultValueShape(r,t);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=S.combineRaggedTensorToTensorShapes(this.raggedRank,o,t);i[0]<0&&(i[0]=n);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(n,t,r){let o=Math.min(n,r),s=[],i=0;for(let a=0;a<o;++a,i+=t)s.push(i);for(let a=o;a<n;++a)s.push(-1);return y.assert(s.length===n,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(n,t,r,o){let s=n.length,i=[];for(let a=0;a<s-1;++a){let c=n[a+1]-n[a],l=Math.min(o,c),u=t[a];u===-1&&(l=0);for(let p=0;p<l;++p)i.push(u),u+=r;for(let p=0;p<c-l;++p)i.push(-1)}if(s>0&&i.length!==n[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(n,t,r,o){let s=n.length,i=[];if(s===0)return[];let a=0,c=n[0];if(c>=t.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${t.length}`);let l=t[c];i.push(l);for(let u=1;u<s;++u){let p=n[u];if(p===c)l>=0&&(++a,a<o?l+=r:l=-1);else{if(a=0,c=p,p>=t.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${t.length}`);l=t[p]}i.push(l)}if(i.length!==n.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(n,t,r,o){let s=this.getRowPartitionTensor(n),i=this.getRowPartitionTypeByDimension(n);switch(i){case Hr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,r,o);case Hr.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,r,o);default:throw new Error(`Unsupported partition type: ${Hr[i]}`)}}getFirstDimensionSize(){let n=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case Hr.FIRST_DIM_SIZE:return n[0];case Hr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Hr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Hr[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let c=o.length-2;c>=0;--c)o[c]=o[c+1]*r[c+1];let s=zB(r,!1),i=y.getArrayFromDType(this.valuesDType,y.sizeFromShape(s));if(o[0]*r[0]>0){let c=this.calculateFirstParentOutputIndex(t,o[0],r[0]);for(let l=1;l<=this.raggedRank;++l)c=this.calculateOutputIndex(l-1,c,o[l],r[l]);this.setOutput(this.raggedRank,c,i,s)}return[s,i]}setOutput(n,t,r,o){if(r.length===0)return;let s=this.values,i=r,a=o.slice();a=a.slice(n+1);let c=y.sizeFromShape(a),l=t.length,u=this.defaultValue;if(u.length!==c&&u.length!==1){let m=this.defaultValueShape;Ce(()=>{let h=U(u,m);u=Ts(h,a).dataSync()})}let p=0,d=0,f=0;for(let m=0;m<=l;++m){let h=m<l?t[m]:-1;if(h===f){++f;continue}if(d<f){let g=s.subarray(p*c),x=i.subarray(d*c),v=(f-d)*c;UB(x,g,v)}if(m>=l){let g=r.length;h=Math.floor(g/c)}if(h>f)if(this.defaultValue.length===1)i.subarray(f*c,h*c).fill(this.defaultValue[0]),f=h;else for(;h>f;){let g=i.slice(f*c);UB(g,u,c),++f}h<0?(p=m+1,d=f):(p=m,d=f,f=d+1)}}};function UB(e,n,t){for(let r=0;r<t;r++)e[r]=n[r]}function zB(e,n){let t=[];for(let r of e){if(r<0){if(!n)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function bv(e,n,t,r,o,s,i,a,c,l){return new yD(e,n,t,r,o,s,i,a,c,l).compute()}T();function Cv(e,n,t,r){let o=e===n,s=e<n&&t<0,i=n<e&&t>1;if(o||s||i)return y.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((n-e)/t)),c=y.makeZerosTypedArray(a,r);n<e&&t===1&&(t=-1),c[0]=e;for(let l=1;l<c.length;l++)c[l]=c[l-1]+t;return c}T();var vD=Jt(e=>1/Math.sqrt(e)),Jre=Gn(Yi,vD),GB={kernelName:Yi,backendName:"cpu",kernelFunc:Jre};T();function vo(e,n,t,r,o,s,i,a,c,l){let u=[r/o,o],p=e.values,d=n.values;if(r===0)return le(t,n.dtype);let f=c instanceof Ke?c:le(u,n.dtype);typeof c=="string"||typeof c=="number"?f.values.fill(c):typeof c=="boolean"&&f.values.fill(+c);for(let m=0;m<s;m++){let h=[],g=0;for(let x=0;x<i;x++){let v=p[m*i+x];h.push(v),g+=v*a[x]}if(g<0||g>=r/o)throw new Error(`Invalid indices: ${h} does not index into ${t}`);for(let x=0;x<o;x++)l?f.values[g*o+x]+=d[m*o+x]:f.values[g*o+x]=n.rank===0?d[0]:d[m*o+x]}return f}T();var HB=Jt(e=>1/(1+Math.exp(-e))),bD=he(ea,e=>1/(1+Math.exp(-e))),WB={kernelName:ea,backendName:"cpu",kernelFunc:bD};T();function CD(e,n,t,r,o){let s=zt.isSliceContinous(r,n,t),i=y.sizeFromShape(t),a=y.computeStrides(r);if(s){let p=zt.computeFlatOffset(n,a);return o==="string"?e.slice(p,p+i):e.subarray(p,p+i)}let c=o==="string"?S.fromUint8ToStringArray(e):e,l=le(r,o,c),u=le(t,o);for(let p=0;p<u.size;++p){let d=u.indexToLoc(p),f=d.map((m,h)=>m+n[h]);u.set(l.get(...f),...d)}return o==="string"?S.fromStringArrayToUint8(u.values):u.values}function Wr(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{begin:s,size:i}=r;X(o,"slice");let[a,c]=zt.parseSliceParams(o,s,i);zt.assertParamsValid(o,a,c);let l=t.data.get(o.dataId).values,u=CD(l,a,c,o.shape,o.dtype);return t.makeTensorInfo(c,o.dtype,u)}var jB={kernelName:Hl,backendName:"cpu",kernelFunc:Wr};T();function wv(e,n,t,r,o,s,i){let a=n[0],c=s[0],l=new Array(c),u=new Array(a),p=n[1];if(c===0){if(a!==0)throw new Error(S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let g=y.getArrayFromDType(t,0),x=y.getArrayFromDType(o,0);return[g,[0,p],x,l,u]}let d=!0,f=0,m=new Array(c).fill(0);for(let g=0;g<a;++g){let x=e[g*p];if(x<0)throw new Error(S.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,x));if(x>=c)throw new Error(S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,x,c));++m[x],d=d&&x>=f,f=x}let h=!0;for(let g=0;g<c;++g){let x=m[g]===0;l[g]=x,h=h&&!x,m[g]=Math.max(m[g],1),g>0&&(m[g]+=m[g-1])}if(h&&d){let g=e,x=r;for(let v=0;v<a;++v)u[v]=v;return[g,[a,p],x,l,u]}else{let g=m[c-1],x=y.getArrayFromDType(t,g*p),v=y.getArrayFromDType(o,g),w=new Array(c).fill(0);for(let I=0;I<a;++I){let _=e[I*p],A=w[_],R=(_===0?0:m[_-1])+A;w[_]++;for(let F=0;F<p;++F)x[R*p+F]=e[I*p+F];v[R]=r[I],u[I]=R}for(let I=0;I<c;++I)if(w[I]===0){let A=I===0?0:m[I-1];x[A*p+0]=I;for(let R=1;R<p;++R)x[A*p+R]=0;v[A]=i}return[x,[g,p],v,l,u]}}T();function Iv(e,n,t,r,o){let s=y.sizeFromShape(r),i=n[0],a=o.length,c=[],l=1,u=-1;for(let g=0;g<a;++g){let x=o[g];if(x===-1){if(u!==-1)throw new Error(S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,g));u=g,c.push(1)}else{if(x<0)throw new Error(S.getSparseReshapeNegativeOutputDimErrorMessage(g,x));l*=x,c.push(x)}}if(u!==-1){if(l<=0)throw new Error(S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/l);if(l*g!==s)throw new Error(S.getSparseReshapeInputOutputMultipleErrorMessage(r,c));c[u]=g}if(y.sizeFromShape(c)!==s)throw new Error(S.getSparseReshapeInputOutputMismatchErrorMessage(r,c));let d=r.length,f=[];if(d>0){f[d-1]=1;for(let g=d-2;g>=0;--g)f[g]=f[g+1]*r[g+1]}let m=[];if(a>0){m[a-1]=1;for(let g=a-2;g>=0;--g)m[g]=m[g+1]*c[g+1]}let h=y.getArrayFromDType(t,i*a);for(let g=0;g<i;++g){let x=0;for(let v=0;v<d;++v)x+=e[g*d+v]*f[v];for(let v=0;v<a;++v)h[g*a+v]=Math.trunc(x/m[v]),x%=m[v]}return[h,[i,a],c]}T();function _d(e,n,t,r,o,s=!1,i=0){let a=r.length,c=[n[0],e.length/n[0]],l=c[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=n.slice();d[0]=p;let f=d.reduce((w,I)=>w*I,1),m=y.getArrayFromDType(t,f);if(a===0)return p>0&&m.fill(i),[m,d];if(p<=0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,x=0,v=o[h];for(;;){let w=0;if(g<a){if(w=o[g],v===w){++g;continue}if(v>=w)throw new Error(S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(v<0||v>=p)throw new Error(S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v,p));v>x&&m.fill(i,x*l,v*l);for(let I=h;I<g;++I){let _=r[I];if(_<0||_>=c[0])throw new Error(S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(I,r[I],c[0]));for(let A=0;A<l;A++)m[v*l+A]+=e[_*l+A]}if(s)for(let I=0;I<l;I++)m[v*l+I]/=g-h;if(h=g,++g,x=v+1,v=w,g>a)break}return x<p&&m.fill(i,x*l,p*l),[m,d]}T();var qB=Jt(e=>Math.sqrt(e)),eoe=he(na,e=>Math.sqrt(e)),KB={kernelName:na,backendName:"cpu",kernelFunc:eoe};T();var wD=Ae((e,n)=>{let t=e-n;return t*t}),toe=Ge(ra,wD),XB={kernelName:ra,backendName:"cpu",kernelFunc:toe};T();var ID=Jt((e,n)=>{let{pattern:t,replaceGlobal:r,rewrite:o}=n;return e.replace(new RegExp(t,r?"g":""),o)}),noe=Gn(oa,ID),YB={kernelName:oa,backendName:"cpu",kernelFunc:noe};T();function Ev(e,n,t,r){let o=le(e,n.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let c=0;c<a.length;c++)a[c]=i[c]*t[c]+r[c];o.set(n.get(...a),...i)}return o}T();var ED=class{constructor(n,t,r,o,s,i){this.separator=y.encodeString(n),this.nGramWidths=t,this.leftPad=y.encodeString(r),this.rightPad=y.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(n){return Math.min(this.padWidth<0?n-1:this.padWidth,n-1)}getNumNGrams(n,t){let r=this.getPadWidth(t);return Math.max(0,n+2*r-t+1)}createNGrams(n,t,r,o,s,i){for(let a=0;a<s;++a){let c=this.getPadWidth(i),l=Math.max(0,c-a),u=Math.max(0,c-(s-(a+1))),p=i-(l+u),d=t+(l>0?0:a-c),f=0;f+=l*this.leftPad.length;for(let v=0;v<p;++v)f+=n[d+v].length;f+=u*this.rightPad.length;let m=l+u+p-1;f+=m*this.separator.length,r[o+a]=new Uint8Array(f);let h=r[o+a],g=0,x=v=>v.forEach(w=>h[g++]=w);for(let v=0;v<l;++v)x(this.leftPad),x(this.separator);for(let v=0;v<p-1;++v)x(n[d+v]),x(this.separator);if(p>0){x(n[d+p-1]);for(let v=0;v<u;++v)x(this.separator),x(this.rightPad)}else{for(let v=0;v<u-1;++v)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(n,t){let r=n.length,o=t.length;if(o>0){let c=t[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let l=1;l<o;++l){let u=t[l]>=c;if(u=u&&t[l]<=r,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${c}, ${r}]`);c=t[l]}if(c!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${c}`)}let s=o-1,i=y.getArrayFromDType("int32",o);if(r===0||o===0){let c=new Array(r);for(let l=0;l<=s;++l)i[l]=0;return[c,i]}i[0]=0;for(let c=1;c<=s;++c){let l=t[c]-t[c-1],u=0;this.nGramWidths.forEach(p=>{u+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&u===0&&(u=1),i[c]=i[c-1]+u}let a=new Array(i[s]);for(let c=0;c<s;++c){let l=t[c],u=i[c];if(this.nGramWidths.forEach(p=>{let d=t[c+1]-t[c],f=this.getNumNGrams(d,p);this.createNGrams(n,l,a,u,f,p),u+=f}),this.preserveShort&&u===i[c]){let p=t[c+1]-t[c];if(p===0)continue;let d=p+2*this.padWidth;this.createNGrams(n,l,a,u,1,d)}}return[a,i]}};function Tv(e,n,t,r,o,s,i,a){return new ED(t,r,o,s,i,a).compute(e,n)}T();function roe(e,n,t,r){if(!e.length)return;if(n.length===0){for(let s=0;s<e.length;++s)r.push(e.subarray(s,s+1));return}if(n.length===1){let s=n[0],i=e.indexOf(s);for(;i!==-1;){let a=e.subarray(0,i);(!t||a.length!==0)&&r.push(a),e=e.subarray(i+1),i=e.indexOf(s)}(!t||e.length!==0)&&r.push(e);return}let o=0;for(let s=0;s<e.length+1;s++)if(s===e.length||n.indexOf(e[s])!==-1){let i=e.subarray(o,s);(!t||i.length!==0)&&r.push(i),o=s+1}}function Sv(e,n,t){let r=e.length,o=[],s=0,i=0,a=new Array(r);for(let d=0;d<r;++d){let f=o.length;roe(e[d],n,t,o);let m=o.length-f;a[d]=m,s+=m,i=Math.max(i,m)}let c=y.getArrayFromDType("int32",s*2),l=new Array(s),u=[r,i],p=0;for(let d=0;d<r;++d)for(let f=0;f<a[d];++f)c[p*2]=d,c[p*2+1]=f,l[p]=o[p],++p;return[c,l,u]}T();function Nv(e,n){let t=y.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)t[r]=y.fingerPrint64(e[r]).modulo(n).getLowBitsUnsigned();return t}T();var TD=Ae((e,n)=>e-n),ooe=Nd((e,n,t,r)=>({real:e-t,imag:n-r})),Sh=Ge("Sub",TD,ooe),ZB={kernelName:"Sub",backendName:"cpu",kernelFunc:Sh};T();function Dv(e,n){let t=new Array(e.rank);for(let o=0;o<t.length;o++)t[o]=e.shape[o]*n[o];let r=le(t,e.dtype);for(let o=0;o<r.values.length;++o){let s=r.indexToLoc(o),i=new Array(e.rank);for(let c=0;c<i.length;c++)i[c]=s[c]%e.shape[c];let a=e.locToIndex(i);r.values[o]=e.values[a]}return r}T();var Nh=(e,n)=>{let t=n.value-e.value;return t===0?e.index-n.index:t};function QB(e,n,t=0,r=e.length-1){for(;r>t;){if(r-t>600){let a=r-t+1,c=n-t+1,l=Math.log(a),u=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*u*(a-u)/a)*Math.sign(c-a/2),d=Math.max(t,Math.floor(n-c*u/a+p)),f=Math.min(r,Math.floor(n+(a-c)*u/a+p));QB(e,n,d,f)}let o=e[n],s=t,i=r;for(y.swap(e,t,n),Nh(e[r],o)>0&&y.swap(e,t,r);s<i;){for(y.swap(e,s,i),s++,i--;Nh(e[s],o)<0;)s=s+1;for(;Nh(e[i],o)>0;)i=i-1}Nh(e[t],o)===0?y.swap(e,t,i):(i=i+1,y.swap(e,i,r)),i<=n&&(t=i+1),n<=i&&(r=i-1)}}function kv(e,n,t,r,o){let s=n[n.length-1],[i,a]=[e.length/s,s],c=y.getTypedArrayFromDType(t,i*r),l=y.getTypedArrayFromDType("int32",i*r);for(let p=0;p<i;p++){let d=p*a,f=e.subarray(d,d+a),m=new Array(f.length);f.forEach((v,w)=>m[w]={value:v,index:w}),r<m.length&&(QB(m,r),m=m.slice(0,r)),o&&m.sort(Nh);let h=p*r,g=c.subarray(h,h+r),x=l.subarray(h,h+r);for(let v=0;v<r;v++)g[v]=m[v].value,x[v]=m[v].index}let u=n.slice();return u[u.length-1]=r,[le(u,t,c),le(u,"int32",l)]}T();function _v(e,n,t,r){let o=y.parseAxisParam(n,t)[0],s=[1,t[0],1];for(let m=0;m<o;m++)s[0]*=t[m];s[1]=t[o];for(let m=o+1;m<t.length;m++)s[2]*=t[m];let i=new Map,a=new Int32Array(t[o]),c=new Ke(s,r,e),l=[],u=s[0]===1&&s[2]===1;for(let m=0;m<t[o];m++){let h;if(u)h=e[m].toString();else{let x=[];for(let v=0;v<s[0];v++)for(let w=0;w<s[2];w++)x.push(c.get(v,m,w));h=x.join(",")}let g=i.get(h);if(g!=null)a[m]=g;else{let x=i.size;i.set(h,x),a[m]=x,l.push(m)}}let p=s.slice();p[1]=i.size;let d=new Ke(p,r);l.forEach((m,h)=>{for(let g=0;g<s[0];g++)for(let x=0;x<s[2];x++)d.set(c.get(g,m,x),g,h,x)});let f=t.slice();return f[o]=p[1],{outputValues:d.values,outputShape:f,indices:a}}Im("cpu",()=>new fB,1);T();T();T();var ND=he("Elu",e=>e>=0?e:Math.exp(e)-1),JB={kernelName:"Elu",backendName:"cpu",kernelFunc:ND};T();function DD(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{alpha:s}=r;X([o],"leakyRelu");let i=y.sizeFromShape(o.shape),a=t.data.get(o.dataId).values,c=y.getTypedArrayFromDType("float32",i);for(let l=0;l<a.length;l++)c[l]=a[l]<0?s*a[l]:a[l];return t.makeTensorInfo(o.shape,"float32",c)}var eV={kernelName:pl,backendName:"cpu",kernelFunc:DD};T();var soe=Ae((e,n)=>e<0?n*e:e);function kD(e){let{inputs:n,backend:t}=e,{x:r,alpha:o}=n;X([r,o],"prelu");let s=t.data.get(r.dataId).values,i=t.data.get(o.dataId).values,[a,c]=soe(r.shape,o.shape,s,i,"float32");return t.makeTensorInfo(c,"float32",a)}var tV={kernelName:kl,backendName:"cpu",kernelFunc:kD};T();var _D=he(qi,e=>Math.max(0,e)),nV={kernelName:qi,backendName:"cpu",kernelFunc:_D};T();var AD=he(Ki,e=>Math.min(Math.max(0,e),6)),rV={kernelName:Ki,backendName:"cpu",kernelFunc:AD};function Hu(e,n,t,r,o){if(t==="linear")return mn({inputs:{x:n},backend:e});if(t==="relu")return _D({inputs:{x:n},backend:e});if(t==="elu")return ND({inputs:{x:n},backend:e});if(t==="relu6")return AD({inputs:{x:n},backend:e});if(t==="prelu")return kD({inputs:{x:n,alpha:r},backend:e});if(t==="leakyrelu")return DD({inputs:{x:n},backend:e,attrs:{alpha:o}});if(t==="sigmoid")return bD({inputs:{x:n},backend:e});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}T();T();function Re(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{shape:s}=r,i=y.sizeFromShape(o.shape),a=y.inferFromImplicitShape(s,i),c=y.sizeFromShape(a);y.assert(i===c,()=>`The new shape (${a}) has ${c} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.incRef(o.dataId);let l=t.data.get(o.dataId);if(l.complexTensorInfos!=null){let u=l.complexTensorInfos.real,p=l.complexTensorInfos.imag;u.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var oV={kernelName:$l,backendName:"cpu",kernelFunc:Re};function RD(e){let{inputs:n,backend:t,attrs:r}=e,{a:o,b:s}=n,{transposeA:i,transposeB:a}=r;X([o,s],"matMul");let c=o.shape.length,l=s.shape.length,u=i?o.shape[c-2]:o.shape[c-1],p=a?s.shape[l-1]:s.shape[l-2],d=i?o.shape[c-1]:o.shape[c-2],f=a?s.shape[l-2]:s.shape[l-1],m=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(m),x=y.sizeFromShape(h),w=fo.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,f]);y.assert(u===p,()=>`Error in matMul: inner shapes (${u}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let I=i?[g,u,d]:[g,d,u],_=a?[x,f,p]:[x,p,f],A=Re({inputs:{x:o},backend:t,attrs:{shape:I}}),R=Re({inputs:{x:s},backend:t,attrs:{shape:_}}),F=i?A.shape[1]:A.shape[2],P=i?A.shape[2]:A.shape[1],L=a?R.shape[1]:R.shape[2],V=Math.max(g,x),z=t.data.get(A.dataId).values,G=t.data.get(R.dataId).values,j=y.computeStrides(A.shape),W=y.computeStrides(R.shape),[Y,Z,K]=i?[j[0],1,j[1]]:[j[0],j[1],1],[Q,te,ne]=a?[1,W[1],W[0]]:[W[1],1,W[0]],se=P*L,re=le([V,P,L],A.dtype),ae=re.values,oe=t.blockSize;for(let ue=0;ue<V;ue++){let xe=ue%g,be=ue%x;for(let ye=0;ye<P;ye+=oe){let Oe=Math.min(ye+oe,P);for(let Pe=0;Pe<L;Pe+=oe){let st=Math.min(Pe+oe,L);for(let mt=0;mt<F;mt+=oe){let $t=Math.min(mt+oe,F);for(let ht=ye;ht<Oe;ht++)for(let ct=Pe;ct<st;ct++){let Rt=0;for(let Tt=mt;Tt<$t;Tt++){let ts=z[xe*Y+ht*Z+Tt*K],cn=G[Tt*Q+ct*te+be*ne];Rt+=ts*cn}ae[ue*se+(ht*L+ct)]+=Rt}}}}}return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(R),t.makeTensorInfo(w,re.dtype,re.values)}var sV={kernelName:_c,backendName:"cpu",kernelFunc:RD};function ioe(e){let{inputs:n,backend:t,attrs:r}=e,{a:o,b:s,bias:i,preluActivationWeights:a}=n,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:p}=r,d,f,m,h=[];d=RD({inputs:{a:o,b:s},attrs:{transposeA:c,transposeB:l},backend:t}),i&&(f=Yo({inputs:{a:d,b:i},backend:t}),h.push(d),d=f),u&&(m=Hu(t,d,u,a,p),h.push(d),d=m);for(let x of h)t.disposeIntermediateTensorInfo(x);return d}var iV={kernelName:aa,backendName:"cpu",kernelFunc:ioe};T();var aoe=he(hi,e=>Math.acos(e)),aV={kernelName:hi,backendName:"cpu",kernelFunc:aoe};T();var coe=he(gi,e=>Math.acosh(e)),cV={kernelName:gi,backendName:"cpu",kernelFunc:coe};T();function loe(e){let{inputs:n,backend:t}=e,r=n;X(n,"addN");let o=r.map(a=>t.data.get(a.dataId).values),s=le(r[0].shape,r[0].dtype),i=s.values;for(let a=0;a<r.length;a++){let c=o[a];for(let l=0;l<i.length;l++)i[l]+=c[l]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}var lV={kernelName:Tc,backendName:"cpu",kernelFunc:loe};T();function uoe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r;X(o,"all");let a=y.parseAxisParam(s,o.shape),c=a,l=S.getAxesPermutation(c,o.shape.length),u=o;l!=null&&(u=Ct({inputs:{x:o},backend:t,attrs:{perm:l}}),c=S.getInnerMostAxes(c.length,o.shape.length)),S.assertAxesAreInnerMostDims("all",c,u.shape.length);let[p,d]=S.computeOutAndReduceShapes(u.shape,c),f=y.sizeFromShape(d),m=y.makeZerosTypedArray(y.sizeFromShape(p),u.dtype),h=t.data.get(u.dataId).values;for(let x=0;x<m.length;++x){let v=x*f,w=h[v];for(let I=0;I<f;++I){let _=h[v+I];w=w&&_}m[x]=w}l!=null&&t.disposeIntermediateTensorInfo(u);let g=t.makeTensorInfo(p,u.dtype,m);if(i){let x=S.expandShapeToKeepDim(p,a),v=Re({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),v}return g}var uV={kernelName:"All",backendName:"cpu",kernelFunc:uoe};T();function poe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r;X(o,"any");let a=y.parseAxisParam(s,o.shape),c=a,l=S.getAxesPermutation(c,o.shape.length),u=o;l!=null&&(u=Ct({inputs:{x:o},backend:t,attrs:{perm:l}}),c=S.getInnerMostAxes(c.length,o.shape.length)),S.assertAxesAreInnerMostDims("any",c,u.shape.length);let[p,d]=S.computeOutAndReduceShapes(u.shape,c),f=y.sizeFromShape(d),m=y.makeZerosTypedArray(y.sizeFromShape(p),u.dtype),h=t.data.get(u.dataId).values;for(let x=0;x<m.length;++x){let v=x*f,w=h[v];for(let I=0;I<f;++I){let _=h[v+I];w=w||_}m[x]=w}l!=null&&t.disposeIntermediateTensorInfo(u);let g=t.makeTensorInfo(p,u.dtype,m);if(i){let x=S.expandShapeToKeepDim(p,a),v=Re({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),v}return g}var pV={kernelName:"Any",backendName:"cpu",kernelFunc:poe};T();function doe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s}=r;X(o,"argMax");let i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,l=[];a!=null&&(c=Ct({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMax",i,c.shape.length);let[u,p]=S.computeOutAndReduceShapes(c.shape,i),d=y.sizeFromShape(u),f=y.makeZerosTypedArray(d,"int32"),m=y.sizeFromShape(p),h=t.data.get(c.dataId).values;for(let g=0;g<f.length;++g){let x=g*m,v=h[x],w=0;for(let I=0;I<m;++I){let _=h[x+I];_>v&&(v=_,w=I)}f[g]=w}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",f)}var dV={kernelName:Sc,backendName:"cpu",kernelFunc:doe};T();function foe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s}=r;X(o,"argMin");let i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,l=[];a!=null&&(c=Ct({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMin",i,c.shape.length);let[u,p]=S.computeOutAndReduceShapes(c.shape,i),d=y.sizeFromShape(u),f=y.makeZerosTypedArray(d,"int32"),m=y.sizeFromShape(p),h=t.data.get(c.dataId).values;for(let g=0;g<f.length;++g){let x=g*m,v=h[x],w=0;for(let I=0;I<m;++I){let _=h[x+I];_<v&&(v=_,w=I)}f[g]=w}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",f)}var fV={kernelName:Nc,backendName:"cpu",kernelFunc:foe};T();var moe=he(xi,e=>Math.asin(e)),mV={kernelName:xi,backendName:"cpu",kernelFunc:moe};T();var hoe=he(yi,e=>Math.asinh(e)),hV={kernelName:yi,backendName:"cpu",kernelFunc:hoe};T();var goe=he(vi,e=>Math.atan(e)),gV={kernelName:vi,backendName:"cpu",kernelFunc:goe};T();var xoe=Ae((e,n)=>Math.atan2(e,n)),yoe=Ge(Ci,xoe),xV={kernelName:Ci,backendName:"cpu",kernelFunc:yoe};T();var voe=he(bi,e=>Math.atanh(e)),yV={kernelName:bi,backendName:"cpu",kernelFunc:voe};T();T();function Ad(e,n,t,r,o,s){let i=o.strideHeight,a=o.strideWidth,c=o.dilationHeight,l=o.dilationWidth,u=o.effectiveFilterHeight,p=o.effectiveFilterWidth,d=o.padInfo.top,f=o.padInfo.left,m=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=le(o.outShape,t),g=h.values,x=o.outShape[1]*o.outShape[2]*o.outShape[3],v=o.outShape[2]*o.outShape[3],w=o.outShape[3];for(let I=0;I<o.batchSize;++I){let _=I*x,A=I*r[0];for(let R=0;R<o.inChannels;++R)for(let F=0;F<o.outHeight;++F){let P=F*i-d,L=Math.max(0,P),V=Math.min(o.inHeight,u+P),z=_+F*v;for(let G=0;G<o.outWidth;++G){let j=G*a-f,W=Math.max(0,j),Y=Math.min(o.inWidth,p+j),Z=m,K=0,Q=0;for(let ne=L;ne<V;ne+=c){let se=A+ne*r[1];for(let re=W;re<Y;re+=l){let ae=se+re*r[2],oe=e[ae+R];s==="max"&&oe>Z?Z=oe:s==="avg"&&(K+=oe,Q++)}if(isNaN(Z))break}let te=z+G*w+R;g[te]=s==="avg"?K/Q:Z}}}return h}function Av(e,n,t,r,o=!1,s=!1){let i=le(r.outShape,"int32"),a=r.strideHeight,c=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,p=r.effectiveFilterHeight,d=r.effectiveFilterWidth,f=r.padInfo.top,m=r.padInfo.left,h=le(n,t,e);for(let g=0;g<r.batchSize;++g)for(let x=0;x<r.inChannels;++x)for(let v=0;v<r.outHeight;++v){let w=v*a-f,I=w;for(;I<0;)I+=l;let _=Math.min(r.inHeight,p+w);for(let A=0;A<r.outWidth;++A){let R=A*c-m,F=R;for(;F<0;)F+=u;let P=Math.min(r.inWidth,d+R),L=Number.NEGATIVE_INFINITY,V=-1;for(let z=I;z<_;z+=l){let G=z-w;for(let j=F;j<P;j+=u){let W=j-R,Y=h.get(g,z,j,x);Y>L&&(L=Y,o?V=s?((g*r.inHeight+z)*r.inWidth+j)*r.inChannels+x:(z*r.inWidth+j)*r.inChannels+x:V=G*d+W)}}i.set(V,g,v,A,x)}}return i}function Rv(e,n,t,r,o,s){let i=o.strideDepth,a=o.strideHeight,c=o.strideWidth,l=o.dilationDepth,u=o.dilationHeight,p=o.dilationWidth,d=o.effectiveFilterDepth,f=o.effectiveFilterHeight,m=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,x=o.padInfo.left,v=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=le(o.outShape,t),I=w.values,_=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],A=o.outShape[2]*o.outShape[3]*o.outShape[4],R=o.outShape[3]*o.outShape[4],F=o.outShape[4];for(let P=0;P<o.batchSize;++P){let L=P*_,V=P*r[0];for(let z=0;z<o.inChannels;++z)for(let G=0;G<o.outDepth;++G){let j=G*i-h,W=j;for(;W<0;)W+=l;let Y=Math.min(o.inDepth,d+j),Z=L+G*A;for(let K=0;K<o.outHeight;++K){let Q=K*a-g,te=Q;for(;te<0;)te+=u;let ne=Math.min(o.inHeight,f+Q),se=Z+K*R;for(let re=0;re<o.outWidth;++re){let ae=re*c-x,oe=ae;for(;oe<0;)oe+=p;let ue=Math.min(o.inWidth,m+ae),xe=se+re*F,be=v,ye=0,Oe=0;for(let st=W;st<Y;st+=l){let mt=V+st*r[1];for(let $t=te;$t<ne;$t+=u){let ht=mt+$t*r[2];for(let ct=oe;ct<ue;ct+=p){let Rt=ht+ct*r[3],Tt=e[Rt+z];if(s==="max"&&Tt>be?be=Tt:s==="avg"&&(ye+=Tt,Oe++),isNaN(be))break}if(isNaN(be))break}if(isNaN(be))break}let Pe=xe+z;I[Pe]=s==="avg"?ye/Math.max(Oe,1):be}}}}return w}function vV(e,n){let t=le(n.outShape,"int32"),r=n.strideDepth,o=n.strideHeight,s=n.strideWidth,i=n.dilationDepth,a=n.dilationHeight,c=n.dilationWidth,l=n.effectiveFilterDepth,u=n.effectiveFilterHeight,p=n.effectiveFilterWidth,d=n.padInfo.front,f=n.padInfo.top,m=n.padInfo.left;for(let h=0;h<n.batchSize;++h)for(let g=0;g<n.inChannels;++g)for(let x=0;x<n.outDepth;++x){let v=x*r-d,w=v;for(;w<0;)w+=i;let I=Math.min(n.inDepth,l+v);for(let _=0;_<n.outHeight;++_){let A=_*o-f,R=A;for(;R<0;)R+=a;let F=Math.min(n.inHeight,u+A);for(let P=0;P<n.outWidth;++P){let L=P*s-m,V=L;for(;V<0;)V+=c;let z=Math.min(n.inWidth,p+L),G=Number.NEGATIVE_INFINITY,j=-1;for(let W=w;W<I;W+=i){let Y=W-v;for(let Z=R;Z<F;Z+=a){let K=Z-A;for(let Q=V;Q<z;Q+=c){let te=Q-L,ne=e.get(h,W,Z,Q,g);ne>=G&&(G=ne,j=Y*u*p+K*u+te)}}}t.set(j,h,x,_,P,g)}}}return t}function boe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n;X(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let u=S.computePool2DInfo(o.shape,s,i,l,a,c),p;if(u.filterWidth===1&&u.filterHeight===1&&y.arraysEqual(u.inShape,u.outShape))p=mn({inputs:{x:o},backend:t});else{let d=t.data.get(o.dataId).values,f=y.computeStrides(o.shape),m=Ad(d,o.shape,o.dtype,f,u,"avg");p=t.makeTensorInfo(u.outShape,o.dtype,m.values)}return p}var bV={kernelName:Dc,backendName:"cpu",kernelFunc:boe};T();function Coe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:c,dataFormat:l}=r;X(o,"avgPool3d");let u=S.computePool3DInfo(o.shape,s,i,1,a,c,l),p=t.data.get(o.dataId).values,d=Rv(p,o.shape,o.dtype,y.computeStrides(o.shape),u,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}var CV={kernelName:kc,backendName:"cpu",kernelFunc:Coe};T();function woe(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,input:s}=n,{filterSize:i,strides:a,pad:c,dimRoundingMode:l}=r;X([o,s],"avgPool3DGrad");let u=S.computePool3DInfo(s.shape,i,a,1,c,l),p=u.strideDepth,d=u.strideHeight,f=u.strideWidth,m=u.filterDepth,h=u.filterHeight,g=u.filterWidth,x=u.dilationDepth,v=u.dilationHeight,w=u.dilationWidth,I=u.effectiveFilterDepth,_=u.effectiveFilterHeight,A=u.effectiveFilterWidth,R=I-1-u.padInfo.front,F=A-1-u.padInfo.left,P=_-1-u.padInfo.top,L=le(s.shape,"float32"),V=1/(m*h*g),z=t.bufferSync(o);for(let G=0;G<u.batchSize;++G)for(let j=0;j<u.inChannels;++j)for(let W=0;W<u.inDepth;++W)for(let Y=0;Y<u.inHeight;++Y)for(let Z=0;Z<u.inWidth;++Z){let K=W-R,Q=Y-P,te=Z-F,ne=0;for(let se=0;se<I;se+=x){let re=(K+se)/p;if(!(re<0||re>=u.outDepth||Math.floor(re)!==re))for(let ae=0;ae<_;ae+=v){let oe=(Q+ae)/d;if(!(oe<0||oe>=u.outHeight||Math.floor(oe)!==oe))for(let ue=0;ue<A;ue+=w){let xe=(te+ue)/f;if(xe<0||xe>=u.outWidth||Math.floor(xe)!==xe)continue;let be=z.get(G,re,oe,xe,j);ne+=be}}}L.set(ne*V,G,W,Y,Z,j)}return t.makeTensorInfo(L.shape,L.dtype,L.values)}var wV={kernelName:im,backendName:"cpu",kernelFunc:woe};T();function Ioe(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,input:s}=n,i=s;X([o,s],"avgPoolGrad");let{filterSize:a,strides:c,pad:l}=r,u=S.computePool2DInfo(i.shape,a,c,1,l),p=u.strideHeight,d=u.strideWidth,f=u.filterHeight,m=u.filterWidth,h=u.dilationHeight,g=u.dilationWidth,x=u.effectiveFilterHeight,v=u.effectiveFilterWidth,w=v-1-u.padInfo.left,I=x-1-u.padInfo.top,_=le(i.shape,"float32"),A=1/(f*m),R=t.data.get(o.dataId).values,F=le(o.shape,"float32",R);for(let P=0;P<u.batchSize;++P)for(let L=0;L<u.inChannels;++L)for(let V=0;V<u.inHeight;++V)for(let z=0;z<u.inWidth;++z){let G=V-I,j=z-w,W=0;for(let Y=0;Y<x;Y+=h){let Z=(G+Y)/p;if(!(Z<0||Z>=u.outHeight||Math.floor(Z)!==Z))for(let K=0;K<v;K+=g){let Q=(j+K)/d;if(Q<0||Q>=u.outWidth||Math.floor(Q)!==Q)continue;let te=F.get(P,Z,Q,L);W+=te}}_.set(W*A,P,V,z,L)}return t.makeTensorInfo(_.shape,_.dtype,_.values)}var IV={kernelName:sm,backendName:"cpu",kernelFunc:Ioe};T();function Eoe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,scale:s,offset:i,mean:a,variance:c}=n;y.assert(a.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),X([o,a,c,s,i],"batchNorm");let{varianceEpsilon:l}=r;l==null&&(l=.001);let u=t.data.get(o.dataId).values,p=t.data.get(a.dataId).values,d=t.data.get(c.dataId).values,f=s?t.data.get(s.dataId).values:new Float32Array([1]),m=i?t.data.get(i.dataId).values:new Float32Array([0]),h=new Float32Array(u.length),g=m.length,x=f.length,v=d.length,w=p.length,I=0,_=0,A=0,R=0;for(let F=0;F<u.length;++F)h[F]=m[I++]+(u[F]-p[_++])*f[A++]/Math.sqrt(d[R++]+l),I>=g&&(I=0),_>=w&&(_=0),A>=x&&(A=0),R>=v&&(R=0);return t.makeTensorInfo(o.shape,o.dtype,h)}var EV={kernelName:il,backendName:"cpu",kernelFunc:Eoe};T();function Toe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{blockShape:s,crops:i}=r;X([o],"batchToSpaceND");let a=s.reduce((x,v)=>x*v),c=S.getReshaped(o.shape,s,a),l=S.getPermuted(c.length,s.length),u=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),d=S.getSliceSize(u,i,s.length),f=Re({inputs:{x:o},backend:t,attrs:{shape:c}}),m=Ct({inputs:{x:f},backend:t,attrs:{perm:l}}),h=Re({inputs:{x:m},backend:t,attrs:{shape:u}}),g=Wr({inputs:{x:h},backend:t,attrs:{begin:p,size:d}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),g}var TV={kernelName:Ac,backendName:"cpu",kernelFunc:Toe};T();function Soe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,weights:s}=n,{size:i}=r,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,l=Dd(a,c,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,l)}var SV={kernelName:Rc,backendName:"cpu",kernelFunc:Soe};T();function Noe(e){let{inputs:n,backend:t}=e,{s0:r,s1:o}=n,s=t.data.get(r.dataId).values,i=t.data.get(o.dataId).values,a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var NV={kernelName:Fc,backendName:"cpu",kernelFunc:Noe};T();var Doe=he(Ei,(e,n)=>{let t=n;return e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e}),DV={kernelName:Ei,backendName:"cpu",kernelFunc:Doe};T();var koe=e=>{let{x:n}=e.inputs,t=e.backend,r=new Float32Array(y.sizeFromShape(n.shape)),o=t.data.get(n.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values;for(let l=0;l<a.length;l++){let u=a[l],p=c[l];r[l]=Math.hypot(u,p)}return t.makeOutput(r,n.shape,"float32")},kV={kernelName:Mc,backendName:"cpu",kernelFunc:koe};T();T();function Zo(e){let{inputs:n,backend:t}=e,{input:r}=n,o=t.data.get(r.dataId).complexTensorInfos.imag,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var _V={kernelName:ul,backendName:"cpu",kernelFunc:Zo};function Ra(e){let{inputs:n,backend:t,attrs:r}=e,{axis:o}=r,s=y.parseAxisParam(o,n[0].shape)[0],i=n.map(h=>h.shape);S.assertParamsConsistent(i,s);let a=S.computeOutShape(n.map(h=>h.shape),s);if(y.sizeFromShape(a)===0)return t.makeTensorInfo(a,n[0].dtype,[]);let c=n.filter(h=>y.sizeFromShape(h.shape)>0);if(c.length===1)return mn({inputs:{x:c[0]},backend:t});if(c[0].dtype==="complex64"){let h=c.map(I=>zr({inputs:{input:I},backend:t})),g=c.map(I=>Zo({inputs:{input:I},backend:t})),x=Ra({inputs:h,backend:t,attrs:{axis:s}}),v=Ra({inputs:g,backend:t,attrs:{axis:s}}),w=Gt({inputs:{real:x,imag:v},backend:t});return h.forEach(I=>t.disposeIntermediateTensorInfo(I)),g.forEach(I=>t.disposeIntermediateTensorInfo(I)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(v),w}let l=c.map(h=>{let x=[-1,y.sizeFromShape(h.shape.slice(s))];return Re({inputs:{x:h},backend:t,attrs:{shape:x}})}),u=l.map(h=>({vals:t.data.get(h.dataId).values,shape:h.shape}));a=S.computeOutShape(l.map(h=>h.shape),1);let p=l[0].shape[0]===1,d=fv(u,a,n[0].dtype,p),f=S.computeOutShape(c.map(h=>h.shape),s),m=t.makeTensorInfo(f,n[0].dtype,d);return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),m}var AV={kernelName:$c,backendName:"cpu",kernelFunc:Ra};T();function FD(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s}=n,{strides:i,pad:a,dataFormat:c,dilations:l,dimRoundingMode:u}=r;X([o,s],"conv2d");let p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,s.shape,i,l,a,u,!1,p),f=d.filterHeight,m=d.filterWidth,h=d.dilationHeight,g=d.dilationWidth,x=d.padInfo.left,v=d.padInfo.top,w=d.dataFormat==="channelsLast",I=new Ke(d.outShape,o.dtype),_=y.computeStrides(o.shape),A=y.computeStrides(s.shape),R=_[0],F=w?_[1]:_[2],P=w?_[2]:1,L=w?1:_[1],V=I.strides[0],z=w?I.strides[1]:I.strides[2],G=w?I.strides[2]:1,j=w?1:I.strides[1],W=t.data.get(o.dataId).values,Y=t.data.get(s.dataId).values,Z=I.values;for(let K=0;K<d.batchSize;++K){let Q=K*R,te=K*V;for(let ne=0;ne<d.outHeight;++ne){let se=te+ne*z,re=ne*d.strideHeight-v;for(let ae=0;ae<f;++ae){let oe=re+ae*h;if(oe<0||oe>=d.inHeight)continue;let ue=ae*A[0],xe=Q+oe*F;for(let be=0;be<d.outWidth;++be){let ye=se+be*G,Oe=be*d.strideWidth-x;for(let Pe=0;Pe<m;++Pe){let st=Oe+Pe*g;if(st<0||st>=d.inWidth)continue;let mt=ue+Pe*A[1],$t=xe+st*P,ht=mt;for(let ct=0;ct<d.inChannels;++ct){let Rt=W[$t+ct*L];for(let Tt=0;Tt<d.outChannels;++Tt)Z[ye+Tt*j]+=Rt*Y[ht+Tt];ht+=d.outChannels}}}}}}return t.makeTensorInfo(I.shape,I.dtype,Z)}var RV={kernelName:Pc,backendName:"cpu",kernelFunc:FD};T();function _oe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,dy:s}=n,{strides:i,pad:a,dataFormat:c,dimRoundingMode:l,filterShape:u}=r;X([o,s],"conv2dBackpropFilter");let p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,u,i,1,a,l,!1,p),{strideHeight:f,strideWidth:m,filterHeight:h,filterWidth:g}=d,x=d.dataFormat==="channelsLast",v=new Ke(d.filterShape,"float32"),w=d.padInfo.left,I=d.padInfo.top,_=t.data.get(o.dataId).values,A=t.data.get(s.dataId).values,R=new Ke(o.shape,o.dtype,_),F=new Ke(s.shape,s.dtype,A);for(let P=0;P<h;++P){let L=Math.max(0,Math.ceil((I-P)/f)),V=Math.min(d.outHeight,(d.inHeight+I-P)/f);for(let z=0;z<g;++z){let G=Math.max(0,Math.ceil((w-z)/m)),j=Math.min(d.outWidth,(d.inWidth+w-z)/m);for(let W=0;W<d.inChannels;++W)for(let Y=0;Y<d.outChannels;++Y){let Z=0;for(let K=0;K<d.batchSize;++K)for(let Q=L;Q<V;++Q){let te=P+Q*f-I;for(let ne=G;ne<j;++ne){let se=z+ne*m-w;x?Z+=R.get(K,te,se,W)*F.get(K,Q,ne,Y):Z+=R.get(K,W,te,se)*F.get(K,Y,Q,ne)}}v.set(Z,P,z,W,Y)}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}var FV={kernelName:Lc,backendName:"cpu",kernelFunc:_oe};T();function Aoe(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,filter:s}=n,{inputShape:i,strides:a,pad:c,dataFormat:l,dimRoundingMode:u}=r;X([o,s],"conv2dBackpropInput");let p=y.computeStrides(s.shape),d=y.computeStrides(o.shape),f=S.convertConv2DDataFormat(l),m=S.computeConv2DInfo(i,s.shape,a,1,c,u,!1,f),h=new Ke(m.inShape,"float32"),g=h.values,x=t.data.get(o.dataId).values,v=t.data.get(s.dataId).values,[w,I,_]=p,{batchSize:A,filterHeight:R,filterWidth:F,inChannels:P,inHeight:L,inWidth:V,outChannels:z,outHeight:G,outWidth:j,strideHeight:W,strideWidth:Y}=m;f=m.dataFormat;let Z=R-1-m.padInfo.top,K=F-1-m.padInfo.left,Q=f==="channelsLast",te=h.strides[0],ne=Q?h.strides[1]:h.strides[2],se=Q?h.strides[2]:1,re=Q?1:h.strides[1],ae=d[0],oe=Q?d[1]:d[2],ue=Q?d[2]:1,xe=Q?1:d[1];for(let be=0;be<A;++be)for(let ye=0;ye<P;++ye)for(let Oe=0;Oe<L;++Oe){let Pe=Oe-Z,st=Math.max(0,Math.ceil(Pe/W)),mt=Math.min(G,(R+Pe)/W);for(let $t=0;$t<V;++$t){let ht=$t-K,ct=Math.max(0,Math.ceil(ht/Y)),Rt=Math.min(j,(F+ht)/Y),Tt=0;for(let cn=st;cn<mt;++cn){let Hs=cn*W-Pe;for(let fr=ct;fr<Rt;++fr){let Va=fr*Y-ht,qr=ae*be+oe*cn+ue*fr,ns=w*(R-1-Hs)+I*(F-1-Va)+_*ye;for(let Ws=0;Ws<z;++Ws){let js=x[qr+xe*Ws],qs=v[ns+Ws];Tt+=js*qs}}}let ts=te*be+ne*Oe+se*$t+re*ye;g[ts]=Tt}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}var OV={kernelName:Bc,backendName:"cpu",kernelFunc:Aoe};T();function Roe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s}=n,{strides:i,pad:a,dilations:c}=r;X([o,s],"conv3d");let l=S.computeConv3DInfo(o.shape,s.shape,i,c,a),{filterDepth:u,filterHeight:p,filterWidth:d,dilationDepth:f,dilationHeight:m,dilationWidth:h,padInfo:g}=l,x=g.front,v=g.left,w=g.top,I=new Ke(l.outShape,o.dtype),_=t.data.get(o.dataId).values,A=t.data.get(s.dataId).values,R=I.values,F=y.computeStrides(o.shape),P=y.computeStrides(s.shape);for(let L=0;L<l.batchSize;++L){let V=L*F[0],z=L*I.strides[0];for(let G=0;G<l.outDepth;++G){let j=z+G*I.strides[1],W=G*l.strideDepth-x;for(let Y=0;Y<u;++Y){let Z=W+Y*f;if(Z<0||Z>=l.inDepth)continue;let K=Y*P[0],Q=V+Z*F[1];for(let te=0;te<l.outHeight;++te){let ne=j+te*I.strides[2],se=te*l.strideHeight-w;for(let re=0;re<p;++re){let ae=se+re*m;if(ae<0||ae>=l.inHeight)continue;let oe=K+re*P[1],ue=Q+ae*F[2];for(let xe=0;xe<l.outWidth;++xe){let be=ne+xe*l.outChannels,ye=xe*l.strideWidth-v;for(let Oe=0;Oe<d;++Oe){let Pe=ye+Oe*h;if(Pe<0||Pe>=l.inWidth)continue;let st=oe+Oe*P[2],mt=ue+Pe*l.inChannels,$t=st;for(let ht=0;ht<l.inChannels;++ht){let ct=_[mt+ht];for(let Rt=0;Rt<l.outChannels;++Rt)R[be+Rt]+=ct*A[$t+Rt];$t+=l.outChannels}}}}}}}}return t.makeTensorInfo(I.shape,I.dtype,I.values)}var MV={kernelName:Vc,backendName:"cpu",kernelFunc:Roe};T();function Foe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,dy:s}=n,{strides:i,pad:a,filterShape:c}=r;X([o,s],"conv3dBackpropFilterV2");let l=y.computeStrides(o.shape),u=y.computeStrides(s.shape),p=S.computeConv3DInfo(o.shape,c,i,1,a),d=p.strideDepth,f=p.strideHeight,m=p.strideWidth,h=p.filterDepth,g=p.filterHeight,x=p.filterWidth,v=new Ke(p.filterShape,"float32"),w=v.values,[I,_,A,R]=v.strides,F=t.data.get(s.dataId).values,[P,L,V,z]=u,G=t.data.get(o.dataId).values,[j,W,Y,Z]=l,K=p.padInfo.front,Q=p.padInfo.left,te=p.padInfo.top;for(let ne=0;ne<h;++ne){let se=Math.max(0,Math.ceil((K-ne)/d)),re=Math.min(p.outDepth,(p.inDepth+K-ne)/d),ae=ne*I;for(let oe=0;oe<g;++oe){let ue=Math.max(0,Math.ceil((te-oe)/f)),xe=Math.min(p.outHeight,(p.inHeight+te-oe)/f),be=oe*_+ae;for(let ye=0;ye<x;++ye){let Oe=Math.max(0,Math.ceil((Q-ye)/m)),Pe=Math.min(p.outWidth,(p.inWidth+Q-ye)/m),st=ye*A+be;for(let mt=0;mt<p.inChannels;++mt){let $t=mt*R+st;for(let ht=0;ht<p.outChannels;++ht){let ct=0;for(let Rt=0;Rt<p.batchSize;++Rt){let Tt=Rt*j,ts=Rt*P;for(let cn=se;cn<re;++cn){let fr=(ne+cn*d-K)*W+Tt,Va=cn*L+ts;for(let qr=ue;qr<xe;++qr){let Ws=(oe+qr*f-te)*Y+fr,js=qr*V+Va;for(let qs=Oe;qs<Pe;++qs){let H0=(ye+qs*m-Q)*Z+Ws,W0=qs*z+js;ct+=G[H0+mt]*F[W0+ht]}}}}w[$t+ht]=ct}}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}var $V={kernelName:am,backendName:"cpu",kernelFunc:Foe};T();function Ooe(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,filter:s}=n,{pad:i,strides:a,inputShape:c}=r;X([o],"conv3dBackpropInputV2");let l=y.computeStrides(o.shape),u=y.computeStrides(s.shape),p=S.computeConv3DInfo(c,s.shape,a,1,i),d=new Ke(p.inShape,"float32"),f=d.values,[m,h,g,x]=d.strides,v=t.data.get(o.dataId).values,[w,I,_,A]=l,R=t.data.get(s.dataId).values,[F,P,L,V]=u,{batchSize:z,filterDepth:G,filterHeight:j,filterWidth:W,inChannels:Y,inDepth:Z,inHeight:K,inWidth:Q,outChannels:te,outDepth:ne,outHeight:se,outWidth:re,strideDepth:ae,strideHeight:oe,strideWidth:ue}=p,xe=G-1-p.padInfo.front,be=j-1-p.padInfo.top,ye=W-1-p.padInfo.left;for(let Oe=0;Oe<z;++Oe)for(let Pe=0;Pe<Y;++Pe)for(let st=0;st<Z;++st){let mt=st-xe,$t=Math.max(0,Math.ceil(mt/ae)),ht=Math.min(ne,(G+mt)/ae);for(let ct=0;ct<K;++ct){let Rt=ct-be,Tt=Math.max(0,Math.ceil(Rt/oe)),ts=Math.min(se,(j+Rt)/oe);for(let cn=0;cn<Q;++cn){let Hs=cn-ye,fr=Math.max(0,Math.ceil(Hs/ue)),Va=Math.min(re,(W+Hs)/ue),qr=0;for(let ns=$t;ns<ht;++ns){let Ws=ns*ae-mt;for(let js=Tt;js<ts;++js){let qs=js*oe-Rt;for(let nf=fr;nf<Va;++nf){let H0=nf*ue-Hs,W0=w*Oe+I*ns+_*js+A*nf,g8=F*(G-1-Ws)+P*(j-1-qs)+L*(W-1-H0)+V*Pe;for(let eg=0;eg<te;++eg){let x8=v[W0+eg],y8=R[g8+eg];qr+=x8*y8}}}}f[m*Oe+h*st+g*ct+x*cn+Pe]=qr}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}var PV={kernelName:Uc,backendName:"cpu",kernelFunc:Ooe};T();var Moe=he("Cos",e=>Math.cos(e)),LV={kernelName:"Cos",backendName:"cpu",kernelFunc:Moe};T();var $oe=he(Ti,e=>Math.cosh(e)),BV={kernelName:Ti,backendName:"cpu",kernelFunc:$oe};T();function Poe(e){let{inputs:n,backend:t,attrs:r}=e,{image:o,boxes:s,boxInd:i}=n,{cropSize:a,method:c,extrapolationValue:l}=r,[u,p,d,f]=o.shape,m=s.shape[0],[h,g]=a,x=le([m,h,g,f],"float32"),v=t.data.get(s.dataId).values,w=t.data.get(i.dataId).values,I=t.data.get(o.dataId).values,_=y.computeStrides(o.shape),A=y.computeStrides(x.shape);for(let R=0;R<m;R++){let F=R*4,P=v[F],L=v[F+1],V=v[F+2],z=v[F+3],G=w[R];if(G>=u)continue;let j=h>1?(V-P)*(p-1)/(h-1):0,W=g>1?(z-L)*(d-1)/(g-1):0;for(let Y=0;Y<h;Y++){let Z=h>1?P*(p-1)+Y*j:.5*(P+V)*(p-1);if(Z<0||Z>p-1){for(let K=0;K<g;K++)for(let Q=0;Q<f;Q++){let te=Q+K*A[2]+Y*A[1]+R*A[0];x.values[te]=l}continue}if(c==="bilinear"){let K=Math.floor(Z),Q=Math.ceil(Z),te=Z-K;for(let ne=0;ne<g;ne++){let se=g>1?L*(d-1)+ne*W:.5*(L+z)*(d-1);if(se<0||se>d-1){for(let ue=0;ue<f;ue++){let xe=ue+ne*A[2]+Y*A[1]+R*A[0];x.values[xe]=l}continue}let re=Math.floor(se),ae=Math.ceil(se),oe=se-re;for(let ue=0;ue<f;ue++){let xe=ue+re*_[2]+K*_[1]+G*_[0],be=I[xe];xe=ue+ae*_[2]+K*_[1]+G*_[0];let ye=I[xe];xe=ue+re*_[2]+Q*_[1]+G*_[0];let Oe=I[xe];xe=ue+ae*_[2]+Q*_[1]+G*_[0];let Pe=I[xe],st=be+(ye-be)*oe,mt=Oe+(Pe-Oe)*oe;xe=ue+ne*A[2]+Y*A[1]+R*A[0],x.values[xe]=st+(mt-st)*te}}}else for(let K=0;K<g;++K){let Q=g>1?L*(d-1)+K*W:.5*(L+z)*(d-1);if(Q<0||Q>d-1){for(let se=0;se<f;se++){let re=se+K*A[2]+Y*A[1]+R*A[0];x.values[re]=l}continue}let te=Math.round(Q),ne=Math.round(Z);for(let se=0;se<f;se++){let re=se+te*_[2]+ne*_[1]+G*_[0],ae=se+K*A[2]+Y*A[1]+R*A[0];x.values[ae]=I[re]}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}var VV={kernelName:Wc,backendName:"cpu",kernelFunc:Poe};T();function Loe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;X(o,"cumprod");let c=S.getAxesPermutation([s],o.shape.length),l=o;c!=null&&(l=Ct({inputs:{x:o},backend:t,attrs:{perm:c}}));let u=S.getInnerMostAxes(1,o.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);let p=Mt(l.dtype,"int32"),d=y.makeOnesTypedArray(y.sizeFromShape(l.shape),p),f=t.data.get(l.dataId).values,m=l.shape[l.shape.length-1],h=a?(x,v)=>x+m-v-1:(x,v)=>x+v;for(let x=0;x<f.length;x+=m)for(let v=0;v<m;v++){let w=h(x,v);if(v===0)d[w]=i?1:f[w];else{let I=h(x,v-1);d[w]=i?f[I]*d[I]:f[w]*d[I]}}let g=t.makeTensorInfo(l.shape,p,d);if(c!=null){let x=S.getUndoAxesPermutation(c),v=Ct({inputs:{x:g},backend:t,attrs:{perm:x}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),v}return g}var UV={kernelName:Gc,backendName:"cpu",kernelFunc:Loe};T();function Boe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;X(o,"cumsum");let c=S.getAxesPermutation([s],o.shape.length),l=o;c!=null&&(l=Ct({inputs:{x:o},backend:t,attrs:{perm:c}}));let u=S.getInnerMostAxes(1,o.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);let p=Mt(l.dtype,"int32"),d=y.makeZerosTypedArray(y.sizeFromShape(l.shape),p),f=t.data.get(l.dataId).values,m=l.shape[l.shape.length-1],h=a?(x,v)=>x+m-v-1:(x,v)=>x+v;for(let x=0;x<f.length;x+=m)for(let v=0;v<m;v++){let w=h(x,v);if(v===0)d[w]=i?0:f[w];else{let I=h(x,v-1);d[w]=i?f[I]+d[I]:f[w]+d[I]}}let g=t.makeTensorInfo(l.shape,p,d);if(c!=null){let x=S.getUndoAxesPermutation(c),v=Ct({inputs:{x:g},backend:t,attrs:{perm:x}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),v}return g}var zV={kernelName:Hc,backendName:"cpu",kernelFunc:Boe};T();function Voe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,weights:s}=n,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let c=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,u=Dd(c,l,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,u)}else if(o.shape.length===2){let c=t.bufferSync(o),l=t.bufferSync(s),u=dv(c,l,i,a);return t.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var GV={kernelName:jc,backendName:"cpu",kernelFunc:Voe};T();function Uoe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{blockSize:s,dataFormat:i}=r;y.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],c=o.shape[1],l=o.shape[2],u=o.shape[3],p=c*s,d=l*s,f=u/(s*s),m=t.data.get(o.dataId).values,h=new Float32Array(a*p*d*f),g=0;for(let x=0;x<a;++x)for(let v=0;v<p;++v){let w=Math.floor(v/s),I=v%s;for(let _=0;_<d;++_){let A=Math.floor(_/s),R=_%s,F=(I*s+R)*f;for(let P=0;P<f;++P){let V=P+F+u*(A+l*(w+c*x));h[g++]=m[V]}}}return t.makeTensorInfo([a,p,d,f],o.dtype,h)}var HV={kernelName:qc,backendName:"cpu",kernelFunc:Uoe};T();function OD(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s}=n,{strides:i,pad:a,dilations:c,dimRoundingMode:l}=r;X([o,s],"depthwiseConv2DNative");let u=y.computeStrides(o.shape),p=y.computeStrides(s.shape),d=c;d==null&&(d=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let f=S.computeConv2DInfo(o.shape,s.shape,i,d,a,l,!0),{filterHeight:m,filterWidth:h,dilationHeight:g,dilationWidth:x,padInfo:v}=f,w=v.left,I=v.top,_=f.outChannels/f.inChannels,A=new Ke(f.outShape,o.dtype),R=t.data.get(o.dataId).values,F=t.data.get(s.dataId).values,P=A.values;for(let L=0;L<f.batchSize;++L){let V=L*u[0],z=L*A.strides[0];for(let G=0;G<f.outHeight;++G){let j=z+G*A.strides[1],W=G*f.strideHeight-I;for(let Y=0;Y<m;++Y){let Z=W+Y*g;if(Z<0||Z>=f.inHeight)continue;let K=Y*p[0],Q=V+Z*u[1];for(let te=0;te<f.outWidth;++te){let ne=j+te*A.strides[2],se=te*f.strideWidth-w;for(let re=0;re<h;++re){let ae=se+re*x;if(ae<0||ae>=f.inWidth)continue;let oe=K+re*p[1],ue=Q+ae*f.inChannels,xe=ne,be=oe;for(let ye=0;ye<f.inChannels;++ye){let Oe=R[ue+ye];for(let Pe=0;Pe<_;++Pe)P[xe+Pe]+=Oe*F[be+Pe];xe+=_,be+=_}}}}}}return t.makeTensorInfo(A.shape,A.dtype,A.values)}var WV={kernelName:Kc,backendName:"cpu",kernelFunc:OD};T();function zoe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,dy:s}=n,{strides:i,dilations:a,pad:c,dimRoundingMode:l,filterShape:u}=r;X([o,s],"depthwiseConv2dNativeBackpropFilter");let p=S.computeConv2DInfo(o.shape,u,i,a,c,l,!0),{strideHeight:d,strideWidth:f,filterHeight:m,filterWidth:h}=p,g=new Ke(p.filterShape,"float32"),x=p.padInfo.left,v=p.padInfo.top,w=p.outChannels/p.inChannels,I=t.data.get(o.dataId).values,_=new Ke(o.shape,o.dtype,I),A=t.data.get(s.dataId).values,R=new Ke(s.shape,s.dtype,A);for(let F=0;F<m;++F){let P=Math.max(0,Math.ceil((v-F)/d)),L=Math.min(p.outHeight,(p.inHeight+v-F)/d);for(let V=0;V<h;++V){let z=Math.max(0,Math.ceil((x-V)/f)),G=Math.min(p.outWidth,(p.inWidth+x-V)/f);for(let j=0;j<p.outChannels;++j){let W=Math.trunc(j/w),Y=j%w,Z=0;for(let K=0;K<p.batchSize;++K)for(let Q=P;Q<L;++Q){let te=F+Q*d-v;for(let ne=z;ne<G;++ne){let se=V+ne*f-x;Z+=_.get(K,te,se,W)*R.get(K,Q,ne,j)}}g.set(Z,F,V,W,Y)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}var jV={kernelName:Xc,backendName:"cpu",kernelFunc:zoe};T();function Goe(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,filter:s}=n,{strides:i,dilations:a,pad:c,dimRoundingMode:l,inputShape:u}=r;X([o,s],"depthwiseConv2DNativeBackpropInput");let p=y.computeStrides(o.shape),d=y.computeStrides(s.shape),f=S.computeConv2DInfo(u,s.shape,i,a,c,l,!0),m=new Ke(f.inShape,"float32"),h=m.values,[g,x,v]=m.strides,w=t.data.get(o.dataId).values,[I,_,A]=p,R=t.data.get(s.dataId).values,[F,P,L]=d,{batchSize:V,filterHeight:z,filterWidth:G,inChannels:j,inHeight:W,inWidth:Y,outChannels:Z,outHeight:K,outWidth:Q,strideHeight:te,strideWidth:ne}=f,se=z-1-f.padInfo.top,re=G-1-f.padInfo.left,ae=Z/j;for(let oe=0;oe<V;++oe)for(let ue=0;ue<j;++ue)for(let xe=0;xe<W;++xe){let be=xe-se,ye=Math.max(0,Math.ceil(be/te)),Oe=Math.min(K,(z+be)/te);for(let Pe=0;Pe<Y;++Pe){let st=Pe-re,mt=Math.max(0,Math.ceil(st/ne)),$t=Math.min(Q,(G+st)/ne),ht=0;for(let ct=ye;ct<Oe;++ct){let Rt=ct*te-be;for(let Tt=mt;Tt<$t;++Tt){let ts=Tt*ne-st,cn=I*oe+_*ct+A*Tt,Hs=F*(z-1-Rt)+P*(G-1-ts)+L*ue;for(let fr=0;fr<ae;++fr){let Va=ue*ae+fr,qr=w[cn+Va],ns=R[Hs+fr];ht+=qr*ns}}}h[g*oe+x*xe+v*Pe+ue]=ht}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}var qV={kernelName:Yc,backendName:"cpu",kernelFunc:Goe};T();function Hoe(e){let{inputs:n,backend:t}=e,{x:r}=n,o=y.sizeFromShape(r.shape),s=t.data.get(r.dataId).values,i=le([o,o],r.dtype),a=i.values;for(let l=0;l<s.length;l++)a[l*o+l]=s[l];let c=[...r.shape,...r.shape];return t.makeTensorInfo(c,i.dtype,i.values)}var KV={kernelName:Zc,backendName:"cpu",kernelFunc:Hoe};T();var XV={kernelName:Qc,backendName:"cpu",kernelFunc:({inputs:e,backend:n,attrs:t})=>{let{x:r,filter:o}=e,{strides:s,pad:i,dilations:a}=t,c=n,l=c.data.get(r.dataId).values,u=r.shape.length,p=c.data.get(o.dataId).values,d=o.shape.length,{batchSize:f,inHeight:m,inWidth:h,inChannels:g,outHeight:x,outWidth:v,padInfo:w,strideHeight:I,strideWidth:_,filterHeight:A,filterWidth:R,dilationHeight:F,dilationWidth:P,outShape:L}=S.computeDilation2DInfo(r.shape,o.shape,s,i,"NHWC",a),V=y.sizeFromShape(L),z=L.length,G=y.getArrayFromDType(r.dtype,V);for(let W=0;W<f;++W)for(let Y=0;Y<x;++Y){let Z=Y*I-w.top;for(let K=0;K<v;++K){let Q=K*_-w.left;for(let te=0;te<g;++te){let ne=Number.MIN_SAFE_INTEGER;for(let re=0;re<A;++re){let ae=Z+re*F;if(ae>=0&&ae<m)for(let oe=0;oe<R;++oe){let ue=Q+oe*P;if(ue>=0&&ue<h){let xe=y.locToIndex([W,ae,ue,te],u,y.computeStrides(r.shape)),be=y.locToIndex([re,oe,te],d,y.computeStrides(o.shape)),ye=l[xe]+p[be];ye>ne&&(ne=ye)}}}let se=y.locToIndex([W,Y,K,te],z,y.computeStrides(L));G[se]=ne}}}return{dataId:c.write(y.toTypedArray(G,r.dtype),L,r.dtype),shape:L,dtype:r.dtype}}};T();var YV={kernelName:Zx,backendName:"cpu",kernelFunc:({inputs:e,backend:n,attrs:t})=>{let{x:r,filter:o,dy:s}=e,{strides:i,pad:a,dilations:c}=t,l=n,u=y.toNestedArray(r.shape,l.data.get(r.dataId).values),p=y.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:h,outHeight:g,outWidth:x,padInfo:v,strideHeight:w,strideWidth:I,filterHeight:_,filterWidth:A,dilationHeight:R,dilationWidth:F,outShape:P}=S.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",c);y.assert(s.rank===P.length,()=>`Error in ${Zx}, dy must have the same rank as output ${P.length}, but got ${s.rank}`);let L=y.toNestedArray(P,l.data.get(s.dataId).values),V=y.makeZerosNestedTypedArray(o.shape,o.dtype);for(let G=0;G<d;++G)for(let j=0;j<g;++j){let W=j*w-v.top;for(let Y=0;Y<x;++Y){let Z=Y*I-v.left;for(let K=0;K<h;++K){let Q=Number.MIN_SAFE_INTEGER,te=0,ne=0;for(let se=0;se<_;++se){let re=W+se*R;if(re>=0&&re<f)for(let ae=0;ae<A;++ae){let oe=Z+ae*F;if(oe>=0&&oe<m){let ue=u[G][re][oe][K]+p[se][ae][K];ue>Q&&(Q=ue,te=se,ne=ae)}}}V[te][ne][K]+=L[G][j][Y][K]}}}return{dataId:l.write(y.toTypedArray(V,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};T();var ZV={kernelName:Yx,backendName:"cpu",kernelFunc:({inputs:e,backend:n,attrs:t})=>{let{x:r,filter:o,dy:s}=e,{strides:i,pad:a,dilations:c}=t,l=n,u=y.toNestedArray(r.shape,l.data.get(r.dataId).values),p=y.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:h,outHeight:g,outWidth:x,padInfo:v,strideHeight:w,strideWidth:I,filterHeight:_,filterWidth:A,dilationHeight:R,dilationWidth:F,outShape:P}=S.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",c);y.assert(s.rank===P.length,()=>`Error in ${Yx}, dy must have the same rank as output ${P.length}, but got ${s.rank}`);let L=y.toNestedArray(P,l.data.get(s.dataId).values),V=y.makeZerosNestedTypedArray(r.shape,r.dtype);for(let G=0;G<d;++G)for(let j=0;j<g;++j){let W=j*w-v.top;for(let Y=0;Y<x;++Y){let Z=Y*I-v.left;for(let K=0;K<h;++K){let Q=Number.MIN_SAFE_INTEGER,te=W<0?0:W,ne=Z<0?0:Z;for(let se=0;se<_;++se){let re=W+se*R;if(re>=0&&re<f)for(let ae=0;ae<A;++ae){let oe=Z+ae*F;if(oe>=0&&oe<m){let ue=u[G][re][oe][K]+p[se][ae][K];ue>Q&&(Q=ue,te=re,ne=oe)}}}V[G][te][ne][K]+=L[G][j][Y][K]}}}return{dataId:l.write(y.toTypedArray(V,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};T();function Woe(e){let{inputs:n,backend:t,attrs:r}=e,{image:o}=n,{canvas:s,options:i}=r,{contextOptions:a,imageOptions:c}=i||{},l=c?.alpha||1,u=a?.contextType||"2d";if(u!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);let p=s.getContext(u,a?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${u} type.`);let[d,f]=o.shape.slice(0,2),m=o.shape.length===2?1:o.shape[2],h=t.data.get(o.dataId).values,g=o.dtype==="float32"?255:1,x=new Uint8ClampedArray(f*d*4);for(let w=0;w<d*f;++w){let I=[0,0,0,255*l];for(let A=0;A<m;A++){let R=h[w*m+A];if(o.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(o.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);m===1?(I[0]=R*g,I[1]=R*g,I[2]=R*g):I[A]=R*g}let _=w*4;x[_+0]=Math.round(I[0]),x[_+1]=Math.round(I[1]),x[_+2]=Math.round(I[2]),x[_+3]=Math.round(I[3])}s.width=f,s.height=d;let v=new ImageData(x,f,d);return p.putImageData(v,0,0),o}var QV={kernelName:zp,backendName:"cpu",kernelFunc:Woe};T();T();function Bs(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r;X(o,"sum");let a;o.dtype==="bool"?a=Gr({inputs:{x:o},backend:t,attrs:{dtype:"int32"}}):a=mn({inputs:{x:o},backend:t});let c=a.shape.length,l=y.parseAxisParam(s,a.shape),u=S.getAxesPermutation(l,c),p=l,d=a;u!=null&&(d=Ct({inputs:{x:a},backend:t,attrs:{perm:u}}),p=S.getInnerMostAxes(p.length,c)),S.assertAxesAreInnerMostDims("sum",p,d.shape.length);let[f,m]=S.computeOutAndReduceShapes(d.shape,p),h=S.upcastType(d.dtype,"int32"),g=Sd(t,f,h),x=y.sizeFromShape(m),v=t.data.get(g.dataId).values,w=t.data.get(d.dataId).values;for(let I=0;I<v.length;++I){let _=I*x,A=0;for(let R=0;R<x;++R)A+=w[_+R];v[I]=A}if(i){let I=S.expandShapeToKeepDim(g.shape,l),_=g;g=Re({inputs:{x:g},backend:t,attrs:{shape:I}}),t.disposeIntermediateTensorInfo(_)}return t.disposeIntermediateTensorInfo(a),u!=null&&t.disposeIntermediateTensorInfo(d),g}var JV={kernelName:"Sum",backendName:"cpu",kernelFunc:Bs};function joe(e){let{inputs:n,backend:t,attrs:r}=e,{equation:o}=r,s=n,{allDims:i,summedDims:a,idDims:c}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,c,s);let{path:l,steps:u}=S.getEinsumComputePath(a,c),p=u.length,d=null,f=i.length,m=[];for(let h=0;h<p;++h){for(let g of u[h]){let{permutationIndices:x,expandDims:v}=S.getEinsumPermutation(f,c[g]),w;S.isIdentityPermutation(x)?w=s[g]:(w=Ct({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),m.push(w));let I=w.shape.slice();for(let _=0;_<v.length;++_)I.splice(v[_],0,1);y.arraysEqual(w.shape,I)||(w=Re({inputs:{x:w},backend:t,attrs:{shape:I}}),m.push(w)),d===null?d=w:(d=Gu({inputs:{a:w,b:d},backend:t}),m.push(d))}h<p-1&&(l[h]>=0&&(d=Bs({inputs:{x:d},backend:t,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),m.push(d)),f--)}for(let h of m)h!==d&&t.disposeIntermediateTensorInfo(h);return d}var e3={kernelName:Jc,backendName:"cpu",kernelFunc:joe};T();function qoe(e){let{inputs:n,backend:t}=e,{dy:r,y:o}=n;X([r,o],"eluGrad");let s=new Float32Array(y.sizeFromShape(o.shape)),i=t.data.get(o.dataId).values,a=t.data.get(r.dataId).values;for(let c=0;c<i.length;++c){let l=i[c];l>=0?s[c]=a[c]:s[c]=a[c]*(l+1)}return t.makeTensorInfo(o.shape,"float32",s)}var t3={kernelName:cm,backendName:"cpu",kernelFunc:qoe};T();var Koe=S.ERF_P,Xoe=S.ERF_A1,Yoe=S.ERF_A2,Zoe=S.ERF_A3,Qoe=S.ERF_A4,Joe=S.ERF_A5,ese=he("Erf",e=>{let n=Math.sign(e),t=Math.abs(e),r=1/(1+Koe*t);return n*(1-((((Joe*r+Qoe)*r+Zoe)*r+Yoe)*r+Xoe)*r*Math.exp(-t*t))}),n3={kernelName:"Erf",backendName:"cpu",kernelFunc:ese};T();function Rd(e){let{inputs:n,backend:t,attrs:r}=e,{input:o}=n,{dim:s}=r,i=o.shape.length,a=o.shape.slice(),c=s;return s<0&&(y.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),c=i+s+1),a.splice(c,0,1),Re({inputs:{x:o},backend:t,attrs:{shape:a}})}var r3={kernelName:rl,backendName:"cpu",kernelFunc:Rd};T();T();T();var tse=Ae((e,n)=>e/n),Dh=Ge(Si,tse),kh={kernelName:Si,backendName:"cpu",kernelFunc:Dh};function Fv(e,n,t){let r=e.shape,o=r[0],s=r[1],i=t.data.get(e.dataId),a=i.complexTensorInfos.real,c=i.complexTensorInfos.imag,l=[o,s],u=y.sizeFromShape(l),p=y.getTypedArrayFromDType("float32",u),d=y.getTypedArrayFromDType("float32",u);for(let g=0;g<o;g++){let x=Wr({inputs:{x:a},backend:t,attrs:{begin:[g,0],size:[1,s]}}),v=Wr({inputs:{x:c},backend:t,attrs:{begin:[g,0],size:[1,s]}}),w=Gt({inputs:{real:x,imag:v},backend:t}),{real:I,imag:_}=nse(w,n,t),A=S.mergeRealAndImagArrays(I,_);for(let R=0;R<s;R++){let F=S.getComplexWithIndex(A,R);p[g*s+R]=F.real,d[g*s+R]=F.imag}t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(w)}let f=t.makeTensorInfo(l,"float32",p),m=t.makeTensorInfo(l,"float32",d),h=Gt({inputs:{real:f,imag:m},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),h}function nse(e,n,t){let r=y.sizeFromShape(e.shape),o=t.data.get(e.dataId),s=t.data.get(o.complexTensorInfos.real.dataId).values,i=t.data.get(o.complexTensorInfos.imag.dataId).values;if(rse(r)){let a=MD(s,i,r,n,t),c=[e.shape[0],e.shape[1]];if(n){let l=t.makeTensorInfo(c,"float32",a.real),u=t.makeTensorInfo(c,"float32",a.imag),p=t.makeTensorInfo([],"float32",y.createScalarValue(r,"float32")),d=mn({inputs:{x:p},backend:t}),f=kh.kernelFunc({inputs:{a:l,b:p},backend:t}),m=kh.kernelFunc({inputs:{a:u,b:d},backend:t}),h=t.data.get(f.dataId).values,g=t.data.get(m.dataId).values;return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),{real:h,imag:g}}return a}else{let a=S.mergeRealAndImagArrays(s,i),c=ose(a,r,n);return S.splitRealAndImagArrays(c)}}function rse(e){return(e&e-1)===0}function MD(e,n,t,r,o){if(t===1)return{real:e,imag:n};let s=S.mergeRealAndImagArrays(e,n),i=t/2,a=S.complexWithEvenIndex(s),c=a.real,l=a.imag,u=[c.length],p=o.makeTensorInfo(u,"float32",c),d=o.makeTensorInfo(u,"float32",l),f=Gt({inputs:{real:p,imag:d},backend:o}),m=S.complexWithOddIndex(s),h=m.real,g=m.imag,x=[h.length],v=o.makeTensorInfo(x,"float32",h),w=o.makeTensorInfo(x,"float32",g),I=Gt({inputs:{real:v,imag:w},backend:o}),_=MD(c,l,i,r,o),A=_.real,R=_.imag,F=[A.length],P=o.makeTensorInfo(F,"float32",A),L=o.makeTensorInfo(F,"float32",R),V=Gt({inputs:{real:P,imag:L},backend:o}),z=MD(h,g,i,r,o),G=z.real,j=z.imag,W=[G.length],Y=o.makeTensorInfo(W,"float32",G),Z=o.makeTensorInfo(W,"float32",j),K=Gt({inputs:{real:Y,imag:Z},backend:o}),Q=S.exponents(t,r),te=[Q.real.length],ne=o.makeTensorInfo(te,"float32",Q.real),se=o.makeTensorInfo(te,"float32",Q.imag),re=Gt({inputs:{real:ne,imag:se},backend:o}),ae=Gu({inputs:{a:re,b:K},backend:o}),oe=Yo({inputs:{a:V,b:ae},backend:o}),ue=Sh({inputs:{a:V,b:ae},backend:o}),xe=zr({inputs:{input:oe},backend:o}),be=zr({inputs:{input:ue},backend:o}),ye=Zo({inputs:{input:oe},backend:o}),Oe=Zo({inputs:{input:ue},backend:o}),Pe=Ra({inputs:[xe,be],backend:o,attrs:{axis:0}}),st=Ra({inputs:[ye,Oe],backend:o,attrs:{axis:0}}),mt=o.data.get(Pe.dataId).values,$t=o.data.get(st.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(I),o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(L),o.disposeIntermediateTensorInfo(V),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(Z),o.disposeIntermediateTensorInfo(K),o.disposeIntermediateTensorInfo(ne),o.disposeIntermediateTensorInfo(se),o.disposeIntermediateTensorInfo(re),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(oe),o.disposeIntermediateTensorInfo(ue),o.disposeIntermediateTensorInfo(xe),o.disposeIntermediateTensorInfo(ye),o.disposeIntermediateTensorInfo(be),o.disposeIntermediateTensorInfo(Oe),o.disposeIntermediateTensorInfo(Pe),o.disposeIntermediateTensorInfo(st),{real:mt,imag:$t}}function ose(e,n,t){let r=new Float32Array(n*2);for(let o=0;o<n;o++){let s=0,i=0;for(let a=0;a<n;a++){let c=S.exponent(o*a,n,t),l=S.getComplexWithIndex(e,a);s+=l.real*c.real-l.imag*c.imag,i+=l.real*c.imag+l.imag*c.real}t&&(s/=n,i/=n),S.assignToTypedArray(r,s,i,o)}return r}function sse(e){let{inputs:n,backend:t}=e,{input:r}=n,o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=Re({inputs:{x:r},backend:t,attrs:{shape:[i,s]}}),c=Fv(a,!1,t),l=Re({inputs:{x:c},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),l}var o3={kernelName:"FFT",backendName:"cpu",kernelFunc:sse};T();function _h(e){let{backend:n,attrs:t}=e,{shape:r,value:o,dtype:s}=t,i=s||y.inferDtype(o),a=y.getArrayFromDType(i,y.sizeFromShape(r));return ise(a,o,i),n.makeTensorInfo(r,i,a)}var s3={kernelName:ol,backendName:"cpu",kernelFunc:_h};function ise(e,n,t){e.fill(n)}T();var i3={kernelName:sl,backendName:"cpu",kernelFunc:({inputs:e,attrs:n,backend:t})=>{let{image:r}=e,o=t,s=y.getTypedArrayFromDType(r.dtype,y.sizeFromShape(r.shape)),[i,a,c,l]=r.shape,u=o.data.get(r.dataId).values;for(let d=0;d<i;d++){let f=d*c*a*l;for(let m=0;m<a;m++){let h=m*(c*l);for(let g=0;g<c;g++){let x=g*l;for(let v=0;v<l;v++){let w=Math.round(c-g-1),I=f+h+x+v,_=u[I];if(w>=0&&w<c){let A=w*l,R=f+h+A+v;_=u[R]}s[I]=_}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};T();function ase(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:c,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,h=FD({inputs:{x:o,filter:s},backend:t,attrs:{strides:c,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d}});if(i){let g=h;if(u==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let x=Re({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});h=Yo({inputs:{a:h,b:x},backend:t}),t.disposeIntermediateTensorInfo(x)}else h=Yo({inputs:{a:h,b:i},backend:t});t.disposeIntermediateTensorInfo(g)}if(f){let g=h;if(u==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){let x=Re({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});h=Hu(t,h,f,x,m),t.disposeIntermediateTensorInfo(x)}else h=Hu(t,h,f,a,m);t.disposeIntermediateTensorInfo(g)}return h}var a3={kernelName:ca,backendName:"cpu",kernelFunc:ase};T();function cse(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:c,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,h=OD({inputs:{x:o,filter:s},backend:t,attrs:{strides:c,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d}});if(i){let g=h;h=Yo({inputs:{a:h,b:i},backend:t}),t.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=Hu(t,h,f,a,m),t.disposeIntermediateTensorInfo(g)}return h}var c3={kernelName:la,backendName:"cpu",kernelFunc:cse};T();function lse(e){let{inputs:n,backend:t}=e,{params:r,indices:o}=n,s=y.sizeFromShape(r.shape),i=o.shape,a=i[i.length-1],[c,l,u,p]=S.prepareAndValidate(r,o);if(l===0)return t.makeTensorInfo(c,r.dtype,[]);let d=t.data.get(o.dataId).values,f=t.bufferSync(r),m=mv(d,f,r.dtype,l,a,u,p,r.shape,s);return t.makeTensorInfo(c,r.dtype,m.values)}var l3={kernelName:cl,backendName:"cpu",kernelFunc:lse};T();function use(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,indices:s}=n,{axis:i,batchDims:a}=r;X([o,s],"gatherV2");let c=y.parseAxisParam(i,o.shape)[0],l=t.data.get(s.dataId).values,u=o.shape[c];for(let I=0;I<l.length;++I){let _=l[I];y.assert(_<=u-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${u-1}]`)}let p=a;a==null&&(p=0);let d=y.sizeFromShape(s.shape),f=S.segment_util.collectGatherOpShapeInfo(o,s,c,p),m=Re({inputs:{x:o},backend:t,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),h=Re({inputs:{x:s},backend:t,attrs:{shape:[f.batchSize,d/f.batchSize]}}),g=[f.batchSize,f.outerSize,d/f.batchSize,f.sliceSize],x=t.bufferSync(h),v=t.bufferSync(m),w=hv(v,x,g);return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),t.makeTensorInfo(f.outputShape,w.dtype,w.values)}var u3={kernelName:al,backendName:"cpu",kernelFunc:use};T();function pse(e){let{inputs:n,backend:t}=e,{input:r}=n,o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=Re({inputs:{x:r},backend:t,attrs:{shape:[i,s]}}),c=Fv(a,!0,t),l=Re({inputs:{x:c},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),l}var p3={kernelName:ll,backendName:"cpu",kernelFunc:pse};T();var dse=he(Fi,e=>Number.isFinite(e)?1:0,"bool"),d3={kernelName:Fi,backendName:"cpu",kernelFunc:dse};T();var fse=he(Oi,e=>Math.abs(e)===1/0?1:0,"bool"),f3={kernelName:Oi,backendName:"cpu",kernelFunc:fse};T();var mse=he(Mi,e=>Number.isNaN(e)?1:0,"bool"),m3={kernelName:Mi,backendName:"cpu",kernelFunc:mse};T();function hse(e){let{backend:n,attrs:t}=e,{start:r,stop:o,num:s}=t,i=gv(r,o,s);return n.makeTensorInfo([i.length],"float32",i)}var h3={kernelName:dl,backendName:"cpu",kernelFunc:hse};T();var gse=he(Li,e=>Math.log1p(e)),g3={kernelName:Li,backendName:"cpu",kernelFunc:gse};T();var xse=Ae((e,n)=>e&&n),yse=Ge(Bi,xse,null,"bool"),x3={kernelName:Bi,backendName:"cpu",kernelFunc:yse};T();var vse=he(Vi,e=>e?0:1,"bool"),y3={kernelName:Vi,backendName:"cpu",kernelFunc:vse};T();var bse=Ae((e,n)=>e||n),Cse=Ge(Ui,bse,null,"bool"),v3={kernelName:Ui,backendName:"cpu",kernelFunc:Cse};T();function wse(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{depthRadius:s,bias:i,alpha:a,beta:c}=r;X(o,"LRN");let l=o.shape[3],u=l-1,p=t.data.get(o.dataId).values,d=y.sizeFromShape(o.shape),f=new Float32Array(d);function m(h){let g=h%l,x=h-g+Math.max(0,g-s),v=h-g+Math.min(g+s,u),w=0;for(;x<=v;x++){let I=p[x];w+=I*I}return w}for(let h=0;h<d;h++){let g=m(h),x=p[h]*Math.pow(i+a*g,-c);f[h]=x}return t.makeTensorInfo(o.shape,o.dtype,f)}var b3={kernelName:"LRN",backendName:"cpu",kernelFunc:wse};T();function Ise(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,y:s,dy:i}=n,{depthRadius:a,bias:c,alpha:l,beta:u}=r;X(i,"LRNGrad");let p=y.sizeFromShape(i.shape),d=i.shape[3],f=t.data.get(i.dataId).values,m=t.data.get(o.dataId).values,h=t.data.get(s.dataId).values,g=new Float32Array(p),x=p;for(let v=0;v<x;v++){let w=v%d,I=v-w+Math.max(0,w-a),_=v-w+Math.min(d,w+a+1),A=0;for(let R=I;R<_;R++)A+=Math.pow(m[R],2);A=l*A+c;for(let R=I;R<_;R++){let F=-2*l*u*m[R]*h[v]/A;v===R&&(F+=Math.pow(A,-u)),F*=f[v],g[R]+=F}}return t.makeTensorInfo(i.shape,o.dtype,g)}var C3={kernelName:lm,backendName:"cpu",kernelFunc:Ise};T();T();T();function $D(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{reductionIndices:s,keepDims:i}=r,a=t,c=o.shape,l=c.length,u=y.parseAxisParam(s,c),p=u,d=S.getAxesPermutation(p,l),f=a.data.get(o.dataId).values;if(d!=null){let I=new Array(l);for(let _=0;_<I.length;_++)I[_]=c[d[_]];f=kd(f,c,o.dtype,d,I),p=S.getInnerMostAxes(p.length,l),c=I}X(o,"max"),S.assertAxesAreInnerMostDims("max",p,l);let[m,h]=S.computeOutAndReduceShapes(c,p),g=y.sizeFromShape(h),x=xv(f,g,m,o.dtype),v=a.write(x,m,o.dtype),w=m;return i&&(w=S.expandShapeToKeepDim(m,u)),{dataId:v,shape:w,dtype:o.dtype}}var w3={kernelName:"Max",backendName:"cpu",kernelFunc:$D};T();function Ese(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n;X(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let u=S.computePool2DInfo(o.shape,s,i,l,a,c),p;if(u.filterWidth===1&&u.filterHeight===1&&y.arraysEqual(u.inShape,u.outShape))p=mn({inputs:{x:o},backend:t});else{let d=t.data.get(o.dataId).values,f=y.computeStrides(o.shape),m=Ad(d,o.shape,o.dtype,f,u,"max");p=t.makeTensorInfo(u.outShape,o.dtype,m.values)}return p}var I3={kernelName:ml,backendName:"cpu",kernelFunc:Ese};T();function Tse(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:c,dataFormat:l}=r;X(o,"maxPool3d");let u=S.computePool3DInfo(o.shape,s,i,1,a,c,l),p=t.data.get(o.dataId).values,d=Rv(p,o.shape,o.dtype,y.computeStrides(o.shape),u,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}var E3={kernelName:hl,backendName:"cpu",kernelFunc:Tse};T();function Sse(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,input:s}=n,{filterSize:i,strides:a,pad:c,dimRoundingMode:l}=r;X([o,s],"maxPool3DGrad");let u=S.computePool3DInfo(s.shape,i,a,1,c,l),p=t.bufferSync(s),d=vV(p,u),f=u.strideDepth,m=u.strideHeight,h=u.strideWidth,g=u.dilationDepth,x=u.dilationHeight,v=u.dilationWidth,w=u.effectiveFilterDepth,I=u.effectiveFilterHeight,_=u.effectiveFilterWidth,A=w-1-u.padInfo.front,R=_-1-u.padInfo.left,F=I-1-u.padInfo.top,P=le(s.shape,"float32"),L=t.bufferSync(o);for(let V=0;V<u.batchSize;++V)for(let z=0;z<u.inChannels;++z)for(let G=0;G<u.inDepth;++G)for(let j=0;j<u.inHeight;++j)for(let W=0;W<u.inWidth;++W){let Y=G-A,Z=j-F,K=W-R,Q=0;for(let te=0;te<w;te+=g){let ne=(Y+te)/f;if(!(ne<0||ne>=u.outDepth||Math.floor(ne)!==ne))for(let se=0;se<I;se+=x){let re=(Z+se)/m;if(!(re<0||re>=u.outHeight||Math.floor(re)!==re))for(let ae=0;ae<_;ae+=v){let oe=(K+ae)/h;if(oe<0||oe>=u.outWidth||Math.floor(oe)!==oe)continue;let ue=w*I*_-1-d.get(V,ne,re,oe,z),xe=te*I*_+se*_+ae,be=ue===xe?1:0;if(be===0)continue;let ye=L.get(V,ne,re,oe,z);Q+=ye*be}}}P.set(Q,V,G,j,W,z)}return t.makeTensorInfo(P.shape,P.dtype,P.values)}var T3={kernelName:pm,backendName:"cpu",kernelFunc:Sse};T();function Nse(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,input:s,output:i}=n,a=s;X([s,i],"maxPoolGrad");let{filterSize:c,strides:l,pad:u,dimRoundingMode:p}=r,d=S.computePool2DInfo(a.shape,c,l,1,u,p),f=t.data.get(a.dataId).values,m=le(d.outShape,a.dtype,Av(f,a.shape,a.dtype,d).values),h=d.strideHeight,g=d.strideWidth,x=d.dilationHeight,v=d.dilationWidth,w=d.effectiveFilterHeight,I=d.effectiveFilterWidth,_=I-1-d.padInfo.left,A=w-1-d.padInfo.top,R=le(a.shape,"float32"),F=t.data.get(o.dataId).values,P=le(o.shape,"float32",F);for(let L=0;L<d.batchSize;++L)for(let V=0;V<d.inChannels;++V)for(let z=0;z<d.inHeight;++z)for(let G=0;G<d.inWidth;++G){let j=z-A,W=G-_,Y=0;for(let Z=0;Z<w;Z+=x){let K=(j+Z)/h;if(!(K<0||K>=d.outHeight||Math.floor(K)!==K))for(let Q=0;Q<I;Q+=v){let te=(W+Q)/g;if(te<0||te>=d.outWidth||Math.floor(te)!==te)continue;let ne=w*I-1-m.get(L,K,te,V),se=Z*I+Q,re=ne===se?1:0;if(re===0)continue;let ae=P.get(L,K,te,V);Y+=ae*re}}R.set(Y,L,z,G,V)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}var S3={kernelName:um,backendName:"cpu",kernelFunc:Nse};T();T();T();function N3(e,n,t,r,o){let s=y.computeStrides(n),i=Ad(e,n,t,s,o,"max"),a=Av(e,n,t,o,!0,r);return[i.values,a.values]}var D3={kernelName:gl,backendName:"cpu",kernelFunc:({inputs:e,attrs:n,backend:t})=>{let{x:r}=e,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=n,c=t;X(r,"MaxPoolWithArgmax");let l=c.data.get(r.dataId).values,u=S.computePool2DInfo(r.shape,o,s,[1,1],i),[p,d]=N3(l,r.shape,r.dtype,a,u),f=c.write(p,u.outShape,r.dtype),m=c.write(d,u.outShape,r.dtype);return[{dataId:f,shape:u.outShape,dtype:r.dtype},{dataId:m,shape:u.outShape,dtype:"int32"}]}};T();function Dse(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r,a=y.parseAxisParam(s,o.shape),l=S.computeOutAndReduceShapes(o.shape,a)[1],u=y.sizeFromShape(l),p=[],d=t.makeTensorInfo([],"float32",new Float32Array([u]));p.push(d);let f=Gr({inputs:{x:o},backend:t,attrs:{dtype:"float32"}});p.push(f);let m=Dh({inputs:{a:f,b:d},backend:t});p.push(m);let h=Bs({inputs:{x:m},backend:t,attrs:{axis:s,keepDims:i}});return p.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}var k3={kernelName:xl,backendName:"cpu",kernelFunc:Dse};T();function kse(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r;X(o,"min");let a=y.parseAxisParam(s,o.shape),c=a,l=S.getAxesPermutation(c,o.shape.length),u=o;l!=null&&(u=Ct({inputs:{x:o},backend:t,attrs:{perm:l}}),c=S.getInnerMostAxes(c.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",c,u.shape.length);let[p,d]=S.computeOutAndReduceShapes(u.shape,c),f=y.sizeFromShape(d),m=y.makeZerosTypedArray(y.sizeFromShape(p),u.dtype),h=t.data.get(u.dataId).values;for(let x=0;x<m.length;++x){let v=x*f,w=h[v];for(let I=0;I<f;++I){let _=h[v+I];(Number.isNaN(_)||_<w)&&(w=_)}m[x]=w}l!=null&&t.disposeIntermediateTensorInfo(u);let g=t.makeTensorInfo(p,u.dtype,m);if(i){let x=S.expandShapeToKeepDim(p,a),v=Re({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),v}return g}var _3={kernelName:"Min",backendName:"cpu",kernelFunc:kse};T();function _se(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{paddings:s,mode:i}=r;X(o,"mirrorPad");let a=s.map((w,I)=>w[0]+o.shape[I]+w[1]),c=s.map(w=>w[0]),l=s.map((w,I)=>w[0]+o.shape[I]),u=i==="reflect"?0:1,p=t.data.get(o.dataId).values,d=o.shape.length,f=y.computeStrides(o.shape),m=y.sizeFromShape(a),h=a.length,g=y.computeStrides(a),x=y.getTypedArrayFromDType(o.dtype,m);for(let w=0;w<m;w++){let I=y.indexToLoc(w,h,g);for(let A=0;A<h;A++)I[A]<c[A]?I[A]=c[A]*2-I[A]-u:I[A]>=l[A]&&(I[A]=(l[A]-1)*2-I[A]+u);I=I.map((A,R)=>A-c[R]);let _=y.locToIndex(I,d,f);x[w]=p[_]}return{dataId:t.write(x,a,o.dtype),shape:a,dtype:o.dtype}}var A3={kernelName:yl,backendName:"cpu",kernelFunc:_se};T();var Ase=Ae((e,n)=>{let t=e%n;return e<0&&n<0||e>=0&&n>=0?t:(t+n)%n}),Rse=Ge("Mod",Ase),R3={kernelName:"Mod",backendName:"cpu",kernelFunc:Rse};T();var O3=tg(FS());T();function PD(e){let{inputs:n,backend:t,attrs:r}=e,{logits:o}=n,{dim:s}=r,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let c=y.parseAxisParam([a],o.shape),l=$D({inputs:{x:o},backend:t,attrs:{reductionIndices:c,keepDims:!1}}),u=S.expandShapeToKeepDim(l.shape,c),p=Re({inputs:{x:l},backend:t,attrs:{shape:u}}),d=Sh({inputs:{a:o,b:p},backend:t}),f=oD({inputs:{x:d},backend:t}),m=Bs({inputs:{x:f},backend:t,attrs:{axis:c,keepDims:!1}}),h=Re({inputs:{x:m},backend:t,attrs:{shape:u}}),g=Dh({inputs:{a:f,b:h},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),g}var F3={kernelName:Kl,backendName:"cpu",kernelFunc:PD};function Fse(e){let{inputs:n,backend:t,attrs:r}=e,{logits:o}=n,{numSamples:s,seed:i,normalized:a}=r;X(o,"multinomial");let c=a?o:PD({inputs:{logits:o},backend:t,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],p=t.data.get(c.dataId).values,d=[l,s],f=y.makeZerosTypedArray(y.sizeFromShape(d),"int32");for(let m=0;m<l;++m){let h=m*u,g=new Float32Array(u-1);g[0]=p[h];for(let w=1;w<g.length;++w)g[w]=g[w-1]+p[h+w];let x=O3.alea(i.toString()),v=m*s;for(let w=0;w<s;++w){let I=x();f[v+w]=g.length;for(let _=0;_<g.length;_++)if(I<g[_]){f[v+w]=_;break}}}return a||t.disposeIntermediateTensorInfo(c),t.makeTensorInfo(d,"int32",f)}var M3={kernelName:bl,backendName:"cpu",kernelFunc:Fse};T();var Ose=sn.nonMaxSuppressionV3Impl;function Mse(e){let{inputs:n,backend:t,attrs:r}=e,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c}=r;X(o,"NonMaxSuppression");let l=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,{selectedIndices:p}=Ose(l,u,i,a,c);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}var $3={kernelName:Cl,backendName:"cpu",kernelFunc:Mse};T();var $se=sn.nonMaxSuppressionV4Impl;function Pse(e){let{inputs:n,backend:t,attrs:r}=e,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,padToMaxOutputSize:l}=r;X(o,"NonMaxSuppressionPadded");let u=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,{selectedIndices:d,validOutputs:f}=$se(u,p,i,a,c,l);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var P3={kernelName:wl,backendName:"cpu",kernelFunc:Pse};T();var Lse=sn.nonMaxSuppressionV5Impl;function Bse(e){let{inputs:n,backend:t,attrs:r}=e,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,softNmsSigma:l}=r;X(o,"NonMaxSuppressionWithScore");let u=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,d=i,f=a,m=c,h=l,{selectedIndices:g,selectedScores:x}=Lse(u,p,d,f,m,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var L3={kernelName:Il,backendName:"cpu",kernelFunc:Bse};T();function Vse(e){let{inputs:n,backend:t,attrs:r}=e,{indices:o}=n,{dtype:s,depth:i,onValue:a,offValue:c}=r;X(o,"oneHot");let l=y.sizeFromShape(o.shape),u=new Float32Array(l*i);u.fill(c);let p=t.data.get(o.dataId).values;for(let d=0;d<l;++d)p[d]>=0&&p[d]<i&&(u[d*i+p[d]]=a);return t.makeTensorInfo([...o.shape,i],s,u)}var B3={kernelName:Tl,backendName:"cpu",kernelFunc:Vse};T();T();function Ah(e){let{inputs:n,backend:t}=e,{x:r}=n;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let o=zr({inputs:{input:r},backend:t}),s=Ah({inputs:{x:o},backend:t}),i=Zo({inputs:{input:r},backend:t}),a=Ah({inputs:{x:i},backend:t}),c=Gt({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return _h({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var V3={kernelName:pu,backendName:"cpu",kernelFunc:Ah};function U3(e){let{inputs:n,backend:t}=e,{x:r}=n;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let o=zr({inputs:{input:r},backend:t}),s=U3({inputs:{x:o},backend:t}),i=Zo({inputs:{input:r},backend:t}),a=Ah({inputs:{x:i},backend:t}),c=Gt({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return _h({backend:t,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var z3={kernelName:El,backendName:"cpu",kernelFunc:U3};T();function LD(e){let{inputs:n,backend:t,attrs:r}=e,{axis:o}=r;if(n.length===1)return Rd({inputs:{input:n[0]},backend:t,attrs:{dim:o}});let s=n[0].shape,i=n[0].dtype;n.forEach(u=>{y.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],c=n.map(u=>{let p=Rd({inputs:{input:u},backend:t,attrs:{dim:o}});return a.push(p),p}),l=Ra({inputs:c,backend:t,attrs:{axis:o}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),l}var G3={kernelName:Sl,backendName:"cpu",kernelFunc:LD};T();function Use(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{paddings:s,constantValue:i}=r;X(o,"pad");let a=s.map((v,w)=>v[0]+o.shape[w]+v[1]),c=s.map(v=>v[0]),l=t.data.get(o.dataId).values,u=y.sizeFromShape(o.shape),p=o.shape.length,d=y.computeStrides(o.shape),f=y.sizeFromShape(a),m=a.length,h=y.computeStrides(a),g=y.getTypedArrayFromDType(o.dtype,f);i!==0&&g.fill(i);for(let v=0;v<u;v++){let I=y.indexToLoc(v,p,d).map((A,R)=>A+c[R]),_=y.locToIndex(I,m,h);g[_]=l[v]}return{dataId:t.write(g,a,o.dtype),shape:a,dtype:o.dtype}}var Ov={kernelName:Nl,backendName:"cpu",kernelFunc:Use};T();var zse=Ae((e,n)=>Math.pow(e,n)),Gse=Ge("Pow",zse),H3={kernelName:"Pow",backendName:"cpu",kernelFunc:Gse};T();function Hse(e){let{inputs:n,backend:t,attrs:r}=e,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=n,{outputRaggedRank:a}=r,c=o.map(x=>t.data.get(x.dataId).values),l=o.map(x=>x.shape),u=t.data.get(s.dataId).values,p=t.data.get(i.dataId).values,[d,f,m]=yv(c,l,u,s.shape,s.dtype,p,i.shape,a),h=d.map(x=>t.makeTensorInfo([x.length],"int32",x)),g=t.makeTensorInfo(m,s.dtype,f);return h.concat([g])}var W3={kernelName:Al,backendName:"cpu",kernelFunc:Hse};T();function Wse(e){let{inputs:n,backend:t}=e,{starts:r,limits:o,deltas:s}=n,i=t.data.get(r.dataId).values,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,[l,u]=vv(i,r.shape,r.dtype,a,o.shape,c,s.shape),p=t.makeTensorInfo([l.length],"int32",l),d=t.makeTensorInfo([u.length],r.dtype,u);return[p,d]}var j3={kernelName:Rl,backendName:"cpu",kernelFunc:Wse};T();function jse(e){let{inputs:n,backend:t,attrs:r}=e,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:c}=r,l=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,p=t.data.get(i.dataId).values,d=a.map(g=>t.data.get(g.dataId).values),f=a.map(g=>g.shape),[m,h]=bv(l,o.shape,u,s.shape,s.dtype,p,i.shape,d,f,c);return t.makeTensorInfo(m,s.dtype,h)}var q3={kernelName:Fl,backendName:"cpu",kernelFunc:jse};T();function qse(e){let{backend:n,attrs:t}=e,{start:r,stop:o,dtype:s,step:i}=t,a=Cv(r,o,i,s);return n.makeTensorInfo([a.length],s,a)}var K3={kernelName:Ol,backendName:"cpu",kernelFunc:qse};T();var Kse=he(ji,e=>1/e),X3={kernelName:ji,backendName:"cpu",kernelFunc:Kse};T();function Xse(e){let{inputs:n,backend:t,attrs:r}=e,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r;X(o,"resizeBilinear");let c=y.computeStrides(o.shape),[l,u]=a,[p,d,f,m]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(y.sizeFromShape([p,l,u,m])),x=[s&&l>1?d-1:d,s&&u>1?f-1:f],v=[s&&l>1?l-1:l,s&&u>1?u-1:u],w=0,I=x[0]/v[0],_=x[1]/v[1];for(let A=0;A<p;A++)for(let R=0;R<l;R++){let F;i?F=I*(R+.5)-.5:F=I*R;let P=Math.max(0,Math.floor(F)),L=F-P,V=Math.min(d-1,Math.ceil(F)),z=A*c[0]+P*c[1],G=A*c[0]+V*c[1];for(let j=0;j<u;j++){let W;i?W=_*(j+.5)-.5:W=_*j;let Y=Math.max(0,Math.floor(W)),Z=W-Y,K=Math.min(f-1,Math.ceil(W)),Q=z+Y*c[2],te=G+Y*c[2],ne=z+K*c[2],se=G+K*c[2];for(let re=0;re<m;re++){let ae=h[Q+re],oe=h[te+re],ue=h[ne+re],xe=h[se+re],be=ae+(ue-ae)*Z,ye=oe+(xe-oe)*Z,Oe=be+(ye-be)*L;g[w++]=Oe}}}return t.makeTensorInfo([p,l,u,m],"float32",g)}var Y3={kernelName:Ll,backendName:"cpu",kernelFunc:Xse};T();function Yse(e){let{inputs:n,backend:t,attrs:r}=e,{images:o,dy:s}=n,{alignCorners:i}=r;X([s,o],"resizeBilinearGrad");let a=y.computeStrides(o.shape),[c,l,u,p]=o.shape,[,d,f]=s.shape,m=new Float32Array(c*l*u*p),h=[i&&d>1?l-1:l,i&&f>1?u-1:u],g=[i&&d>1?d-1:d,i&&f>1?f-1:f],x=h[0]/g[0],v=h[1]/g[1],w=t.data.get(s.dataId).values,I=0;for(let _=0;_<c;_++){let A=_*a[0];for(let R=0;R<d;R++){let F=R*x,P=Math.floor(F),L=Math.min(Math.ceil(F),l-1),V=A+P*a[1],z=A+L*a[1],G=F-P,j=1-G;for(let W=0;W<f;W++){let Y=W*v,Z=Math.floor(Y),K=Math.min(Math.ceil(Y),u-1),Q=Y-Z,te=1-Q,ne=V+Z*a[2],se=V+K*a[2],re=z+Z*a[2],ae=z+K*a[2],oe=j*te,ue=j*Q,xe=G*te,be=G*Q;for(let ye=0;ye<p;ye++){let Oe=w[I++];m[ne+ye]+=Oe*oe,m[se+ye]+=Oe*ue,m[re+ye]+=Oe*xe,m[ae+ye]+=Oe*be}}}}return t.makeTensorInfo([c,u,l,p],"float32",m)}var Z3={kernelName:fm,backendName:"cpu",kernelFunc:Yse};T();function Zse(e){let{inputs:n,backend:t,attrs:r}=e,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r;X(o,"resizeNearestNeighbor");let c=y.computeStrides(o.shape),[l,u]=a,[p,d,f,m]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(p*l*u*m),x=[s&&l>1?d-1:d,s&&u>1?f-1:f],v=[s&&l>1?l-1:l,s&&u>1?u-1:u],w=x[0]/v[0],I=x[1]/v[1],_=0;for(let A=0;A<p;A++){let R=A*c[0];for(let F=0;F<l;F++){let P=i?w*(F+.5):w*F,L=Math.min(d-1,s?Math.round(P):Math.floor(P));i&&(L=Math.max(0,L));let V=R+L*c[1];for(let z=0;z<u;z++){let G=i?I*(z+.5):I*z,j=Math.min(f-1,s?Math.round(G):Math.floor(G));i&&(j=Math.max(0,j));let W=V+j*c[2];for(let Y=0;Y<m;Y++){let Z=h[W+Y];g[_++]=Z}}}}return t.makeTensorInfo([p,l,u,m],o.dtype,g)}var Q3={kernelName:Pl,backendName:"cpu",kernelFunc:Zse};T();function Qse(e){let{inputs:n,backend:t,attrs:r}=e,{images:o,dy:s}=n,{alignCorners:i}=r;X([s,o],"resizeNearestNeighborGrad");let a=y.computeStrides(o.shape),c=y.computeStrides(s.shape),[l,u,p,d]=o.shape,[,f,m]=s.shape,h=new Float32Array(l*u*p*d),g=t.data.get(s.dataId).values,x=[i&&f>1?u-1:u,i&&m>1?p-1:p],v=[i&&f>1?f-1:f,i&&m>1?m-1:m],w=x[0]/v[0],I=x[1]/v[1],_=1/w,A=1/I,R=Math.ceil(_)*2+2,F=Math.ceil(A)*2+2;for(let P=0;P<l;P++){let L=P*a[0];for(let V=0;V<u;V++){let z=L+V*a[1],G=Math.floor(V*_),j=Math.floor(G-R/2);for(let W=0;W<p;W++){let Y=z+W*a[2],Z=Math.floor(W*A),K=Math.floor(Z-F/2);for(let Q=0;Q<d;Q++){let te=0;for(let ne=0;ne<R;ne++){let se=ne+j;if(se<0||se>=f)continue;let re=L+se*c[1],ae=se*w,oe=Math.min(u-1,i?Math.round(ae):Math.floor(ae));if(V===oe)for(let ue=0;ue<F;ue++){let xe=ue+K;if(xe<0||xe>=m)continue;let be=re+xe*c[2],ye=xe*I,Oe=Math.min(p-1,i?Math.round(ye):Math.floor(ye));W===Oe&&(te+=g[be+Q])}}h[Y+Q]=te}}}}return t.makeTensorInfo(o.shape,o.dtype,h)}var J3={kernelName:dm,backendName:"cpu",kernelFunc:Qse};T();function Jse(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{dims:s}=r;X(o,"reverse");let i=o.shape.length,a=y.parseAxisParam(s,o.shape);if(i===0)return mn({inputs:{x:o},backend:t});let c=new Ke(o.shape,o.dtype),l=t.bufferSync(o);for(let u=0;u<c.size;u++){let p=c.indexToLoc(u),d=p.slice();a.forEach(f=>d[f]=o.shape[f]-1-d[f]),c.set(l.get(...d),...p)}return t.makeTensorInfo(c.shape,c.dtype,c.values)}var e4={kernelName:Bl,backendName:"cpu",kernelFunc:Jse};T();var t4={kernelName:du,backendName:"cpu",kernelFunc:({inputs:e,attrs:n,backend:t})=>{let{image:r}=e,{radians:o,fillValue:s,center:i}=n,a=t,c=y.getTypedArrayFromDType(r.dtype,y.sizeFromShape(r.shape)),[l,u,p,d]=r.shape,[f,m]=S.getImageCenter(i,u,p),h=255,g=Math.sin(o),x=Math.cos(o),v=a.data.get(r.dataId).values;for(let I=0;I<l;I++){let _=I*p*u*d;for(let A=0;A<u;A++){let R=A*(p*d);for(let F=0;F<p;F++){let P=F*d;for(let L=0;L<d;L++){let V=[l,A,F,L],z=V[2],G=V[1],j=(z-f)*x-(G-m)*g,W=(z-f)*g+(G-m)*x;j=Math.round(j+f),W=Math.round(W+m);let Y=s;if(typeof s!="number"&&(L===3?Y=h:Y=s[L]),j>=0&&j<p&&W>=0&&W<u){let K=W*(p*d),Q=j*d,te=_+K+Q+L;Y=v[te]}let Z=_+R+P+L;c[Z]=Y}}}}return{dataId:a.write(c,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};T();var eie=he(Xi,e=>{let n=Math.floor(e);return e-n<.5?Math.floor(e):e-n>.5?Math.ceil(e):n%2===0?n:n+1}),n4={kernelName:Xi,backendName:"cpu",kernelFunc:eie};T();function tie(e){let{inputs:n,backend:t,attrs:r}=e,{indices:o,updates:s}=n,{shape:i}=r,{sliceRank:a,numUpdates:c,sliceSize:l,strides:u,outputSize:p}=S.calculateShapes(s,o,i),d=!0,f=t.bufferSync(o),m=t.bufferSync(s),h=vo(f,m,i,p,l,c,a,u,0,d);return t.makeTensorInfo(i,h.dtype,h.values)}var r4={kernelName:Vl,backendName:"cpu",kernelFunc:tie};T();T();function nie(e,n){let t=0,r=e.length,o=0;for(;t<r;)o=Math.floor((t+r)/2),e[o]<n?t=o+1:r=o;return r}function rie(e,n){let t=0,r=e.length,o=0;for(;t<r;)o=Math.floor((t+r)/2),e[o]<=n?t=o+1:r=o;return r}function o4(e,n,t,r,o,s){let i=y.getArrayFromDType("int32",t*o);for(let a=0;a<t;++a){let c=e.slice(a*r,(a+1)*r),l=a*o;for(let u=0;u<o;++u)i[l+u]=s==="left"?nie(c,n[u+l]):rie(c,n[u+l])}return i}function oie(e){let{inputs:n,backend:t,attrs:r}=e,{sortedSequence:o,values:s}=n,{side:i}=r,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,l=o4(a,c,o.shape[0],o.shape[1],s.shape[1],i);return t.makeTensorInfo(s.shape,"int32",l)}var s4={kernelName:zl,backendName:"cpu",kernelFunc:oie};T();function sie(e){let{inputs:n,backend:t}=e,{condition:r,t:o,e:s}=n;X([r,o,s],"select");let i=r.shape.length,a=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,u=Mt(o.dtype,s.dtype),p=y.makeZerosTypedArray(y.sizeFromShape(o.shape),u),d=0,f=i===0||i>1||o.shape.length===1?1:y.sizeFromShape(o.shape.slice(1));for(let m=0;m<a.length;m++)for(let h=0;h<f;h++)a[m]===1?p[d++]=c[m]:p[d++]=l[m];return t.makeTensorInfo(o.shape,u,p)}var i4={kernelName:Gl,backendName:"cpu",kernelFunc:sie};T();var iie=S.SELU_SCALEALPHA,aie=S.SELU_SCALE,cie=he(Zi,e=>e>=0?aie*e:iie*(Math.exp(e)-1)),a4={kernelName:Zi,backendName:"cpu",kernelFunc:cie};T();var lie=he(Ji,e=>e<0?-1:e>0?1:0),c4={kernelName:Ji,backendName:"cpu",kernelFunc:lie};T();var uie=he("Sin",e=>Math.sin(e)),l4={kernelName:"Sin",backendName:"cpu",kernelFunc:uie};T();var pie=he(Qi,e=>Math.sinh(e)),u4={kernelName:Qi,backendName:"cpu",kernelFunc:pie};T();var die=11920928955078125e-23,p4=Math.log(die)+2,fie=he(ta,e=>{let n=e>-p4,t=e<p4,r=Math.exp(e),o;return t?o=r:n?o=e:o=Math.log(1+r),o}),d4={kernelName:ta,backendName:"cpu",kernelFunc:fie};T();function mie(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{blockShape:s,paddings:i}=r;X([o],"spaceToBatchND");let a=y.sizeFromShape(s),c=[[0,0]];c.push(...i);for(let A=1+s.length;A<o.shape.length;++A)c.push([0,0]);let l=Ov.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:c,constantValue:0}}),u=S.getReshaped(l.shape,s,a,!1),p=S.getPermuted(u.length,s.length,!1),d=S.getReshapedPermuted(l.shape,s,a,!1),h=Re({inputs:{x:l},backend:t,attrs:{shape:u}}),v=Ct({inputs:{x:h},backend:t,attrs:{perm:p}}),_=Re({inputs:{x:v},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(v),_}var f4={kernelName:jl,backendName:"cpu",kernelFunc:mie};T();function hie(e){let{inputs:n,backend:t}=e,{indices:r,values:o,denseShape:s,defaultValue:i}=n;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values[0],[p,d,f,m,h]=wv(a,r.shape,r.dtype,c,o.dtype,l,u);return[t.makeTensorInfo(d,r.dtype,p),t.makeTensorInfo([d[0]],o.dtype,f),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}var m4={kernelName:Xl,backendName:"cpu",kernelFunc:hie};T();function gie(e){let{inputs:n,backend:t}=e,{inputIndices:r,inputShape:o,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(t.data.get(o.dataId).values),a=t.data.get(r.dataId).values,c=Array.from(t.data.get(s.dataId).values),[l,u,p]=Iv(a,r.shape,r.dtype,i,c);return[t.makeTensorInfo(u,r.dtype,l),t.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var h4={kernelName:Yl,backendName:"cpu",kernelFunc:gie};T();function xie(e){let{inputs:n,backend:t}=e,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=t.data.get(r.dataId).values,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,[l,u]=_d(i,r.shape,r.dtype,a,c,!0);return t.makeTensorInfo(u,r.dtype,l)}var g4={kernelName:Zl,backendName:"cpu",kernelFunc:xie};T();function yie(e){let{inputs:n,backend:t}=e,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=t.data.get(r.dataId).values,a=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,[l,u]=_d(i,r.shape,r.dtype,a,c);return t.makeTensorInfo(u,r.dtype,l)}var x4={kernelName:Ql,backendName:"cpu",kernelFunc:yie};T();function vie(e){let{inputs:n,backend:t,attrs:r}=e,{sparseIndices:o,sparseValues:s,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:c,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=S.calculateShapes(s,o,a),f=!1,m=t.bufferSync(o),h;switch(s.dtype){case"bool":{let g=t.bufferSync(s),x=!!t.data.get(i.dataId).values[0];h=vo(m,g,a,d,u,l,c,p,x,f);break}case"float32":{let g=t.bufferSync(s),x=t.data.get(i.dataId).values[0];h=vo(m,g,a,d,u,l,c,p,x,f);break}case"int32":{let g=t.bufferSync(s),x=t.data.get(i.dataId).values[0];h=vo(m,g,a,d,u,l,c,p,x,f);break}case"string":{let g=t.bufferSync(s),x=y.decodeString(t.data.get(i.dataId).values[0]);h=vo(m,g,a,d,u,l,c,p,x,f);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return t.makeTensorInfo(a,h.dtype,h.values)}var y4={kernelName:Jl,backendName:"cpu",kernelFunc:vie};T();T();function bie(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{numOrSizeSplits:s,axis:i}=r,a=y.parseAxisParam(i,o.shape)[0],c=S.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),u=o.shape.slice();return c.map(p=>{let d=[...u];d[a]=p;let f=Wr({inputs:{x:o},backend:t,attrs:{begin:l,size:d}});return l[a]+=p,f})}var v4={kernelName:ql,backendName:"cpu",kernelFunc:bie};T();var b4={kernelName:mm,backendName:"cpu",kernelFunc:({inputs:e,backend:n})=>{let{x:t}=e,r=n;X(t,"square");let o=r.data.get(t.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let c=o[a];s[a]=c*c}return{dataId:r.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};T();var Cie=he(ia,(e,n)=>{let t=n;return isNaN(e)?NaN:e>0?1:t.alpha}),C4={kernelName:ia,backendName:"cpu",kernelFunc:Cie};T();function wie(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{begin:s,end:i,strides:a,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:p,shrinkAxisMask:d}=r;X(o,"stridedSlice");let{finalShapeSparse:f,finalShape:m,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:v,end:w,strides:I}=zt.sliceInfo(o.shape,s,i,a,c,l,u,p,d),_;if(h)_=Re({inputs:{x:o},backend:t,attrs:{shape:m}});else if(g||x){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let A=zt.computeOutShape(v,w,I),R=Wr({inputs:{x:o},backend:t,attrs:{begin:v,size:A}});_=Re({inputs:{x:R},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(R)}else{let A=t.bufferSync(o),R=Ev(f,A,I,v);_=t.makeTensorInfo(m,R.dtype,R.values)}return _}var w4={kernelName:eu,backendName:"cpu",kernelFunc:wie};T();function Iie(e){let{inputs:n,backend:t,attrs:r}=e,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:c,preserveShortSequences:l}=r,{data:u,dataSplits:p}=n,d=t.data.get(u.dataId).values,f=t.data.get(p.dataId).values,[m,h]=Tv(d,f,o,s,i,a,c,l);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(p.shape,"int32",h)]}var I4={kernelName:tu,backendName:"cpu",kernelFunc:Iie};T();function Eie(e){let{inputs:n,backend:t,attrs:r}=e,{skipEmpty:o}=r,{input:s,delimiter:i}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values[0],[l,u,p]=Sv(a,c,o),d=u.length;return[t.makeTensorInfo([d,2],"int32",l),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(p))]}var E4={kernelName:nu,backendName:"cpu",kernelFunc:Eie};T();function Tie(e){let{inputs:n,backend:t,attrs:r}=e,{numBuckets:o}=r,{input:s}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=t.data.get(s.dataId).values,a=Nv(i,o);return t.makeTensorInfo(s.shape,"int32",a)}var T4={kernelName:ru,backendName:"cpu",kernelFunc:Tie};T();var Sie=he("Tan",e=>Math.tan(e)),S4={kernelName:"Tan",backendName:"cpu",kernelFunc:Sie};T();var Nie=he(sa,e=>Math.tanh(e)),N4={kernelName:sa,backendName:"cpu",kernelFunc:Nie};T();function Die(e){let{inputs:n,backend:t}=e,{tensor:r,indices:o,updates:s}=n,{sliceRank:i,numUpdates:a,sliceSize:c,strides:l,outputSize:u}=S.calculateShapes(s,o,r.shape),p=!1,d=t.bufferSync(o),f=t.bufferSync(s),m=t.bufferSync(r),h=vo(d,f,r.shape,u,c,a,i,l,m,p);return t.makeTensorInfo(r.shape,h.dtype,h.values)}var D4={kernelName:Ul,backendName:"cpu",kernelFunc:Die};T();function kie(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{reps:s}=r;X(o,"tile");let i=Dv(t.bufferSync(o),s);return t.makeTensorInfo(i.shape,i.dtype,i.values)}var k4={kernelName:hs,backendName:"cpu",kernelFunc:kie};T();function _ie(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{k:s,sorted:i}=r;X(o,"topk");let a=t.data.get(o.dataId).values,[c,l]=kv(a,o.shape,o.dtype,s,i);return[t.makeTensorInfo(c.shape,c.dtype,c.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}var _4={kernelName:iu,backendName:"cpu",kernelFunc:_ie};T();function Aie(e){let{inputs:n,attrs:t,backend:r}=e,{image:o,transforms:s}=n,{interpolation:i,fillMode:a,fillValue:c,outputShape:l}=t,[u,p,d,f]=o.shape,[m,h]=l??[p,d],g=[u,m,h,f],x=y.computeStrides(o.shape),v=x[0],w=x[1],I=x[2],_=y.computeStrides(g),A=_[0],R=_[1],F=_[2],P=y.getTypedArrayFromDType(o.dtype,y.sizeFromShape(g));P.fill(c);let L=r.data.get(o.dataId).values,V=r.data.get(s.dataId).values;for(let G=0;G<u;++G){let j=s.shape[0]===1?V:V.subarray(G*8,G*8+8);for(let W=0;W<m;++W)for(let Y=0;Y<h;++Y)for(let Z=0;Z<f;++Z){let K,Q=j[6]*Y+j[7]*W+1;if(Q===0)continue;let te=(j[0]*Y+j[1]*W+j[2])/Q,ne=(j[3]*Y+j[4]*W+j[5])/Q,se=A4(te,d,a),re=A4(ne,p,a);switch(i){case"nearest":K=$ie(L,p,d,v,w,I,G,re,se,Z,c);break;case"bilinear":K=Pie(L,p,d,v,w,I,G,re,se,Z,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let ae=G*A+W*R+Y*F+Z;P[ae]=K}return r.makeTensorInfo(g,o.dtype,P)}return{dataId:r.write(P,g,o.dtype),shape:o.shape,dtype:o.dtype}}var R4={kernelName:au,backendName:"cpu",kernelFunc:Aie};function A4(e,n,t){switch(t){case"reflect":return Rie(e,n);case"wrap":return Fie(e,n);case"nearest":return Mie(e,n);case"constant":default:return Oie(e,n)}}function Rie(e,n){let t=e;if(t<0)if(n<=1)t=0;else{let r=2*n;t<r&&(t=r*Math.trunc(-t/r)+t),t=t<-n?t+r:-t-1}else if(t>n-1)if(n<=1)t=0;else{let r=2*n;t-=r*Math.trunc(t/r),t>=n&&(t=r-t-1)}return y.clamp(0,t,n-1)}function Fie(e,n){let t=e;if(t<0)if(n<=1)t=0;else{let r=n-1;t+=n*(Math.trunc(-t/r)+1)}else if(t>n-1)if(n<=1)t=0;else{let r=n-1;t-=n*Math.trunc(t/r)}return y.clamp(0,t,n-1)}function Oie(e,n){return e}function Mie(e,n){return y.clamp(0,e,n-1)}function Rh(e,n,t,r,o,s,i,a,c,l,u){let p=i*r+a*o+c*s+l;return 0<=a&&a<n&&0<=c&&c<t?e[p]:u}function $ie(e,n,t,r,o,s,i,a,c,l,u){let p=Math.round(a),d=Math.round(c);return Rh(e,n,t,r,o,s,i,p,d,l,u)}function Pie(e,n,t,r,o,s,i,a,c,l,u){let p=Math.floor(a),d=Math.floor(c),f=p+1,m=d+1,h=(m-c)*Rh(e,n,t,r,o,s,i,p,d,l,u)+(c-d)*Rh(e,n,t,r,o,s,i,p,m,l,u),g=(m-c)*Rh(e,n,t,r,o,s,i,f,d,l,u)+(c-d)*Rh(e,n,t,r,o,s,i,f,m,l,u);return(f-a)*h+(a-p)*g}T();function Lie(e){let{inputs:n,attrs:t,backend:r}=e,{axis:o}=t,{x:s}=n;X(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:a,outputShape:c,indices:l}=_v(i,o,s.shape,s.dtype);return[r.makeTensorInfo(c,s.dtype,a),r.makeTensorInfo([l.length],"int32",l)]}var F4={kernelName:cu,backendName:"cpu",kernelFunc:Lie};T();function Bie(e){let{inputs:n,backend:t,attrs:r}=e,{value:o}=n,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],c=new Array(i-1),l=0;for(let f=0;f<i;f++)f!==s&&(c[l++]=o.shape[f]);let u=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let d=new Array(a);for(let f=0;f<d.length;f++){u[s]=f;let m=Wr({inputs:{x:o},backend:t,attrs:{begin:u,size:p}});d[f]=Re({inputs:{x:m},backend:t,attrs:{shape:c}}),t.disposeIntermediateTensorInfo(m)}return d}var O4={kernelName:lu,backendName:"cpu",kernelFunc:Bie};T();function Vie(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,segmentIds:s}=n,{numSegments:i}=r;X(o,"unsortedSegmentSum");let a=o.shape.length,c=s.shape.length,l=[],u=[],p=a-c,d=s;for(let m=0;m<p;++m){let h=Rd({inputs:{input:d},backend:t,attrs:{dim:m+1}});d=h,u.push(h)}for(let m=0;m<i;++m){let h=y.createScalarValue(m,"int32"),g=t.makeTensorInfo([],"int32",h),x=nD({inputs:{a:g,b:d},backend:t}),v=Gr({inputs:{x},backend:t,attrs:{dtype:"float32"}}),w=Gu({inputs:{a:v,b:o},backend:t}),I=Bs({inputs:{x:w},backend:t,attrs:{axis:0,keepDims:!1}});l.push(I),u.push(g),u.push(x),u.push(v),u.push(w),u.push(I)}let f=LD({inputs:l,backend:t,attrs:{axis:0}});return u.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}var M4={kernelName:uu,backendName:"cpu",kernelFunc:Vie};var Uie=[iV,mB,aV,cV,vB,lV,uV,pV,dV,fV,mV,hV,gV,xV,yV,bV,CV,wV,IV,sV,EV,TV,SV,bB,NV,yB,CB,DV,hB,kV,AV,RV,FV,OV,MV,$V,PV,LV,BV,VV,UV,zV,GV,HV,WV,jV,qV,KV,XV,YV,ZV,QV,e3,JB,t3,wB,n3,IB,r3,EB,o3,s3,i3,TB,SB,a3,c3,l3,u3,NB,DB,gB,p3,_V,d3,f3,m3,eV,kB,_B,h3,AB,g3,x3,y3,v3,b3,C3,w3,RB,I3,E3,T3,S3,D3,k3,_3,FB,A3,R3,M3,OB,MB,$3,P3,L3,$B,B3,z3,G3,Ov,H3,tV,LB,W3,j3,q3,K3,xB,kh,X3,nV,rV,oV,Y3,Z3,Q3,J3,e4,t4,n4,GB,r4,s4,i4,a4,WB,c4,l4,u4,jB,F3,d4,f4,m4,h4,g4,x4,y4,v4,KB,b4,XB,YB,C4,w4,I4,E4,T4,ZB,JV,S4,N4,D4,k4,_4,R4,PB,F4,O4,M4,V3];for(let e of Uie)Zp(e);T();T();T();T();var Wu={},Mv={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function $4(e,n){Wu[e]=n}function ar(e,n){if(!(e in Wu)||n!=null){let r=Gie(e,n);if(r!==null)Wu[e]=r;else return console.log("Could not get context for WebGL version",e),null}let t=Wu[e];return t==null||t.isContextLost()?(delete Wu[e],ar(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Wu[e])}function zie(e){if(!M().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Gie(e,n){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=n??zie(e);return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Wu[e]},!1),M().getBool("SOFTWARE_WEBGL_ENABLED")&&(Mv.failIfMajorPerformanceCaveat=!1),e===1?t.getContext("webgl",Mv)||t.getContext("experimental-webgl",Mv):t.getContext("webgl2",Mv)}T();var ju=(function(e){return e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH",e})(ju||{}),In=(function(e){return e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD",e})(In||{}),hn=(function(e){return e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",e})(hn||{});function qu(e,n){return[n,e]}function P4(e,n){return e*n}function Fh(e){let n=y.sizeFromShape(e),t=Math.ceil(n/4);return y.sizeToSquarishShape(t)}function Qo(e,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(e/2))]}function L4(e,n){let[t,r]=Qo(e,n);return t*r*4}function Oh(e,n){let t=e,r,o,s,i,a,c,l,u,p,d;return M().getNumber("WEBGL_VERSION")===2?(r=t.R32F,o=t.R16F,s=t.RGBA16F,i=t.RGBA32F,a=t.RED,l=4,u=1,p=t.HALF_FLOAT,d=t.FLOAT,c=t.RGBA8):(r=e.RGBA,o=e.RGBA,s=e.RGBA,i=t.RGBA,a=e.RGBA,l=4,u=4,p=n!=null?n.HALF_FLOAT_OES:null,d=e.FLOAT,c=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:p,textureTypeFloat:d}}function ce(e,n){let t=n();return M().getBool("DEBUG")&&Hie(e),t}function Hie(e){let n=e.getError();if(n!==e.NO_ERROR)throw new Error("WebGL Error: "+qie(e,n))}var Wie=596e-10,jie=65504;function B4(e){return!!(M().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||Wie<Math.abs(e)&&Math.abs(e)<jie)}function qie(e,n){switch(n){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}function Mh(e,n){return Vs(e,()=>e.getExtension(n),'Extension "'+n+'" not supported on this browser.')}function V4(e,n){let t=Vs(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ce(e,()=>e.shaderSource(t,n)),ce(e,()=>e.compileShader(t)),e.getShaderParameter(t,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function U4(e,n){let t=Vs(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ce(e,()=>e.shaderSource(t,n)),ce(e,()=>e.compileShader(t)),M().get("ENGINE_COMPILE_ONLY"))return t;if(e.getShaderParameter(t,e.COMPILE_STATUS)===!1)throw GD(n,e.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var Kie=/ERROR: [0-9]+:([0-9]+):/g;function GD(e,n){let t=Kie.exec(n);if(t==null){console.log(`Couldn't parse line number in error: ${n}`),console.log(e);return}let r=+t[1],o=e.split(`
`),s=o.length.toString().length+2,i=o.map((p,d)=>y.rightPad((d+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let c=i.slice(0,r-1),l=i.slice(r-1,r),u=i.slice(r);console.log(c.join(`
`)),console.log(n.split(`
`)[0]),console.log(`%c ${y.rightPad(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function z4(e){return Vs(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function G4(e,n){if(ce(e,()=>e.linkProgram(n)),!M().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(n,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function Pv(e,n){if(ce(e,()=>e.validateProgram(n)),e.getProgramParameter(n,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function H4(e,n){let t=Vs(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ce(e,()=>e.bindBuffer(e.ARRAY_BUFFER,t)),ce(e,()=>e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW)),t}function W4(e,n){let t=Vs(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ce(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t)),ce(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,n,e.STATIC_DRAW)),t}function j4(e){return Vs(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function q4(e,n){let t=M().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||n<=0){let r=`[${e}x${n}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>t||n>t){let r=`[${e}x${n}]`,o=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+o+".")}}function K4(e){return Vs(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function HD(e,n,t,r,o,s,i){let a=e.getAttribLocation(n,t);return a===-1?!1:(ce(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),ce(e,()=>e.vertexAttribPointer(a,o,e.FLOAT,!1,s,i)),ce(e,()=>e.enableVertexAttribArray(a)),!0)}function Xie(e,n,t){Zie(e,t),ce(e,()=>e.activeTexture(e.TEXTURE0+t)),ce(e,()=>e.bindTexture(e.TEXTURE_2D,n))}function X4(e,n,t){return Vs(e,()=>e.getUniformLocation(n,t),'uniform "'+t+'" not present in program.')}function Y4(e,n,t){return e.getUniformLocation(n,t)}function Z4(e,n,t,r){ce(e,()=>Xie(e,n,r)),ce(e,()=>e.uniform1i(t,r))}function Lv(e,n,t){ce(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),ce(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0))}function WD(e,n){ce(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),ce(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function $h(e){let n=e.checkFramebufferStatus(e.FRAMEBUFFER);if(n!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Yie(e,n))}function Yie(e,n){switch(n){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}function Vs(e,n,t){let r=ce(e,()=>n());if(r==null)throw new Error(t);return r}function Zie(e,n){let t=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+e.TEXTURE0;if(r<e.TEXTURE0||r>t){let o=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${o}.`)}}function Fa(e,n=2){return y.sizeFromShape(e.slice(0,e.length-n))}function Oa(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Ph(e){let n=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(n=[Fa(e),...Oa(e)]),n}function Q4(e,n=!1){let t=M().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=M().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&M().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),n&&(t=t*2,r=r*2,e=e.map((a,c)=>c>=e.length-2?y.nearestLargerEven(e[c]):e[c]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=y.squeezeShape(e).newShape);let o=y.sizeFromShape(e),s=null;e.length<=1&&o<=t?s=[1,o]:e.length===2&&e[0]<=t&&e[1]<=t?s=e:e.length===3&&e[0]*e[1]<=t&&e[2]<=t?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=t&&e[1]*e[2]<=t?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=t&&e[3]<=t?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=t&&e[1]*e[2]*e[3]<=t&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(n?2:1)&&Math.min(...s)>0;if(s==null||i)if(n){let a=Fa(e),c=2,l=2;e.length&&([c,l]=Oa(e)),o=a*(c/2)*(l/2),s=y.sizeToSquarishShape(o).map(u=>u*2)}else s=y.sizeToSquarishShape(o);return s}function $v(e){return e%2===0}function Ku(e,n){if(e=e.slice(-2),n=n.slice(-2),y.arraysEqual(e,n)||!e.length||!n.length||e[0]===0||e[1]===0||n[0]===0||n[1]===0)return!0;if(e.length!==n.length){let t=e[e.length-1],r=n[n.length-1];if(t===r||$v(t)&&$v(r)&&(e[0]===1||n[0]===1))return!0}return e[1]===n[1]&&$v(e[0])&&$v(n[0])}var VD,UD;function J4(e){if(VD==null){let n=ar(e);VD=n.getParameter(n.MAX_TEXTURE_SIZE)}return VD}function eU(e){if(UD==null){let n=ar(e);UD=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,UD)}function tU(e){if(e===0)return 0;let n,t=ar(e);return Dr(t,"EXT_disjoint_timer_query_webgl2")&&e===2?n=2:Dr(t,"EXT_disjoint_timer_query")?n=1:n=0,n}function Dr(e,n){return e.getExtension(n)!=null}function jD(e){try{if(ar(e)!=null)return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function nU(e){if(e===0)return!1;let n=ar(e);if(e===1){if(!Dr(n,"OES_texture_float"))return!1}else if(!Dr(n,"EXT_color_buffer_float"))return!1;return zD(n)}function rU(e){if(e===0)return!1;let n=ar(e);if(e===1){if(!Dr(n,"OES_texture_float")||!Dr(n,"WEBGL_color_buffer_float"))return!1}else{if(Dr(n,"EXT_color_buffer_float"))return zD(n);let r="EXT_color_buffer_half_float";if(Dr(n,r)){let o=n.getExtension(r);return Qie(n,o)}return!1}return zD(n)}function zD(e){let n=Oh(e),t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(s),i}function Qie(e,n){let t=Oh(e,n),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);let i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),a}function oU(e){return e!==2?!1:ar(e).fenceSync!=null}function Jo(e,n){Array.isArray(e)||(e=[e]),e.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}var fe=M();fe.registerFlag("HAS_WEBGL",()=>fe.getNumber("WEBGL_VERSION")>0);fe.registerFlag("WEBGL_VERSION",()=>jD(2)?2:jD(1)?1:0);fe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);fe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>fe.get("WEBGL_VERSION")===2);fe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);fe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);fe.registerFlag("WEBGL_PACK",()=>fe.getBool("HAS_WEBGL"));fe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_CLIP",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_REDUCE",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_LAZILY_UNPACK",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_CONV_IM2COL",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>fe.getBool("WEBGL_PACK"));fe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>J4(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>eU(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=fe.getNumber("WEBGL_VERSION");return e===0?0:tU(e)});fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>fe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!xs.isMobile());fe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>nU(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>fe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:fe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));fe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>rU(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>oU(fe.getNumber("WEBGL_VERSION")));fe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>fe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);fe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});fe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>xs.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});fe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);fe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);fe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);fe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);fe.registerFlag("WEBGL_EXP_CONV",()=>!1);fe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>fe.getBool("IS_TEST"));fe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);fe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);fe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);fe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);T();T();function wt(){let e,n,t,r,o,s,i,a,c,l;return M().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",n="in",t="out",r="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=M().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",n="attribute",t="varying",r="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:n,varyingVs:t,varyingFs:r,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:c,defineRound:l}}T();T();T();function bo(e,n,t="index"){let r=y.computeStrides(n);return r.map((o,s)=>{let i=`int ${e[s]} = ${t} / ${o}`,a=s===r.length-1?`int ${e[s+1]} = ${t} - ${e[s]} * ${o}`:`index -= ${e[s]} * ${o}`;return`${i}; ${a};`}).join("")}function Xu(e,n,t="index"){let r=y.computeStrides(n);return r.map((o,s)=>{let i=`int ${e[s]} = ${t} / outShapeStrides[${s}]`,a=s===r.length-1?`int ${e[s+1]} = ${t} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function Jie(e,n){let t=e.length,r=e.map(s=>`${n}[${s}]`),o=new Array(t-1);o[t-2]=r[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${r[s+1]})`;return o}function sU(e,n,t="index"){let r=e.map((s,i)=>i),o=Jie(r,n);return o.map((s,i)=>{let a=`int ${e[i]} = ${t} / ${o[i]}`,c=i===o.length-1?`int ${e[i+1]} = ${t} - ${e[i]} * ${o[i]}`:`index -= ${e[i]} * ${o[i]}`;return`${a}; ${c};`}).join("")}function Fd(e){let n=y.computeStrides(e).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;
  }
`}function Od(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Vv=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:iU}=S;function aU(e,n,t){let r=[];if(e.forEach(f=>{let m=y.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${m>1?`[${m}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),t.enableShapeUniforms){let{uniformShape:h}=Uv(t.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(h.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),t.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let o=r.join(`
`),s=e.map(f=>eae(f,n,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=n.texShape,a=wt(),c=rae(a),l,u,p=iae(a);return n.isPacked?(l=tae(n.logicalShape,i,t.enableShapeUniforms),u=sae(a)):(l=nae(n.logicalShape,i,t.enableShapeUniforms),u=oae(a)),t.packedInputs&&(p+=uae),[p,c,u,o,l,s,t.userCode].join(`
`)}function $d(e,n=!1){let t=e.shapeInfo.logicalShape;switch(t.length){case 0:return wae(e,n);case 1:return Eae(e,n);case 2:return Sae(e,n);case 3:return Dae(e,n);case 4:return _ae(e,n);case 5:return Aae(e);case 6:return Rae(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function cU(e,n){switch(e.shapeInfo.logicalShape.length){case 0:return Cae(e);case 1:return Iae(e,n);case 2:return Tae(e,n);case 3:return Nae(e,n);default:return kae(e,n)}}function eae(e,n,t=!1,r){let o="";t?o+=cU(e,r):o+=$d(e,r);let s=e.shapeInfo.logicalShape,i=n.logicalShape;return s.length<=i.length&&(t?o+=Fae(e,n):o+=Oae(e,n)),o}function tae(e,n,t){switch(e.length){case 0:return lU();case 1:return pae(e,n,t);case 2:return vae(e,n,t);case 3:return fae(e,n,t);default:return hae(e,n,t)}}function nae(e,n,t){switch(e.length){case 0:return lU();case 1:return dae(e,n,t);case 2:return bae(e,n,t);case 3:return mae(e,n,t);case 4:return gae(e,n,t);case 5:return xae(e,n);case 6:return yae(e,n);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function rae(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function oae(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function sae(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function iae(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${aae}
    ${cae}
    ${lae}
  `}var aae=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,cae=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,lae=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,uae=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function lU(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function pae(e,n,t){let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function dae(e,n,t){return n[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${n[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return resTexRC.x * ${n[1]} + resTexRC.y;
    }
  `}function fae(e,n,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=Math.ceil(e[2]/2),s=o*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function mae(e,n,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Xu(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=bo(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function hae(e,n,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=Math.ceil(e[e.length-1]/2),s=o*Math.ceil(e[e.length-2]/2),i=s,a="",c="b, r, c";for(let l=2;l<e.length-1;l++)i*=e[e.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,c=`b${l}, `+c;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${e.length}(${c});
    }
  `}function gae(e,n,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Xu(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=bo(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function xae(e,n){let t=bo(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},
                             ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function yae(e,n){let t=bo(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function vae(e,n,t){let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(y.arraysEqual(e,n))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let o=Math.ceil(e[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function bae(e,n,t){return y.arraysEqual(e,n)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `:e[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${n[0]}, ${n[1]}));
        int index = resTexRC.x * ${n[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${n[0]}, ${n[1]}));
        int index = resTexRC.x * ${n[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Yu(e){return`offset${e}`}function Cae(e){let n=e.name,t="get"+n.charAt(0).toUpperCase()+n.slice(1),r=wt();return`
    vec4 ${t}() {
      return ${r.texture2D}(${n}, halfCR);
    }
  `}function wae(e,n){let t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;let[o,s]=e.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let i=Yu(t);if(n)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;let[a,c]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${c}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function Iae(e,n){let t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e.shapeInfo.texShape,s=wt();if(n)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function Eae(e,n){let t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Pd(e)}
      }
    `;let o=e.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=Yu(t);return i===1?n?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?n?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:n?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function Tae(e,n){let t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],a=s[1],c=wt();if(s!=null&&y.arraysEqual(t,s))return n?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${c.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${c.texture2D}(${r}, uv);
      }
    `;if(n)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `}function Sae(e,n){let t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(s!=null&&y.arraysEqual(t,s)){if(n)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let d=s[0],f=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:a}=y.squeezeShape(t),c=i;if(c.length<t.length){let d=Ld(e,c),f=["row","col"];return`
      ${$d(d,n)}
      float ${o}(int row, int col) {
        return ${o}(${Bd(f,a)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Pd(e)}
      }
    `;let l=s[0],u=s[1],p=Yu(r);return u===1?n?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${r}, uv);
    }
  `:l===1?n?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:n?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${p};
    vec2 uv = uvFromFlat(${l}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function Nae(e,n){let t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let d=t.slice(1),f=[1,2],m=Ld(e,d),h=["b","row","col"];return`
        ${cU(m,n)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Bd(h,f)});
        }
      `}let a=wt();if(n)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;let c=i[0],l=i[1],u=Math.ceil(t[2]/2),p=u*Math.ceil(t[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${l}, ${p}, ${u}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function Dae(e,n){let t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t[1]*t[2],i=t[2],{newShape:a,keptDims:c}=y.squeezeShape(t),l=a;if(l.length<t.length){let h=Ld(e,l),g=["row","col","depth"];return`
        ${$d(h,n)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Bd(g,c)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Pd(e)}
      }
    `;let u=e.shapeInfo.texShape,p=u[0],d=u[1],f=e.shapeInfo.flatOffset;if(d===s&&f==null)return n?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===i&&f==null)return n?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;let m=Yu(r);return n?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${m};
        vec2 uv = uvFromFlat(${p}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function kae(e,n){let t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=wt();if(n)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,a=e.shapeInfo.texShape,c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=c[0],u=c[1],p=Math.ceil(s[i-1]/2),d=p*Math.ceil(s[i-2]/2),f="int b, int row, int col",m=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let h=2;h<i-1;h++)f=`int b${h}, `+f,d*=s[i-h-1],m=`b${h} * ${d} + `+m;return`
    vec4 ${r}(${f}) {
      int index = ${m};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${l});
      return ${o.texture2D}(${t}, uv);
    }
  `}function _ae(e,n){let t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t[3],i=t[2]*s,a=t[1]*i,{newShape:c,keptDims:l}=y.squeezeShape(t);if(c.length<t.length){let v=Ld(e,c),w=["row","col","depth","depth2"];return`
      ${$d(v,n)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Bd(w,l)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${Pd(e)}
      }
    `;let u=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],f=p[1],m=`int stride2 = ${r}Shape[3];`,h=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===a&&u==null)return n?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${m}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(f===s&&u==null)return n?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;let x=Yu(r);return n?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${x});
      return sampleTexture(${r}, uv);
    }
  `}function Aae(e){let n=e.shapeInfo.logicalShape,t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=n[4],s=n[3]*o,i=n[2]*s,a=n[1]*i,{newShape:c,keptDims:l}=y.squeezeShape(n);if(c.length<n.length){let h=Ld(e,c),g=["row","col","depth","depth2","depth3"];return`
      ${$d(h)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Bd(g,l)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${Pd(e)}
      }
    `;let u=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],f=p[1];if(f===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${n[1]*n[2]*n[3]},
               ${n[2]*n[3]}, ${n[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;let m=Yu(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${m};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Rae(e){let n=e.shapeInfo.logicalShape,t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:s}=y.squeezeShape(n);if(o.length<n.length){let g=Ld(e,o),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${$d(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Bd(x,s)});
      }
    `}let i=n[5],a=n[4]*i,c=n[3]*a,l=n[2]*c,u=n[1]*l;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${l}, ${c}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Pd(e)}
      }
    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,f=d[0],m=d[1];if(m===u&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${c}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(m===i&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${n[1]*n[2]*n[3]*n[4]},
               ${n[2]*n[3]*n[4]},
               ${n[3]*n[4]},
               ${n[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;let h=Yu(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${l} + depth * ${c} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Pd(e){let n=e.name,t=y.sizeFromShape(e.shapeInfo.logicalShape);return t<2?`return ${n};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${n}[i];
      }
    }
  `}function Fae(e,n){let t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),o="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=n.logicalShape.length,a=iU(e.shapeInfo.logicalShape,n.logicalShape),c=ve(i),l=i-s,u,p=["x","y","z","w","u","v"];s===0?u="":i<2&&a.length>=1?u="coords = 0;":u=a.map(v=>`coords.${p[v+l]} = 0;`).join(`
`);let d="";i<2&&s>0?d="coords":d=e.shapeInfo.logicalShape.map((v,w)=>`coords.${p[w+l]}`).join(", ");let f="return outputValue;",h=y.sizeFromShape(e.shapeInfo.logicalShape)===1,x=y.sizeFromShape(n.logicalShape)===1;if(s===1&&!h&&!x)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!x)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){let v=s-2,w=s-1;a.indexOf(v)>-1&&a.indexOf(w)>-1?f="return vec4(outputValue.x);":a.indexOf(v)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${c} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${d});
      ${f}
    }
  `}function Oae(e,n){let t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),o="get"+r+"AtOutCoords",s=n.texShape,i=e.shapeInfo.texShape,a=e.shapeInfo.logicalShape.length,c=n.logicalShape.length;if(!e.shapeInfo.isUniform&&a===c&&e.shapeInfo.flatOffset==null&&y.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${t}, resultUV);
      }
    `;let l=ve(c),u=iU(e.shapeInfo.logicalShape,n.logicalShape),p=c-a,d,f=["x","y","z","w","u","v"];a===0?d="":c<2&&u.length>=1?d="coords = 0;":d=u.map(h=>`coords.${f[h+p]} = 0;`).join(`
`);let m="";return c<2&&a>0?m="coords":m=e.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${d}
      return get${r}(${m});
    }
  `}function ve(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Uv(e,n,t){let{newShape:r,keptDims:o}=y.squeezeShape(n),s=n.length,i=e&&s===3&&n[0]===1,a=i?n.slice(1):r,c=!e&&s>1&&!y.arraysEqual(n,t)&&r.length<s||i;return{useSqueezeShape:c,uniformShape:c?a:n,keptDims:o}}function Ld(e,n){let t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function Bd(e,n){return n.map(t=>e[t]).join(", ")}function pU(e,n,t,r){let o=t.map((u,p)=>{let d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:n.variableNames[p],shapeInfo:d}}),s=o.map(u=>u.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=aU(o,i,n),c=U4(e.gl,a),l=e.createProgram(c);return M().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:c,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:n,fragmentShader:c,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i},qD(e,n,l)))}function qD(e,n,t){let r=[],o=[],s,i,a,c=null,l=null;l=e.getUniformLocation(t,"NAN",!1),M().getNumber("WEBGL_VERSION")===1&&(c=e.getUniformLocation(t,"INFINITY",!1));let u=!1;for(let p of n.variableNames){let d={name:p,uniform:e.getUniformLocation(t,p,u),offset:e.getUniformLocation(t,`offset${p}`,u)};n.enableShapeUniforms&&(d.shape=e.getUniformLocation(t,`${p}Shape`,u),d.texShape=e.getUniformLocation(t,`${p}TexShape`,u)),r.push(d)}if(n.enableShapeUniforms&&(s=e.getUniformLocation(t,"outShape",u),a=e.getUniformLocation(t,"outShapeStrides",u),i=e.getUniformLocation(t,"outTexShape",u)),n.customUniforms)for(let p of n.customUniforms)o.push(e.getUniformLocation(t,p.name,u));return{variablesLocations:r,customUniformLocations:o,infLoc:c,nanLoc:l,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:i}}function uU(e,n){if(e.length!==n.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${n.length} inputs`);e.forEach((t,r)=>{let o=t.logicalShape,s=n[r],i=s.shape;if(!y.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(t.isUniform&&s.isUniform)return;let a=t.texShape,c=s.isUniform?null:s.texData.texShape;if(!y.arraysEqual(a,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${c} must match`)})}function dU(e,n,t,r,o){n.program.enableShapeUniforms||(uU(n.inShapeInfos,t),uU([n.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(n.webGLProgram),e.bindVertexArray(n.webGLProgram.vao),M().getNumber("WEBGL_VERSION")===1&&n.infLoc!==null&&e.gl.uniform1f(n.infLoc,1/0),n.nanLoc!==null&&e.gl.uniform1f(n.nanLoc,NaN);for(let c=0;c<t.length;++c){let l=t[c],{uniform:u,offset:p,shape:d,texShape:f}=n.variablesLocations[c];if(d){let{uniformShape:m}=Uv(n.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:e.gl.uniform1iv(d,new Int32Array(m));break;case 2:e.gl.uniform2iv(d,new Int32Array(m));break;case 3:e.gl.uniform3iv(d,new Int32Array(m));break;case 4:e.gl.uniform4iv(d,new Int32Array(m));break;default:break}}if(f&&e.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),u!=null){if(l.isUniform){if(y.sizeFromShape(l.shape)<2)e.gl.uniform1f(u,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(u,m)}continue}l.texData.slice!=null&&p!=null&&e.gl.uniform1i(p,l.texData.slice.flatOffset),e.setInputMatrixTexture(l.texData.texture.texture,u,c)}}let a=n.outShapeLocation;if(a)switch(r.shape.length){case 1:e.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(a,new Int32Array(r.shape));break;default:break}if(n.outShapeStridesLocation){let c=y.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(c));break;case 3:e.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(c));break;case 4:e.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(c));break;default:break}}if(n.outTexShapeLocation&&e.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&o)for(let c=0;c<n.program.customUniforms.length;++c){let l=n.program.customUniforms[c],u=n.customUniformLocations[c],p=o[c];if(l.type==="float")e.gl.uniform1fv(u,p);else if(l.type==="vec2")e.gl.uniform2fv(u,p);else if(l.type==="vec3")e.gl.uniform3fv(u,p);else if(l.type==="vec4")e.gl.uniform4fv(u,p);else if(l.type==="int")e.gl.uniform1iv(u,p);else if(l.type==="ivec2")e.gl.uniform2iv(u,p);else if(l.type==="ivec3")e.gl.uniform3iv(u,p);else if(l.type==="ivec4")e.gl.uniform4iv(u,p);else throw Error(`uniform type ${l.type} is not supported yet.`)}e.executeProgram()}function fU(e,n,t){let r="";n.concat(t).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let c=i.texData.texShape,{useSqueezeShape:l,uniformShape:u,keptDims:p}=Uv(e.packedInputs,i.shape,c),d="",f="",m="";if(u.length===1&&e.packedInputs){let _=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];d=`${_[0]>1}_${_[1]>1}`}else if(u.length===2&&!e.packedInputs)f=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!e.packedInputs){let _=y.computeStrides(u);m=`${_[0]===c[1]}_${_[_.length-1]===c[1]}`}let h=i.shape.length,g=u.length===2&&y.arraysEqual(i.shape,c),x=y.sizeFromShape(i.shape)===1,v=S.getBroadcastDims(i.shape,t.shape),w=!e.packedInputs&&h===t.shape.length&&y.arraysEqual(c,t.texData.texShape),I=e.packedInputs||u.length>2?"":`${c[0]>1}_${c[1]>1}`;r+=`${h}_${w}_${l?p:""}_${u.length}_${x}_${v}_${g}_${d}_${f}_${m}_${I}_${a}`}else{let c=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${c}_${a}`}});let o=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+o+`${M().getNumber("WEBGL_VERSION")}`,s}function rt(e){return M().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var zv=class{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ju.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=wt();this.outputShape=n,this.enableShapeUniforms=rt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Xu(["r","c","d"],n):bo(["r","c","d"],n)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}};var Gv=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ju.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=wt();this.outputShape=n,this.enableShapeUniforms=rt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Xu(["r","c","d"],n):bo(["r","c","d"],n)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}};var Hv=class{constructor(n){this.variableNames=["A"],this.outTexUsage=In.DOWNLOAD;let t=wt();this.outputShape=n,this.userCode=`
      ${Vv}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}};var Wv=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=In.DOWNLOAD;let t=wt();this.outputShape=n,this.userCode=`
      ${Vv}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}};var Pae={R:0,G:1,B:2,A:3},Lh=class{constructor(n,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let o=wt();this.outputShape=n,this.enableShapeUniforms=rt(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++){let c=r[a];i+=`
          if(offset == ${a}) {
            result = values[${Pae[c]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Od():Fd(n)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${i}
        }
        ${o.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var jv=class{constructor(n,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=wt();this.outputShape=n,this.enableShapeUniforms=rt(this.outputShape.length);let o="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let c=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${n[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${n[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Od():Fd(n)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${r.output} = ${s};
        }
    `}};T();T();function mU(e){let n=wt(),t=`${n.version}
    precision highp float;
    ${n.attribute} vec3 clipSpacePos;
    ${n.attribute} vec2 uv;
    ${n.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return V4(e,t)}function hU(e){let n=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return H4(e,n)}function gU(e){let n=new Uint16Array([0,1,2,2,1,3]);return W4(e,n)}function Bh(e,n,t,r,o,s){q4(n,t);let i=j4(e),a=e.TEXTURE_2D;return ce(e,()=>e.bindTexture(a,i)),ce(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),ce(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),ce(e,()=>e.texParameteri(a,e.TEXTURE_MIN_FILTER,e.NEAREST)),ce(e,()=>e.texParameteri(a,e.TEXTURE_MAG_FILTER,e.NEAREST)),M().getNumber("WEBGL_VERSION")===1?ce(e,()=>e.texImage2D(a,0,r,n,t,0,o,s,null)):ce(e,()=>e.texStorage2D(a,1,r,n,t)),ce(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[t,n]}}function KD(e){return e.internalFormatFloat}function xU(e,n,t,r){let[o,s]=qu(n,t);return Bh(e,o,s,KD(r),r.textureFormatFloat,e.FLOAT)}function XD(e){return e.internalFormatHalfFloat}function yU(e,n,t,r){let[o,s]=qu(n,t);return Bh(e,o,s,XD(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function YD(e){return e.downloadTextureFormat}function vU(e,n,t,r){let[o,s]=qu(n,t);return Bh(e,o,s,YD(r),e.RGBA,e.UNSIGNED_BYTE)}function ZD(e){return e.internalFormatPackedFloat}function bU(e,n,t,r){let[o,s]=Qo(n,t);return Bh(e,o,s,ZD(r),e.RGBA,e.FLOAT)}function QD(e){return e.internalFormatPackedHalfFloat}function CU(e,n,t,r){let[o,s]=Qo(n,t);return Bh(e,o,s,QD(r),e.RGBA,r.textureTypeHalfFloat)}function wU(e,n,t){return ce(e,()=>e.bindBuffer(e.ARRAY_BUFFER,t)),HD(e,n,"clipSpacePos",t,3,20,0)&&HD(e,n,"uv",t,2,20,12)}function IU(e,n,t,r,o,s){ce(e,()=>e.bindTexture(e.TEXTURE_2D,n));let i,a,c;o instanceof Uint8Array?(i=new Uint8Array(t*r*4),a=e.UNSIGNED_BYTE,c=e.RGBA):(i=new Float32Array(t*r*4),a=e.FLOAT,c=s.internalFormatPackedFloat),i.set(o),M().getNumber("WEBGL_VERSION")===2?ce(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,t,r,e.RGBA,a,i)):ce(e,()=>e.texImage2D(e.TEXTURE_2D,0,c,t,r,0,e.RGBA,a,i)),ce(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function EU(e,n,t){ce(e,()=>e.bindTexture(e.TEXTURE_2D,n)),t.data instanceof Uint8Array?M().getNumber("WEBGL_VERSION")===2?ce(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,t.width,t.height,e.RGBA,e.UNSIGNED_BYTE,t.data)):ce(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t.width,t.height,0,e.RGBA,e.UNSIGNED_BYTE,t.data)):M().getNumber("WEBGL_VERSION")===2?ce(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,t)):ce(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t)),ce(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function TU(e,n,t,r){let o=e.createBuffer();ce(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,o));let a=4*4*n*t;return ce(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),ce(e,()=>e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,0)),ce(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),o}function SU(e,n,t){let r=e,o=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function NU(e,n,t,r){let[o,s]=qu(n,t),i=4,a=new Uint8Array(P4(n*t,i));return ce(e,()=>e.readPixels(0,0,o,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function DU(e,n,t,r,o,s,i,a){let c=e,l=new Float32Array(L4(s,i));return c.bindBuffer(c.PIXEL_PACK_BUFFER,n),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}function kU(e,n,t){let r=new Float32Array(n*t*4);return ce(e,()=>e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,r)),r}var Vd=class{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=M().getNumber("WEBGL_VERSION");if(n!=null?(this.gl=n,$4(t,n)):this.gl=ar(t),n=this.gl,M().getNumber("WEBGL_VERSION")===2){let s=n;this.createVertexArray=()=>ce(s,()=>s.createVertexArray()),this.bindVertexArray=i=>ce(s,()=>s.bindVertexArray(i)),this.deleteVertexArray=i=>ce(s,()=>s.deleteVertexArray(i)),this.getVertexArray=()=>ce(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(n!=null){let s=n.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ce(n,()=>s.createVertexArrayOES()),this.bindVertexArray=i=>ce(n,()=>s.bindVertexArrayOES(i)),this.deleteVertexArray=i=>ce(n,()=>s.deleteVertexArrayOES(i)),this.getVertexArray=()=>ce(n,()=>n.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),M().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Mh(this.gl,s),Dr(this.gl,i))this.textureHalfFloatExtension=Mh(this.gl,i);else if(M().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Dr(this.gl,o))this.colorBufferHalfFloatExtension=Mh(this.gl,o);else if(M().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Dr(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Dr(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=hU(this.gl),this.indexBuffer=gU(this.gl),this.framebuffer=K4(this.gl),this.textureConfig=Oh(this.gl,this.textureHalfFloatExtension)}get debug(){return M().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let n=this.gl;ce(n,()=>n.finish()),ce(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),ce(n,()=>n.deleteFramebuffer(this.framebuffer)),ce(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),ce(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),ce(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,t){return this.throwIfDisposed(),xU(this.gl,n,t,this.textureConfig)}createFloat16MatrixTexture(n,t){return this.throwIfDisposed(),yU(this.gl,n,t,this.textureConfig)}createUnsignedBytesMatrixTexture(n,t){return this.throwIfDisposed(),vU(this.gl,n,t,this.textureConfig)}uploadPixelDataToTexture(n,t){this.throwIfDisposed(),EU(this.gl,n,t)}uploadDenseMatrixToTexture(n,t,r,o){this.throwIfDisposed(),IU(this.gl,n,t,r,o,this.textureConfig)}createFloat16PackedMatrixTexture(n,t){return this.throwIfDisposed(),CU(this.gl,n,t,this.textureConfig)}createPackedMatrixTexture(n,t){return this.throwIfDisposed(),bU(this.gl,n,t,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(WD(this.gl,this.framebuffer),this.outputTexture=null),ce(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,t,r){return this.downloadMatrixDriver(n,()=>NU(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,t,r,o,s,i){return DU(this.gl,n,t,r,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(n,t){return SU(this.gl,n,t)}createBufferFromTexture(n,t,r){this.bindTextureToFrameBuffer(n);let o=TU(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let t,r;if(M().getBool("WEBGL_FENCE_API_ENABLED")){let o=n,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},t=s}else M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(n,t,r){return this.downloadMatrixDriver(n,()=>kU(this.gl,t,r))}createProgram(n){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=mU(t));let r=z4(t);ce(t,()=>t.attachShader(r,this.vertexShader)),ce(t,()=>t.attachShader(r,n)),G4(t,r);let o=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Pv(t,o),o}buildVao(n){this.setProgram(n),this.bindVertexArray(n.vao);let t=this.gl;ce(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),wU(t,n,this.vertexBuffer)}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),n!=null&&(ce(this.gl,()=>this.gl.deleteProgram(n)),this.deleteVertexArray(n.vao))}setProgram(n){this.throwIfDisposed(),this.program=n,this.program!=null&&this.debug&&Pv(this.gl,this.program),ce(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,t,r=!0){return this.throwIfDisposed(),r?X4(this.gl,n,t):Y4(this.gl,n,t)}getAttributeLocation(n,t){return this.throwIfDisposed(),ce(this.gl,()=>this.gl.getAttribLocation(n,t))}getUniformLocationNoThrow(n,t){return this.throwIfDisposed(),this.gl.getUniformLocation(n,t)}setInputMatrixTexture(n,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),Z4(this.gl,n,t,r)}setOutputMatrixTexture(n,t,r){this.setOutputMatrixTextureDriver(n,r,t)}setOutputPackedMatrixTexture(n,t,r){this.throwIfDisposed();let[o,s]=Qo(t,r);this.setOutputMatrixTextureDriver(n,o,s)}setOutputMatrixWriteRegion(n,t,r,o){this.setOutputMatrixWriteRegionDriver(r,n,o,t)}setOutputPackedMatrixWriteRegion(n,t,r,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Pv(this.gl,this.program),$h(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let n=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ce(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ce(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Mh(this.gl,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(o.TIME_ELAPSED_EXT,s),s}let n=this.getQueryTimerExtensionWebGL1(),t=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,t),t}endQuery(){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}let n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(n){return await y.repeatedTry(()=>this.disposed||this.isQueryAvailable(n,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(n,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(n,t){if(t===0)return null;if(t===2){let r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}else{let r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,t){if(t===0)return!0;if(t===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let r=this.getQueryTimerExtensionWebGL1(),o=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(n){return new Promise(t=>{this.addItemToPoll(()=>n.isFencePassed(),()=>t())})}pollItems(){let n=Bae(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=n;++t){let{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,t){if(this.itemsToPoll.push({isDoneFn:n,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in M().platform&&(r=M().platform.setTimeoutCustom.bind(M().platform)),y.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(n){this.throwIfDisposed(),Lv(this.gl,n,this.framebuffer),this.debug&&$h(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Lv(this.gl,this.outputTexture,this.framebuffer),this.debug&&$h(this.gl)):WD(this.gl,this.framebuffer)}downloadMatrixDriver(n,t){this.bindTextureToFrameBuffer(n);let r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,t,r){this.throwIfDisposed();let o=this.gl;Lv(o,n,this.framebuffer),this.debug&&$h(o),this.outputTexture=n,ce(o,()=>o.viewport(0,0,t,r)),ce(o,()=>o.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(n,t,r,o){this.throwIfDisposed(),ce(this.gl,()=>this.gl.scissor(n,t,r,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Bae(e){let n=0;for(;n<e.length&&e[n]();++n);return n-1}var{addImpl:_U,bincountImpl:qv,bincountReduceImpl:AU,bitwiseAndImpl:RU,castImpl:FU,ceilImpl:OU,concatImpl:MU,equalImpl:$U,expImpl:PU,expm1Impl:LU,floorImpl:BU,gatherNdImpl:VU,gatherV2Impl:UU,greaterImpl:zU,greaterEqualImpl:GU,lessImpl:HU,lessEqualImpl:WU,linSpaceImpl:jU,logImpl:qU,maxImpl:KU,maximumImpl:XU,minimumImpl:YU,multiplyImpl:ZU,negImpl:QU,notEqualImpl:JU,prodImpl:ez,raggedGatherImpl:tz,raggedRangeImpl:nz,raggedTensorToTensorImpl:rz,rangeImpl:oz,rsqrtImpl:sz,scatterImpl:iz,sigmoidImpl:az,simpleAbsImpl:Kv,sliceImpl:cz,sparseFillEmptyRowsImpl:lz,sparseReshapeImpl:uz,sparseSegmentReductionImpl:Xv,sqrtImpl:pz,staticRegexReplaceImpl:dz,stridedSliceImpl:fz,stringNGramsImpl:mz,stringSplitImpl:hz,stringToHashBucketFastImpl:gz,subImpl:xz,tileImpl:yz,topKImpl:vz,transposeImpl:Zu,uniqueImpl:bz}=SD;function JD(e,n){return["x","y","z","w","u","v"].slice(0,n).map(t=>`${e}.${t}`)}function kt(e,n){return n===1?[e]:JD(e,n)}function Cz(e,n){if(e===1)return"rc";let t="";for(let r=0;r<e;r++)t+=n[r],r<e-1&&(t+=",");return t}var Yv=class{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=rt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=kt("rc",this.rank),r=ve(this.rank),o=this.getOutOfBoundsCondition(t),s=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(n){let t=[];for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){let s=`${r===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${n[n.length-1-i]},`+s;t.push(s)}return t}getOutOfBoundsCondition(n){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${n[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(n){if(this.rank===1)return"";let t=n.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${o};
    `}getOutput(n){let t=this.getSourceCoordsArr(n);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}};var Ud=class{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=rt(this.outputShape.length);let r="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),r+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Vae(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Od():Fd(n)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};

        ${r}

        setOutput(result);
      }
    `}};function Vae(e,n){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${n?sU(["r","c","d"],"inputShape"):bo(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}T();var Zv=class{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(n,t,r){let o=Iz(t,r),s=Ez(n,o,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=wz(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let c=this.freeTextures[s].pop();return this.usedTextures[s].push(c),c}let a;return o===hn.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):o===hn.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):o===hn.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):o===hn.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):o===hn.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(n,t,r,o){if(this.freeTextures==null)return;let s=Iz(r,o),i=Ez(t,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=wz(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),c=M().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(n.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[i],u=l&&l.indexOf(n);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let n=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${n})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let n in this.freeTextures)this.freeTextures[n].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let n in this.usedTextures)this.usedTextures[n].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Uae(e,n){let t=e;if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===e.RGBA)return 16;if(n===t.RGBA16F)return 8;if(n===t.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}function wz(e,n,t,r,o){let s=zae(n,r),i;if(o){let[c,l]=Qo(e[0],e[1]);i=c*l}else{let[c,l]=qu(e[0],e[1]);i=c*l}let a=Uae(t,s);return i*a}function zae(e,n){switch(e){case hn.PACKED_2X2_FLOAT32:return ZD(n);case hn.PACKED_2X2_FLOAT16:return QD(n);case hn.UNPACKED_FLOAT32:return KD(n);case hn.UNPACKED_FLOAT16:return XD(n);case hn.PACKED_4X1_UNSIGNED_BYTE:return YD(n);default:throw new Error(`Unknown physical texture type ${e}`)}}function Gae(e){return M().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?hn.PACKED_2X2_FLOAT32:hn.UNPACKED_FLOAT32:e?hn.PACKED_2X2_FLOAT16:hn.UNPACKED_FLOAT16}function Iz(e,n){if(e===In.UPLOAD)return hn.PACKED_2X2_FLOAT32;if(e===In.RENDER||e==null)return Gae(n);if(e===In.DOWNLOAD||e===In.PIXELS)return hn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Ez(e,n,t){return`${e[0]}_${e[1]}_${n}_${t}`}var an=class{constructor(n,t){this.variableNames=["A"],this.outputShape=n,this.enableShapeUniforms=rt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Vt="if (isnan(x)) return x;",Tz="return x;",e1="return abs(x);";var Sz="return (x >= 0.0) ? x : (exp(x) - 1.0);",Nz=Vt+`
  return (x < 0.0) ? 0.0 : x;
`,Dz=Vt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,es="return x;",kz="return 1.0 / (1.0 + exp(-1.0 * x));";var Az="return x;",Rz=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Fz=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Oz=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Mz="return 1.0 / (1.0 + exp(-1.0 * x));",Hn=class{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=rt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var Qv=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n,this.enableShapeUniforms=rt(this.outputShape.length);let t=n.length,r=kt("rc",t),o=ve(t),s=Cz(t,r),i=r.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var Wae=sn.whereImpl,jae=1e-7,qae=1e-4,Jv={};function Kae(e){return e in Jv||(Jv[e]={}),Jv[e]}var Xae=M().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Yae=600;function Zae(){return M().global.screen==null?1024:M().global.screen.height*M().global.screen.width*window.devicePixelRatio*Yae/1024/1024}var $z=(()=>{class e extends Mo{nextDataId(){return e.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!M().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(t!=null){if(t instanceof Vd)r=t;else{let o=ar(M().getNumber("WEBGL_VERSION"),t);r=new Vd(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let o=ar(M().getNumber("WEBGL_VERSION"));r=new Vd(o),this.binaryCache=Kae(M().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Zv(this.gpgpu),this.numMBBeforeWarning=Zae(),this.texData=new di(this,Tr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,r,o,s,i,a){let c=this.makeTensorInfo(r,o),l=this.texData.get(c.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[s,i]},l.texShape=[s,i];let u=Ph(r),p=new Lh(u,!1,a),d=this.runWebGLProgram(p,[c],o,[[s,i]]);return d.shape=r,l.texture=null,this.disposeIntermediateTensorInfo(c),d.dataId}write(t,r,o){if((M().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||M().getBool("DEBUG"))&&this.checkNumericalProblems(t),o==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:r,dtype:o,values:t,usage:In.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let r=this.texData.get(t);r.refCount++}decRef(t){if(this.texData.has(t)){let r=this.texData.get(t);r.refCount--}}move(t,r,o,s,i){if(M().getBool("DEBUG")&&this.checkNumericalProblems(r),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:o,dtype:s,values:r,usage:In.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let r=this.texData.get(t),{values:o,dtype:s,complexTensorInfos:i,slice:a,shape:c,isPacked:l}=r;if(a!=null){let f;l?f=new Hn(c,es):f=new an(c,es);let m=this.runWebGLProgram(f,[{dataId:t,shape:c,dtype:s}],s),h=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),h}if(o!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return o;let u=this.activeTimers!=null,p;u&&(p=y.now());let d;if(s==="complex64"){let f=this.readSync(i.real.dataId),m=this.readSync(i.imag.dataId);d=S.mergeRealAndImagArrays(f,m)}else d=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=y.now()-p),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){let h=this.pendingRead.get(t);return new Promise(g=>h.push(g))}let r=this.texData.get(t),{values:o,shape:s,slice:i,dtype:a,complexTensorInfos:c,isPacked:l}=r;if(i!=null){let h;l?h=new Hn(s,es):h=new an(s,es);let g=this.runWebGLProgram(h,[{dataId:t,shape:s,dtype:a}],a),x=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),x}if(o!=null)return this.convertAndCacheOnCPU(t);if(M().getBool("DEBUG")&&!M().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&M().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,p;if(a!=="complex64"&&M().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(t);let h=this.texData.get(p.dataId);u=this.gpgpu.createBufferFromTexture(h.texture.texture,...Fh(s))}this.pendingRead.set(t,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(a==="complex64"){let h=await Promise.all([this.read(c.real.dataId),this.read(c.imag.dataId)]),g=h[0],x=h[1];d=S.mergeRealAndImagArrays(g,x)}else if(u==null)d=this.getValuesFromTexture(t);else{let h=y.sizeFromShape(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,h)}if(p!=null&&this.disposeIntermediateTensorInfo(p),u!=null){let h=this.gpgpu.gl;ce(h,()=>h.deleteBuffer(u))}let f=this.convertAndCacheOnCPU(t,d),m=this.pendingRead.get(t);return this.pendingRead.delete(t),m.forEach(h=>h(f)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Tr().removeDataId(t,this),this.pendingDeletes--),f}readToGPU(t,r={}){let o=this.texData.get(t),{values:s,shape:i,slice:a,dtype:c,isPacked:l,texture:u}=o;if(c==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let m;l?m=new Hn(i,es):m=new an(i,es);let h=this.runWebGLProgram(m,[{dataId:t,shape:i,dtype:c}],c),g=this.readToGPU(h,r);return this.disposeIntermediateTensorInfo(h),g}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(t,r.customTexShape),d=Tr().makeTensorFromTensorInfo(p),f=this.texData.get(p.dataId);return Object.assign({tensorRef:d},f.texture)}bufferSync(t){let r=this.readSync(t.dataId);if(t.dtype==="string")try{let o=r.map(s=>y.decodeString(s));return le(t.shape,t.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return le(t.shape,t.dtype,r)}checkNumericalProblems(t){if(t!=null)for(let r=0;r<t.length;r++){let o=t[r];if(!B4(o))throw M().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:r,dtype:o,isPacked:s}=this.texData.get(t),i=y.sizeFromShape(r);if(M().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let f=this.decode(t),m=this.texData.get(f.dataId),h=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...Fh(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),h}let a=M().getBool("WEBGL_PACK")&&s===!0,c=a?Ph(r):r,l=a?new Wv(c):new Hv(c),u=this.runWebGLProgram(l,[{shape:c,dtype:o,dataId:t}],"float32"),p=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let r=this.activeTimers,o=[],s=!1;this.programTimersStack==null?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,t();let i=y.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=y.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=r,s&&(this.programTimersStack=null);let c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(i);c.kernelMs=y.sum(l),c.getExtraProfileInfo=()=>l.map((u,p)=>({name:a[p],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:y.now(),endMs:null}}endTimer(t){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=y.now(),t)}async getQueryTime(t){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let r=t;return r.endMs-r.startMs}disposeData(t,r=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(r?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!r&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:o}=this.texData.get(t);return o!=null&&(this.disposeData(o.real.dataId,r),this.disposeData(o.imag.dataId,r)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:r,dtype:o,texShape:s,usage:i,isPacked:a,slice:c}=this.texData.get(t),l=c&&c.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),r!=null&&(this.numBytesInGPU-=this.computeBytes(s,o),this.textureManager.releaseTexture(r,s,i,a)));let p=this.texData.get(t);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,r=Xae){return M().getBool("WEBGL_CPU_FORWARD")&&t.every(o=>this.texData.get(o.dataId).texture==null&&y.sizeFromShape(o.shape)<r)}getGPGPUContext(){return this.gpgpu}where(t){S.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let r=t.dataSync();return Wae(t.shape,r)}packedUnaryOp(t,r,o){let s=new Hn(t.shape,r),i=this.compileAndRun(s,[t],o);return Tr().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let s=Kv(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if(M().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,e1,t.dtype);let r=new an(t.shape,e1),o=this.compileAndRun(r,[t]);return Tr().makeTensorFromTensorInfo(o)}makeTensorInfo(t,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&y.isString(o[0])){let i=o.map(a=>y.encodeString(a));s=this.write(i,t,r)}else s=this.write(o,t,r);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:r}}makeOutput(t,r,o){return Tr().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,o),this)}unpackTensor(t){let r=new Qv(t.shape);return this.runWebGLProgram(r,[t],t.dtype)}packTensor(t){let r=new Yv(t.shape);return this.runWebGLProgram(r,[t],t.dtype,null,!0)}packedReshape(t,r){let o=[Fa(t.shape),...Oa(t.shape)],s={dtype:t.dtype,shape:o,dataId:t.dataId},i=[Fa(r),...Oa(r)],a=new Ud(i,o),c=!0,l=[o],u=this.runWebGLProgram(a,[s],t.dtype,l,c);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(t,r){let o=this.texData.get(t),{isPacked:s,shape:i,dtype:a}=o;if(r!=null){let f=y.sizeFromShape(i),m=r[0]*r[1]*4;y.assert(f<=m,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let c=Ph(i),l;s?l=new Gv(c):l=new zv(c);let u=!0,p=[r??Fh(c)],d=this.runWebGLProgram(l,[{shape:c,dtype:a,dataId:t}],a,p,u,r);return{dtype:a,shape:i,dataId:d.dataId}}runWebGLProgram(t,r,o,s,i=!1,a){let c=this.makeTensorInfo(t.outputShape,o),l=this.texData.get(c.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===ju.DENSE){let v=a??Fh(t.outputShape);l.texShape=v.map(w=>w*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),y.sizeFromShape(c.shape)===0)return l.values=y.getTypedArrayFromDType(c.dtype,0),c;let u=[],p=r.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(v.dataId);if(w.texture==null){if(!t.packedInputs&&y.sizeFromShape(v.shape)<=M().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:w.values};t.packedInputs&&(w.isPacked=!0,w.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!w.isPacked!=!!t.packedInputs)v=w.isPacked?this.unpackTensor(v):this.packTensor(v),u.push(v),w=this.texData.get(v.dataId);else if(w.isPacked&&!Ku(w.shape,v.shape)){let I=v,_=v.shape;v.shape=w.shape,v=this.packedReshape(v,_),u.push(v),w=this.texData.get(v.dataId),I.shape=_}return{shape:v.shape,texData:w,isUniform:!1}});this.uploadToGPU(c.dataId);let d={shape:c.shape,texData:l,isUniform:!1},f=fU(t,p,d),m=this.getAndSaveBinary(f,()=>pU(this.gpgpu,t,p,d)),h=this.activeTimers!=null,g;h&&(g=this.startTimer()),M().get("ENGINE_COMPILE_ONLY")||dU(this.gpgpu,m,p,d,s),u.forEach(v=>this.disposeIntermediateTensorInfo(v)),h&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));let x=M().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){let v=y.now();v-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!M().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){let v=this.unpackTensor(c);return this.disposeIntermediateTensorInfo(c),v}return c}compileAndRun(t,r,o,s,i=!1){return o=o||r[0].dtype,this.runWebGLProgram(t,r,o,s,i)}getAndSaveBinary(t,r){return t in this.binaryCache||(this.binaryCache[t]=r()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(M().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Ce(()=>{if(!M().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=M().getBool("DEBUG");M().set("DEBUG",!1);let r=this.abs(me(1e-8)).dataSync()[0];if(M().set("DEBUG",t),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?jae:qae}uploadToGPU(t){let r=this.texData.get(t),{shape:o,dtype:s,values:i,texture:a,usage:c,isPacked:l}=r;if(a!=null)return;let u=this.activeTimers!=null,p;u&&(p=y.now());let d=r.texShape;if(d==null&&(d=Q4(o,l),r.texShape=d),i!=null){let f=Ph(o),m,h=d[1],g=d[0],x=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!x)&&([h,g]=Qo(d[0],d[1])),l?m=new jv(f,x):m=new Lh(f,x);let v=x?[g,h]:d,w=this.makeTensorInfo(v,s),I=this.texData.get(w.dataId);x?I.usage=In.PIXELS:I.usage=In.UPLOAD,I.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),h,g,i);let _=[[g,h]],R=this.runWebGLProgram(m,[w],s,_,!0),F=this.texData.get(R.dataId);r.texShape=F.texShape,r.isPacked=F.isPacked,r.usage=F.usage,M().get("ENGINE_COMPILE_ONLY")?this.disposeData(R.dataId):(r.texture=F.texture,r.values=null,this.texData.delete(R.dataId)),this.disposeIntermediateTensorInfo(w),u&&(this.uploadWaitMs+=y.now()-p)}else{let f=this.acquireTexture(d,c,s,l);r.texture=f}}convertAndCacheOnCPU(t,r){let o=this.texData.get(t),{dtype:s}=o;return r!=null&&(o.values=Qae(r,s)),o.values}acquireTexture(t,r,o,s){if(this.numBytesInGPU+=this.computeBytes(t,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,r,s)}computeBytes(t,r){return t[0]*t[1]*y.bytesPerElement(r)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,r]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(r));return Promise.all(t)}else{for(let[,r]of Object.entries(this.binaryCache)){let o=new Promise(s=>{try{this.checkCompletion_(r),s(!0)}catch(i){throw i}});t.push(o)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await lv(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(GD(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:r,customUniformLocations:o,infLoc:s,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}=qD(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=r,t.customUniformLocations=o,t.infLoc=s,t.nanLoc=i,t.outShapeLocation=a,t.outShapeStridesLocation=c,t.outTexShapeLocation=l}}createTensorFromGPUData(t,r,o){t.channels=t.channels||"RGBA";let{texture:s,height:i,width:a,channels:c}=t,l=Tr().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=l.writeTexture(s,r,o,i,a,c);return Tr().makeTensorFromDataId(u,r,o,l)}}return e.nextDataId=0,e})();function Qae(e,n){if(n==="float32"||n==="complex64")return e;if(n==="int32"||n==="bool"){let t=n==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<t.length;++r)t[r]=Math.round(e[r]);return t}else throw new Error(`Unknown dtype ${n}`)}xs.isBrowser()&&Im("webgl",()=>new $z,2);T();T();T();T();T();var zd=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Wn=class{constructor(n,t,r){this.variableNames=["A","B"],this.outputShape=S.assertAndGetBroadcastShape(t,r),this.enableShapeUniforms=rt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${n}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};T();var lr=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var cr=class{constructor(n,t,r,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S.assertAndGetBroadcastShape(t,r);let s=this.outputShape.length;this.enableShapeUniforms=rt(s);let i="";if(o)if(s===0||y.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${ve(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let c=kt("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${c[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${c[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${c[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${c[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${n}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};T();T();function _t(e){let{inputs:n,backend:t}=e,{x:r}=n;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Pz={kernelName:ms,backendName:"webgl",kernelFunc:_t};function jn(e){let{inputs:n,backend:t}=e,{real:r,imag:o}=n,s=t.makeTensorInfo(r.shape,"complex64"),i=t.texData.get(s.dataId),a=_t({inputs:{x:r},backend:t}),c=_t({inputs:{x:o},backend:t});return i.complexTensorInfos={real:a,imag:c},s}var Lz={kernelName:Oc,backendName:"webgl",kernelFunc:jn};T();var t1="return (a < 0.) ? b * a : a;",n1=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Jae(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{alpha:s}=r,i=t.makeTensorInfo([],"float32",y.createScalarValue(s,"float32")),a=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new cr(n1,o.shape,i.shape):new Wn(t1,o.shape,i.shape),c=t.runWebGLProgram(a,[o,i],"float32");return t.disposeIntermediateTensorInfo(i),c}var Bz={kernelName:pl,backendName:"webgl",kernelFunc:Jae};T();var r1="return (a < 0.) ? b * a : a;",o1=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function ece(e){let{inputs:n,backend:t}=e,{x:r,alpha:o}=n,s=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new cr(o1,r.shape,o.shape):new Wn(r1,r.shape,o.shape);return t.runWebGLProgram(s,[r,o],"float32")}var Vz={kernelName:kl,backendName:"webgl",kernelFunc:ece};var jr="if (isnan(x)) return x;";function pe({opSnippet:e,packedOpSnippet:n,cpuKernelImpl:t,dtype:r}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,c=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){let p=a.texData.get(i.dataId),d=t(p.values,c);return a.makeTensorInfo(i.shape,c,d)}let l=M().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&n!=null,u;return l?u=new Hn(i.shape,n):u=new an(i.shape,e),a.runWebGLProgram(u,[i],c)}}function Qe({opSnippet:e,packedOpSnippet:n,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:c,b:l}=i,u=a;if(r&&c.dtype==="complex64"){let m=u.texData.get(c.dataId),h=u.texData.get(l.dataId),[g,x]=[[m.complexTensorInfos.real,h.complexTensorInfos.real],[m.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(w=>{let[I,_]=w,A={dataId:I.dataId,dtype:I.dtype,shape:c.shape},R={dataId:_.dataId,dtype:_.dtype,shape:l.shape},F=new Wn(e,c.shape,l.shape);return u.runWebGLProgram(F,[A,R],Mt(I.dtype,_.dtype))}),v=jn({inputs:{real:g,imag:x},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(x),v}let p=s||Mt(c.dtype,l.dtype);if((c.dtype==="string"||l.dtype==="string"||u.shouldExecuteOnCPU([c,l]))&&o!=null){let m=u.texData.get(c.dataId).values,h=u.texData.get(l.dataId).values,g=c.dtype==="string"?S.fromUint8ToStringArray(m):m,x=c.dtype==="string"?S.fromUint8ToStringArray(h):h,[v,w]=o(c.shape,l.shape,g,x,p),I=u.makeTensorInfo(w,p),_=u.texData.get(I.dataId);return _.values=v,I}let d=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&n!=null,f;return d?f=new cr(n,c.shape,l.shape,t):f=new Wn(e,c.shape,l.shape),u.runWebGLProgram(f,[c,l],p)}}function Us(e,n=!1){if(e==="linear")return n?Az:Tz;if(e==="relu")return n?Fz:Nz;if(e==="elu")return n?Rz:Sz;if(e==="relu6")return n?Oz:Dz;if(e==="prelu")return n?o1:r1;if(e==="leakyrelu")return n?n1:t1;if(e==="sigmoid")return n?Mz:kz;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var Gd=class{constructor(n,t,r,o=!1,s=!1,i=!1,a=null,c=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=rt(this.outputShape.length);let u=o?n[1]:n[2],p=Math.ceil(u/2),d=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",m=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",x="";a&&(c?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");let v=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let w="rc.x",I="rc.x";n[0]<t[0]?w=`imod(rc.x, ${n[0]})`:t[0]<n[0]&&(I=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w};
        int batchB = ${I};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${h[0]});
          result += (${m[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${v}

        ${x}

        setOutput(result);
      }
    `}};T();T();var s1={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},Vh=class{constructor(n,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=S.assertAndGetBroadcastShape(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${n}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var Uz="return a * b;";function Uh(e){let{inputs:n,backend:t}=e,{a:r,b:o}=n,s=S.upcastType(r.dtype,o.dtype);if(r.dtype==="complex64"){let a=t.texData.get(r.dataId),c=t.texData.get(o.dataId),l=new Vh(s1.REAL,r.shape,o.shape),u=new Vh(s1.IMAG,r.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:o.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:o.shape}],d=t.runWebGLProgram(l,p,"float32"),f=t.runWebGLProgram(u,p,"float32"),m=jn({inputs:{real:d,imag:f},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),m}if(t.shouldExecuteOnCPU([r,o])){let a=t.texData.get(r.dataId),c=t.texData.get(o.dataId),[l,u]=ZU(r.shape,o.shape,a.values,c.values,s),p=t.makeTensorInfo(u,s),d=t.texData.get(p.dataId);return d.values=l,p}let i;return M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new cr(Uz,r.shape,o.shape):i=new Wn(Uz,r.shape,o.shape),t.runWebGLProgram(i,[r,o],s)}var zz={kernelName:Hi,backendName:"webgl",kernelFunc:Uh};T();function Gz(e,n,t){let r=[Fa(e.shape),...Oa(e.shape)],o={dtype:e.dtype,shape:r,dataId:e.dataId},s=[Fa(n),...Oa(n)],i=new Ud(s,r),a=!0,c=[r],l=t.runWebGLProgram(i,[o],e.dtype,c,a);return{dataId:l.dataId,shape:n,dtype:l.dtype}}function J(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{shape:s}=r,i=t,a=y.sizeFromShape(o.shape),c=y.inferFromImplicitShape(s,a),l=y.sizeFromShape(c);y.assert(a===l,()=>`The new shape (${c}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let u=i.texData.get(o.dataId);return u.isPacked&&!Ku(o.shape,c)&&!(u.texture!==null&&Ku(u.shape,c))?Gz(o,c,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:c,dtype:o.dtype})}var Hz={kernelName:$l,backendName:"webgl",kernelFunc:J};T();T();T();T();var zh=class{constructor(n,t){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=n;this.outputShape=[o,i];let a=Math.floor(r/4)*4,c=r%4,l="sumValue += dot(values, ones);";if(t!=null){let p=1/t;l=`sumValue += dot(values * ${y.isInt(p)?p.toPrecision(2):p}, ones);`}let u="";s%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var eb=class{constructor(n,t){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=n;this.outputShape=[o,i];let a="0.0",c="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",c="min"):t==="max"&&(a="-1.0 / 1e-20",c="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let u=Math.floor(r/4)*4,p=r%4,d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let m="";s%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function nce(e){let n=[];for(;n.length===0||n[n.length-1].outSize!==1;){let t=n.length?n[n.length-1].outSize:e[1],r=S.computeOptimalWindowSize(t);n.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return n}function ur(e,n,t,r){let o=nce(e.shape),s=e;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:c,outSize:l}=o[i],u,p;t==="mean"?u=i===0?new zh({windowSize:c,inSize:a,batchSize:e.shape[0],outSize:l},a):new zh({windowSize:c,inSize:a,batchSize:e.shape[0],outSize:l}):u=new eb({windowSize:c,inSize:a,batchSize:e.shape[0],outSize:l},t),p=s,s=r.runWebGLProgram(u,[s],n),p.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(p)}return s}T();var tb=class{constructor(n,t){this.variableNames=["A"];let r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[t[i]];this.outputShape=r,this.rank=r.length;let o=ve(this.rank),s=rce(t);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function rce(e){let n=e.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let o=0;o<e.length;o++)r[e[o]]=t[o];return r.join()}var nb=class{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let r=new Array(n.length);for(let u=0;u<r.length;u++)r[u]=n[t[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=ve(this.rank),s=JD("rc",this.rank),i=new Array(this.rank);for(let u=0;u<t.length;u++)i[t[u]]=s[u];let a=`vec2(${i.slice(-2).join()})`,c=`++${s[this.rank-1]} < ${r[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${c}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${l};
        if(${c}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function Ma(e,n,t){let r=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new nb(e.shape,n):new tb(e.shape,n);return t.runWebGLProgram(r,[e],e.dtype)}function Wz(e,n,t,r){let o=n,s=e.shape.length,i=y.parseAxisParam(o,e.shape),a=i,c=S.getAxesPermutation(a,s),l=c!=null,u=e;l&&(u=Ma(e,c,r),a=S.getInnerMostAxes(a.length,s)),S.assertAxesAreInnerMostDims("sum",a,s);let[p,d]=S.computeOutAndReduceShapes(u.shape,a),f=p;t&&(f=S.expandShapeToKeepDim(p,i));let m=y.sizeFromShape(d),g=y.sizeFromShape(e.shape)/m,x=J({inputs:{x:u},attrs:{shape:[g,m]},backend:r}),v=da(e.dtype),w=ur(x,v,"sum",r),I=J({inputs:{x:w},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(w),l&&r.disposeIntermediateTensorInfo(u),I}function Qu(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r;return Wz(o,s,i,t)}var jz={kernelName:"Sum",backendName:"webgl",kernelFunc:Qu};T();function ft(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{perm:s}=r,i=t,a=o.shape.length,c=new Array(a);for(let u=0;u<c.length;u++)c[u]=o.shape[s[u]];let l;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,d=Zu(p,o.shape,o.dtype,s,c);l=i.makeTensorInfo(c,o.dtype);let f=i.texData.get(l.dataId);f.values=d}else l=Ma(o,s,i);return l}var qz={kernelName:gs,backendName:"webgl",kernelFunc:ft};var i1=1e3;function Ju({a:e,b:n,transposeA:t,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:c=null}){let l=e.shape.length,u=n.shape.length,p=t?e.shape[l-2]:e.shape[l-1],d=r?n.shape[u-1]:n.shape[u-2],f=t?e.shape[l-1]:e.shape[l-2],m=r?n.shape[u-2]:n.shape[u-1],h=e.shape.slice(0,-2),g=n.shape.slice(0,-2),x=y.sizeFromShape(h),v=y.sizeFromShape(g),I=fo.assertAndGetBroadcastShape(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);y.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${e.shape} and ${n.shape} and transposeA=${t} and transposeB=${r} must match.`);let _=t?[x,p,f]:[x,f,p],A=r?[v,m,d]:[v,d,m],R=J({inputs:{x:e},backend:o,attrs:{shape:_}}),F=J({inputs:{x:n},backend:o,attrs:{shape:A}}),P=[R,F],L=Math.max(x,v),V=t?R.shape[1]:R.shape[2],z=s!=null,G=i!=null,j=c==="leakyrelu",W=c!=null?Us(c,!0):null,Y=z||G||j||W!=null,Z;if((f===1||m===1)&&V>i1&&Y===!1){let Q=R,te=F;t&&(Q=ft({inputs:{x:R},backend:o,attrs:{perm:[0,2,1]}}),P.push(Q)),r&&(te=ft({inputs:{x:F},backend:o,attrs:{perm:[0,2,1]}}),P.push(te));let ne=m!==1,se=m===1,re=Q;ne&&(re=J({inputs:{x:Q},backend:o,attrs:{shape:[L,V,1]}}),P.push(re));let ae=m===1?2:1,oe=te;se&&(oe=J({inputs:{x:te},backend:o,attrs:{shape:[L,1,V]}}),P.push(oe));let ue=Uh({inputs:{a:re,b:oe},backend:o});Z=Qu({inputs:{x:ue},backend:o,attrs:{axis:ae,keepDims:!0}}),P.push(ue)}else{let Q=Mt(e.dtype,n.dtype),te=new Gd(_,A,[L,f,m],t,r,z,W,G,j),ne=[R,F];if(s!=null&&ne.push(s),G&&ne.push(i),j){let se=o.makeTensorInfo([],"float32",y.createScalarValue(a,"float32"));ne.push(se),P.push(se)}Z=o.runWebGLProgram(te,ne,Q)}let K=J({inputs:{x:Z},backend:o,attrs:{shape:I}});P.push(Z);for(let Q of P)o.disposeIntermediateTensorInfo(Q);return K}function oce(e){let{inputs:n,backend:t,attrs:r}=e,{a:o,b:s,bias:i,preluActivationWeights:a}=n,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:p}=r;return Ju({a:o,b:s,transposeA:c,transposeB:l,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:u})}var Kz={kernelName:aa,backendName:"webgl",kernelFunc:oce};T();var Xz="return abs(x);";function sce(e){let{inputs:n,backend:t}=e,{x:r}=n;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=t.texData.get(r.dataId),i=Kv(s.values);return t.makeTensorInfo(r.shape,r.dtype,i)}let o;return M().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Hn(r.shape,Xz):o=new an(r.shape,Xz),t.runWebGLProgram(o,[r],r.dtype)}var Yz={kernelName:"Abs",backendName:"webgl",kernelFunc:sce};T();var ice=Vt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,ace=pe({opSnippet:ice}),Zz={kernelName:hi,backendName:"webgl",kernelFunc:ace};T();var cce=Vt+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,lce=pe({opSnippet:cce}),Qz={kernelName:gi,backendName:"webgl",kernelFunc:lce};T();var Jz="return a + b;",uce=Qe({opSnippet:Jz,packedOpSnippet:Jz,supportsComplex:!0,cpuKernelImpl:_U}),eG={kernelName:"Add",backendName:"webgl",kernelFunc:uce};T();var rb=class{constructor(n,t){this.outputShape=[],this.outputShape=n,this.variableNames=t.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var ob=class{constructor(n,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=t.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function sb(e){let{inputs:n,backend:t}=e,r=n;if(r.length===1)return _t({inputs:{x:r[0]},backend:t});if(r.length>M().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(r.length/2),l=sb({inputs:r.slice(0,c),backend:t}),u=sb({inputs:r.slice(c),backend:t});return sb({inputs:[l,u],backend:t})}let o=r.map(c=>c.dtype).reduce((c,l)=>Mt(c,l)),s=r.map(c=>c.shape),a=M().getBool("WEBGL_PACK")?new ob(r[0].shape,s):new rb(r[0].shape,s);return t.runWebGLProgram(a,r,o)}var tG={kernelName:Tc,backendName:"webgl",kernelFunc:sb};T();function pce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),l=c,u=S.getAxesPermutation(l,a),p=o;u!=null&&(p=ft({inputs:{x:o},backend:t,attrs:{perm:u}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("all",l,a);let[d,f]=S.computeOutAndReduceShapes(p.shape,l),m=y.sizeFromShape(f),h=J({inputs:{x:p},backend:t,attrs:{shape:[-1,m]}}),g=ur(h,h.dtype,"all",t),x;if(i){let v=S.expandShapeToKeepDim(d,c);x=J({inputs:{x:g},backend:t,attrs:{shape:v}})}else x=J({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(p),x}var nG={kernelName:"All",backendName:"webgl",kernelFunc:pce};T();function dce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),l=c,u=S.getAxesPermutation(l,a),p=o;u!=null&&(p=ft({inputs:{x:o},backend:t,attrs:{perm:u}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("any",l,a);let[d,f]=S.computeOutAndReduceShapes(p.shape,l),m=y.sizeFromShape(f),h=J({inputs:{x:p},backend:t,attrs:{shape:[-1,m]}}),g=ur(h,h.dtype,"any",t),x;if(i){let v=S.expandShapeToKeepDim(d,c);x=J({inputs:{x:g},backend:t,attrs:{shape:v}})}else x=J({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(p),x}var rG={kernelName:"Any",backendName:"webgl",kernelFunc:dce};T();T();var ib=class{constructor(n,t,r){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=t==="max"?">":"<",c=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};T();var ab=class{constructor(n,t,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,y.assert(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);let s=n[n.length-1],i=Math.ceil(s/t);this.outputShape=n.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,c=a.length,l=ve(c),u=kt("coords",c),p,d;if(i===1){d=c+1;let F=ve(d);p=`
        ${F} sourceLocR = ${F}(${u.join()}, 0);
        ++${u[c-1]};
        ${F} sourceLocG = ${F}(${u.join()}, 0);
        ++${u[c-2]};
        ${F} sourceLocA = ${F}(${u.join()}, 0);
        --${u[c-1]};
        ${F} sourceLocB = ${F}(${u.join()}, 0);
        --${u[c-2]};`}else d=c,p=`
        ${l} sourceLocR = coords;
        ++${u[c-1]};
        ${l} sourceLocG = coords;
        ++${u[c-2]};
        ${l} sourceLocA = coords;
        --${u[c-1]};
        ${l} sourceLocB = coords;
        --${u[c-2]};`;let f=["x","y","z","w","u","v"].slice(0,d),m="."+f[d-1],h=f.map(F=>"int "+F),g=kt("sourceLocR",d-1).concat("inIdx.r"),x=kt("sourceLocG",d-1).concat("inIdx.g"),v=kt("sourceLocB",d-1).concat("inIdx.b"),w=kt("sourceLocA",d-1).concat("inIdx.a"),I=r==="max"?"greaterThan":"lessThan",_=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()})));`,A=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${v.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,R=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[c-1]} < ${a[c-1]-1};
        bool hasNextRow = ${u[c-2]} < ${a[c-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${A};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${_}
          vec4 candidate = ${A};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${I}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function oG(e,n,t,r=null){let o=n.shape[0],s=n.shape[1];r!=null&&(o=r.shape[0],s=r.shape[1]);let i=S.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},c=new ib(a,t,r==null),l=[n];r!=null&&l.push(r);let u=e.runWebGLProgram(c,l,"int32");if(u.shape[1]===1)return u;let p=oG(e,n,t,u);return e.disposeIntermediateTensorInfo(u),p}function sG(e,n,t,r=null){let o=r!=null?r.shape:n.shape,s=o[o.length-1],i=S.computeOptimalWindowSize(s),a=new ab(o,i,t,r==null),c=r==null?[n]:[n,r],l=e.runWebGLProgram(a,c,"int32");if(l.shape.length===n.shape.length){let u=sG(e,n,t,l);return e.disposeIntermediateTensorInfo(l),u}return l}function cb(e,n,t,r){let o=[t];if(S.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,n.shape.length),!M().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){let s=[],i=e.texData.get(n.dataId),a=i!==null&&i.isPacked,c=n;a&&(c=e.unpackTensor(n),s.push(c));let[l,u]=S.computeOutAndReduceShapes(c.shape,o),p=y.sizeFromShape(u),d=J({inputs:{x:c},backend:e,attrs:{shape:[-1,p]}});s.push(d);let f=oG(e,d,r);s.push(f);let m=J({inputs:{x:f},backend:e,attrs:{shape:l}});return s.forEach(h=>e.disposeIntermediateTensorInfo(h)),m}return sG(e,n,r)}function fce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s}=r,i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,l=[];a!=null&&(c=ft({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),S.assertAxesAreInnerMostDims("argMax",[i[0]],c.shape.length);let u=cb(t,c,i[0],"max");return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),u}var iG={kernelName:Sc,backendName:"webgl",kernelFunc:fce};T();function mce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s}=r,i=y.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),c=o,l=[];a!=null&&(c=ft({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(c),i=S.getInnerMostAxes(i.length,c.shape.length)),S.assertAxesAreInnerMostDims("argMin",[i[0]],c.shape.length);let u=cb(t,c,i[0],"min");return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),u}var aG={kernelName:Nc,backendName:"webgl",kernelFunc:mce};T();var hce=Vt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,gce=pe({opSnippet:hce}),cG={kernelName:xi,backendName:"webgl",kernelFunc:gce};T();var xce=Vt+"return log(x + sqrt(x * x + 1.0));",yce=pe({opSnippet:xce}),lG={kernelName:yi,backendName:"webgl",kernelFunc:yce};T();var vce=Vt+`
  return atan(x);
`,bce=pe({opSnippet:vce}),uG={kernelName:vi,backendName:"webgl",kernelFunc:bce};T();var Cce=zd+`
  return atan(a, b);
`,wce=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+lr+`
  return result;
`,Ice=Qe({opSnippet:Cce,packedOpSnippet:wce}),pG={kernelName:Ci,backendName:"webgl",kernelFunc:Ice};T();var Ece=Vt+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Tce=pe({opSnippet:Ece}),dG={kernelName:bi,backendName:"webgl",kernelFunc:Tce};T();var Co=class{constructor(n,t,r,o=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=n.filterWidth,a=n.strideHeight,c=n.strideWidth,l=n.dilationHeight,u=n.dilationWidth,p=n.effectiveFilterHeight,d=n.effectiveFilterWidth,f=n.padInfo.top,m=n.padInfo.left;this.outputShape=n.outShape;let h=t==="avg",g=`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`,x=`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`,v="0.0";if(h||(v="-1.0 / 1e-20"),r){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${c});
        const ivec2 pads = ivec2(${f}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:x:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(I="avgValue / max(count, 1.0)");let _=Math.floor(i/4)*4,A=i%4,R=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${c});
      const ivec2 pads = ivec2(${f}, ${m});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${n.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${n.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${_};
          if (${A===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${A===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${A===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${I});
      }
    `}},$a=class{constructor(n,t,r,o=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=n.filterWidth,a=n.strideDepth,c=n.strideHeight,l=n.strideWidth,u=n.dilationDepth,p=n.dilationHeight,d=n.dilationWidth,f=n.effectiveFilterDepth,m=n.effectiveFilterHeight,h=n.effectiveFilterWidth,g=n.padInfo.front,x=n.padInfo.top,v=n.padInfo.left;this.outputShape=n.outShape;let w=t==="avg",I="0.0";if(w||(I="-1.0 / 1e-20"),r){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${c}, ${l});
        const ivec3 pads = ivec3(${g}, ${x}, ${v});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${n.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${n.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${n.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${m} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let _="max",A=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(A="avgValue / max(count, 1.0)");let R=Math.floor(i/4)*4,F=i%4,P=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${c}, ${l});
      const ivec3 pads = ivec3(${g}, ${x}, ${v});
      const float initializationValue = ${I};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${n.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${I});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${n.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${P}
            }

            int xC = xCCorner + ${R};
            if (${F===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${P}
            } else if (${F===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${P}
            } else if (${F===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${P}
            }
          }
        }
        setOutput(${A});
      }
    `}};function Sce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n;Jo(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let u=S.computePool2DInfo(o.shape,s,i,l,a,c);if(u.filterWidth===1&&u.filterHeight===1&&y.arraysEqual(u.inShape,u.outShape))return _t({inputs:{x:o},backend:t});let p=new Co(u,"avg",!1);return t.runWebGLProgram(p,[o],"float32")}var fG={kernelName:Dc,backendName:"webgl",kernelFunc:Sce};T();function Nce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:c,dataFormat:l}=r,u=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,u,a,c,l),d=new $a(p,"avg",!1);return t.runWebGLProgram(d,[o],"float32")}var mG={kernelName:kc,backendName:"webgl",kernelFunc:Nce};T();var lb=class{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;let t=n.filterHeight,r=n.filterWidth,o=n.strideHeight,s=n.strideWidth,i=n.dilationHeight,a=n.dilationWidth,c=n.effectiveFilterHeight,l=n.effectiveFilterWidth,u=c-1-n.padInfo.top,p=l-1-n.padInfo.left,d=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${p});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},ub=class{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;let t=n.filterDepth,r=n.filterHeight,o=n.filterWidth,s=n.strideDepth,i=n.strideHeight,a=n.strideWidth,c=n.dilationDepth,l=n.dilationHeight,u=n.dilationWidth,p=n.effectiveFilterDepth,d=n.effectiveFilterHeight,f=n.effectiveFilterWidth,m=p-1-n.padInfo.front,h=d-1-n.padInfo.top,g=f-1-n.padInfo.left,x=1/(t*r*o);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${h}, ${g});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Dce(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,input:s}=n,i=s,{filterSize:a,strides:c,pad:l,dimRoundingMode:u}=r,p=[1,1,1],d=S.computePool3DInfo(i.shape,a,c,p,l,u),f=new ub(d);return t.runWebGLProgram(f,[o],i.dtype)}var hG={kernelName:im,backendName:"webgl",kernelFunc:Dce};T();function kce(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,input:s}=n,i=s;Jo([o,s],"avgPoolGrad");let{filterSize:a,strides:c,pad:l}=r,u=S.computePool2DInfo(i.shape,a,c,1,l),p=new lb(u);return t.runWebGLProgram(p,[o],i.dtype)}var gG={kernelName:sm,backendName:"webgl",kernelFunc:kce};T();function _ce(e){let{inputs:n,backend:t,attrs:r}=e,{a:o,b:s}=n,{transposeA:i,transposeB:a}=r;return Ju({a:o,b:s,transposeA:i,transposeB:a,backend:t})}var xG={kernelName:_c,backendName:"webgl",kernelFunc:_ce};T();T();var pb=class{constructor(n,t,r,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(n,t),S.assertAndGetBroadcastShape(n,r);let a="0.0";o!=null&&(S.assertAndGetBroadcastShape(n,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let c="1.0";s!=null&&(S.assertAndGetBroadcastShape(n,s),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};T();var db=class{constructor(n,t,r,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(n,t),S.assertAndGetBroadcastShape(n,r);let a="vec4(0.0)";o!=null&&(S.assertAndGetBroadcastShape(n,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let c="vec4(1.0)";s!=null&&(S.assertAndGetBroadcastShape(n,s),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var Ace=({inputs:e,backend:n,attrs:t})=>{let{x:r,mean:o,variance:s,offset:i,scale:a}=e;y.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=t;c==null&&(c=.001);let l=[r,o,s],u=null;i!=null&&(u=i.shape,l.push(i));let p=null;a!=null&&(p=a.shape,l.push(a));let d=M().getBool("WEBGL_PACK_NORMALIZATION")?new db(r.shape,o.shape,s.shape,u,p,c):new pb(r.shape,o.shape,s.shape,u,p,c);return n.runWebGLProgram(d,l,l[0].dtype)},yG={kernelName:il,backendName:"webgl",kernelFunc:Ace};T();T();var fb=class{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;let t=ve(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let r=Rce(this.rank),o,s=n.map((i,a)=>`sourceLoc.${a1[a]} = start[${a}] + coords.${a1[a]};`);o=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${r}));
      }
    `}},a1=["x","y","z","w","u","v"];function Rce(e){if(e===1)return"sourceLoc";if(e<=6)return a1.slice(0,e).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var mb=class{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=ve(this.rank),r=kt("coords",this.rank),o=kt("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${n.map((u,p)=>`start[${p}]`).join()});`:n.map((u,p)=>`${o[p]} = ${r[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${c}
        setOutput(result);
      }
    `}};function Fce(e,n,t,r){let o=r.texData.get(e.dataId),s=r.makeTensorInfo(t,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=t,i.dtype=e.dtype;let a=zt.computeFlatOffset(n,y.computeStrides(e.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||e.dataId};let c=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,c+1),s}function wo(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{begin:s,size:i}=r,[a,c]=zt.parseSliceParams(o,s,i);if(zt.assertParamsValid(o,a,c),y.sizeFromShape(c)===0)return t.makeTensorInfo(c,o.dtype,[]);if(t.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=t.texData.get(o.dataId),d=cz(p.values,a,c,o.shape,o.dtype);return t.makeTensorInfo(c,o.dtype,d)}let{isPacked:l}=t.texData.get(o.dataId),u=zt.isSliceContinous(o.shape,a,c);if(l||!u){let p=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mb(c):new fb(c),d=[a];return t.runWebGLProgram(p,[o],o.dtype,d)}return t.uploadToGPU(o.dataId),Fce(o,a,c,t)}var vG={kernelName:Hl,backendName:"webgl",kernelFunc:wo};var Oce=e=>{let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{blockShape:s,crops:i}=r;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((v,w)=>v*w),c=S.getReshaped(o.shape,s,a),l=S.getPermuted(c.length,s.length),u=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),d=S.getSliceSize(u,i,s.length),f=[],m=J({inputs:{x:o},backend:t,attrs:{shape:c}}),h=ft({inputs:{x:m},backend:t,attrs:{perm:l}}),g=J({inputs:{x:h},backend:t,attrs:{shape:u}}),x=wo({inputs:{x:g},backend:t,attrs:{begin:p,size:d}});return f.push(m),f.push(h),f.push(g),f.forEach(v=>t.disposeIntermediateTensorInfo(v)),x},bG={kernelName:Ac,backendName:"webgl",kernelFunc:Oce};T();function Mce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,weights:s}=n,{size:i}=r,a=t.readSync(o.dataId),c=t.readSync(s.dataId),l=qv(a,c,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,l)}var CG={kernelName:Rc,backendName:"webgl",kernelFunc:Mce};T();var $ce=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Pce=`
  return float(int(a.r) & int(b.r));
`;function Lce(e){let{inputs:n,backend:t}=e,{a:r,b:o}=n,s=M().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=M().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([r,o])||i===1){let c=t.texData.get(r.dataId).values,l=t.texData.get(o.dataId).values,[u,p]=RU(r.shape,o.shape,c,l,r.dtype),d=t.makeTensorInfo(p,r.dtype),f=t.texData.get(d.dataId);return f.values=u,d}let a;return s?a=new cr($ce,r.shape,o.shape,!1):a=new Wn(Pce,r.shape,o.shape),t.runWebGLProgram(a,[r,o],r.dtype)}var wG={kernelName:wi,backendName:"webgl",kernelFunc:Lce};T();function Bce(e){let{inputs:n,backend:t}=e,{s0:r,s1:o}=n,s=t.readSync(r.dataId),i=t.readSync(o.dataId),a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var IG={kernelName:Fc,backendName:"webgl",kernelFunc:Bce};T();T();T();var Vce="return float(a != b);",c1=Qe({opSnippet:Vce,cpuKernelImpl:JU,dtype:"bool"}),EG={kernelName:Wi,backendName:"webgl",kernelFunc:c1};T();function zs(e){let{inputs:n,backend:t}=e,{input:r}=n,o=t.texData.get(r.dataId);return _t({inputs:{x:o.complexTensorInfos.real},backend:t})}var TG={kernelName:Ml,backendName:"webgl",kernelFunc:zs};var Uce="return float(int(x));";function SG(e,n){let t=new an(e.shape,Uce),r=n.runWebGLProgram(t,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function l1(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return _t({inputs:{x:o},backend:t});let i=Nr(o.shape),a=l1({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),c=jn({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),c}if(o.dtype==="complex64"){let i=zs({inputs:{input:o},backend:t}),a=l1({inputs:{x:i},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(i),a}if(!y.hasEncodingLoss(o.dtype,s)){let i=_t({inputs:{x:o},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(t.shouldExecuteOnCPU([o])){let i=t.texData.get(o.dataId).values,[a,c,l]=FU(i,o.shape,o.dtype,s);return t.makeTensorInfo(a,c,l)}if(s==="int32")return SG(o,t);if(s==="bool"){let i=t.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),c=c1({inputs:{a:o,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),c}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var NG={kernelName:fs,backendName:"webgl",kernelFunc:l1};T();var DG="return ceil(x);",zce=pe({opSnippet:DG,packedOpSnippet:DG,cpuKernelImpl:OU}),kG={kernelName:Ii,backendName:"webgl",kernelFunc:zce};T();var hb=class{constructor(n){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var gb=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Gce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{clipValueMin:s,clipValueMax:i}=r,a;M().getBool("WEBGL_PACK_CLIP")?a=new gb(o.shape):a=new hb(o.shape);let c=[[s],[i]];return t.runWebGLProgram(a,[o],o.dtype,c)}var _G={kernelName:Ei,backendName:"webgl",kernelFunc:Gce};T();var xb=class{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function AG(e,n){return{dataId:n.dataId,dtype:n.dtype,shape:e.shape}}function Hce(e){let{inputs:n,backend:t}=e,{x:r}=n,o=t.texData.get(r.dataId),s=new xb(r.shape),i=[AG(r,o.complexTensorInfos.real),AG(r,o.complexTensorInfos.imag)];return t.runWebGLProgram(s,i,i[0].dtype)}var RG={kernelName:Mc,backendName:"webgl",kernelFunc:Hce};T();T();T();var yb=class{constructor(n){this.outputShape=[],this.outputShape=S.computeOutShape(n,1),this.variableNames=n.map((i,a)=>`T${a}`);let t=new Array(n.length-1);t[0]=n[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+n[i][1];let r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){let a=t[i-1];r.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=t.length,s=t[t.length-1];r.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};T();var bb=class{constructor(n,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=S.computeOutShape(n,t);let r=this.outputShape,o=r.length,s=ve(o),i=kt("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=n.map((h,g)=>`T${g}`);let c=new Array(n.length-1);c[0]=n[0][t];for(let h=1;h<c.length;h++)c[h]=c[h-1]+n[h][t];let l=a[t],u=a.slice(-2),p=a.join(),d=`if (${l} < ${c[0]}) {
        return getChannel(
            getT0(${p}), vec2(${u.join()}));
        }`;for(let h=1;h<c.length;h++){let g=c[h-1];d+=`
        if (${l} < ${c[h]}  && ${l} >= ${c[h-1]}) {
          return getChannel(
            getT${h}(${vb(a,l,g)}),
            vec2(${vb(u,l,g)}));
        }`}let f=c.length,m=c[c.length-1];d+=`
        return getChannel(
          getT${f}(${vb(a,l,m)}),
          vec2(${vb(u,l,m)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${r[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${r[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${r[o-2]} &&
            ${i[o-1]} < ${r[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function vb(e,n,t){let r=e.indexOf(n);return e.map((s,i)=>i===r?`${s} - ${t}`:s).join()}T();function ep(e){let{inputs:n,backend:t}=e,{input:r}=n,o=t.texData.get(r.dataId);return _t({inputs:{x:o.complexTensorInfos.imag},backend:t})}var FG={kernelName:ul,backendName:"webgl",kernelFunc:ep};function Hd(e,n,t){let r=e[0].dtype;if(r==="complex64"){let f=e.map(v=>zs({inputs:{input:v},backend:t})),m=e.map(v=>ep({inputs:{input:v},backend:t})),h=Hd(f,n,t),g=Hd(m,n,t),x=jn({inputs:{real:h,imag:g},backend:t});return f.forEach(v=>t.disposeIntermediateTensorInfo(v)),m.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),x}let o=t.shouldExecuteOnCPU(e);if(r==="string"&&(o=!0),o){let f=e.map(I=>{let A=[-1,y.sizeFromShape(I.shape.slice(n))];return J({inputs:{x:I},backend:t,attrs:{shape:A}})}),m=f.map(I=>({vals:t.readSync(I.dataId),shape:I.shape})),h=S.computeOutShape(f.map(I=>I.shape),1),g=f[0].shape[0]===1,x=MU(m,h,r,g),v=S.computeOutShape(e.map(I=>I.shape),n),w=t.makeTensorInfo(v,r,x);return f.forEach(I=>t.disposeIntermediateTensorInfo(I)),w}let s=e.filter(f=>y.sizeFromShape(f.shape)>0),i=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let f=i?new an(e[0].shape,es):new Hn(e[0].shape,es);return t.runWebGLProgram(f,e,r)}let a=M().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){let f=[];for(let h=0;h<s.length;h+=a){let g=s.slice(h,h+a);f.push(Hd(g,n,t))}let m=Hd(f,n,t);for(let h of f)t.disposeIntermediateTensorInfo(h);return m}if(i){let f=new bb(s.map(m=>m.shape),n);return t.runWebGLProgram(f,s,r)}let{tensors2D:c,outShape:l}=Wce(s,n,t),u=new yb(c.map(f=>f.shape)),p=t.runWebGLProgram(u,c,r);c.forEach(f=>t.disposeIntermediateTensorInfo(f));let d=J({inputs:{x:p},attrs:{shape:l},backend:t});return t.disposeIntermediateTensorInfo(p),d}function Wce(e,n,t){let r=S.computeOutShape(e.map(s=>s.shape),n);return{tensors2D:e.map(s=>J({inputs:{x:s},attrs:{shape:[-1,y.sizeFromShape(s.shape.slice(n))]},backend:t})),outShape:r}}function u1(e){let{inputs:n,backend:t,attrs:r}=e,{axis:o}=r,s=y.parseAxisParam(o,n[0].shape)[0],i=n.map(l=>l.shape);S.assertParamsConsistent(i,s);let a=S.computeOutShape(n.map(l=>l.shape),s);if(y.sizeFromShape(a)===0)return t.makeTensorInfo(a,n[0].dtype,[]);let c=n.filter(l=>y.sizeFromShape(l.shape)>0);return c.length===1?_t({inputs:{x:c[0]},backend:t}):Hd(c,s,t)}var OG={kernelName:$c,backendName:"webgl",kernelFunc:u1};T();var Wd=class{constructor(n,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;let i=n.padInfo.top,a=n.padInfo.left,c=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,p=n.dilationWidth,d=n.filterHeight,f=n.filterWidth,m=Math.floor(n.inChannels/4)*4,h=n.inChannels%4,g=n.dataFormat==="channelsLast",x=g?1:2,v=g?2:3,w=g?3:1,I="",_="";r&&(o?I=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?I=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:I=`
          float activation(float x) {
            ${r}
          }
        `,_="result = activation(result);");let A=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${I}

      const ivec2 strides = ivec2(${c}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${v}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${n.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${n.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${A}
        ${_}
        setOutput(result);
      }
    `}},Cb=class{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;let t=n.padInfo.front,r=n.padInfo.top,o=n.padInfo.left,s=n.strideDepth,i=n.strideHeight,a=n.strideWidth,c=n.dilationDepth,l=n.dilationHeight,u=n.dilationWidth,p=n.filterDepth,d=n.filterHeight,f=n.filterWidth,m=Math.floor(n.inChannels/4)*4,h=n.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${t}, ${r}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${n.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};T();var jd=class{constructor(n,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=rt(this.outputShape.length);let i=n.padInfo.left,a=n.strideWidth,c=n.dilationWidth,l=n.filterHeight,u=n.filterWidth,p=u,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${n.inChannels}; d1 += 2) {
       `;for(let g=0;g<u;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(p+1)/2;g++){let x=g*2;if(d+=`
           xC = xCCorner + ${x*c};
           `,a===1){if(x<u&&(i%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,c===1&&x>0?d+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<u)){let v=i%2===0?y.nearestLargerEven(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${v};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,c>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:d+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):v===1?d+=`
                     xC${x+1} = xTexelC${x};
                     `:d+=`
                     xCOffset = xC + ${v};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<u&&(i%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<u&&(d+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<u&&(d+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${n.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<u&&(d+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${n.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let f="",m="";r&&(o?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:s?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:f=`vec4 activation(vec4 x) {
           ${r}
         }`,m="result = activation(result);");let h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${h}
         ${m}
         setOutput(result);
       }
     `}};T();var wb=class{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=n,this.enableShapeUniforms=rt(this.outputShape.length);let{dataFormat:r}=t,o=wt(),s=r==="channelsLast",i=s?1:2,a=s?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${n[2]} && pos < ${n[1]}) {`,l="";for(let u=0;u<=1;u++)for(let p=0;p<=1;p++)l+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${u};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function Ib(e,n){let t=e.length;return t>=3?n?[...e.slice(0,-3),e[t-3]*e[t-2],e[t-1]]:[...e.slice(0,-3),e[t-3],e[t-2]*e[t-1]]:!n&&t===1&&e[0]>1?[e[0],1]:null}function Eb({x:e,filter:n,convInfo:t,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let c=e.shape,l=r.texData.get(e.dataId),u=t.inChannels,p=c[0]*c[1]*c[2],d=t.outChannels,f=t.dataFormat==="channelsLast",m=!1,h=!1,g,x=[];if(s!=null){let I=Ib(s.shape,f);I!=null&&(s=J({inputs:{x:s},backend:r,attrs:{shape:I}}),x.push(s))}if(o!=null){let I=Ib(o.shape,f);I!=null&&(o=J({inputs:{x:o},backend:r,attrs:{shape:I}}),x.push(o))}if(!((p===1||d===1)&&u>i1)&&l.isPacked&&f&&l.texture!=null&&c[2]%2!==0&&y.arraysEqual(l.shape.slice(-3),c.slice(-3))){let I=c[0]*c[1]*(c[2]+1),_={dataId:e.dataId,shape:[1,I,t.inChannels],dtype:e.dtype},A=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,y.assert(Ku(l.shape,_.shape),()=>`packed reshape ${l.shape} to ${_.shape} isn't free`);let R=J({inputs:{x:n},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});x.push(R);let F=Ju({a:_,b:R,backend:r,transposeA:m,transposeB:h,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),P=r.texData.get(F.dataId);y.assert(P.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=A,P.shape=t.outShape,g=_t({inputs:{x:F},backend:r}),g.shape=t.outShape,x.push(F)}else{let I=t.outHeight*t.outWidth,_=J({inputs:{x:e},backend:r,attrs:{shape:f?[t.batchSize,I,t.inChannels]:[t.batchSize,t.inChannels,I]}}),A=J({inputs:{x:n},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),R=Ju({a:f?_:A,b:f?A:_,transposeA:!f,transposeB:h,backend:r,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});g=J({inputs:{x:R},backend:r,attrs:{shape:t.outShape}}),x.push(_),x.push(A),x.push(R)}for(let I of x)r.disposeIntermediateTensorInfo(I);return g}function Tb({x:e,filter:n,convInfo:t,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:c,filterHeight:l,inChannels:u,outWidth:p,outHeight:d,dataFormat:f}=t,m=f==="channelsLast",h=c*l*u,g=d*p,x=[t.batchSize,h,g],v=!0,w=!1,I=[];if(s!=null){let K=Ib(s.shape,m);K!=null&&(s=J({inputs:{x:s},backend:r,attrs:{shape:K}}),I.push(s))}if(o!=null){let K=Ib(o.shape,m);K!=null&&(o=J({inputs:{x:o},backend:r,attrs:{shape:K}}),I.push(o))}let _=J({inputs:{x:n},backend:r,attrs:{shape:[1,h,y.sizeFromShape(n.shape)/h]}});I.push(_);let A=new wb(x,t),R=[e.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],F=r.runWebGLProgram(A,[e],"float32",R),P=J({inputs:{x:F},backend:r,attrs:{shape:x}});I.push(F),I.push(P);let L=o!=null,V=s!=null,z=a==="leakyrelu",G=a?Us(a,!0):null,j=new Gd(m?P.shape:_.shape,m?_.shape:P.shape,m?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],v,w,L,G,V,z),W=m?[P,_]:[_,P];if(o&&W.push(o),V&&W.push(s),z){let K=r.makeTensorInfo([],"float32",y.createScalarValue(i,"float32"));W.push(K),I.push(K)}let Y=r.runWebGLProgram(j,W,"float32"),Z=J({inputs:{x:Y},backend:r,attrs:{shape:t.outShape}});I.push(Y);for(let K of I)r.disposeIntermediateTensorInfo(K);return Z}function jce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s}=n,{strides:i,pad:a,dataFormat:c,dilations:l,dimRoundingMode:u}=r,p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,s.shape,i,l,a,u,!1,p),f;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))f=Eb({x:o,filter:s,convInfo:d,backend:t});else if(d.strideWidth<=2&&p==="channelsLast"&&M().getBool("WEBGL_EXP_CONV")){let h=new jd(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];f=t.runWebGLProgram(h,[o,s],"float32",g)}else if(M().getBool("WEBGL_CONV_IM2COL"))f=Tb({x:o,filter:s,convInfo:d,backend:t});else{let h=new Wd(d);f=t.runWebGLProgram(h,[o,s],"float32")}let m=J({inputs:{x:f},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(f),m}var MG={kernelName:Pc,backendName:"webgl",kernelFunc:jce};T();var Sb=class{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;let t=n.strideHeight,r=n.strideWidth,o=n.padInfo.top,s=n.padInfo.left,i=n.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${n.batchSize}; b++) {
          for (int yR = 0; yR < ${n.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${n.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Nb=class{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;let t=n.filterHeight,r=n.filterWidth,o=n.strideHeight,s=n.strideWidth,i=n.dataFormat==="channelsLast",a=t-1-n.padInfo.top,c=r-1-n.padInfo.left,l=i?1:2,u=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Db=class{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;let t=n.strideDepth,r=n.strideHeight,o=n.strideWidth,s=n.padInfo.front,i=n.padInfo.top,a=n.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${n.batchSize}; b++) {
          for (int yF = 0; yF < ${n.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${n.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${n.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${n.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${n.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${n.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},kb=class{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;let t=n.filterDepth,r=n.filterHeight,o=n.filterWidth,s=n.strideDepth,i=n.strideHeight,a=n.strideWidth,c=t-1-n.padInfo.front,l=r-1-n.padInfo.top,u=o-1-n.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function qce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,dy:s}=n,{strides:i,pad:a,dataFormat:c,dimRoundingMode:l,filterShape:u}=r,p=S.convertConv2DDataFormat(c),d=S.computeConv2DInfo(o.shape,u,i,1,a,l,!1,p),f=new Sb(d);return t.runWebGLProgram(f,[o,s],"float32")}var $G={kernelName:Lc,backendName:"webgl",kernelFunc:qce};T();var _b=class{constructor(n){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=n.inShape,this.enableShapeUniforms=rt(this.outputShape.length);let t=n.filterHeight,r=n.filterWidth,o=t-1-n.padInfo.top,s=r-1-n.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${n.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${n.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function Kce(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,filter:s}=n,{inputShape:i,strides:a,pad:c,dataFormat:l,dimRoundingMode:u}=r,p=S.convertConv2DDataFormat(l),d=S.computeConv2DInfo(i,s.shape,a,1,c,u,!1,p);if(M().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){let f=[[d.strideHeight,d.strideWidth]],m=new _b(d);return t.runWebGLProgram(m,[o,s],"float32",f)}else{let f=new Nb(d);return t.runWebGLProgram(f,[o,s],"float32")}}var PG={kernelName:Bc,backendName:"webgl",kernelFunc:Kce};T();function Xce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s}=n,{strides:i,pad:a,dilations:c}=r,l=S.computeConv3DInfo(o.shape,s.shape,i,c,a),u=new Cb(l);return t.runWebGLProgram(u,[o,s],"float32")}var LG={kernelName:Vc,backendName:"webgl",kernelFunc:Xce};T();function Yce(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,dy:s}=n,{strides:i,pad:a,filterShape:c}=r,l=S.computeConv3DInfo(o.shape,c,i,1,a),u=new Db(l);return t.runWebGLProgram(u,[o,s],"float32")}var BG={kernelName:am,backendName:"webgl",kernelFunc:Yce};T();function Zce(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,filter:s}=n,{pad:i,strides:a,inputShape:c}=r,l=S.computeConv3DInfo(c,s.shape,a,1,i),u=new kb(l);return t.runWebGLProgram(u,[o,s],"float32")}var VG={kernelName:Uc,backendName:"webgl",kernelFunc:Zce};T();var Qce=jr+`
  return cos(x);
`,Jce=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${lr}
  return result;
`,ele=pe({opSnippet:Qce,packedOpSnippet:Jce}),UG={kernelName:"Cos",backendName:"webgl",kernelFunc:ele};T();var tle=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,nle=pe({opSnippet:tle}),zG={kernelName:Ti,backendName:"webgl",kernelFunc:nle};T();var Ab=class{constructor(n,t,r,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,c,l]=n,[u]=t,[p,d]=r;this.outputShape=[u,p,d,l];let f=o==="bilinear"?1:0,[m,h]=[`${a-1}.0`,`${c-1}.0`],[g,x,v]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[w,I,_]=d>1?[`${(c-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${I};

        float in_y = ${v};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${_};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var rle=e=>{let{inputs:n,backend:t,attrs:r}=e,{image:o,boxes:s,boxInd:i}=n,{cropSize:a,method:c,extrapolationValue:l}=r,u=new Ab(o.shape,s.shape,a,c,l);return t.runWebGLProgram(u,[o,s,i],"float32")},GG={kernelName:Wc,backendName:"webgl",kernelFunc:rle};T();var qd=(function(e){return e.Prod="*",e.Sum="+",e})(qd||{}),Gh=class{constructor(n,t,r,o){this.op=n,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,i=this.op===qd.Prod?"1.0":"0.0",a=r?i:`getX(${HG(s,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1],l="",u="";r?(l=o?`end != ${c-1}`:"end != 0",u=o?"end + 1":"end - 1"):(l=o?`end + pow2 < ${c}`:"end >= pow2",u=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ve(s)} coords = getOutputCoords();
        int end = ${WG(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${WG(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${HG(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function HG(e,n,t){if(e===1)return`${n}`;if(e===2)return`${n}.x, ${n}.y`;if(e===3)return`${n}.x, ${n}.y, ${n}.z`;if(e===4)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw new Error(`Cumulative ${t} for rank ${e} is not yet supported`)}function WG(e,n,t){if(e===1)return`${n}`;if(e===2)return`${n}.y`;if(e===3)return`${n}.z`;if(e===4)return`${n}.w`;throw new Error(`Cumulative ${t} for rank ${e} is not yet supported`)}T();function Rb(e,n,t,r,o,s){let i=n.shape.length,a=S.getAxesPermutation([r],i),c=n;a!=null&&(c=ft({inputs:{x:n},backend:t,attrs:{perm:a}}));let l=S.getInnerMostAxes(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${r}`);let u=c.shape[l],p=_t({inputs:{x:c},backend:t});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){let f=new Gh(e,c.shape,!1,s),m=[[d]],h=p;p=t.runWebGLProgram(f,[p],p.dtype,m),t.disposeIntermediateTensorInfo(h)}if(o){let d=new Gh(e,c.shape,o,s),f=p;p=t.runWebGLProgram(d,[p],p.dtype),t.disposeIntermediateTensorInfo(f)}if(a!=null){let d=S.getUndoAxesPermutation(a),f=ft({inputs:{x:p},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(c),f}return p}function ole(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;return Rb(qd.Prod,o,t,s,i,a)}var jG={kernelName:Gc,backendName:"webgl",kernelFunc:ole};T();function sle(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;return Rb(qd.Sum,o,t,s,i,a)}var qG={kernelName:Hc,backendName:"webgl",kernelFunc:sle};T();function ile(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,weights:s}=n,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let c=t.readSync(o.dataId),l=t.readSync(s.dataId),u=qv(c,l,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,u)}else if(o.shape.length===2){let c=t.bufferSync(o),l=t.bufferSync(s),u=AU(c,l,i,a);return t.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var KG={kernelName:jc,backendName:"webgl",kernelFunc:ile};T();var Fb=class{constructor(n,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function ale(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{blockSize:s,dataFormat:i}=r,a=o.shape[0],c=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],u=i==="NHWC"?o.shape[3]:o.shape[1],p=c*s,d=l*s,f=u/(s*s),m=i==="NHWC"?[a,p,d,f]:[a,f,p,d],h=new Fb(m,s,i);return t.runWebGLProgram(h,[o],o.dtype)}var XG={kernelName:qc,backendName:"webgl",kernelFunc:ale};T();var Kd=class{constructor(n,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=rt(this.outputShape.length);let i=n.filterHeight,a=n.filterWidth,c=n.outChannels/n.inChannels,l="",u="";r&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:l=`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);");let p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${u}
        setOutput(result);
      }
    `}};T();var Xd=class{constructor(n,t=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=rt(this.outputShape.length);let i=n.outChannels/n.inChannels,a=n.padInfo.left,c=n.strideWidth,l=n.dilationWidth,u=n.filterHeight,p=n.filterWidth,d=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<p;x++)f+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;f+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let x=0;x<p;x++)f+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(d+1)/2;x++){let v=x*2;if(f+=`
          xC = xCCorner + ${v*l};
          `,c===1){if(v<p&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }
              `,l===1&&v>0?f+=`
                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                  } else {
                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xC${v} = xTexelC${v};
                `,v+1<p)){let w=a%2===0?y.nearestLargerEven(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${v+1}.zw = vec2(0.0);
                    }
                    xTexelC${v+1}Ready = 1;
                  }
                  `,l>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                    } else {
                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                    }
                    `:f+=`
                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                    `):w===1?f+=`
                    xC${v+1} = xTexelC${v};
                    `:f+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${v+1}.zw = vec2(0.0);
                      }
                      xTexelC${v+1}Ready = 1;
                    }

                    xC${v+1} = xTexelC${v+1};
                    `}}else v<p&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.0);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
              `,v+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                  xTexelC${v} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${v}.zw = vec2(0.0);
                  }
                  xTexelC${v}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${v+1}.zw = vec2(0.);
                  }
                  xTexelC${v+1}Ready = 1;
                }

                xC${v} = vec4(
                  xTexelC${v}.xy, xTexelC${v+1}.xy);
              `,v+1<p&&(f+=`
                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                `)));v<p&&(f+=`
            wTexel = getW(r, ${v}, d1, q);
            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);
          `,v+1<p&&(f+=`
              wTexel = getW(r, ${v+1}, d1, q);
              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let m="",h="";r&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:m=`vec4 activation(vec4 x) {
          ${r}
        }`,h="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function cle(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s}=n,{strides:i,pad:a,dilations:c,dimRoundingMode:l}=r,u=c;u==null&&(u=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(i,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=S.computeConv2DInfo(o.shape,s.shape,i,u,a,l,!0),d;M().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?d=new Xd(p):d=new Kd(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return t.runWebGLProgram(d,[o,s],"float32",f)}var YG={kernelName:Kc,backendName:"webgl",kernelFunc:cle};T();var Ob=class{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;let t=n.strideHeight,r=n.strideWidth,o=n.padInfo.top,s=n.padInfo.left,i=n.outChannels/n.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${n.batchSize}; b++) {
          for (int yR = 0; yR < ${n.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${n.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Mb=class{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;let t=n.filterHeight,r=n.filterWidth,o=n.strideHeight,s=n.strideWidth,i=t-1-n.padInfo.top,a=r-1-n.padInfo.left,c=n.outChannels/n.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function lle(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,dy:s}=n,{strides:i,dilations:a,pad:c,dimRoundingMode:l,filterShape:u}=r,p=S.computeConv2DInfo(o.shape,u,i,a,c,l,!0),d=new Ob(p);return t.runWebGLProgram(d,[o,s],"float32")}var ZG={kernelName:Xc,backendName:"webgl",kernelFunc:lle};T();function ule(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,filter:s}=n,{strides:i,dilations:a,pad:c,dimRoundingMode:l,inputShape:u}=r,p=S.computeConv2DInfo(u,s.shape,i,a,c,l,!0),d=new Mb(p);return t.runWebGLProgram(d,[o,s],"float32")}var QG={kernelName:Yc,backendName:"webgl",kernelFunc:ule};T();var $b=class{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function ple(e){let{inputs:n,backend:t}=e,{x:r}=n,o=[...r.shape,...r.shape],s=y.sizeFromShape(r.shape),i=J({inputs:{x:r},backend:t,attrs:{shape:[s]}}),a=new $b(s),c=t.runWebGLProgram(a,[i],i.dtype),l=J({inputs:{x:c},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),l}var JG={kernelName:Zc,backendName:"webgl",kernelFunc:ple};T();var Pb=class{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;let{inHeight:t,inWidth:r,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:c,dilationHeight:l,dilationWidth:u}=n,{top:p,left:d}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function dle(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s}=n,{strides:i,pad:a,dilations:c}=r,l=S.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",c),u,p=new Pb(l);u=t.runWebGLProgram(p,[o,s],"float32");let d=J({inputs:{x:u},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(u),d}var eH={kernelName:Qc,backendName:"webgl",kernelFunc:dle};T();function fle(e){let{inputs:n,backend:t,attrs:r}=e,{equation:o}=r,s=n,{allDims:i,summedDims:a,idDims:c}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,c,s);let{path:l,steps:u}=S.getEinsumComputePath(a,c),p=u.length,d=null,f=i.length,m=[];for(let h=0;h<p;++h){for(let g of u[h]){let{permutationIndices:x,expandDims:v}=S.getEinsumPermutation(f,c[g]),w;S.isIdentityPermutation(x)?w=s[g]:(w=ft({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),m.push(w));let I=w.shape.slice();for(let _=0;_<v.length;++_)I.splice(v[_],0,1);y.arraysEqual(w.shape,I)||(w=J({inputs:{x:w},backend:t,attrs:{shape:I}}),m.push(w)),d===null?d=w:(d=Uh({inputs:{a:w,b:d},backend:t}),m.push(d))}h<p-1&&(l[h]>=0&&(d=Qu({inputs:{x:d},backend:t,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),m.push(d)),f--)}for(let h of m)h!==d&&t.disposeIntermediateTensorInfo(h);return d}var tH={kernelName:Jc,backendName:"webgl",kernelFunc:fle};T();var mle="return (x >= 0.0) ? x : (exp(x) - 1.0);",hle=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,gle=pe({opSnippet:mle,packedOpSnippet:hle}),nH={kernelName:"Elu",backendName:"webgl",kernelFunc:gle};T();var xle="return (b >= 0.0) ? a : a * (b + 1.0);",yle=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,vle=e=>{let{inputs:n,backend:t}=e,{dy:r,y:o}=n,s=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new cr(yle,r.shape,o.shape):new Wn(xle,r.shape,o.shape);return t.runWebGLProgram(s,[r,o],r.dtype)},rH={kernelName:cm,backendName:"webgl",kernelFunc:vle};T();var ble=`
  return vec4(equal(a, b));
`,Cle="return float(a == b);",wle=Qe({opSnippet:Cle,packedOpSnippet:ble,dtype:"bool",cpuKernelImpl:$U}),oH={kernelName:Ni,backendName:"webgl",kernelFunc:wle};T();var Ile=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${S.ERF_P};
  float a1 = ${S.ERF_A1};
  float a2 = ${S.ERF_A2};
  float a3 = ${S.ERF_A3};
  float a4 = ${S.ERF_A4};
  float a5 = ${S.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Ele=pe({opSnippet:Ile}),sH={kernelName:"Erf",backendName:"webgl",kernelFunc:Ele};T();var Tle=jr+`
  return exp(x);
`,Sle=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,p1=pe({opSnippet:Tle,packedOpSnippet:Sle,cpuKernelImpl:PU,dtype:"float32"}),iH={kernelName:"Exp",backendName:"webgl",kernelFunc:p1};T();function Lb(e){let{inputs:n,attrs:t,backend:r}=e,{dim:o}=t,{input:s}=n,i=s.shape.length,a=s.shape.slice(),c=o;return o<0&&(y.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),c=i+o+1),a.splice(c,0,1),J({inputs:{x:s},backend:r,attrs:{shape:a}})}var aH={kernelName:rl,backendName:"webgl",kernelFunc:Lb};T();var cH="return exp(x) - 1.0;",Nle=pe({opSnippet:cH,packedOpSnippet:cH,cpuKernelImpl:LU}),lH={kernelName:Di,backendName:"webgl",kernelFunc:Nle};T();T();var Hh=class{constructor(n,t,r){this.variableNames=["real","imag"];let o=t[1];this.outputShape=t;let s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${o}.0`:"1.0",a;if(n==="real")a="return real * expR - imag * expI;";else if(n==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function Bb(e,n,t){let r=t.texData.get(e.dataId),o=y.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=o/s,a=J({inputs:{x:e},backend:t,attrs:{shape:[i,s]}}),c=a.shape,l=new Hh("real",c,n),u=new Hh("imag",c,n),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],d=t.runWebGLProgram(l,p,"float32"),f=t.runWebGLProgram(u,p,"float32"),m=jn({inputs:{real:d,imag:f},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f);let h=J({inputs:{x:m},backend:t,attrs:{shape:e.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(m),h}function Dle(e){let{inputs:n,backend:t}=e,{input:r}=n;return Bb(r,!1,t)}var uH={kernelName:"FFT",backendName:"webgl",kernelFunc:Dle};T();var Vb=class{constructor(n,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=n,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Gs(e){let{backend:n,attrs:t}=e,{shape:r,value:o}=t,{dtype:s}=t;if(s=s||y.inferDtype(o),s==="string"){let i=y.getArrayFromDType(s,y.sizeFromShape(r));return i.fill(o),n.makeTensorInfo(r,s,i)}else{let i=new Vb(r,o),a=[[o]];return n.runWebGLProgram(i,[],s,a)}}var pH={kernelName:ol,backendName:"webgl",kernelFunc:Gs};T();var Ub=class{constructor(n){this.variableNames=["Image"],this.outputShape=[];let t=n[2];this.outputShape=n,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var dH={kernelName:sl,backendName:"webgl",kernelFunc:({inputs:e,backend:n})=>{let{image:t}=e,r=n,o=new Ub(t.shape);return r.runWebGLProgram(o,[t],t.dtype)}};T();var fH="return floor(x);",kle=pe({opSnippet:fH,packedOpSnippet:fH,cpuKernelImpl:BU}),mH={kernelName:ki,backendName:"webgl",kernelFunc:kle};T();var _le=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Ale=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Rle=Qe({opSnippet:_le,packedOpSnippet:Ale,dtype:"int32"}),hH={kernelName:_i,backendName:"webgl",kernelFunc:Rle};T();T();var zb=class{constructor(n){this.variableNames=["A"];let t=wt(),[r,o]=n;this.outputShape=n,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var Gb=class{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=wt(),[r,o]=n;this.outputShape=n,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};var gH={kernelName:Xp,backendName:"webgl",kernelFunc:Fle},Yd,d1=M().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Fle(e){let{inputs:n,backend:t,attrs:r}=e,{pixels:o}=n,{numChannels:s}=r,i=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[c,l]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],u=[l,c],p=[l,c,s];if(a||i){let h=M().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Yd==null||h!==d1)&&(d1=h,Yd=document.createElement("canvas").getContext("2d",{willReadFrequently:d1})),Yd.canvas.width=c,Yd.canvas.height=l,Yd.drawImage(o,0,0,c,l),o=Yd.canvas}let d=t.makeTensorInfo(u,"int32");t.texData.get(d.dataId).usage=In.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),o);let f=M().getBool("WEBGL_PACK")?new Gb(p):new zb(p),m=t.runWebGLProgram(f,[d],"int32");return t.disposeData(d.dataId),m}T();function Ole(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:c,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,h=S.convertConv2DDataFormat(u),g=S.computeConv2DInfo(o.shape,s.shape,c,p,l,d,!1,h),x,v=[],w=i!=null,I=a!=null,_=f==="leakyrelu",A=()=>{let F=[o,s],P=(L,V)=>{if(V==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){let z=J({inputs:{x:L},backend:t,attrs:{shape:[L.shape[0],1,1]}});return v.push(z),z}return L};if(w&&F.push(P(i,u)),I&&F.push(P(a,u)),_){let L=t.makeTensorInfo([],"float32",y.createScalarValue(m,"float32"));F.push(L),v.push(L)}return F};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))x=Eb({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:m});else if(g.strideWidth<=2&&h==="channelsLast"&&M().getBool("WEBGL_EXP_CONV")){let F=f?Us(f,!0):null,P=new jd(g,w,F,I,_),L=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],V=A();x=t.runWebGLProgram(P,V,"float32",L)}else if(M().getBool("WEBGL_CONV_IM2COL"))x=Tb({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:m});else{let F=f?Us(f,!1):null,P=new Wd(g,w,F,I,_),L=A();x=t.runWebGLProgram(P,L,"float32")}let R=J({inputs:{x},backend:t,attrs:{shape:g.outShape}});return v.push(x),v.forEach(F=>t.disposeIntermediateTensorInfo(F)),R}var xH={kernelName:ca,backendName:"webgl",kernelFunc:Ole};T();function Mle(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:c,pad:l,dilations:u,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r,m=[],h=u;h==null&&(h=[1,1]),y.assert(S.eitherStridesOrDilationsAreOne(c,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${h}'`);let g=S.computeConv2DInfo(o.shape,s.shape,c,h,l,p,!0),x=M().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,v=d?Us(d,x):null,w=[o,s],I=i!=null,_=a!=null,A=d==="leakyrelu";if(I&&w.push(i),_&&w.push(a),A){let L=t.makeTensorInfo([],"float32",y.createScalarValue(f,"float32"));w.push(L),m.push(L)}let R;x?R=new Xd(g,I,v,_,A):R=new Kd(g,I,v,_,A);let F=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],P=t.runWebGLProgram(R,w,"float32",F);return m.forEach(L=>t.disposeIntermediateTensorInfo(L)),P}var yH={kernelName:la,backendName:"webgl",kernelFunc:Mle};T();var Hb=class{constructor(n,t,r,o){this.sliceDim=n,this.strides=t,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=r;let s=ve(r.length),i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function $le(e){let{inputs:n,backend:t}=e,{params:r,indices:o}=n,s=o.shape,i=s[s.length-1],a=y.sizeFromShape(r.shape),[c,l,u,p]=S.prepareAndValidate(r,o),d=J({inputs:{x:o},backend:t,attrs:{shape:[l,i]}}),f=J({inputs:{x:r},backend:t,attrs:{shape:[y.sizeFromShape(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,o])||r.dtype==="string"){let x=t.readSync(o.dataId),v=t.bufferSync(r),w=VU(x,v,r.dtype,l,i,u,p,r.shape,a);return t.makeTensorInfo(c,r.dtype,w.values)}let m=new Hb(i,p,[l,u],r.shape),h=t.runWebGLProgram(m,[f,d],f.dtype),g=J({inputs:{x:h},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var vH={kernelName:cl,backendName:"webgl",kernelFunc:$le};T();var Wb=class{constructor(n,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let r=ve(this.rank),o=Ple(n,2);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${n[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function Ple(e,n){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let o=0;o<e.length;o++)o===2?r.push("index"):r.push(`${t[o]}`);return r.join()}function f1(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,indices:s}=n,{axis:i,batchDims:a}=r,c=y.parseAxisParam(i,o.shape)[0];if(M().get("DEBUG")){let v=t.readSync(s.dataId),w=o.shape[c];for(let I=0;I<v.length;++I){let _=v[I];y.assert(_<=w-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${w-1}]`)}}let l=S.segment_util.collectGatherOpShapeInfo(o,s,c,a),u=y.sizeFromShape(s.shape),p=[],d=J({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=J({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,u/l.batchSize]}});p.push(d),p.push(f);let m=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let v=t.bufferSync(f),w=t.bufferSync(d),I=UU(w,v,m);return p.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.makeTensorInfo(l.outputShape,I.dtype,I.values)}let h=new Wb(d.shape,m),g=t.runWebGLProgram(h,[d,f],d.dtype);p.push(g);let x=J({inputs:{x:g},backend:t,attrs:{shape:l.outputShape}});return p.forEach(v=>t.disposeIntermediateTensorInfo(v)),x}var bH={kernelName:al,backendName:"webgl",kernelFunc:f1};T();var Lle="return float(a > b);",Ble=`
  return vec4(greaterThan(a, b));
`,Vle=Qe({opSnippet:Lle,packedOpSnippet:Ble,cpuKernelImpl:zU,dtype:"bool"}),CH={kernelName:Ai,backendName:"webgl",kernelFunc:Vle};T();var Ule="return float(a >= b);",zle=`
  return vec4(greaterThanEqual(a, b));
`,Gle=Qe({opSnippet:Ule,packedOpSnippet:zle,dtype:"bool",cpuKernelImpl:GU}),wH={kernelName:Ri,backendName:"webgl",kernelFunc:Gle};T();function Hle(e){let{inputs:n,backend:t}=e,{input:r}=n;return Bb(r,!0,t)}var IH={kernelName:ll,backendName:"webgl",kernelFunc:Hle};T();var Wle="return float(!isnan(x) && !isinf(x));",jle=pe({opSnippet:Wle,dtype:"bool"}),EH={kernelName:Fi,backendName:"webgl",kernelFunc:jle};T();var qle="return float(isinf(x));",Kle=pe({opSnippet:qle,dtype:"bool"}),TH={kernelName:Oi,backendName:"webgl",kernelFunc:Kle};T();var Xle="return float(isnan(x));",Yle=pe({opSnippet:Xle,dtype:"bool"}),SH={kernelName:Mi,backendName:"webgl",kernelFunc:Yle};T();var Zle="return float(a < b);",Qle=`
  return vec4(lessThan(a, b));
`,Jle=Qe({opSnippet:Zle,packedOpSnippet:Qle,cpuKernelImpl:HU,dtype:"bool"}),NH={kernelName:$i,backendName:"webgl",kernelFunc:Jle};T();var eue="return float(a <= b);",tue=`
  return vec4(lessThanEqual(a, b));
`,nue=Qe({opSnippet:eue,packedOpSnippet:tue,cpuKernelImpl:WU,dtype:"bool"}),DH={kernelName:Pi,backendName:"webgl",kernelFunc:nue};T();function rue(e){let{backend:n,attrs:t}=e,{start:r,stop:o,num:s}=t,i=jU(r,o,s);return n.makeTensorInfo([i.length],"float32",i)}var kH={kernelName:dl,backendName:"webgl",kernelFunc:rue};T();var oue=jr+`
  return x < 0.0 ? 0./0. : log(x);
`,sue=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,iue=pe({opSnippet:oue,packedOpSnippet:sue,cpuKernelImpl:qU}),_H={kernelName:"Log",backendName:"webgl",kernelFunc:iue};T();var aue=jr+`
  return log(1.0 + x);
`,cue=pe({opSnippet:aue}),AH={kernelName:Li,backendName:"webgl",kernelFunc:cue};T();var lue="return float(a >= 1.0 && b >= 1.0);",uue=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,pue=Qe({opSnippet:lue,packedOpSnippet:uue,dtype:"bool"}),RH={kernelName:Bi,backendName:"webgl",kernelFunc:pue};T();var due="return float(!(x >= 1.0));",fue=pe({opSnippet:due}),FH={kernelName:Vi,backendName:"webgl",kernelFunc:fue};T();var mue="return float(a >= 1.0 || b >= 1.0);",hue=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,gue=Qe({opSnippet:mue,packedOpSnippet:hue,dtype:"bool"}),OH={kernelName:Ui,backendName:"webgl",kernelFunc:gue};T();var jb=class{constructor(n,t,r,o,s){this.variableNames=["x"],this.outputShape=[];let i=t,a=n[3]-1;this.outputShape=n;let c,l=`float(${r}) + float(${o}) * sum`;s===.5?c=`inversesqrt(${l})`:s===1?c=`1.0/(${l})`:c=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}};var qb=class{constructor(n,t,r,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=t,a=n[3]-1;this.outputShape=n;let c,l=`float(${r}) + float(${o}) * sum`;s===.5?c=`inversesqrt(${l})`:s===1?c=`1.0/(${l})`:c=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}};var xue=e=>{let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{depthRadius:s,bias:i,alpha:a,beta:c}=r,l=M().getBool("WEBGL_PACK_NORMALIZATION")?new qb(o.shape,s,i,a,c):new jb(o.shape,s,i,a,c);return t.runWebGLProgram(l,[o],o.dtype)},MH={kernelName:"LRN",backendName:"webgl",kernelFunc:xue};T();var Kb=class{constructor(n,t,r,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=t,this.bias=r,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var yue=e=>{let{inputs:n,backend:t,attrs:r}=e,{x:o,y:s,dy:i}=n,{depthRadius:a,bias:c,alpha:l,beta:u}=r,p=new Kb(o.shape,a,c,l,u);return t.runWebGLProgram(p,[o,s,i],o.dtype)},$H={kernelName:lm,backendName:"webgl",kernelFunc:yue};T();T();T();function PH(e,n,t,r){let o=y.sizeFromShape(n),i=y.sizeFromShape(e.shape)/o,a=J({inputs:{x:e},attrs:{shape:[i,o]},backend:r}),c=ur(a,e.dtype,"max",r),l=J({inputs:{x:c},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(c),l}function m1(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{reductionIndices:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),l=c,u=S.getAxesPermutation(l,a),p=u!=null,d=t.shouldExecuteOnCPU([o]),f=o;if(p){if(d){let w=t.texData.get(f.dataId).values,I=new Array(a);for(let R=0;R<I.length;R++)I[R]=o.shape[u[R]];let _=Zu(w,o.shape,o.dtype,u,I);f=t.makeTensorInfo(I,o.dtype);let A=t.texData.get(f.dataId);A.values=_}else f=Ma(o,u,t);l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("max",l,a);let[m,h]=S.computeOutAndReduceShapes(f.shape,l),g=m;i&&(g=S.expandShapeToKeepDim(m,c));let x;if(d){let w=t.texData.get(f.dataId).values,I=KU(w,y.sizeFromShape(h),g,o.dtype);x=t.makeTensorInfo(g,o.dtype);let _=t.texData.get(x.dataId);_.values=I}else x=PH(f,h,g,t);return p&&t.disposeIntermediateTensorInfo(f),x}var LH={kernelName:"Max",backendName:"webgl",kernelFunc:m1};T();var vue=zd+`
  return max(a, b);
`,bue=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+lr+`
  return result;
`,Cue=Qe({opSnippet:vue,packedOpSnippet:bue,cpuKernelImpl:XU}),BH={kernelName:zi,backendName:"webgl",kernelFunc:Cue};T();function wue(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n;Jo(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:c}=r,l=1;y.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let u=S.computePool2DInfo(o.shape,s,i,l,a,c);if(u.filterWidth===1&&u.filterHeight===1&&y.arraysEqual(u.inShape,u.outShape))return _t({inputs:{x:o},backend:t});let p=new Co(u,"max",!1);return t.runWebGLProgram(p,[o],o.dtype)}var VH={kernelName:ml,backendName:"webgl",kernelFunc:wue};T();function Iue(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{filterSize:s,strides:i,pad:a,dataFormat:c,dimRoundingMode:l}=r,u=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,u,a,l,c),d=new $a(p,"max",!1);return t.runWebGLProgram(d,[o],o.dtype)}var UH={kernelName:hl,backendName:"webgl",kernelFunc:Iue};T();var Xb=class{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;let t=n.strideHeight,r=n.strideWidth,o=n.dilationHeight,s=n.effectiveFilterHeight,i=n.effectiveFilterWidth,a=s-1-n.padInfo.top,c=i-1-n.padInfo.left,l=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Yb=class{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;let t=n.strideDepth,r=n.strideHeight,o=n.strideWidth,s=n.dilationDepth,i=n.dilationHeight,a=n.dilationWidth,c=n.effectiveFilterDepth,l=n.effectiveFilterHeight,u=n.effectiveFilterWidth,p=c-1-n.padInfo.front,d=l-1-n.padInfo.top,f=u-1-n.padInfo.left,m=c*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Eue(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,input:s}=n,i=s,{filterSize:a,strides:c,pad:l,dimRoundingMode:u}=r,p=[1,1,1],d=S.computePool3DInfo(i.shape,a,c,p,l,u),f=new $a(d,"max",!0),m=t.runWebGLProgram(f,[i],i.dtype),h=new Yb(d),g=t.runWebGLProgram(h,[o,m],i.dtype);return t.disposeIntermediateTensorInfo(m),g}var zH={kernelName:pm,backendName:"webgl",kernelFunc:Eue};T();function Tue(e){let{inputs:n,backend:t,attrs:r}=e,{dy:o,input:s,output:i}=n,a=s;Jo([s,i],"maxPoolGrad");let{filterSize:c,strides:l,pad:u,dimRoundingMode:p}=r,d=S.computePool2DInfo(a.shape,c,l,1,u,p),f=!0,m=new Co(d,"max",f),h=t.runWebGLProgram(m,[a],a.dtype),g=new Xb(d),x=t.runWebGLProgram(g,[o,h],a.dtype);return t.disposeIntermediateTensorInfo(h),x}var GH={kernelName:um,backendName:"webgl",kernelFunc:Tue};T();T();function HH(e,n,t,r){let o=new Co(t,"max",!1),s=r.runWebGLProgram(o,[e],"float32");o=new Co(t,"max",!0,!0,n);let i=r.runWebGLProgram(o,[e],"float32");return[s,i]}var WH={kernelName:gl,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{let{x:r}=e,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=n,c=t;y.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let l=[1,1];y.assert(S.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let u=S.computePool2DInfo(r.shape,o,s,l,i),[p,d]=HH(r,a,u,c);return[p,d]}};T();T();function jH(e,n,t,r){let o=y.sizeFromShape(n),i=y.sizeFromShape(e.shape)/o,a=J({inputs:{x:e},attrs:{shape:[i,o]},backend:r}),c=ur(a,"float32","mean",r),l=J({inputs:{x:c},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(c),l}var qH={kernelName:xl,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{let{x:r}=e,{keepDims:o,axis:s}=n,i=t,a=r.shape.length,c=y.parseAxisParam(s,r.shape),l=c,u=S.getAxesPermutation(l,a),p=u!=null,d=i.shouldExecuteOnCPU([r]),f=[],m=r;if(p){if(d){let I=i.texData.get(m.dataId).values,_=new Array(a);for(let F=0;F<_.length;F++)_[F]=r.shape[u[F]];let A=Zu(I,r.shape,r.dtype,u,_);m=i.makeTensorInfo(_,r.dtype);let R=i.texData.get(m.dataId);R.values=A}else m=Ma(r,u,i);f.push(m),l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("sum",l,a);let[h,g]=S.computeOutAndReduceShapes(m.shape,l),x=h;o&&(x=S.expandShapeToKeepDim(h,c));let v=jH(m,g,x,i);for(let w of f)i.disposeIntermediateTensorInfo(w);return v}};T();function Sue(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,c=y.parseAxisParam(s,o.shape),l=c,u=S.getAxesPermutation(l,a),p=o;u!=null&&(p=ft({inputs:{x:o},backend:t,attrs:{perm:u}}),l=S.getInnerMostAxes(l.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",l,a);let[d,f]=S.computeOutAndReduceShapes(p.shape,l),m=y.sizeFromShape(f),h=J({inputs:{x:p},backend:t,attrs:{shape:[-1,m]}}),g=ur(h,h.dtype,"min",t),x;if(i){let v=S.expandShapeToKeepDim(d,c);x=J({inputs:{x:g},backend:t,attrs:{shape:v}})}else x=J({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(p),x}var KH={kernelName:"Min",backendName:"webgl",kernelFunc:Sue};T();var Nue=zd+`
  return min(a, b);
`,Due=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+lr+`
  return result;
`,kue=Qe({opSnippet:Nue,packedOpSnippet:Due,cpuKernelImpl:YU}),XH={kernelName:Gi,backendName:"webgl",kernelFunc:kue};T();var Zb=class{constructor(n,t,r){this.variableNames=["x"],this.outputShape=t.map((u,p)=>u[0]+n[p]+u[1]);let o=n.length,s=ve(o),i=t.map(u=>u[0]).join(","),a=t.map((u,p)=>u[0]+n[p]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=r==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}};var Qb=class{constructor(n,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((m,h)=>m[0]+n[h]+m[1]);let o=n.length,s=ve(o),i=t.map(m=>m[0]).join(","),a=t.map((m,h)=>m[0]+n[h]).join(","),c=kt("rc",o),l=kt("source",o),u=`${c[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,d=r==="reflect"?0:1,f="";if(o===1){let m=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${c[o-1]} += 1;
        if(${u}) {
          ${m}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `}else{let m=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${c[o-1]} += 1;
        if(${u}) {
          ${m}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${c[o-2]} += 1;
        if(${c[o-2]} < ${this.outputShape[o-2]}) {
          ${m}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${c[o-1]} += 1;
          if(${u}) {
            ${m}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var _ue=({inputs:e,backend:n,attrs:t})=>{let{x:r}=e,{paddings:o,mode:s}=t,i=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qb(r.shape,o,s):new Zb(r.shape,o,s);return n.runWebGLProgram(i,[r],r.dtype)},YH={kernelName:yl,backendName:"webgl",kernelFunc:_ue};T();var Aue=`if (b == 0.0) return NAN;
  return mod(a, b);`,Rue=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+lr+`
  return result;
`,Fue=Qe({opSnippet:Aue,packedOpSnippet:Rue}),ZH={kernelName:"Mod",backendName:"webgl",kernelFunc:Fue};T();var Jb=class{constructor(n,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[n,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};T();T();var Oue=`
if (a == b) {
  return 1.0;
};
return a / b;`,Mue=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,h1=Qe({opSnippet:Oue,packedOpSnippet:Mue,checkOutOfBounds:!0}),QH={kernelName:Si,backendName:"webgl",kernelFunc:h1};T();var JH="return a - b;",g1=Qe({opSnippet:JH,packedOpSnippet:JH,supportsComplex:!0,cpuKernelImpl:xz}),eW={kernelName:"Sub",backendName:"webgl",kernelFunc:g1};function x1(e){let{inputs:n,backend:t,attrs:r}=e,{logits:o}=n,{dim:s}=r,i=y.parseAxisParam([s],o.shape),a=m1({inputs:{x:o},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),c=S.expandShapeToKeepDim(a.shape,i),l=J({inputs:{x:a},backend:t,attrs:{shape:c}}),u=g1({inputs:{a:o,b:l},backend:t}),p=p1({inputs:{x:u},backend:t}),d=Qu({inputs:{x:p},backend:t,attrs:{axis:i,keepDims:!1}}),f=J({inputs:{x:d},backend:t,attrs:{shape:c}}),m=h1({inputs:{a:p,b:f},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),m}var tW={kernelName:Kl,backendName:"webgl",kernelFunc:x1};function $ue(e){let{inputs:n,backend:t,attrs:r}=e,{logits:o}=n,{numSamples:s,seed:i,normalized:a}=r,c=a?o:x1({inputs:{logits:o},backend:t,attrs:{dim:o.shape.length-1}}),l=c.shape[0],u=c.shape[1],p=new Jb(l,u,s),d=[[i]],f=t.runWebGLProgram(p,[c],"int32",d);return a||t.disposeIntermediateTensorInfo(c),f}var nW={kernelName:bl,backendName:"webgl",kernelFunc:$ue};T();var Pue=Vt+`
  return -x;
`,Lue=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Bue(e){let{inputs:n,backend:t}=e,{x:r}=n;if(t.shouldExecuteOnCPU([r])){let s=t.texData.get(r.dataId),[i,a]=QU(s.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,i)}let o;return M().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Hn(r.shape,Lue):o=new an(r.shape,Pue),t.runWebGLProgram(o,[r],r.dtype)}var rW={kernelName:"Neg",backendName:"webgl",kernelFunc:Bue};T();var Vue=sn.nonMaxSuppressionV3Impl;function Uue(e){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:n,backend:t,attrs:r}=e,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c}=r,l=t.readSync(o.dataId),u=t.readSync(s.dataId),{selectedIndices:p}=Vue(l,u,i,a,c);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}var oW={kernelName:Cl,backendName:"webgl",kernelFunc:Uue};T();var zue=sn.nonMaxSuppressionV4Impl;function Gue(e){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:n,backend:t,attrs:r}=e,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,padToMaxOutputSize:l}=r,u=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:d,validOutputs:f}=zue(u,p,i,a,c,l);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var sW={kernelName:wl,backendName:"webgl",kernelFunc:Gue};T();var Hue=sn.nonMaxSuppressionV5Impl;function Wue(e){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:n,backend:t,attrs:r}=e,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:c,softNmsSigma:l}=r,u=t.readSync(o.dataId),p=t.readSync(s.dataId),d=i,f=a,m=c,h=l,{selectedIndices:g,selectedScores:x}=Hue(u,p,d,f,m,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var iW={kernelName:Il,backendName:"webgl",kernelFunc:Wue};T();var e0=class{constructor(n,t,r,o){this.variableNames=["indices"],this.outputShape=[n,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${r}),
                      float(index == coords.y)));
      }
    `}};var jue=e=>{let{inputs:n,backend:t,attrs:r}=e,{indices:o}=n,{dtype:s,depth:i,onValue:a,offValue:c}=r,l=y.sizeFromShape(o.shape),u=new e0(l,i,a,c),p=J({inputs:{x:o},backend:t,attrs:{shape:[l]}}),d=t.runWebGLProgram(u,[p],s);t.disposeIntermediateTensorInfo(p);let f=[...o.shape,i],m=J({inputs:{x:d},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(d),m},aW={kernelName:Tl,backendName:"webgl",kernelFunc:jue};T();T();function Wh(e){let{inputs:n,backend:t}=e,{x:r}=n;if(r.dtype==="complex64"){let o=zs({inputs:{input:r},backend:t}),s=Wh({inputs:{x:o},backend:t}),i=ep({inputs:{input:r},backend:t}),a=Wh({inputs:{x:i},backend:t}),c=jn({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return Gs({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}var cW={kernelName:pu,backendName:"webgl",kernelFunc:Wh};function lW(e){let{inputs:n,backend:t}=e,{x:r}=n;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let o=zs({inputs:{input:r},backend:t}),s=lW({inputs:{x:o},backend:t}),i=ep({inputs:{input:r},backend:t}),a=Wh({inputs:{x:i},backend:t}),c=jn({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),c}else return Gs({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}var uW={kernelName:El,backendName:"webgl",kernelFunc:lW};T();function que(e){let{inputs:n,backend:t,attrs:r}=e,{axis:o}=r;if(n.length===1)return Lb({inputs:{input:n[0]},backend:t,attrs:{dim:o}});let s=n[0].shape,i=n[0].dtype;n.forEach(u=>{y.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),y.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],c=n.map(u=>{let p=Lb({inputs:{input:u},backend:t,attrs:{dim:o}});return a.push(p),p}),l=u1({inputs:c,backend:t,attrs:{axis:o}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),l}var pW={kernelName:Sl,backendName:"webgl",kernelFunc:que};T();var t0=class{constructor(n,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+n[u]+l[1]);let o=n.length,s=ve(o),i=t.map(l=>l[0]).join(","),a=t.map((l,u)=>l[0]+n[u]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}};var n0=class{constructor(n,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((h,g)=>h[0]+n[g]+h[1]);let o=n.length,s=ve(o),i=t.map(h=>h[0]).join(","),a=t.map((h,g)=>h[0]+n[g]).join(","),c=kt("rc",o),l=kt("source",o),u=`${c[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${c[o-1]} += 1;
       if(${u}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${c[o-2]} += 1;
       if(${c[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${c[o-1]} += 1;
         if(${u}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",m="";for(let h=0,g=o===1?2:4;h<g;h++)m+=`
        ${d[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${p});
        }
      `;m+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}};var y1=e=>{let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{paddings:s,constantValue:i}=r;if(y.sizeFromShape(o.shape)===0){let l=s.map((u,p)=>u[0]+o.shape[p]+u[1]);return Gs({backend:t,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new n0(o.shape,s,i):new t0(o.shape,s,i),c=[[i]];return t.runWebGLProgram(a,[o],o.dtype,c)},dW={kernelName:Nl,backendName:"webgl",kernelFunc:y1};T();var Kue=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Xue=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+lr+`
  return result;
`,Yue=Qe({opSnippet:Kue,packedOpSnippet:Xue}),fW={kernelName:"Pow",backendName:"webgl",kernelFunc:Yue};T();function Zue(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,c=[],l=y.parseAxisParam(s,o.shape),u=l,p=S.getAxesPermutation(u,a),d=o;p!=null&&(d=ft({inputs:{x:o},backend:t,attrs:{perm:p}}),u=S.getInnerMostAxes(u.length,a),c.push(d)),S.assertAxesAreInnerMostDims("prod",u,a);let f;if(t.shouldExecuteOnCPU([d])){let m=t.texData.get(d.dataId).values,{outVals:h,outShape:g,outDtype:x}=ez(d.shape,d.dtype,m,u);f=t.makeTensorInfo(g,x,h)}else{let[m,h]=S.computeOutAndReduceShapes(d.shape,u),g=y.sizeFromShape(h),x=J({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),v=da(o.dtype),w=ur(x,v,"prod",t);f=J({inputs:{x:w},backend:t,attrs:{shape:m}}),c.push(x),c.push(w)}if(i){c.push(f);let m=S.expandShapeToKeepDim(f.shape,l);f=J({inputs:{x:f},backend:t,attrs:{shape:m}})}return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}var mW={kernelName:_l,backendName:"webgl",kernelFunc:Zue};T();function Que(e){let{inputs:n,backend:t,attrs:r}=e,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=n,{outputRaggedRank:a}=r,c=o.map(x=>t.readSync(x.dataId)),l=o.map(x=>x.shape),u=t.readSync(s.dataId),p=t.readSync(i.dataId),[d,f,m]=tz(c,l,u,s.shape,s.dtype,p,i.shape,a),h=d.map(x=>t.makeTensorInfo([x.length],"int32",x)),g=t.makeTensorInfo(m,s.dtype,f);return h.concat([g])}var hW={kernelName:Al,backendName:"webgl",kernelFunc:Que};T();function Jue(e){let{inputs:n,backend:t}=e,{starts:r,limits:o,deltas:s}=n,i=t.readSync(r.dataId),a=t.readSync(o.dataId),c=t.readSync(s.dataId),[l,u]=nz(i,r.shape,r.dtype,a,o.shape,c,s.shape),p=t.makeTensorInfo([l.length],"int32",l),d=t.makeTensorInfo([u.length],r.dtype,u);return[p,d]}var gW={kernelName:Rl,backendName:"webgl",kernelFunc:Jue};T();function epe(e){let{inputs:n,backend:t,attrs:r}=e,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:c}=r,l=t.readSync(o.dataId),u=t.readSync(s.dataId),p=t.readSync(i.dataId),d=a.map(g=>t.readSync(g.dataId)),f=a.map(g=>g.shape),[m,h]=rz(l,o.shape,u,s.shape,s.dtype,p,i.shape,d,f,c);return t.makeTensorInfo(m,s.dtype,h)}var xW={kernelName:Fl,backendName:"webgl",kernelFunc:epe};T();var v1=e=>{let{backend:n,attrs:t}=e,{start:r,stop:o,step:s,dtype:i}=t,a=oz(r,o,s,i);return n.makeTensorInfo([a.length],i,a)},yW={kernelName:Ol,backendName:"webgl",kernelFunc:v1};T();var tpe="return 1.0 / x;",npe=pe({opSnippet:tpe}),vW={kernelName:ji,backendName:"webgl",kernelFunc:npe};T();var rpe=Vt+`
  return (x < 0.0) ? 0.0 : x;
`,ope=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,spe=pe({opSnippet:rpe,packedOpSnippet:ope}),bW={kernelName:qi,backendName:"webgl",kernelFunc:spe};T();var ipe=Vt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ape=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpe=pe({opSnippet:ipe,packedOpSnippet:ape}),CW={kernelName:Ki,backendName:"webgl",kernelFunc:cpe};T();var r0=class{constructor(n,t,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,c,l]=n;this.outputShape=[i,t,r,l];let u=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/p[0]},
          ${u[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var o0=class{constructor(n,t,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,c,l]=n;this.outputShape=[i,t,r,l];let u=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/p[0]},
          ${u[1]/p[1]},
          ${u[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function lpe(e){let{inputs:n,backend:t,attrs:r}=e,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r,[c,l]=a,u=M().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new o0(o.shape,c,l,s,i):new r0(o.shape,c,l,s,i);return t.runWebGLProgram(u,[o],"float32")}var wW={kernelName:Ll,backendName:"webgl",kernelFunc:lpe};T();var s0=class{constructor(n,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,o,s]=t,[,i,a]=n,c=[r&&i>1?o-1:o,r&&a>1?s-1:s],l=[r&&i>1?i-1:i,r&&a>1?a-1:a],u=c[0]/l[0],p=c[1]/l[1],d=1/u,f=1/p,m=Math.ceil(d)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function upe(e){let{inputs:n,backend:t,attrs:r}=e,{images:o,dy:s}=n,{alignCorners:i}=r,a=new s0(s.shape,o.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}var IW={kernelName:fm,backendName:"webgl",kernelFunc:upe};T();var i0=class{constructor(n,t,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,c,l]=n;this.outputShape=[i,t,r,l];let u=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/p[0]},
          ${u[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var a0=class{constructor(n,t,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,c,l]=n;this.outputShape=[i,t,r,l];let u=[o&&t>1?a-1:a,o&&r>1?c-1:c],p=[o&&t>1?t-1:t,o&&r>1?r-1:r],d=o?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/p[0]},
          ${u[1]/p[1]},
          ${u[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function ppe(e){let{inputs:n,backend:t,attrs:r}=e,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r,[c,l]=a,u=M().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new a0(o.shape,c,l,s,i):new i0(o.shape,c,l,s,i);return t.runWebGLProgram(u,[o],o.dtype)}var EW={kernelName:Pl,backendName:"webgl",kernelFunc:ppe};T();var c0=class{constructor(n,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,o,s]=t,[,i,a]=n,c=[r&&i>1?o-1:o,r&&a>1?s-1:s],l=[r&&i>1?i-1:i,r&&a>1?a-1:a],u=c[0]/l[0],p=c[1]/l[1],d=1/u,f=1/p,m=Math.ceil(d)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function dpe(e){let{inputs:n,backend:t,attrs:r}=e,{images:o,dy:s}=n,{alignCorners:i}=r,a=new c0(s.shape,o.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}var TW={kernelName:dm,backendName:"webgl",kernelFunc:dpe};T();var l0=class{constructor(n,t){this.variableNames=["x"];let r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${n[0]} - coord - 1));
        }
      `;return}let o=a=>t.indexOf(a)!==-1&&n[a]!==1?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`,s=n.map((a,c)=>o(c)).join(","),i=ve(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var u0=class{constructor(n,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;let o=kt("rc",r),s=`${o[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${o[r-2]} + 1 < ${this.outputShape[r-2]}`,a=ve(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${n[0]} - rc - 1),
            ${n[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),
                ${n[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${i}) {
            result.b = ${u(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(m){return d(m)}function l(m){return m[r-1]="("+m[r-1]+" + 1)",d(m)}function u(m){return m[r-2]="("+m[r-2]+" + 1)",d(m)}function p(m){return m[r-1]="("+m[r-1]+" + 1)",m[r-2]="("+m[r-2]+" + 1)",d(m)}function d(m){let h=n.map((v,w)=>f(w,m)),g=h.join(","),x=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${x}))`}function f(m,h){return t.indexOf(m)!==-1&&n[m]!==1?`${n[m]} - ${h[m]} - 1`:`${h[m]}`}}};function fpe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{dims:s}=r,i=o.shape.length,a=y.parseAxisParam(s,o.shape);if(i===0)return _t({inputs:{x:o},backend:t});let c=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new u0(o.shape,a):new l0(o.shape,a);return t.runWebGLProgram(c,[o],o.dtype)}var SW={kernelName:Bl,backendName:"webgl",kernelFunc:fpe};T();T();var p0=class{constructor(n,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let r=n[1],o=n[2];this.outputShape=n;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var NW={kernelName:du,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{let{image:r}=e,{radians:o,fillValue:s,center:i}=n,a=t,c=new p0(r.shape,s),[l,u]=S.getImageCenter(i,r.shape[1],r.shape[2]),p=[[l,u,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(c,[r],r.dtype,p)}};T();var mpe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,hpe=pe({opSnippet:mpe}),DW={kernelName:Xi,backendName:"webgl",kernelFunc:hpe};T();var gpe="return inversesqrt(x);",xpe=pe({opSnippet:gpe,cpuKernelImpl:sz}),kW={kernelName:Yi,backendName:"webgl",kernelFunc:xpe};T();var Pa=class{constructor(n,t,r,o,s,i,a=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let l=ve(s.length),u=ve(i.length),p="";r===1?p="i":r===2&&(p="i, j");let d=`getIndices(${p})`,f="";o===1?f="i":o===2&&(f="i, coords[1]");let m=`getUpdates(${f})`,h="";c&&(h="coords[0], coords[1]");let g=`getDefaultValue(${h})`,x=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${n}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${x};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${m};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}};var d0=class{constructor(n,t,r,o,s,i,a=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let l=ve(s.length),u=ve(i.length),p="";r===1?p="i":r===2&&(p="i, j");let d=`getIndices(${p})`,f="";o===1?f="i":o===2&&(f="i, coords[1]");let m=`getUpdates(${f})`,h="";c&&(h="coords[0], coords[1]");let g=`getDefaultValue(${h})`,x=t>1?"strides[j]":"strides",v=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${n}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${x};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${v};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${m};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}};function ype(e){let{inputs:n,backend:t,attrs:r}=e,{indices:o,updates:s}=n,{shape:i}=r,{sliceRank:a,numUpdates:c,sliceSize:l,strides:u,outputSize:p}=S.calculateShapes(s,o,i),d=[p/l,l];if(p===0)return t.makeTensorInfo(i,o.dtype);let f=J({inputs:{x:o},backend:t,attrs:{shape:[c,a]}}),m=J({inputs:{x:s},backend:t,attrs:{shape:[c,l]}}),h=t.makeTensorInfo([],"float32",new Float32Array([0])),g;M().getBool("WEBGL_PACK")?g=new d0(c,a,f.shape.length,m.shape.length,u,d):g=new Pa(c,a,f.shape.length,m.shape.length,u,d);let x=t.runWebGLProgram(g,[m,f,h],m.dtype),v=J({inputs:{x},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(h),v}var _W={kernelName:Vl,backendName:"webgl",kernelFunc:ype};T();T();var f0=class{constructor(n,t,r,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,r];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=M().getNumber("WEBGL_VERSION")===2?s:i,c=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function vpe(e){let{inputs:n,backend:t,attrs:r}=e,{sortedSequence:o,values:s}=n,{side:i}=r,a=new f0(o.shape[0],o.shape[1],s.shape[1],i),c=[[o.shape[1]]];return t.runWebGLProgram(a,[o,s],"int32",c)}var AW={kernelName:zl,backendName:"webgl",kernelFunc:vpe};T();var m0=class{constructor(n,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let o,s;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],l=[];for(let u=0;u<t.length;u++)l.push(`${a[u]}`),u<n&&c.push(`${a[u]}`);o=c.join(),s=l.join()}let i=ve(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function bpe(e){let{inputs:n,backend:t}=e,{condition:r,t:o,e:s}=n,i=new m0(r.shape.length,o.shape,o.shape.length);return t.runWebGLProgram(i,[r,o,s],Mt(o.dtype,s.dtype))}var RW={kernelName:Gl,backendName:"webgl",kernelFunc:bpe};T();var Cpe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${S.SELU_SCALEALPHA};
  float scale = ${S.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,wpe=pe({opSnippet:Cpe}),FW={kernelName:Zi,backendName:"webgl",kernelFunc:wpe};T();var Ipe=jr+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Epe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Tpe=pe({opSnippet:Ipe,packedOpSnippet:Epe,cpuKernelImpl:az}),OW={kernelName:ea,backendName:"webgl",kernelFunc:Tpe};T();var Spe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Npe=pe({opSnippet:Spe}),MW={kernelName:Ji,backendName:"webgl",kernelFunc:Npe};T();var Dpe=jr+`
  return sin(x);
`,kpe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${lr}
  return result;
`,_pe=pe({opSnippet:Dpe,packedOpSnippet:kpe}),$W={kernelName:"Sin",backendName:"webgl",kernelFunc:_pe};T();var Ape=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Rpe=pe({opSnippet:Ape}),PW={kernelName:Qi,backendName:"webgl",kernelFunc:Rpe};T();var Fpe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Ope=pe({opSnippet:Fpe}),LW={kernelName:ta,backendName:"webgl",kernelFunc:Ope};T();var Mpe=e=>{let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{blockShape:s,paddings:i}=r;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((x,v)=>x*v),c=[[0,0]];c.push(...i);for(let x=1+s.length;x<o.shape.length;++x)c.push([0,0]);let l=[],u=y1({inputs:{x:o},backend:t,attrs:{paddings:c,constantValue:0}}),p=S.getReshaped(u.shape,s,a,!1),d=S.getPermuted(p.length,s.length,!1),f=S.getReshapedPermuted(u.shape,s,a,!1),m=J({inputs:{x:u},backend:t,attrs:{shape:p}}),h=ft({inputs:{x:m},backend:t,attrs:{perm:d}}),g=J({inputs:{x:h},backend:t,attrs:{shape:f}});return l.push(u),l.push(m),l.push(h),l.forEach(x=>t.disposeIntermediateTensorInfo(x)),g},BW={kernelName:jl,backendName:"webgl",kernelFunc:Mpe};T();function $pe(e){let{inputs:n,backend:t}=e,{indices:r,values:o,denseShape:s,defaultValue:i}=n;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=t.readSync(r.dataId),c=t.readSync(o.dataId),l=t.readSync(s.dataId),u=t.readSync(i.dataId)[0],[p,d,f,m,h]=lz(a,r.shape,r.dtype,c,o.dtype,l,u);return[t.makeTensorInfo(d,r.dtype,p),t.makeTensorInfo([d[0]],o.dtype,f),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}var VW={kernelName:Xl,backendName:"webgl",kernelFunc:$pe};T();function Ppe(e){let{inputs:n,backend:t}=e,{inputIndices:r,inputShape:o,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(t.readSync(o.dataId)),a=t.readSync(r.dataId),c=Array.from(t.readSync(s.dataId)),[l,u,p]=uz(a,r.shape,r.dtype,i,c);return[t.makeTensorInfo(u,r.dtype,l),t.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var UW={kernelName:Yl,backendName:"webgl",kernelFunc:Ppe};T();function Lpe(e){let{inputs:n,backend:t}=e,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=t.readSync(r.dataId),a=t.readSync(o.dataId),c=t.readSync(s.dataId),[l,u]=Xv(i,r.shape,r.dtype,a,c,!0);return t.makeTensorInfo(u,r.dtype,l)}var zW={kernelName:Zl,backendName:"webgl",kernelFunc:Lpe};T();function Bpe(e){let{inputs:n,backend:t}=e,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=t.readSync(r.dataId),a=t.readSync(o.dataId),c=t.readSync(s.dataId),[l,u]=Xv(i,r.shape,r.dtype,a,c);return t.makeTensorInfo(u,r.dtype,l)}var GW={kernelName:Ql,backendName:"webgl",kernelFunc:Bpe};T();function Vpe(e){let{inputs:n,backend:t,attrs:r}=e,{sparseIndices:o,sparseValues:s,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:c,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=S.calculateShapes(s,o,a),f=!1;if(s.dtype==="string"){let x=t.bufferSync(o),v=t.bufferSync(s),w=y.decodeString(t.readSync(i.dataId)[0]),I=iz(x,v,a,d,u,l,c,p,w,f);return t.makeTensorInfo(a,I.dtype,I.values)}let m=new Pa(l,c,o.shape.length,s.shape.length,p,[d,1],f),h=t.runWebGLProgram(m,[s,o,i],s.dtype),g=J({inputs:{x:h},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(h),g}var HW={kernelName:Jl,backendName:"webgl",kernelFunc:Vpe};T();function Upe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{numOrSizeSplits:s,axis:i}=r,a=y.parseAxisParam(i,o.shape)[0],c=S.prepareSplitSize(o,s,a),l=o.shape.length,u=new Array(l).fill(0),p=o.shape.slice();return c.map(d=>{let f=[...p];f[a]=d;let m=wo({inputs:{x:o},backend:t,attrs:{begin:u,size:f}});return u[a]+=d,m})}var WW={kernelName:ql,backendName:"webgl",kernelFunc:Upe};T();var jW="return sqrt(x);",zpe=pe({opSnippet:jW,packedOpSnippet:jW,cpuKernelImpl:pz}),qW={kernelName:na,backendName:"webgl",kernelFunc:zpe};T();var Gpe="return x * x;",Hpe=pe({opSnippet:Gpe}),KW={kernelName:mm,backendName:"webgl",kernelFunc:Hpe};T();var XW="return (a - b) * (a - b);",Wpe=Qe({opSnippet:XW,packedOpSnippet:XW}),YW={kernelName:ra,backendName:"webgl",kernelFunc:Wpe};T();function jpe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n;if(o.dtype!=="string")throw new Error("Input must be of datatype string");let s=t.readSync(o.dataId),i=S.fromUint8ToStringArray(s),a=dz(i,"string",r);return t.makeTensorInfo(o.shape,"string",a)}var ZW={kernelName:oa,backendName:"webgl",kernelFunc:jpe};T();function qpe({inputs:e,attrs:n,backend:t}){let{x:r}=e,o=Vt+`
    return x > 0.0 ? 1.0 : float(${n.alpha});
  `,s=new an(r.shape,o);return t.runWebGLProgram(s,[r],r.dtype)}var QW={kernelName:ia,backendName:"webgl",kernelFunc:qpe};T();var h0=class{constructor(n,t,r){this.variableNames=["x"],this.outputShape=r;let o=r.length,s=ve(r.length),i=ve(r.length),a="";if(o===1)a="coords * strides + begin";else{let c=0;a=r.map((l,u)=>(c++,r.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${c-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${n});
      ${s} strides = ${s}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function Kpe(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{begin:s,end:i,strides:a,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:p,shrinkAxisMask:d}=r,{finalShapeSparse:f,finalShape:m,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:v,end:w,strides:I}=zt.sliceInfo(o.shape,s,i,a,c,l,u,p,d),_;if(h)_=J({inputs:{x:o},backend:t,attrs:{shape:m}});else if(g||x){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let R=zt.computeOutShape(v,w,I),F=wo({inputs:{x:o},backend:t,attrs:{begin:v,size:R}});_=J({inputs:{x:F},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(F)}else if(t.shouldExecuteOnCPU([o])){let F=t.readSync(o.dataId),P=le(o.shape,o.dtype,F),L=fz(f,P,I,v);_=t.makeTensorInfo(m,o.dtype,L.values)}else{let F=new h0(v,I,f);_=t.runWebGLProgram(F,[o],o.dtype)}let A=J({inputs:{x:_},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(_),A}var JW={kernelName:eu,backendName:"webgl",kernelFunc:Kpe};T();function Xpe(e){let{inputs:n,backend:t,attrs:r}=e,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:c,preserveShortSequences:l}=r,{data:u,dataSplits:p}=n,d=t.readSync(u.dataId),f=t.readSync(p.dataId),[m,h]=mz(d,f,o,s,i,a,c,l);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(p.shape,"int32",h)]}var ej={kernelName:tu,backendName:"webgl",kernelFunc:Xpe};T();function Ype(e){let{inputs:n,backend:t,attrs:r}=e,{skipEmpty:o}=r,{input:s,delimiter:i}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=t.readSync(s.dataId),c=t.readSync(i.dataId)[0],[l,u,p]=hz(a,c,o),d=u.length;return[t.makeTensorInfo([d,2],"int32",l),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(p))]}var tj={kernelName:nu,backendName:"webgl",kernelFunc:Ype};T();function Zpe(e){let{inputs:n,backend:t,attrs:r}=e,{numBuckets:o}=r,{input:s}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=t.readSync(s.dataId),a=gz(i,o);return t.makeTensorInfo(s.shape,"int32",a)}var nj={kernelName:ru,backendName:"webgl",kernelFunc:Zpe};T();var Qpe="return tan(x);",Jpe=pe({opSnippet:Qpe}),rj={kernelName:"Tan",backendName:"webgl",kernelFunc:Jpe};T();var ede=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,tde=pe({opSnippet:ede}),oj={kernelName:sa,backendName:"webgl",kernelFunc:tde};T();function nde(e){let{inputs:n,backend:t,attrs:r}=e,{tensor:o,indices:s,updates:i}=n,{}=r,{sliceRank:a,numUpdates:c,sliceSize:l,strides:u,outputSize:p}=S.calculateShapes(i,s,o.shape),d=[p/l,l];if(p===0)return t.makeTensorInfo(o.shape,s.dtype);let f=J({inputs:{x:s},backend:t,attrs:{shape:[c,a]}}),m=J({inputs:{x:i},backend:t,attrs:{shape:[c,l]}}),h=J({inputs:{x:o},backend:t,attrs:{shape:d}}),g=new Pa(c,a,f.shape.length,m.shape.length,u,d,!1,!0),x=t.runWebGLProgram(g,[m,f,h],h.dtype),v=J({inputs:{x},backend:t,attrs:{shape:o.shape}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(x),v}var sj={kernelName:Ul,backendName:"webgl",kernelFunc:nde};T();var g0=class{constructor(n,t){this.variableNames=["A"];let r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[i]*t[i];this.outputShape=r,this.rank=r.length;let o=ve(this.rank),s=rde(n);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function rde(e){let n=e.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`imod(resRC, ${e[0]})`;let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<e.length;o++)r.push(`imod(${t[o]}, ${e[o]})`);return r.join()}function b1(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{reps:s}=r;if(o.dtype==="string"||o.shape.length>5){let c=t.readSync(o.dataId),l=o.dtype==="string"?c.map(d=>y.decodeString(d)):c,u=le(o.shape,o.dtype,l),p=yz(u,s);return t.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new g0(o.shape,s);return t.runWebGLProgram(i,[o],o.dtype)}var ij={kernelName:hs,backendName:"webgl",kernelFunc:b1};T();var x0=class{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=n,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},y0=class{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=n,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function tp(e,n){n!==null&&e.disposeIntermediateTensorInfo(n)}function aj(e){let n=1;for(;n<e;)n*=2;return n}function ode(e){let{inputs:n,backend:t,attrs:r}=e,{x:o}=n,{k:s,sorted:i}=r,a=M().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=M().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,u=l[l.length-1];if(t.shouldExecuteOnCPU([o])||u<a||s>c){let L=t.readSync(o.dataId),[V,z]=vz(L,l,o.dtype,s,i);return[t.makeTensorInfo(V.shape,V.dtype,V.values),t.makeTensorInfo(z.shape,z.dtype,z.values)]}if(s===0)return l[l.length-1]=0,[t.makeTensorInfo(l,o.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(u===1)return[o,Gs({attrs:{shape:l,dtype:"int32",value:0},backend:t})];let p=t.texData.get(o.dataId),d=p!==null&&p.isPacked,f=d?t.unpackTensor(o):o,h=y.sizeFromShape(l)/u,g=J({inputs:{x:f},attrs:{shape:[h,u]},backend:t});d&&tp(t,f);let x=aj(s),v=aj(u),w=null,I=()=>w===null?[g,g]:[g,w],_=(L,V,z)=>{let G=I(),j=new x0(z),Y=[[u],[w===null?1:0],[Number.NEGATIVE_INFINITY],[L],[V]],Z=w;w=t.runWebGLProgram(j,G,"int32",Y),tp(t,Z)};for(let L=1;L<x;L*=2){let V=L*2;for(let z=L;z>=1;z/=2)_(V,z,[h,v])}for(let L=v;L>x;L/=2){let V=I(),z=new y0([h,L/2]),j=[[u],[w===null?1:0],[x]],W=w;w=t.runWebGLProgram(z,V,"int32",j),tp(t,W);let Y=x/2,Z=Y*2;for(let K=Y;K>=1;K/=2)_(Z,K,w.shape)}let A=w;w=wo({inputs:{x:w},backend:t,attrs:{begin:0,size:[h,s]}}),tp(t,A);let R=f1({inputs:{x:g,indices:w},backend:t,attrs:{axis:1,batchDims:1}});tp(t,g);let F=l.slice(0,-1);F.push(s),A=w,w=J({inputs:{x:w},attrs:{shape:F},backend:t}),tp(t,A);let P=R;return R=J({inputs:{x:R},attrs:{shape:F},backend:t}),tp(t,P),[R,w]}var cj={kernelName:iu,backendName:"webgl",kernelFunc:ode};T();var v0=class{constructor(n,t,r,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=r==="nearest"?1:2,c;switch(o){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${n}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function sde(e){let{inputs:n,backend:t,attrs:r}=e,{image:o,transforms:s}=n,{interpolation:i,fillMode:a,fillValue:c,outputShape:l}=r,[u,p,d,f]=o.shape,[m,h]=l??[p,d],g=[u,m,h,f],x=new v0(p,d,i,a,c,g);return t.runWebGLProgram(x,[o,s],"float32")}var lj={kernelName:au,backendName:"webgl",kernelFunc:sde};T();function ide(e){let{inputs:n,attrs:t,backend:r}=e,{axis:o}=t,{x:s}=n;Jo(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:a,outputShape:c,indices:l}=bz(i,o,s.shape,s.dtype);return[r.makeTensorInfo(c,s.dtype,a),r.makeTensorInfo([l.length],"int32",l)]}var uj={kernelName:cu,backendName:"webgl",kernelFunc:ide};T();function ade(e){let{inputs:n,backend:t,attrs:r}=e,{value:o}=n,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,c=o.shape[s],l=new Array(a-1),u=0;for(let h=0;h<a;h++)h!==s&&(l[u++]=i.shape[h]);let p=[],d=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let m=new Array(c);for(let h=0;h<m.length;h++){d[s]=h;let g=wo({inputs:{x:i},backend:t,attrs:{begin:d,size:f}}),x=J({inputs:{x:g},backend:t,attrs:{shape:l}});m[h]=x,p.push(g)}return p.forEach(h=>t.disposeIntermediateTensorInfo(h)),m}var pj={kernelName:lu,backendName:"webgl",kernelFunc:ade};T();var b0=class{constructor(n,t){this.variableNames=["x","segmentIds"];let r=n.windowSize,o=n.batchSize,s=n.inSize,i=n.numSegments,a=i*Math.ceil(s/r);this.outputShape=[o,a];let c="0.0",l="sumValue",u=Math.floor(r/4)*4,p=r%4,d=`
        sumValue += dot(values, segFilter);
    `,f="";s%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let m="";s%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function cde(e){let{inputs:n,backend:t,attrs:r}=e,{x:o,segmentIds:s}=n,{numSegments:i}=r,a=o.shape.length,c=[],l=0,u=S.getAxesPermutation([l],a),p=o;u!=null&&(p=ft({inputs:{x:o},backend:t,attrs:{perm:u}}),c.push(p),l=S.getInnerMostAxes(1,a)[0]);let d=S.segment_util.computeOutShape(p.shape,l,i),f=y.sizeFromShape([p.shape[l]]),m=J({inputs:{x:p},backend:t,attrs:{shape:[-1,f]}});c.push(m);let h=da(o.dtype),g=(I,_,A,R,F)=>{let P=I.shape[0],L=I.shape[1],V=S.segment_util.segOpComputeOptimalWindowSize(L,F),z={windowSize:V,inSize:L,batchSize:P,numSegments:F},G=new b0(z,_),j=t.compileAndRun(G,[I,A],R);if(c.push(j),j.shape[1]===F)return j;let W=v1({backend:t,attrs:{start:0,stop:F,step:1,dtype:"float32"}}),Y=b1({inputs:{x:W},backend:t,attrs:{reps:[L/V]}});return c.push(W),c.push(Y),g(j,_,Y,R,F)},x=g(m,"unsortedSegmentSum",s,h,i),v=J({inputs:{x},backend:t,attrs:{shape:d}}),w=v;if(u!=null){c.push(v);let I=S.getUndoAxesPermutation(u);w=ft({inputs:{x:w},backend:t,attrs:{perm:I}})}return c.forEach(I=>t.disposeIntermediateTensorInfo(I)),w}var dj={kernelName:uu,backendName:"webgl",kernelFunc:cde};var lde=[Kz,Yz,Zz,Qz,eG,tG,nG,rG,iG,aG,cG,lG,uG,pG,dG,fG,mG,hG,gG,xG,yG,bG,CG,wG,IG,NG,kG,_G,Lz,RG,OG,MG,$G,PG,LG,BG,VG,UG,zG,GG,jG,qG,KG,XG,YG,ZG,QG,JG,eH,tH,nH,rH,oH,sH,iH,aH,lH,uH,pH,dH,mH,hH,gH,xH,yH,vH,bH,CH,wH,Pz,IH,FG,EH,TH,SH,Bz,NH,DH,kH,_H,AH,RH,FH,OH,MH,$H,LH,BH,VH,UH,zH,GH,WH,qH,KH,XH,YH,ZH,nW,zz,rW,oW,sW,iW,EG,aW,uW,pW,dW,fW,Vz,mW,hW,gW,xW,yW,TG,QH,vW,bW,CW,Hz,wW,IW,EW,TW,SW,NW,DW,kW,_W,AW,RW,FW,OW,MW,$W,PW,vG,tW,LW,BW,VW,UW,zW,GW,HW,WW,qW,KW,YW,ZW,QW,JW,ej,tj,nj,eW,jz,rj,oj,sj,ij,cj,lj,qz,uj,pj,dj,cW];for(let e of lde)Zp(e);var ude=["proportionChart"],C0=class e{canvasRef;newValue=Vx(null);nearThreshold=Vx(.98);farThreshold=Vx(.88);ctx;history=[];maxPoints=50;yMin=.5;yMax=1;updateEffect=RI(()=>{let n=this.newValue();n!==null&&!Number.isNaN(n)&&this.ctx&&this.updateChart(n)});ngAfterViewInit(){this.ctx=this.canvasRef.nativeElement.getContext("2d"),this.drawAxes()}drawAxes(){let n=this.canvasRef.nativeElement;this.ctx.clearRect(0,0,n.width,n.height);let t=[{value:this.farThreshold(),color:"orange"},{value:this.nearThreshold(),color:"red"}];console.log(`${t[0].value}, ${t[1].value}`),t.forEach(r=>{console.log(typeof r.value);let o=this.valueToY(r.value);this.ctx.beginPath(),this.ctx.strokeStyle=r.color,this.ctx.setLineDash([4,4]),this.ctx.moveTo(0,o),this.ctx.lineTo(n.width,o),this.ctx.stroke(),this.ctx.setLineDash([]),this.ctx.fillStyle=r.color,this.ctx.font="12px Arial",this.ctx.fillText(r.value.toFixed(2),5,o-5)}),this.ctx.setLineDash([])}valueToY(n){let t=this.canvasRef.nativeElement,r=this.yMax-this.yMin,o=Math.max(this.yMin,Math.min(this.yMax,n));return t.height-(o-this.yMin)/r*t.height}updateChart(n){this.history.push(n),this.history.length>this.maxPoints&&this.history.shift(),this.drawAxes(),this.ctx.beginPath(),this.ctx.strokeStyle="#0ff",this.ctx.lineWidth=2,this.history.forEach((t,r)=>{let o=r/(this.maxPoints-1)*this.canvasRef.nativeElement.width,s=this.valueToY(t);r===0?this.ctx.moveTo(o,s):this.ctx.lineTo(o,s)}),this.ctx.stroke()}static \u0275fac=function(t){return new(t||e)};static \u0275cmp=Rp({type:e,selectors:[["app-chart"]],viewQuery:function(t,r){if(t&1&&vr(ude,7),t&2){let o;br(o=Cr())&&(r.canvasRef=o.first)}},inputs:{newValue:[1,"newValue"],nearThreshold:[1,"nearThreshold"],farThreshold:[1,"farThreshold"]},decls:2,vars:0,consts:[["proportionChart",""],["width","400","height","120"]],template:function(t,r){t&1&&Yf(0,"canvas",1,0)},styles:["[_nghost-%COMP%]{display:block;margin:8px auto;text-align:center}canvas[_ngcontent-%COMP%]{width:100%;max-width:400px;height:auto;border:1px solid #555;border-radius:6px;background:#111}"]})};var fj="M3.90109 181.502C0.90318 168.367 1.31828 162.376 6.09542 149.831C6.71373 146.3 6.9413 143.133 6.9413 139.538C6.9413 137.5 8.25102 134.278 9.49994 132.5C11.2887 129.955 16.0694 126.71 18.8285 124.921C26.0956 120.212 35.8646 114.377 43.4999 110.5C62.1815 101.015 75.4999 96.5 94.4999 88C109.139 82.67 121.266 78.174 135.994 73.1612C142.625 70.907 154.538 67.4968 159.576 62.2266C159.328 61.1189 158.235 60.0478 158.012 59C157.82 58.103 157.964 57.2111 158.012 56.6703C158.596 55.3677 159.31 54.0703 160.218 52.9887C162.438 50.3445 166.819 49.0003 170.075 49.9519C173.207 50.8655 171.732 51.5 176.257 47.4492C196.486 29.3011 205.322 16.7591 232.084 10.2955C261.869 3.10121 295.752 1.51 326.244 2.11841C361.186 2.33421 394.589 3.97222 421.316 30.56C423.262 32.263 424.672 33.7762 426.914 35.24C431.452 38.204 435.768 38.9118 438.5 44C439.51 45.8824 441.585 49.5 442.232 51C444.605 56.5 444 60.5 442.232 65.5C442.237 68.3132 444.152 80.107 444.5 83.5C446.015 98.2317 445.27 100.477 438.5 113.5C437.241 126.786 435.5 151.779 425 155.5C420.269 157.177 414.584 158.028 409.63 157.298C404.677 156.567 402.102 154.593 400 149.5C363 173.5 333.552 195.195 295 217.519C291.388 235.803 283.375 256.184 269.5 268.5C265.441 272.103 255.5 278.042 247 279.042C239.037 279.979 235.364 280.512 227.5 278.042C221.954 276.303 218 272.5 215 268.5C212 270.359 207.934 272.44 203.916 273.888C188.598 279.397 124.523 273.466 92.4661 266.712C57.1281 259.265 31.1236 241.035 20.3212 231.423C16.4999 228.022 9.30978 222.793 8.70771 216.519C8.21013 211.327 7.72856 207.69 9.49994 203C9.49994 200.428 4.67273 193.515 4.23198 188.436C4.023 186.024 4.34394 184.048 3.90109 181.502Z";function mj(e){return e&&e.constructor&&typeof e.constructor.isBuffer=="function"&&e.constructor.isBuffer(e)}function hj(e){return e}function C1(e,n){n=n||{};let t=n.delimiter||".",r=n.maxDepth,o=n.transformKey||hj,s={};function i(a,c,l){l=l||1,Object.keys(a).forEach(function(u){let p=a[u],d=n.safe&&Array.isArray(p),f=Object.prototype.toString.call(p),m=mj(p),h=f==="[object Object]"||f==="[object Array]",g=c?c+t+o(u):o(u);if(!d&&!m&&h&&Object.keys(p).length&&(!n.maxDepth||l<r))return i(p,g,l+1);s[g]=p})}return i(e),s}function w1(e,n){n=n||{};let t=n.delimiter||".",r=n.overwrite||!1,o=n.transformKey||hj,s={};if(mj(e)||Object.prototype.toString.call(e)!=="[object Object]")return e;function a(u){let p=Number(u);return isNaN(p)||u.indexOf(".")!==-1||n.object?u:p}function c(u,p,d){return Object.keys(d).reduce(function(f,m){return f[u+t+m]=d[m],f},p)}function l(u){let p=Object.prototype.toString.call(u),d=p==="[object Array]",f=p==="[object Object]";if(u){if(d)return!u.length;if(f)return!Object.keys(u).length}else return!0}return e=Object.keys(e).reduce(function(u,p){let d=Object.prototype.toString.call(e[p]);return!(d==="[object Object]"||d==="[object Array]")||l(e[p])?(u[p]=e[p],u):c(p,u,C1(e[p],n))},{}),Object.keys(e).forEach(function(u){let p=u.split(t).map(o),d=a(p.shift()),f=a(p[0]),m=s;for(;f!==void 0;){if(d==="__proto__")return;let h=Object.prototype.toString.call(m[d]),g=h==="[object Object]"||h==="[object Array]";if(!r&&!g&&typeof m[d]<"u")return;(r&&!g||!r&&m[d]==null)&&(m[d]=typeof f=="number"&&!n.object?[]:{}),m=m[d],p.length>0&&(d=a(p.shift()),f=a(p[0]))}m[d]=w1(e[u],n)}),s}var E1=class{translations;constructor(n){this.translations=n}getTranslation(n){return lf(this.translations.get(n)||{})}},vj=new Ee("TRANSLOCO_LOADER");function gj(e,n){return e&&(Object.prototype.hasOwnProperty.call(e,n)?e[n]:n.split(".").reduce((t,r)=>t?.[r],e))}function pde(e,n,t){e=Je({},e);let r=n.split("."),o=r.length-1;return r.reduce((s,i,a)=>(a===o?s[i]=t:s[i]=Array.isArray(s[i])?s[i].slice():Je({},s[i]),s&&s[i]),e),e}function bj(e){return e?Array.isArray(e)?e.length:k1(e)?Object.keys(e).length:e?e.length:0:0}function dde(e){return bj(e)===0}function fde(e){return typeof e=="function"}function jh(e){return typeof e=="string"}function k1(e){return!!e&&typeof e=="object"&&!Array.isArray(e)}function Cj(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(n,t)=>t==0?n.toLowerCase():n.toUpperCase()).replace(/\s+|_|-|\//g,"")}function T1(e){return e==null}function xj(e){return T1(e)===!1}function _1(e){return e&&typeof e.scope=="string"}function mde(e){return Array.isArray(e)&&e.every(_1)}function hde(e){return e&&k1(e.loader)}function gde(e){return w1(e)}function yj(e){return C1(e,{safe:!0})}var Zd=new Ee("TRANSLOCO_CONFIG",{providedIn:"root",factory:()=>qh}),qh={defaultLang:"en",reRenderOnLangChange:!1,prodMode:!1,failedRetries:2,fallbackLang:[],availableLangs:[],missingHandler:{logMissingKey:!0,useFallbackTranslation:!1,allowEmpty:!1},flatten:{aot:!1},interpolation:["{{","}}"]};function xde(e={}){return Ft(Je(Je({},qh),e),{missingHandler:Je(Je({},qh.missingHandler),e.missingHandler),flatten:Je(Je({},qh.flatten),e.flatten)})}var wj=new Ee("TRANSLOCO_TRANSPILER"),yde=(()=>{class e{interpolationMatcher;constructor(t){this.interpolationMatcher=vde(t??qh)}transpile(t,r={},o,s){return jh(t)?t.replace(this.interpolationMatcher,(i,a)=>(a=a.trim(),xj(r[a])?r[a]:xj(o[a])?this.transpile(o[a],r,o,s):"")):(r&&(k1(t)?t=this.handleObject(t,r,o,s):Array.isArray(t)&&(t=this.handleArray(t,r,o,s))),t)}handleObject(t,r={},o,s){let i=t;return Object.keys(r).forEach(a=>{let c=gj(i,a),l=gj(r,a),u=this.transpile(c,l,o,s);i=pde(i,a,u)}),i}handleArray(t,r={},o,s){return t.map(i=>this.transpile(i,r,o,s))}static \u0275fac=function(r){return new(r||e)(at(Zd,8))};static \u0275prov=tt({token:e,factory:e.\u0275fac})}return e})();function vde(e){let[n,t]=e.interpolation;return new RegExp(`${n}(.*?)${t}`,"g")}var Ij=new Ee("TRANSLOCO_MISSING_HANDLER"),bde=(()=>{class e{handle(t,r){if(r.missingHandler.logMissingKey&&!r.prodMode){let o=`Missing translation for '${t}'`;console.warn(`%c ${o}`,"font-size: 12px; color: red")}return t}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:e.\u0275fac})}return e})(),Ej=new Ee("TRANSLOCO_INTERCEPTOR"),Cde=(()=>{class e{preSaveTranslation(t){return t}preSaveTranslationKey(t,r){return r}static \u0275fac=function(r){return new(r||e)};static \u0275prov=tt({token:e,factory:e.\u0275fac})}return e})(),Tj=new Ee("TRANSLOCO_FALLBACK_STRATEGY"),wde=(()=>{class e{userConfig;constructor(t){this.userConfig=t}getNextLangs(){let t=this.userConfig.fallbackLang;if(!t)throw new Error("When using the default fallback, a fallback language must be provided in the config!");return Array.isArray(t)?t:[t]}static \u0275fac=function(r){return new(r||e)(at(Zd))};static \u0275prov=tt({token:e,factory:e.\u0275fac})}return e})();function Kh(e){if(!e)return"";let n=e.split("/");return n.pop(),n.join("/")}function La(e){return e?e.split("/").pop():""}function S1(e,n,t="|"){if(jh(e)){let r=e.split(t),o=r.pop();return o===n?[!0,r.toString()]:[!1,o]}return[!1,""]}function Ide(e,n){let[t]=S1(n,"static");return t?!1:!!e.config.reRenderOnLangChange}function Ede(e){return e?n=>n:fp(1)}function Tde(e,n){return Object.keys(e).reduce((t,r)=>(t[`${n}/${r}`]=e[r],t),{})}function Sj(e,n){return hde(e)?Tde(e.loader,n):void 0}function I1(e){return{scope:Kh(e)||null,langName:La(e)}}function Nj(e){let{path:n,inlineLoader:t,mainLoader:r,data:o}=e;if(t){let s=t[n];if(fde(s)===!1)throw`You're using an inline loader but didn't provide a loader for ${n}`;return t[n]().then(i=>i.default?i.default:i)}return r.getTranslation(n,o)}function Sde({mainLoader:e,path:n,data:t,fallbackPath:r,inlineLoader:o}){return(r?[n,r]:[n]).map(i=>{let a=Nj({path:i,mainLoader:e,inlineLoader:o,data:t});return Xr(a).pipe(Xn(c=>({translation:c,lang:i})))})}var Nde;var Xh=(()=>{class e{loader;parser;missingHandler;interceptor;fallbackStrategy;langChanges$;subscription=null;translations=new Map;cache=new Map;firstFallbackLang;defaultLang="";availableLangs=[];isResolvedMissingOnce=!1;lang;failedLangs=new Set;events=new Tn;events$=this.events.asObservable();config;constructor(t,r,o,s,i,a){this.loader=t,this.parser=r,this.missingHandler=o,this.interceptor=s,this.fallbackStrategy=a,this.loader||(this.loader=new E1(this.translations)),Nde=this,this.config=JSON.parse(JSON.stringify(i)),this.setAvailableLangs(this.config.availableLangs||[]),this.setFallbackLangForMissingTranslation(this.config),this.setDefaultLang(this.config.defaultLang),this.lang=new Wa(this.getDefaultLang()),this.langChanges$=this.lang.asObservable(),this.subscription=this.events$.subscribe(c=>{c.type==="translationLoadSuccess"&&c.wasFailure&&this.setActiveLang(c.payload.langName)})}getDefaultLang(){return this.defaultLang}setDefaultLang(t){this.defaultLang=t}getActiveLang(){return this.lang.getValue()}setActiveLang(t){return this.parser.onLangChanged?.(t),this.lang.next(t),this.events.next({type:"langChanged",payload:I1(t)}),this}setAvailableLangs(t){this.availableLangs=t}getAvailableLangs(){return this.availableLangs}load(t,r={}){let o=this.cache.get(t);if(o)return o;let s,i=this._isLangScoped(t),a;i&&(a=Kh(t));let c={path:t,mainLoader:this.loader,inlineLoader:r.inlineLoader,data:i?{scope:a}:void 0};if(this.useFallbackTranslation(t)){let u=i?`${a}/${this.firstFallbackLang}`:this.firstFallbackLang,p=Sde(Ft(Je({},c),{fallbackPath:u}));s=Og(p)}else{let u=Nj(c);s=Xr(u)}let l=s.pipe(hC(this.config.failedRetries),$g(u=>{if(Array.isArray(u)){u.forEach(p=>{this.handleSuccess(p.lang,p.translation),p.lang!==t&&this.cache.set(p.lang,lf({}))});return}this.handleSuccess(t,u)}),pf(u=>(this.config.prodMode||console.error(`Error while trying to load "${t}"`,u),this.handleFailure(t,r))),xC(1));return this.cache.set(t,l),l}translate(t,r={},o=this.getActiveLang()){if(!t)return t;let{scope:s,resolveLang:i}=this.resolveLangAndScope(o);if(Array.isArray(t))return t.map(l=>this.translate(s?`${s}.${l}`:l,r,i));t=s?`${s}.${t}`:t;let a=this.getTranslation(i),c=a[t];return c?this.parser.transpile(c,r,a,t):this._handleMissingKey(t,c,r)}selectTranslate(t,r,o,s=!1){let i,a=(l,u)=>this.load(l,u).pipe(Xn(()=>s?this.translateObject(t,r,l):this.translate(t,r,l)));if(T1(o))return this.langChanges$.pipe(Ya(l=>a(l)));if(mde(o)||_1(o)){let l=Array.isArray(o)?o[0]:o;o=l.scope,i=Sj(l,l.scope)}if(o=o,this.isLang(o)||this.isScopeWithLang(o))return a(o);let c=o;return this.langChanges$.pipe(Ya(l=>a(`${c}/${l}`,{inlineLoader:i})))}isScopeWithLang(t){return this.isLang(La(t))}translateObject(t,r={},o=this.getActiveLang()){if(jh(t)||Array.isArray(t)){let{resolveLang:i,scope:a}=this.resolveLangAndScope(o);if(Array.isArray(t))return t.map(u=>this.translateObject(a?`${a}.${u}`:u,r,i));let c=this.getTranslation(i);t=a?`${a}.${t}`:t;let l=gde(this.getObjectByKey(c,t));return dde(l)?this.translate(t,r,o):this.parser.transpile(l,r,c,t)}let s=[];for(let[i,a]of this.getEntries(t))s.push(this.translateObject(i,a,o));return s}selectTranslateObject(t,r,o){if(jh(t)||Array.isArray(t))return this.selectTranslate(t,r,o,!0);let[[s,i],...a]=this.getEntries(t);return this.selectTranslateObject(s,i,o).pipe(Xn(c=>{let l=[c];for(let[u,p]of a)l.push(this.translateObject(u,p,o));return l}))}getTranslation(t){if(t){if(this.isLang(t))return this.translations.get(t)||{};{let{scope:r,resolveLang:o}=this.resolveLangAndScope(t),s=this.translations.get(o)||{};return this.getObjectByKey(s,r)}}return this.translations}selectTranslation(t){let r=this.langChanges$;if(t){let o=La(t)!==t;this.isLang(t)||o?r=lf(t):r=this.langChanges$.pipe(Xn(s=>`${t}/${s}`))}return r.pipe(Ya(o=>this.load(o).pipe(Xn(()=>this.getTranslation(o)))))}setTranslation(t,r=this.getActiveLang(),o={}){let i=Je(Je({},{merge:!0,emitChange:!0}),o),a=Kh(r),c=t;if(a){let f=this.getMappedScope(a);c=yj({[f]:t})}let l=a?La(r):r,u=Je(Je({},i.merge&&this.getTranslation(l)),c),p=this.config.flatten.aot?u:yj(u),d=this.interceptor.preSaveTranslation(p,l);this.translations.set(l,d),i.emitChange&&this.setActiveLang(this.getActiveLang())}setTranslationKey(t,r,o=this.getActiveLang(),s={}){let i=this.interceptor.preSaveTranslationKey(t,r,o),a={[t]:i};this.setTranslation(a,o,Ft(Je({},s),{merge:!0}))}setFallbackLangForMissingTranslation({fallbackLang:t}){let r=Array.isArray(t)?t[0]:t;t&&this.useFallbackTranslation(r)&&(this.firstFallbackLang=r)}_handleMissingKey(t,r,o){if(this.config.missingHandler.allowEmpty&&r==="")return"";if(!this.isResolvedMissingOnce&&this.useFallbackTranslation()){this.isResolvedMissingOnce=!0;let s=this.translate(t,o,this.firstFallbackLang);return this.isResolvedMissingOnce=!1,s}return this.missingHandler.handle(t,this.getMissingHandlerData(),o)}_isLangScoped(t){return this.getAvailableLangsIds().indexOf(t)===-1}isLang(t){return this.getAvailableLangsIds().indexOf(t)!==-1}_loadDependencies(t,r){let o=La(t);return this._isLangScoped(t)&&!this.isLoadedTranslation(o)?fC([this.load(o),this.load(t,{inlineLoader:r})]):this.load(t,{inlineLoader:r})}_completeScopeWithLang(t){return this._isLangScoped(t)&&!this.isLang(La(t))?`${t}/${this.getActiveLang()}`:t}_setScopeAlias(t,r){this.config.scopeMapping||(this.config.scopeMapping={}),this.config.scopeMapping[t]=r}ngOnDestroy(){this.subscription&&(this.subscription.unsubscribe(),this.subscription=null),this.cache.clear()}isLoadedTranslation(t){return bj(this.getTranslation(t))}getAvailableLangsIds(){let t=this.getAvailableLangs()[0];return jh(t)?this.getAvailableLangs():this.getAvailableLangs().map(r=>r.id)}getMissingHandlerData(){return Ft(Je({},this.config),{activeLang:this.getActiveLang(),availableLangs:this.availableLangs,defaultLang:this.defaultLang})}useFallbackTranslation(t){return this.config.missingHandler.useFallbackTranslation&&t!==this.firstFallbackLang}handleSuccess(t,r){this.setTranslation(r,t,{emitChange:!1}),this.events.next({wasFailure:!!this.failedLangs.size,type:"translationLoadSuccess",payload:I1(t)}),this.failedLangs.forEach(o=>this.cache.delete(o)),this.failedLangs.clear()}handleFailure(t,r){T1(r.failedCounter)&&(r.failedCounter=0,r.fallbackLangs||(r.fallbackLangs=this.fallbackStrategy.getNextLangs(t)));let o=t.split("/"),i=r.fallbackLangs[r.failedCounter];if(this.failedLangs.add(t),this.cache.has(i))return this.handleSuccess(i,this.getTranslation(i)),ja;let a=i===o[o.length-1];if(!i||a){let l="Unable to load translation and all the fallback languages";throw o.length>1&&(l+=", did you misspelled the scope name?"),new Error(l)}let c=i;return o.length>1&&(o[o.length-1]=i,c=o.join("/")),r.failedCounter++,this.events.next({type:"translationLoadFailure",payload:I1(t)}),this.load(c,r)}getMappedScope(t){let{scopeMapping:r={}}=this.config;return r[t]||Cj(t)}resolveLangAndScope(t){let r=t,o;if(this._isLangScoped(t)){let s=La(t),i=this.isLang(s);r=i?s:this.getActiveLang(),o=this.getMappedScope(i?Kh(t):t)}return{scope:o,resolveLang:r}}getObjectByKey(t,r){let o={},s=`${r}.`;for(let i in t)i.startsWith(s)&&(o[i.replace(s,"")]=t[i]);return o}getEntries(t){return t instanceof Map?t.entries():Object.entries(t)}static \u0275fac=function(r){return new(r||e)(at(vj,8),at(wj),at(Ij),at(Ej),at(Zd),at(Tj))};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();var Dde=new Ee("TRANSLOCO_LANG"),UVt=new Ee("TRANSLOCO_LOADING_TEMPLATE"),kde=new Ee("TRANSLOCO_SCOPE"),N1=class{initialized=!1;resolve({inline:n,provider:t,active:r}){let o=r;if(this.initialized)return o=r,o;if(t){let[,s]=S1(t,"static");o=s}if(n){let[,s]=S1(n,"static");o=s}return this.initialized=!0,o}resolveLangBasedOnScope(n){return Kh(n)?La(n):n}resolveLangPath(n,t){return t?`${t}/${n}`:n}},D1=class{service;constructor(n){this.service=n}resolve(n){let{inline:t,provider:r}=n;if(t)return t;if(r){if(_1(r)){let{scope:o,alias:s=Cj(o)}=r;return this.service._setScopeAlias(o,s),o}return r}}};var Dj=(()=>{class e{service;providerScope;providerLang;cdr;subscription=null;lastValue="";lastKey;path;langResolver=new N1;scopeResolver;constructor(t,r,o,s){this.service=t,this.providerScope=r,this.providerLang=o,this.cdr=s,this.scopeResolver=new D1(this.service)}transform(t,r,o){if(!t)return t;let s=r?`${t}${JSON.stringify(r)}`:t;if(s===this.lastKey)return this.lastValue;this.lastKey=s,this.subscription?.unsubscribe();let i=Ide(this.service,this.providerLang||o);return this.subscription=this.service.langChanges$.pipe(Ya(a=>{let c=this.langResolver.resolve({inline:o,provider:this.providerLang,active:a});return Array.isArray(this.providerScope)?Og(this.providerScope.map(l=>this.resolveScope(c,l))):this.resolveScope(c,this.providerScope)}),Ede(i)).subscribe(()=>this.updateValue(t,r)),this.lastValue}ngOnDestroy(){this.subscription?.unsubscribe(),this.subscription=null}updateValue(t,r){let o=this.langResolver.resolveLangBasedOnScope(this.path);this.lastValue=this.service.translate(t,r,o),this.cdr.markForCheck()}resolveScope(t,r){let o=this.scopeResolver.resolve({inline:void 0,provider:r});this.path=this.langResolver.resolveLangPath(t,o);let s=Sj(r,o);return this.service._loadDependencies(this.path,s)}static \u0275fac=function(r){return new(r||e)(Nn(Xh,16),Nn(kde,24),Nn(Dde,24),Nn(Ux,16))};static \u0275pipe=qf({name:"transloco",type:e,pure:!1})}return e})();function zVt(e){let n=[Rde(yde),Ode(bde),Mde(Cde),Fde(wde)];return e.config&&n.push(_de(e.config)),e.loader&&n.push(Ade(e.loader)),n}function _de(e){return hr([{provide:Zd,useValue:xde(e)}])}function Ade(e){return hr([{provide:vj,useClass:e}])}function Rde(e){return hr([{provide:wj,useClass:e,deps:[Zd]}])}function Fde(e){return hr([{provide:Tj,useClass:e,deps:[Zd]}])}function Ode(e){return hr([{provide:Ij,useClass:e}])}function Mde(e){return hr([{provide:Ej,useClass:e}])}var GVt=new Ee("TRANSLOCO_TEST_LANGS - Available testing languages"),HVt=new Ee("TRANSLOCO_TEST_OPTIONS - Testing options");var ok=tg(m8());var U0=class e{model=null;isLoaded=lt(!1);worker=null;constructor(){this.loadModelInBackground()}async loadModelInBackground(){typeof Worker<"u"?(this.worker=new Worker(new URL("worker-RCF4645K.js",import.meta.url),{type:"module"}),this.worker.onmessage=async({data:n})=>{n.status==="loaded"?(console.log("Woker pre-loaded the model. Loading locally..."),this.model=await ok.load(),this.isLoaded.set(!0)):n.status==="error"&&console.error("Error on worker:",n.error)},this.worker.postMessage("start")):this.directLoad()}async directLoad(){this.model=await ok.load(),this.isLoaded.set(!0)}async getModelReady(){if(this.model)return this.model;for(;!this.isLoaded();)await new Promise(n=>setTimeout(n,200));return this.model}static \u0275fac=function(t){return new(t||e)};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})};var z0=class e{constructor(n){this.transloco=n}currentLang=lt("en");initializeFromUrl(){return new Promise(n=>{let t=this.detectLangFromUrl();this.setLanguage(t),console.log("\u2705 Idioma cargado:",t),n()})}detectLangFromUrl(){let[,n]=window.location.pathname.split("/");return n==="es"||n==="pt"?n:"en"}setLanguage(n){this.currentLang.set(n),this.transloco.setActiveLang(n)}static \u0275fac=function(t){return new(t||e)(at(Xh))};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})};var G0=class e{constructor(n){this.languageService=n}config=lt(null);async loadConfig(){try{let n=new URLSearchParams(window.location.search);console.log(window.location);let t=n.get("variant")?.toLowerCase()??"dev",r=this.languageService.detectLangFromUrl(),o=`config/config-${t}.json`,i=await(await fetch(o)).json();this.config.set(i),console.log("\u2705 Configuraci\xF3n cargada:",i)}catch(n){console.error("\u274C No se pudo cargar la configuraci\xF3n:",n)}}getFeature(n){return this.config()?.features[n]??!1}get variant(){return this.config()?.variant??"default"}static \u0275fac=function(t){return new(t||e)(at(z0))};static \u0275prov=tt({token:e,factory:e.\u0275fac,providedIn:"root"})};var Pfe=["video"],Lfe=["detectionCanvas"],Bfe=["overlayCanvas"],Vfe=["startBtn"],Ufe=["irregularPath"],zfe=["rectPath"],Gfe=["freezeCanvas"],Hfe=["header"],Wfe=["footer"];function jfe(e,n){if(e&1){let t=vc();$e(0,"div")(1,"button",66,8),ro("click",function(){eo(t);let o=yr();return to(o.startCapture())}),Dn(3),Ln(4,"transloco"),Be()()}e&2&&(Me(3),us(" ",wr(4,1,"startCapture")," "))}function qfe(e,n){e&1&&($e(0,"div",67),pt(1,"span")(2,"span")(3,"span"),Be())}function Kfe(e,n){e&1&&($e(0,"div",68),pt(1,"span")(2,"span")(3,"span"),Be())}function Xfe(e,n){e&1&&($e(0,"div",69),pt(1,"span")(2,"span")(3,"span"),Be())}function Yfe(e,n){e&1&&($e(0,"div",70),pt(1,"span")(2,"span")(3,"span"),Be())}function Zfe(e,n){e&1&&($e(0,"div",72),pt(1,"img",74),$e(2,"b",75),Dn(3,"Image saved."),Be()())}function Qfe(e,n){if(e&1){let t=vc();$e(0,"div",73)(1,"button",76),ro("click",function(){eo(t);let o=yr(2);return to(o.retryPhoto())}),Dn(2),Ln(3,"transloco"),Be(),$e(4,"button",77),ro("click",function(){eo(t);let o=yr(2);return to(o.usePhoto())}),Dn(5),Ln(6,"transloco"),Be()()}e&2&&(Me(2),us(" ",wr(3,2,"retry")," "),Me(3),us(" ",wr(6,4,"usePhoto")," "))}function Jfe(e,n){if(e&1&&($e(0,"div",21),pt(1,"img",71),ci(2,Zfe,4,0,"div",72),ci(3,Qfe,7,6,"div",73),Be()),e&2){let t=yr();Me(),Jn("src",t.capturedImage(),oI),Me(),li(t.showToastOk()?2:-1),Me(),li(t.showRetryConfirmMessageSignal()?3:-1)}}function eme(e,n){if(e&1){let t=vc();$e(0,"div",22)(1,"div",78)(2,"label",79)(3,"input",80),ro("change",function(){eo(t);let o=yr();return to(o.toggleDetections())}),Be(),pt(4,"span",81),Be(),$e(5,"span",82),Dn(6),Ln(7,"transloco"),Be()(),$e(8,"div",78)(9,"label",79)(10,"input",80),ro("change",function(){eo(t);let o=yr();return to(o.toggleBoxes())}),Be(),pt(11,"span",81),Be(),$e(12,"span",82),Dn(13),Ln(14,"transloco"),Be()()()}if(e&2){let t=yr();Me(3),Jn("checked",t.showDetections()),Me(3),ls(wr(7,4,"showDetections")),Me(4),Jn("checked",t.showBoxes()),Me(3),ls(wr(14,6,"showBoxes"))}}function tme(e,n){if(e&1){let t=vc();$e(0,"div",23)(1,"div",83),Dn(2),Ln(3,"transloco"),$e(4,"span"),Dn(5),Be(),pt(6,"app-chart",84),Be(),$e(7,"div",85)(8,"label"),Dn(9),Ln(10,"transloco"),Ln(11,"number"),$e(12,"input",86),ro("input",function(o){eo(t);let s=yr();return to(s.setNearThreshold(o.target.value))}),Be()(),$e(13,"label"),Dn(14),Ln(15,"transloco"),Ln(16,"number"),$e(17,"input",87),ro("input",function(o){eo(t);let s=yr();return to(s.setFarThreshold(o.target.value))}),Be()()()()}if(e&2){let t=yr();Me(2),us(" ",wr(3,11,"proportion")," "),Me(3),ls(t.proportion()!==null?t.proportion():"N/A"),Me(),Jn("newValue",t.proportion())("nearThreshold",t.nearThreshold())("farThreshold",t.farThreshold()),Me(3),Jf(" ",wr(10,13,"nearThreshold")," (",Lx(11,15,t.nearThreshold(),"1.2-2"),") "),Me(3),Jn("value",t.nearThreshold()),Me(2),Jf(" ",wr(15,18,"farThreshold")," (",Lx(16,20,t.farThreshold(),"1.2-2"),") "),Me(3),Jn("value",t.farThreshold())}}function nme(e,n){if(e&1&&($e(0,"div",62),Dn(1),Be()),e&2){let t=yr();Me(),ls(t.feedback())}}var h8=class e{constructor(n,t,r){this.tfModelService=n;this.config=t;this.transloco=r}videoRef;detectionCanvasRef;overlayCanvasRef;startBtnRef;irregularPathRef;rectPathRef;freezeCanvasRef;headerDivRef;footerDivRef;feedback=lt("Press 'Start capture' button");detections=lt([]);proportion=lt(null);capturedImage=lt(null);isFrozen=lt(!1);cameraReady=lt(!0);directionMessage=lt(null);showFeedbackMessage=lt(!1);showCapturedPhotoSignal=lt(!1);showRetryConfirmMessageSignal=lt(!1);showToastOk=lt(!1);arrowDirection=lt({left:!1,right:!1,up:!1,down:!1});isCentered=lt(!1);showTogglePanel=lt(!0);showPermissionSlider=lt(!0);showDetections=lt(!1);showBoxes=lt(!1);nearThreshold=lt(.99);farThreshold=lt(.88);ctx;overlayCtx;model;detectionTimer;stream=null;isCapturingPhoto=!1;isAnimating=!1;isAnimatingFill=!1;rectPath2D;rectMetrics={offsetX:0,offsetY:0,width:0,height:0};outlinePathData=fj;svgWidth=448;svgHeight=282;ngOnInit(){let n=this.config.config();this.showTogglePanel.set(this.config.getFeature("showDetectionsPanel")),console.log("Active component configuration:",n)}ngAfterViewInit(){let n=this.irregularPathRef.nativeElement,t=n.getTotalLength();n.style.setProperty("--path-length",`${t}`)}ngOnDestroy(){this.detectionTimer&&clearInterval(this.detectionTimer),this.stream&&this.stream.getTracks().forEach(n=>n.stop())}showArrow(n){return this.arrowDirection()[n]}showCentered(){return this.isCentered()}toggleDetections(){this.showDetections.update(n=>!n)}toggleBoxes(){this.showBoxes.update(n=>!n)}setNearThreshold(n){this.nearThreshold.set(Number(n))}setFarThreshold(n){this.farThreshold.set(Number(n))}async startCapture(){if(!this.stream)return;let n=this.startBtnRef?.nativeElement;n&&(n.style.display="none"),await this.requestFullscreenAndOrientation(),await this.initVideoAndCanvases(),this.initReferenceShapes(),await this.showGeneralInstructionsMessage(),this.config.getFeature("enableObjectDetection")&&await this.runDetectionLoop()}async showGeneralInstructionsMessage(){this.feedback.set(this.transloco.translate("framing.generalIsntructions")),this.showFeedbackMessage.set(!0),await new Promise(n=>setTimeout(n,3e3)),this.showFeedbackMessage.set(!1)}async requestFullscreenAndOrientation(){try{await(document.documentElement.requestFullScreen?.()||document.documentElement.webkitRequestFullscreen?.()||document.documentElement.mozRequestFullScreen?.()||document.documentElement.msRequestFullscreen?.())}catch(n){console.warn("Can't force fullscreen/orientation:",n)}}async requestCameraAccess(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:{ideal:"environment"}}}),this.feedback.set(this.transloco.translate("camera.ready")),this.showPermissionSlider.set(!1),this.cameraReady.set(!0)}catch{this.feedback.set(this.transloco.translate("camera.notAllowed"))}}async initVideoAndCanvases(){if(!this.stream){this.feedback.set(this.transloco.translate("camera.noStream"));return}let n=this.videoRef.nativeElement,t=this.detectionCanvasRef.nativeElement,r=this.overlayCanvasRef.nativeElement;n.srcObject=this.stream,await new Promise(o=>{n.onloadedmetadata=()=>{t.width=n.videoWidth,t.height=n.videoHeight,r.width=n.videoWidth,r.height=n.videoHeight,this.ctx=t.getContext("2d"),this.overlayCtx=r.getContext("2d"),o()}}),this.overlayCtx.clearRect(0,0,r.width,r.height)}initReferenceShapes(){let n=this.overlayCanvasRef.nativeElement,t=n.width,r=n.height,s=this.headerDivRef.nativeElement.getBoundingClientRect(),a=this.footerDivRef.nativeElement.getBoundingClientRect(),c=t-t*.3,l=r-s.height-a.height,u=t*.5-c*.5,p=r*.5-l*.5;console.log("frameWidth: "+c),console.log("frameHeight: "+l),console.log("frameOffsetX: "+u),console.log("frameOffsetY: "+p),this.rectPath2D=new Path2D,this.rectPath2D.rect(u,p,c,l),this.rectMetrics.offsetX=u,this.rectMetrics.offsetY=p,this.rectMetrics.width=c,this.rectMetrics.height=l,this.overlayCtx.clearRect(0,0,t,r),this.drawBackgroundAndRefereceCanvas(n)}drawBackgroundAndRefereceCanvas(n){this.showBoxes()?this.overlayCtx.strokeStyle="rgba(255, 255, 0, 1)":this.overlayCtx.strokeStyle="rgba(255, 255, 0, 0)",this.overlayCtx.lineWidth=0,this.overlayCtx.stroke(this.rectPath2D)}drawBoundingBoxes(n){n.forEach(t=>{let[r,o,s,i]=t.bbox;this.overlayCtx.strokeStyle="red",this.overlayCtx.lineWidth=2,this.overlayCtx.strokeRect(r,o,s,i),this.overlayCtx.fillStyle="red",this.overlayCtx.font="16px monospace";let a=o>20?o-6:o+16;this.overlayCtx.fillText(`${t.class} ${(t.score*100).toFixed(1)}%`,r,a)})}disableFramingGuides(){let n={left:!1,right:!1,up:!1,down:!1};this.arrowDirection.set(n)}enableFramingGuides(n){let[t,r,o,s]=n.bbox,i={x:t+o/2,y:r+s/2},{offsetX:a,offsetY:c,width:l,height:u}=this.rectMetrics,p={x:a+l/2,y:c+u/2},d=i.x-p.x,f=i.y-p.y,m=l*.05,h=u*.05,g={left:!1,right:!1,up:!1,down:!1},x=!0,v="framing.guideance.";Math.abs(d)>m&&(x=!1,d>0?(g.right=!0,v+="right"):(g.left=!0,v+="left")),Math.abs(f)>h&&(x=!1,f>0?(g.down=!0,g.right||g.left?v+="Down":v+="down"):(g.up=!0,g.right||g.left?v+="Up":v+="up")),this.arrowDirection.set(g),this.isCentered.set(x),this.feedback.set(this.transloco.translate(v))}getMainCar(n){if(n.length===1)return n[0];let t=n.map(i=>Ft(Je({},i),{area:i.bbox[2]*i.bbox[3]}));t.sort((i,a)=>a.area-i.area);let r=t[0],o=t[1];return(r.area-o.area)/r.area<.1?(this.feedback.set(this.transloco.translate("framing.oneVehicle")),null):r}async runDetectionLoop(){let n=this.detectionCanvasRef.nativeElement,t=this.overlayCanvasRef.nativeElement,r=this.videoRef.nativeElement;this.model=await this.tfModelService.getModelReady(),this.detectionTimer=setInterval(async()=>{if(this.isCapturingPhoto)return;this.ctx.drawImage(r,0,0,n.width,n.height);let o=await this.model.detect(n);this.detections.set(o.map(a=>`${a.class} (${(a.score*100).toFixed(1)}%)`)),this.overlayCtx.clearRect(0,0,t.width,t.height),this.initReferenceShapes(),this.showBoxes()&&this.drawBoundingBoxes(o);let s=o.filter(a=>["car","truck","bus"].includes(a.class)),i;if(this.showFeedbackMessage.set(!0),s.length===0){this.feedback.set(this.transloco.translate("framing.noCar")),this.disableFramingGuides(),this.proportion.set(null);return}if(s.length>1?i=this.getMainCar(s):i=s[0],i){let[a,c,l,u]=i.bbox,p=[[a,c],[a+l,c],[a,c+u],[a+l,c+u]].every(([h,g])=>this.overlayCtx.isPointInPath(this.rectPath2D,h,g)),d=l,f=this.rectMetrics.width,m=d/f;this.proportion.set(+m.toFixed(3)),console.log(m),p?m>this.nearThreshold()?this.feedback.set(this.transloco.translate("framing.tooNear")):m<this.farThreshold()?this.feedback.set(this.transloco.translate("framing.tooFar")):(this.feedback.set(this.transloco.translate("framing.perfect")),this.isCapturingPhoto=!0,this.freezeFrame(),this.isAnimating||await this.orchestratePhotoCapturingAsync()):this.enableFramingGuides(i)}else this.disableFramingGuides(),this.proportion.set(null)},1e3)}freezeFrame(){this.isFrozen.set(!0)}unfreezeFrame(){this.isFrozen.set(!1),this.isCapturingPhoto=!1}async capturePhotoAsync(){let n=this.detectionCanvasRef.nativeElement,{offsetX:t,offsetY:r,width:o,height:s}=this.rectMetrics,i=s*.1,a=s-2*i,c=r+i,l=document.createElement("canvas");l.width=o,l.height=a,l.getContext("2d")?.drawImage(n,t,c,o,a,0,0,o,a),this.capturedImage.set(l.toDataURL("image/png")),await this.showCapturedPhoto()}async showCapturedPhoto(){this.showCapturedPhotoSignal.set(!0),this.config.getFeature("showPhotoConfirmation")?this.showRetryConfirmMessageSignal.set(!0):await this.usePhoto()}retryPhoto(){this.capturedImage.set(null),this.showCapturedPhotoSignal.set(!1),this.unfreezeFrame()}async usePhoto(){await this.showImageOkMessageAsync(),this.showCapturedPhotoSignal.set(!1),this.unfreezeFrame()}async animateFrameGlowAsync(){if(this.isAnimating)return;this.isAnimating=!0,this.showFeedbackMessage.set(!1);let n=this.irregularPathRef.nativeElement.closest("svg");n?.classList.add("glow"),await new Promise(t=>setTimeout(t,1e3)),this.isAnimating=!1,n?.classList.remove("glow")}async startFillAnimationAsync(){if(this.isAnimatingFill)return;this.isAnimatingFill=!0,this.showFeedbackMessage.set(!0),this.feedback.set(this.transloco.translate("analizingAI"));let n=this.irregularPathRef.nativeElement;n.setAttribute("fill","url(#fillGradient)"),n.classList.add("animate-fill"),await new Promise(t=>setTimeout(t,3e3)),this.isAnimatingFill=!1,this.showFeedbackMessage.set(!1),n.classList.remove("animate-fill")}async showImageOkMessageAsync(){this.showRetryConfirmMessageSignal.set(!1),this.showToastOk.set(!0),await new Promise(n=>setTimeout(n,2e3)),this.showToastOk.set(!1)}async orchestratePhotoCapturingAsync(){this.disableFramingGuides(),await this.animateFrameGlowAsync(),await this.startFillAnimationAsync(),await this.capturePhotoAsync()}static \u0275fac=function(t){return new(t||e)(Nn(U0),Nn(G0),Nn(Xh))};static \u0275cmp=Rp({type:e,selectors:[["app-camera"]],viewQuery:function(t,r){if(t&1&&(vr(Pfe,5),vr(Lfe,5),vr(Bfe,5),vr(Vfe,5),vr(Ufe,5),vr(zfe,5),vr(Gfe,5),vr(Hfe,5),vr(Wfe,5)),t&2){let o;br(o=Cr())&&(r.videoRef=o.first),br(o=Cr())&&(r.detectionCanvasRef=o.first),br(o=Cr())&&(r.overlayCanvasRef=o.first),br(o=Cr())&&(r.startBtnRef=o.first),br(o=Cr())&&(r.irregularPathRef=o.first),br(o=Cr())&&(r.rectPathRef=o.first),br(o=Cr())&&(r.freezeCanvasRef=o.first),br(o=Cr())&&(r.headerDivRef=o.first),br(o=Cr())&&(r.footerDivRef=o.first)}},decls:75,vars:35,consts:[["detectionCanvas",""],["video",""],["overlayCanvas",""],["header",""],["marcoContainer",""],["irregularPath",""],["captureFrame",""],["footer",""],["startBtn",""],[1,"camera-permission-slider"],[1,"slider-content"],["id","allowBtn",3,"click"],[4,"ngIf"],[1,"frame-guide"],["class","arrow arrow-left",4,"ngIf"],["class","arrow arrow-right",4,"ngIf"],["class","arrow arrow-up",4,"ngIf"],["class","arrow arrow-down",4,"ngIf"],["id","detectionCanvas"],["id","video","autoplay","","playsinline","","muted",""],["id","overlayCanvas"],["id","capturedImage",1,"photo-preview"],[1,"toggle-panel"],[1,"detections-area"],["id","closeButton"],["width","24","height","24","viewBox","0 0 24 24","fill","none","xmlns","http://www.w3.org/2000/svg"],["d","M6 18L18 6M6 6L18 18","stroke","white","stroke-width","2","stroke-linecap","round","stroke-linejoin","round"],["id","main-container"],["id","header"],[1,"marco-container"],[1,"marco-svg"],["id","glowGradient","gradientTransform","rotate(90)"],["offset","0%","stop-color","#0ff"],["offset","50%","stop-color","#0f0"],["offset","100%","stop-color","#0ff"],["id","fillGradient","x1","0%","y1","50%","x2","100%","y2","50%"],["offset","0%","stop-color","rgba(31, 238, 200, 0.69)"],["attributeName","stop-color","values","rgba(31, 238, 200, 0.69);rgba(194, 255, 231, 0.30);rgba(58, 241, 144, 0.26);rgba(194, 255, 231, 0.30);rgba(31, 238, 200, 0.69)","dur","2s","repeatCount","indefinite"],["offset","100%","stop-color","rgba(31, 238, 200, 0.69)"],["attributeName","offset","values","0;.20;.40;.60;.80;.95;.80;.60;.40;.20;0;","dur","2s","repeatCount","indefinite"],["id","hole-mask"],["id","reference-frame-mask","preserveAspectRatio","xMidYMid meet"],["id","outline-hole","fill","#000"],["x","0","y","0","width","100%","height","100%","fill","#FFF"],["href","#reference-frame-mask","transform","scale(1.05)",2,"transform-origin","center","transform-box","fill-box"],["id","reference-frame","preserveAspectRatio","xMidYMid meet"],["id","top-left-corner","viewBox","0 0 17 16"],["d","M0.000137329 -1.45545e-06L0.00013593 16L2.00014 16L2.00014 2L16.6486 2L16.6486 0L0.000137329 -1.45545e-06Z","fill","white"],["id","top-right-corner","viewBox","0 0 17 16"],["d","M16.6485 -1.45545e-06L16.6485 16L14.6485 16L14.6485 2L6.121e-05 2L6.10352e-05 0L16.6485 -1.45545e-06Z","fill","white"],["id","bottom-left-corner","viewBox","0 0 17 16"],["d","M1.52588e-05 16.0001L1.386e-05 0.000123526L2.00001 0.000123351L2.00002 14.0001L16.6485 14.0001L16.6485 16.0001L1.52588e-05 16.0001Z","fill","white"],["id","bottom-right-corner","viewBox","0 0 17 16"],["d","M16.6486 16L16.6486 1.45545e-06L14.6486 1.28061e-06L14.6486 14L0.00018328 14L0.000183105 16L16.6486 16Z","fill","white"],["href","#top-left-corner","width","16px","height","16px","transform","translate(0 0)"],["href","#top-right-corner","width","16px","height","16px"],["href","#bottom-left-corner","width","16px","height","16px"],["href","#bottom-right-corner","width","16px","height","16px"],[1,"irregular-path"],["id","overlay-box","x","0","y","0"],["href","#reference-frame"],["id","footer"],["id","feedback"],[1,"orientation-warning"],[1,"orientation-content"],[1,"phone-icon"],["id","startBtn",3,"click"],[1,"arrow","arrow-left"],[1,"arrow","arrow-right"],[1,"arrow","arrow-up"],[1,"arrow","arrow-down"],["alt","Captured photo",3,"src"],["id","toast-ok"],[1,"photo-actions"],["alt","","src","assets/icons/check-circle.svg",1,"iconsolidcheck-circle"],[1,"toast-ok-text"],[1,"retry",3,"click"],[1,"confirm",3,"click"],[1,"toggle-item"],[1,"switch"],["type","checkbox",3,"change","checked"],[1,"slider"],[1,"toggle-label"],["id","proportionBox"],[3,"newValue","nearThreshold","farThreshold"],[1,"slider-group"],["type","range","min","0.81","max","1","step","0.01",1,"slider-near",3,"input","value"],["type","range","min","0.5","max","0.9","step","0.01",1,"slider-far",3,"input","value"]],template:function(t,r){if(t&1){let o=vc();$e(0,"div",9)(1,"div",10)(2,"p"),Dn(3),Ln(4,"transloco"),Be(),$e(5,"button",11),ro("click",function(){return eo(o),to(r.requestCameraAccess())}),Dn(6),Ln(7,"transloco"),Be()()(),Kf(8,jfe,5,3,"div",12),$e(9,"div",13),Kf(10,qfe,4,0,"div",14)(11,Kfe,4,0,"div",15)(12,Xfe,4,0,"div",16)(13,Yfe,4,0,"div",17),Be(),pt(14,"canvas",18,0)(16,"video",19,1)(18,"canvas",20,2),ci(20,Jfe,4,3,"div",21),ci(21,eme,15,8,"div",22),ci(22,tme,18,23,"div",23),$e(23,"div",24),_f(),$e(24,"svg",25),pt(25,"path",26),Be()(),Af(),$e(26,"div",27),pt(27,"div",28,3),$e(29,"div",29,4),_f(),$e(31,"svg",30)(32,"defs")(33,"linearGradient",31),pt(34,"stop",32)(35,"stop",33)(36,"stop",34),Be(),$e(37,"linearGradient",35)(38,"stop",36),pt(39,"animate",37),Be(),$e(40,"stop",38),pt(41,"animate",37)(42,"animate",39),Be()(),$e(43,"mask",40)(44,"symbol",41),pt(45,"path",42),Be(),pt(46,"rect",43)(47,"use",44),Be(),$e(48,"symbol",45)(49,"symbol",46),pt(50,"path",47),Be(),$e(51,"symbol",48),pt(52,"path",49),Be(),$e(53,"symbol",50),pt(54,"path",51),Be(),$e(55,"symbol",52),pt(56,"path",53),Be(),pt(57,"use",54)(58,"use",55)(59,"use",56)(60,"use",57)(61,"path",58,5),Be()(),pt(63,"rect",59)(64,"use",60,6),Be()(),Af(),pt(66,"div",61,7),Be(),ci(68,nme,2,1,"div",62),$e(69,"div",63)(70,"div",64),pt(71,"div",65),$e(72,"p"),Dn(73),Ln(74,"transloco"),Be()()()}t&2&&(Fp("visible",r.showPermissionSlider()),Me(3),ls(wr(4,29,"requestAccess")),Me(3),us(" ",wr(7,31,"allowAccess")," "),Me(2),Jn("ngIf",r.cameraReady()),Me(2),Jn("ngIf",r.showArrow("left")),Me(),Jn("ngIf",r.showArrow("right")),Me(),Jn("ngIf",r.showArrow("up")),Me(),Jn("ngIf",r.showArrow("down")),Me(),Qf("display",r.isFrozen()?"block":"none"),Me(2),Qf("display",r.isFrozen()?"none":"block"),Me(4),li(r.showCapturedPhotoSignal()?20:-1),Me(),li(r.showTogglePanel()?21:-1),Me(),li(r.showDetections()?22:-1),Me(9),Fp("glow",r.isAnimating),Me(13),Fo("viewBox","0 0 "+r.svgWidth+" "+r.svgHeight),Me(),Fo("d",r.outlinePathData),Me(3),Fo("viewBox","0 0 "+r.svgWidth+" "+r.svgHeight),Me(10),Fo("transform","translate("+(r.svgWidth-16)+" 0)"),Me(),Fo("transform","translate(0 "+(r.svgHeight-16)+")"),Me(),Fo("transform","translate("+(r.svgWidth-16)+" "+(r.svgHeight-16)+")"),Me(),Fp("animate-fill",r.isAnimatingFill),Fo("d",r.outlinePathData),Me(7),li(r.showFeedbackMessage()?68:-1),Me(5),ls(wr(74,33,"orientationMesage")))},dependencies:[UI,BI,C0,VI,Dj],styles:['[_nghost-%COMP%]{display:block;background:#000;height:100vh;width:100vw;overflow:hidden;position:relative}.camera-permission-slider[_ngcontent-%COMP%]{position:fixed;left:50%;transform:translate(-50%);bottom:-200px;background:#fff;box-shadow:0 -4px 12px #0003;border-top-left-radius:16px;border-top-right-radius:16px;padding:20px;text-align:center;transition:bottom .3s ease-in-out;z-index:1000;width:50%}.camera-permission-slider.visible[_ngcontent-%COMP%]{bottom:0}.slider-content[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin-bottom:15px;font-size:16px}.camera-container[_ngcontent-%COMP%]{position:relative;width:100%;height:100%;overflow:hidden}#video[_ngcontent-%COMP%], #detectionCanvas[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100vw;height:100vh;object-fit:cover}#overlay-box[_ngcontent-%COMP%]{width:100%;height:100%;fill:#0006;mask:url(#hole-mask)}#main-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:100%;height:100%}.marco-container[_ngcontent-%COMP%]{flex-grow:1;display:flex;justify-content:center;width:100%;z-index:2}#header[_ngcontent-%COMP%], #footer[_ngcontent-%COMP%]{height:20px;width:100%;background-color:#0006;z-index:2}.marco-svg[_ngcontent-%COMP%]{width:100%;height:100%}#capturedImage[_ngcontent-%COMP%]{z-index:3}#overlayCanvas[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100vw;height:100vh;pointer-events:none}#startBtn[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:15px 30px;font-size:18px;z-index:1000;border-radius:10px;border:none;background:#32cd32;color:#fff;cursor:pointer;z-index:3}#allowBtn[_ngcontent-%COMP%]{height:32px}#feedback-box[_ngcontent-%COMP%]{display:flex;width:100%;justify-content:center;background:#0006;height:36px;z-index:2;padding:10px 20px}#feedback[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:fit-content;background:#000000b3;color:#fff;text-align:center;padding:5px 20px;font-size:18px;font-weight:500;border-radius:6px;z-index:3}#detections[_ngcontent-%COMP%]{position:absolute;top:20px;left:20px;padding:10px;background:#0009;color:#0f0;font-family:monospace;font-size:14px;border-radius:8px;max-width:50%;max-height:30%;overflow-y:auto;white-space:pre-wrap}#proportionBox[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:100%;padding:0;background:#0009;color:#0ff;font-size:14px;border-radius:8px}#proportionBox[_ngcontent-%COMP%]   canvas[_ngcontent-%COMP%]{display:block;margin-top:8px;background:#111;border:1px solid #0ff;border-radius:4px}#closeButton[_ngcontent-%COMP%]{position:absolute;top:15px;right:15px;width:32px;height:32px;padding:12px;display:flex;justify-content:center;align-items:center;gap:10px;flex-shrink:0;border-radius:50%;box-shadow:inset 0 0 6px #0003;background:#0009;z-index:4}.orientation-warning[_ngcontent-%COMP%]{display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000000e6;color:#fff;z-index:9999;display:flex;justify-content:center;align-items:center;text-align:center;padding:20px}@media only screen and (orientation: portrait){.orientation-warning[_ngcontent-%COMP%]{display:flex}}@media only screen and (orientation: landscape){.orientation-warning[_ngcontent-%COMP%]{display:none}}.orientation-content[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center}.phone-icon[_ngcontent-%COMP%]{width:60px;height:100px;border:4px solid white;border-radius:12px;position:relative;margin-bottom:20px;animation:_ngcontent-%COMP%_rotatePhone 2s infinite ease-in-out}.phone-icon[_ngcontent-%COMP%]:after{content:"";position:absolute;bottom:8px;left:50%;transform:translate(-50%);width:12px;height:12px;border:2px solid white;border-radius:50%}@keyframes _ngcontent-%COMP%_rotatePhone{0%{transform:rotate(0)}30%{transform:rotate(0)}50%{transform:rotate(-90deg)}80%{transform:rotate(-90deg)}to{transform:rotate(0)}}.orientation-warning[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:18px;font-weight:700;max-width:300px}.toggle-panel[_ngcontent-%COMP%]{position:absolute;top:15px;left:15px;display:flex;flex-direction:column;gap:10px;z-index:4}.toggle-item[_ngcontent-%COMP%]{display:flex;align-items:center;gap:8px;color:#fff}.switch[_ngcontent-%COMP%]{position:relative;display:inline-block;width:50px;height:28px}.switch[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{opacity:0;width:0;height:0}.slider[_ngcontent-%COMP%]{position:absolute;cursor:pointer;inset:0;background-color:#aaa;transition:.3s;border-radius:28px}.slider[_ngcontent-%COMP%]:before{position:absolute;content:"";height:20px;width:20px;left:4px;bottom:4px;background-color:#fff;transition:.3s;border-radius:50%}input[_ngcontent-%COMP%]:checked + .slider[_ngcontent-%COMP%]{background-color:#4caf50}input[_ngcontent-%COMP%]:checked + .slider[_ngcontent-%COMP%]:before{transform:translate(22px)}.photo-preview[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;background:#000000d9;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:5}.photo-preview[_ngcontent-%COMP%] > img[_ngcontent-%COMP%]{max-width:90%;max-height:60%;border-radius:12px;box-shadow:0 4px 12px #00000080;margin-bottom:20px}.photo-actions[_ngcontent-%COMP%]{display:flex;gap:20px}.photo-actions[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{padding:10px 20px;border:none;border-radius:8px;font-size:16px;font-weight:500;cursor:pointer}button.retry[_ngcontent-%COMP%]{background:#444;color:#fff}button.confirm[_ngcontent-%COMP%]{background:#2ecc71;color:#fff}.detections-area[_ngcontent-%COMP%]{position:absolute;width:30%;top:100px;left:8px;background:#0009;padding:10px;border-top:1px solid #444;border-right:1px solid #444;border-bottom:1px solid #444;display:flex;flex-direction:column;align-items:flex-start;gap:12px;z-index:1000}.detections-area[_ngcontent-%COMP%]   app-chart[_ngcontent-%COMP%]{width:100%}.slider-group[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:8px;width:100%;color:#0ff;font-size:14px}.slider-group[_ngcontent-%COMP%]   input[type=range][_ngcontent-%COMP%]{width:100%}.slider-near[_ngcontent-%COMP%]{background:#e74c3c66}.slider-near[_ngcontent-%COMP%]::-webkit-slider-thumb{background:#e74c3c}.slider-near[_ngcontent-%COMP%]::-moz-range-thumb{background:#e74c3c}.slider-far[_ngcontent-%COMP%]{background:#f39c1266}.slider-far[_ngcontent-%COMP%]::-webkit-slider-thumb{background:#f39c12}.slider-far[_ngcontent-%COMP%]::-moz-range-thumb{background:#f39c12}.level-container[_ngcontent-%COMP%]{position:absolute;top:50%;left:10px;transform:translateY(-50%);z-index:4}.overlay[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.rect-path[_ngcontent-%COMP%]{stroke:#fff;stroke-width:2;fill:transparent;mask:url(#corner-mask)}.irregular-path[_ngcontent-%COMP%]{fill:transparent;stroke-width:3;stroke:#fff;stroke-linejoin:round;stroke-linecap:round;transition:stroke-width .3s ease;transform:scale(.95);transform-origin:center;transform-box:fill-box}#outline-hole[_ngcontent-%COMP%]{transform:scale(.9);transform-origin:center;transform-box:fill-box}.glow[_ngcontent-%COMP%]   .irregular-path[_ngcontent-%COMP%]{stroke:url(#glowGradient);stroke-width:3;stroke-dasharray:var(--path-length);stroke-dashoffset:var(--path-length);animation:_ngcontent-%COMP%_dashGlow 1s linear forwards;filter:drop-shadow(0 0 6px #0ff) drop-shadow(0 0 12px rgba(31,238,200,.69))}@keyframes _ngcontent-%COMP%_dashGlow{to{stroke-dashoffset:0}}.animate-fill[_ngcontent-%COMP%]{fill:url(#fillGradient)}.frame-guide[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:flex;justify-content:center;align-items:center}.arrow[_ngcontent-%COMP%]{position:absolute;z-index:10;width:48px;height:48px}.arrow[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{display:block;width:1.5vw;height:1.5vw;border-bottom:5px solid white;border-right:5px solid white;transform:rotate(45deg);margin:-10px;animation:_ngcontent-%COMP%_animate 2s infinite}.arrow[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]:nth-child(2){animation-delay:-.2s}.arrow[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]:nth-child(3){animation-delay:-.4s}@keyframes _ngcontent-%COMP%_animate{0%{opacity:0;transform:rotate(45deg) translate(-20px,-20px)}50%{opacity:1}to{opacity:0;transform:rotate(45deg) translate(20px,20px)}}.arrow-left[_ngcontent-%COMP%]{left:10px;top:50%;transform:rotate(90deg)}.arrow-right[_ngcontent-%COMP%]{right:10px;top:50%;transform:rotate(270deg)}.arrow-up[_ngcontent-%COMP%]{top:10px;left:50%;transform:rotate(180deg)}.arrow-down[_ngcontent-%COMP%]{bottom:10px;left:50%}.direction-text[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:1.8rem;color:#eafff9;text-align:center;text-shadow:0 0 12px rgba(0,255,180,.7);font-weight:500;line-height:1.4;pointer-events:none;animation:_ngcontent-%COMP%_fadeInOut 1.2s ease-in-out infinite alternate;z-index:10}@keyframes _ngcontent-%COMP%_fadeInOut{0%{opacity:.4}to{opacity:1}}#toast-ok[_ngcontent-%COMP%]{width:340px;height:56px;position:relative;border-radius:8px;background-color:#82d3c466;border:1px solid #12856a;box-sizing:border-box;display:flex;align-items:center;padding:8px 16px;gap:8px;text-align:left;font-size:16px;color:#fff;margin-top:16px}.iconsolidcheck-circle[_ngcontent-%COMP%]{height:26px;width:26px;position:relative;margin-bottom:0}.toast-ok-text[_ngcontent-%COMP%]{position:relative;line-height:30px}']})};export{Ht as a,D8 as b,et as c,pC as d,dC as e,Tn as f,Wa as g,ja as h,Xr as i,lf as j,B8 as k,V8 as l,Ka as m,Xn as n,fC as o,Xa as p,Fg as q,X8 as r,uf as s,pf as t,Y8 as u,df as v,fp as w,Q8 as x,J8 as y,mC as z,e5 as A,t5 as B,n5 as C,Ya as D,r5 as E,$g as F,ze as G,tt as H,i5 as I,Ee as J,at as K,Ie as L,hr as M,jC as N,_r as O,Kg as P,A_ as Q,So as R,Ip as S,uc as T,Zs as U,Ao as V,F5 as W,lt as X,pc as Y,Qw as Z,IA as _,mq as $,hq as aa,AA as ba,xq as ca,yq as da,Np as ea,Lf as fa,Vf as ga,yc as ha,SR as ia,NR as ja,Rp as ka,Ox as la,wI as ma,cs as na,Qn as oa,z7 as pa,Mx as qa,G7 as ra,PR as sa,Xf as ta,W7 as ua,j7 as va,pt as wa,C9 as xa,E9 as ya,KR as za,Vx as Aa,Ux as Ba,sDe as Ca,zx as Da,Z9 as Ea,OI as Fa,l2 as Ga,dX as Ha,zI as Ia,R1e as Ja,xde as Ka,zVt as La,z0 as Ma,G0 as Na,h8 as Oa};
